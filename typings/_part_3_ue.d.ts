declare class KismetNodeHelperLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetNodeHelperLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetNodeHelperLibrary;
	static GetDefaultObject(): KismetNodeHelperLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetNodeHelperLibrary;
	static MarkBit(Data?: number,index?: number): {Data: number};
	static HasUnmarkedBit(Data: number,NumBits: number): boolean;
	static HasMarkedBit(Data: number,NumBits: number): boolean;
	static GetValidValue(Enum: Enum,EnumeratorValue: number): number;
	static GetUnmarkedBit(Data: number,StartIdx: number,NumBits: number,bRandom: boolean): number;
	static GetRandomUnmarkedBit(Data: number,StartIdx: number,NumBits: number): number;
	static GetFirstUnmarkedBit(Data: number,StartIdx: number,NumBits: number): number;
	static GetEnumeratorValueFromIndex(Enum: Enum,EnumeratorIndex: number): number;
	static GetEnumeratorUserFriendlyName(Enum: Enum,EnumeratorValue: number): string;
	static GetEnumeratorName(Enum: Enum,EnumeratorValue: number): string;
	static ClearBit(Data?: number,index?: number): {Data: number};
	static ClearAllBits(Data?: number): {Data: number};
	static BitIsMarked(Data: number,index: number): boolean;
	static C(Other: UObject | any): KismetNodeHelperLibrary;
}

declare class KismetRenderingLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetRenderingLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetRenderingLibrary;
	static GetDefaultObject(): KismetRenderingLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetRenderingLibrary;
	static SetCastInsetShadowForAllAttachments(PrimitiveComponent: PrimitiveComponent,bCastInsetShadow: boolean,bLightAttachmentsAsGroup: boolean): void;
	static RenderTargetCreateStaticTexture2DEditorOnly(RenderTarget: TextureRenderTarget2D,Name: string,CompressionSettings: TextureCompressionSettings,MipSettings: TextureMipGenSettings): Texture2D;
	static ReleaseRenderTarget2D(TextureRenderTarget: TextureRenderTarget2D): void;
	static ReadRenderTargetUV(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,U: number,V: number): Color;
	static ReadRenderTargetRawUVArea(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Area: Box2D,bNormalize: boolean): LinearColor[];
	static ReadRenderTargetRawUV(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,U: number,V: number,bNormalize: boolean): LinearColor;
	static ReadRenderTargetRawPixelArea(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,MinX: number,MinY: number,MaxX: number,MaxY: number,bNormalize: boolean): LinearColor[];
	static ReadRenderTargetRawPixel(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,X: number,Y: number,bNormalize: boolean): LinearColor;
	static ReadRenderTargetRaw(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,OutLinearSamples?: LinearColor[],bNormalize?: boolean): {OutLinearSamples: LinearColor[], $: boolean};
	static ReadRenderTargetPixel(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,X: number,Y: number): Color;
	static ReadRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,OutSamples?: Color[],bNormalize?: boolean): {OutSamples: Color[], $: boolean};
	static MakeSkinWeightInfo(Bone0: number,Weight0: number,Bone1: number,Weight1: number,Bone2: number,Weight2: number,Bone3: number,Weight3: number): SkelMeshSkinWeightInfo;
	static ImportFileAsTexture2D(WorldContextObject: UObject,Filename: string): Texture2D;
	static ImportBufferAsTexture2D(WorldContextObject: UObject,Buffer: number[]): Texture2D;
	static ExportTexture2D(WorldContextObject: UObject,Texture: Texture2D,FilePath: string,Filename: string): void;
	static ExportRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,FilePath: string,Filename: string): void;
	static EndDrawCanvasToRenderTarget(WorldContextObject: UObject,Context: DrawToRenderTargetContext): void;
	static DrawMaterialToRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Material: MaterialInterface): void;
	static CreateRenderTargetVolume(WorldContextObject: UObject,Width: number,Height: number,Depth: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTargetVolume;
	static CreateRenderTarget2DArray(WorldContextObject: UObject,Width: number,Height: number,Slices: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTarget2DArray;
	static CreateRenderTarget2D(WorldContextObject: UObject,Width: number,Height: number,Format: ETextureRenderTargetFormat,ClearColor: LinearColor,bAutoGenerateMipMaps: boolean): TextureRenderTarget2D;
	static ConvertRenderTargetToTexture2DEditorOnly(WorldContextObject: UObject,RenderTarget: TextureRenderTarget2D,Texture: Texture2D): void;
	static ClearRenderTarget2D(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,ClearColor: LinearColor): void;
	static CalculateProjectionMatrix(MinimalViewInfo: MinimalViewInfo): Matrix;
	static BreakSkinWeightInfo(InWeight: SkelMeshSkinWeightInfo,Bone0?: number,Weight0?: number,Bone1?: number,Weight1?: number,Bone2?: number,Weight2?: number,Bone3?: number,Weight3?: number): {Bone0: number, Weight0: number, Bone1: number, Weight1: number, Bone2: number, Weight2: number, Bone3: number, Weight3: number};
	static BeginDrawCanvasToRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Canvas?: Canvas,Size?: Vector2D,Context?: DrawToRenderTargetContext): {Canvas: Canvas, Size: Vector2D, Context: DrawToRenderTargetContext};
	static C(Other: UObject | any): KismetRenderingLibrary;
}

declare type ESearchCase = 'CaseSensitive' | 'IgnoreCase' | 'ESearchCase_MAX';
declare var ESearchCase : { CaseSensitive:'CaseSensitive',IgnoreCase:'IgnoreCase',ESearchCase_MAX:'ESearchCase_MAX', };
declare type ESearchDir = 'FromStart' | 'FromEnd' | 'ESearchDir_MAX';
declare var ESearchDir : { FromStart:'FromStart',FromEnd:'FromEnd',ESearchDir_MAX:'ESearchDir_MAX', };
declare class KismetStringLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetStringLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetStringLibrary;
	static GetDefaultObject(): KismetStringLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetStringLibrary;
	static TrimTrailing(SourceString: string): string;
	static Trim(SourceString: string): string;
	static ToUpper(SourceString: string): string;
	static ToLower(SourceString: string): string;
	static TimeSecondsToString(InSeconds: number): string;
	static StartsWith(SourceString: string,InPrefix: string,SearchCase: ESearchCase): boolean;
	static Split(SourceString: string,InStr: string,LeftS?: string,RightS?: string,SearchCase?: ESearchCase,SearchDir?: ESearchDir): {LeftS: string, RightS: string, $: boolean};
	static RightPad(SourceString: string,ChCount: number): string;
	static RightChop(SourceString: string,Count: number): string;
	static Right(SourceString: string,Count: number): string;
	static Reverse(SourceString: string): string;
	static ReplaceInline(SourceString?: string,SearchText?: string,ReplacementText?: string,SearchCase?: ESearchCase): {SourceString: string, $: number};
	static Replace(SourceString: string,From: string,To: string,SearchCase: ESearchCase): string;
	static ParseIntoArray(SourceString: string,Delimiter: string,CullEmptyStrings: boolean): string[];
	static NotEqual_StrStr(A: string,B: string): boolean;
	static NotEqual_StriStri(A: string,B: string): boolean;
	static Mid(SourceString: string,Start: number,Count: number): string;
	static MatchesWildcard(SourceString: string,wildcard: string,SearchCase: ESearchCase): boolean;
	static Len(S: string): number;
	static LeftPad(SourceString: string,ChCount: number): string;
	static LeftChop(SourceString: string,Count: number): string;
	static Left(SourceString: string,Count: number): string;
	static JoinStringArray(SourceArray: string[],Separator: string): string;
	static IsNumeric(SourceString: string): boolean;
	static IsEmpty(InString: string): boolean;
	static GetSubstring(SourceString: string,StartIndex: number,Length: number): string;
	static GetCharacterAsNumber(SourceString: string,index: number): number;
	static GetCharacterArrayFromString(SourceString: string): string[];
	static FindSubstring(SearchIn: string,Substring: string,bUseCase: boolean,bSearchFromEnd: boolean,StartPosition: number): number;
	static EqualEqual_StrStr(A: string,B: string): boolean;
	static EqualEqual_StriStri(A: string,B: string): boolean;
	static EndsWith(SourceString: string,InSuffix: string,SearchCase: ESearchCase): boolean;
	static CullArray(SourceString: string,inArray?: string[]): {inArray: string[], $: number};
	static Conv_VectorToString(InVec: Vector): string;
	static Conv_Vector3fToString(InVec: Vector3f): string;
	static Conv_Vector2dToString(InVec: Vector2D): string;
	static Conv_TransformToString(InTrans: Transform): string;
	static Conv_StringToVector3f(InString: string,OutConvertedVector?: Vector3f,OutIsValid?: boolean): {OutConvertedVector: Vector3f, OutIsValid: boolean};
	static Conv_StringToVector2D(InString: string,OutConvertedVector2D?: Vector2D,OutIsValid?: boolean): {OutConvertedVector2D: Vector2D, OutIsValid: boolean};
	static Conv_StringToVector(InString: string,OutConvertedVector?: Vector,OutIsValid?: boolean): {OutConvertedVector: Vector, OutIsValid: boolean};
	static Conv_StringToRotator(InString: string,OutConvertedRotator?: Rotator,OutIsValid?: boolean): {OutConvertedRotator: Rotator, OutIsValid: boolean};
	static Conv_StringToName(InString: string): string;
	static Conv_StringToInt(InString: string): number;
	static Conv_StringToDouble(InString: string): any;
	static Conv_StringToColor(InString: string,OutConvertedColor?: LinearColor,OutIsValid?: boolean): {OutConvertedColor: LinearColor, OutIsValid: boolean};
	static Conv_RotatorToString(InRot: Rotator): string;
	static Conv_ObjectToString(InObj: UObject): string;
	static Conv_NameToString(InName: string): string;
	static Conv_MatrixToString(InMatrix: Matrix): string;
	static Conv_IntVectorToString(InIntVec: IntVector): string;
	static Conv_IntToString(inInt: number): string;
	static Conv_IntPointToString(InIntPoint: IntPoint): string;
	static Conv_Int64ToString(inInt: any): string;
	static Conv_DoubleToString(InDouble: any): string;
	static Conv_ColorToString(InColor: LinearColor): string;
	static Conv_ByteToString(InByte: number): string;
	static Conv_BoolToString(InBool: boolean): string;
	static Contains(SearchIn: string,Substring: string,bUseCase: boolean,bSearchFromEnd: boolean): boolean;
	static Concat_StrStr(A: string,B: string): string;
	static BuildString_Vector2d(AppendTo: string,Prefix: string,InVector2D: Vector2D,Suffix: string): string;
	static BuildString_Vector(AppendTo: string,Prefix: string,InVector: Vector,Suffix: string): string;
	static BuildString_Rotator(AppendTo: string,Prefix: string,InRot: Rotator,Suffix: string): string;
	static BuildString_Object(AppendTo: string,Prefix: string,InObj: UObject,Suffix: string): string;
	static BuildString_Name(AppendTo: string,Prefix: string,InName: string,Suffix: string): string;
	static BuildString_IntVector(AppendTo: string,Prefix: string,InIntVector: IntVector,Suffix: string): string;
	static BuildString_Int(AppendTo: string,Prefix: string,inInt: number,Suffix: string): string;
	static BuildString_Double(AppendTo: string,Prefix: string,InDouble: any,Suffix: string): string;
	static BuildString_Color(AppendTo: string,Prefix: string,InColor: LinearColor,Suffix: string): string;
	static BuildString_Bool(AppendTo: string,Prefix: string,InBool: boolean,Suffix: string): string;
	static C(Other: UObject | any): KismetStringLibrary;
}

declare class KismetStringTableLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetStringTableLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetStringTableLibrary;
	static GetDefaultObject(): KismetStringTableLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetStringTableLibrary;
	static IsRegisteredTableId(TableId: string): boolean;
	static IsRegisteredTableEntry(TableId: string,Key: string): boolean;
	static GetTableNamespace(TableId: string): string;
	static GetTableEntrySourceString(TableId: string,Key: string): string;
	static GetTableEntryMetaData(TableId: string,Key: string,MetaDataId: string): string;
	static GetRegisteredStringTables(): string[];
	static GetMetaDataIdsFromStringTableEntry(TableId: string,Key: string): string[];
	static GetKeysFromStringTable(TableId: string): string[];
	static C(Other: UObject | any): KismetStringTableLibrary;
}

declare class UserActivity { 
	ActionName: string;
	clone() : UserActivity;
	static C(Other: UObject | any): UserActivity;
	SetUserActivity(): void;
	static SetUserActivity(UserActivity: UserActivity): void;
}

declare class KismetSystemLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetSystemLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetSystemLibrary;
	static GetDefaultObject(): KismetSystemLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetSystemLibrary;
	static UnregisterForRemoteNotifications(): void;
	static UnloadPrimaryAssetList(PrimaryAssetIdList: PrimaryAssetId[]): void;
	static UnloadPrimaryAsset(PrimaryAssetId: PrimaryAssetId): void;
	static TransactObject(UObject: UObject): void;
	static StackTrace(): void;
	static SphereTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static SphereTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static SphereTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static SphereTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static SphereOverlapComponents(WorldContextObject: UObject,SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static SphereOverlapActors(WorldContextObject: UObject,SpherePos: Vector,SphereRadius: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static SnapshotObject(UObject: UObject): void;
	static ShowPlatformSpecificLeaderboardScreen(CategoryName: string): void;
	static ShowPlatformSpecificAchievementsScreen(SpecificPlayer: PlayerController): void;
	static ShowInterstitialAd(): void;
	static ShowAdBanner(AdIdIndex: number,bShowOnBottomOfScreen: boolean): void;
	static SetWindowTitle(Title: string): void;
	static SetVolumeButtonsHandledBySystem(bEnabled: boolean): void;
	static SetVectorPropertyByName(UObject: UObject,PropertyName: string,Value: Vector): void;
	static SetVector3fPropertyByName(UObject: UObject,PropertyName: string,Value: Vector3f): void;
	static SetUserActivity(UserActivity: UserActivity): void;
	static SetTransformPropertyByName(UObject: UObject,PropertyName: string,Value: Transform): void;
	static SetTextPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetSuppressViewportTransitionMessage(WorldContextObject: UObject,bState: boolean): void;
	static SetStructurePropertyByName(UObject: UObject,PropertyName: string,Value: GenericStruct): void;
	static SetStringPropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetSoftObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetSoftClassPropertyByName(UObject: UObject,PropertyName: string,Value: Class): void;
	static SetRotatorPropertyByName(UObject: UObject,PropertyName: string,Value: Rotator): void;
	static SetObjectPropertyByName(UObject: UObject,PropertyName: string,Value: UObject): void;
	static SetNamePropertyByName(UObject: UObject,PropertyName: string,Value: string): void;
	static SetLinearColorPropertyByName(UObject: UObject,PropertyName: string,Value: LinearColor): void;
	static SetIntPropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetInt64PropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetGamepadsBlockDeviceFeedback(bBlock: boolean): void;
	static SetFieldPathPropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetEditorProperty(UObject: UObject,PropertyName: string,PropertyValue: number,ChangeNotifyMode: EPropertyAccessChangeNotifyMode): boolean;
	static SetDoublePropertyByName(UObject: UObject,PropertyName: string,Value: any): void;
	static SetColorPropertyByName(UObject: UObject,PropertyName: string,Value: Color): void;
	static SetCollisionProfileNameProperty(UObject: UObject,PropertyName: string,Value: CollisionProfileName): void;
	static SetClassPropertyByName(UObject: UObject,PropertyName: string,Value: UnrealEngineClass): void;
	static SetBytePropertyByName(UObject: UObject,PropertyName: string,Value: number): void;
	static SetBoolPropertyByName(UObject: UObject,PropertyName: string,Value: boolean): void;
	static RetriggerableDelay(WorldContextObject: UObject,Duration: number,LatentInfo: LatentActionInfo): void;
	static ResetGamepadAssignmentToController(ControllerId: number): void;
	static ResetGamepadAssignments(): void;
	static RegisterForRemoteNotifications(): void;
	static QuitGame(WorldContextObject: UObject,SpecificPlayer: PlayerController,QuitPreference: EQuitPreference,bIgnorePlatformRestrictions: boolean): void;
	static QuitEditor(): void;
	static PrintWarning(InString: string): void;
	static PrintText(WorldContextObject: UObject,InText: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number,Key: string): void;
	static PrintString(WorldContextObject: UObject,InString: string,bPrintToScreen: boolean,bPrintToLog: boolean,TextColor: LinearColor,Duration: number,Key: string): void;
	static ParseParamValue(InString: string,InParam: string,OutValue?: string): {OutValue: string, $: boolean};
	static ParseParam(InString: string,InParam: string): boolean;
	static ParseCommandLine(InCmdLine: string,OutTokens?: string[],OutSwitches?: string[],OutParams?: any): {OutTokens: string[], OutSwitches: string[], OutParams: any};
	static NotEqual_SoftObjectReference(A: UObject,B: UObject): boolean;
	static NotEqual_SoftClassReference(A: Class,B: Class): boolean;
	static NotEqual_PrimaryAssetType(A: PrimaryAssetType,B: PrimaryAssetType): boolean;
	static NotEqual_PrimaryAssetId(A: PrimaryAssetId,B: PrimaryAssetId): boolean;
	static NormalizeFilename(InFilename: string): string;
	static MoveComponentTo(Component: SceneComponent,TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	static MakeSoftObjectPath(PathString: string): SoftObjectPath;
	static MakeSoftClassPath(PathString: string): SoftClassPath;
	static MakeLiteralText(Value: string): string;
	static MakeLiteralString(Value: string): string;
	static MakeLiteralName(Value: string): string;
	static MakeLiteralInt64(Value: any): any;
	static MakeLiteralInt(Value: number): number;
	static MakeLiteralFloat(Value: number): number;
	static MakeLiteralDouble(Value: any): any;
	static MakeLiteralByte(Value: number): number;
	static MakeLiteralBool(Value: boolean): boolean;
	static LogString(InString: string,bPrintToLog: boolean): void;
	static LoadInterstitialAd(AdIdIndex: number): void;
	static LoadClassAsset_Blocking(AssetClass: Class): UnrealEngineClass;
	static LoadAsset_Blocking(Asset: UObject): UObject;
	static LineTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LineTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LineTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static LineTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LineTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static LaunchURL(URL: string): void;
	static K2_UnPauseTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static K2_UnPauseTimer(UObject: UObject,FunctionName: string): void;
	static K2_TimerExistsHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_TimerExists(UObject: UObject,FunctionName: string): boolean;
	static K2_SetTimerForNextTick(UObject: UObject,FunctionName: string): TimerHandle;
	static K2_SetTimer(UObject: UObject,FunctionName: string,Time: number,bLooping: boolean,InitialStartDelay: number,InitialStartDelayVariance: number): TimerHandle;
	static K2_PauseTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static K2_PauseTimer(UObject: UObject,FunctionName: string): void;
	static K2_IsValidTimerHandle(Handle: TimerHandle): boolean;
	static K2_IsTimerPausedHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_IsTimerPaused(UObject: UObject,FunctionName: string): boolean;
	static K2_IsTimerActiveHandle(WorldContextObject: UObject,Handle: TimerHandle): boolean;
	static K2_IsTimerActive(UObject: UObject,FunctionName: string): boolean;
	static K2_InvalidateTimerHandle(Handle?: TimerHandle): {Handle: TimerHandle, $: TimerHandle};
	static K2_GetTimerRemainingTimeHandle(WorldContextObject: UObject,Handle: TimerHandle): number;
	static K2_GetTimerRemainingTime(UObject: UObject,FunctionName: string): number;
	static K2_GetTimerElapsedTimeHandle(WorldContextObject: UObject,Handle: TimerHandle): number;
	static K2_GetTimerElapsedTime(UObject: UObject,FunctionName: string): number;
	static K2_ClearTimerHandle(WorldContextObject: UObject,Handle: TimerHandle): void;
	static K2_ClearTimer(UObject: UObject,FunctionName: string): void;
	static K2_ClearAndInvalidateTimerHandle(WorldContextObject: UObject,Handle?: TimerHandle): {Handle: TimerHandle};
	static IsValidSoftObjectReference(SoftObjectReference: UObject): boolean;
	static IsValidSoftClassReference(SoftClassReference: Class): boolean;
	static IsValidPrimaryAssetType(PrimaryAssetType: PrimaryAssetType): boolean;
	static IsValidPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): boolean;
	static IsValidClass(Class: UnrealEngineClass): boolean;
	static IsValid(UObject: UObject): boolean;
	static IsUnattended(): boolean;
	static IsStandalone(WorldContextObject: UObject): boolean;
	static IsSplitScreen(WorldContextObject: UObject): boolean;
	static IsServer(WorldContextObject: UObject): boolean;
	static IsScreensaverEnabled(): boolean;
	static IsPackagedForDistribution(): boolean;
	static IsLoggedIn(SpecificPlayer: PlayerController): boolean;
	static IsInterstitialAdRequested(): boolean;
	static IsInterstitialAdAvailable(): boolean;
	static IsDedicatedServer(WorldContextObject: UObject): boolean;
	static IsControllerAssignedToGamepad(ControllerId: number): boolean;
	static HideAdBanner(): void;
	static HasMultipleLocalPlayers(WorldContextObject: UObject): boolean;
	static GetVolumeButtonsHandledBySystem(): boolean;
	static GetUniqueDeviceId(): string;
	static GetSystemPath(UObject: UObject): string;
	static GetSupportedFullscreenResolutions(Resolutions?: IntPoint[]): {Resolutions: IntPoint[], $: boolean};
	static GetSoftObjectReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): UObject;
	static GetSoftClassReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): Class;
	static GetRenderingMaterialQualityLevel(): number;
	static GetRenderingDetailMode(): number;
	static GetProjectSavedDirectory(): string;
	static GetProjectDirectory(): string;
	static GetProjectContentDirectory(): string;
	static GetPrimaryAssetsWithBundleState(RequiredBundles: string[],ExcludedBundles: string[],ValidTypes: PrimaryAssetType[],bForceCurrentState: boolean,OutPrimaryAssetIdList?: PrimaryAssetId[]): {OutPrimaryAssetIdList: PrimaryAssetId[]};
	static GetPrimaryAssetIdList(PrimaryAssetType: PrimaryAssetType,OutPrimaryAssetIdList?: PrimaryAssetId[]): {OutPrimaryAssetIdList: PrimaryAssetId[]};
	static GetPrimaryAssetIdFromSoftObjectReference(SoftObjectReference: UObject): PrimaryAssetId;
	static GetPrimaryAssetIdFromSoftClassReference(SoftClassReference: Class): PrimaryAssetId;
	static GetPrimaryAssetIdFromObject(UObject: UObject): PrimaryAssetId;
	static GetPrimaryAssetIdFromClass(Class: UnrealEngineClass): PrimaryAssetId;
	static GetPreferredLanguages(): string[];
	static GetPlatformUserName(): string;
	static GetPlatformUserDir(): string;
	static GetPathName(UObject: UObject): string;
	static GetOuterObject(UObject: UObject): UObject;
	static GetObjectName(UObject: UObject): string;
	static GetObjectFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): UObject;
	static GetMinYResolutionForUI(): number;
	static GetMinYResolutionFor3DView(): number;
	static GetLocalCurrencySymbol(): string;
	static GetLocalCurrencyCode(): string;
	static GetGameTimeInSeconds(WorldContextObject: UObject): number;
	static GetGamepadControllerName(ControllerId: number): string;
	static GetGamepadButtonGlyph(ButtonKey: string,ControllerIndex: number): Texture2D;
	static GetGameName(): string;
	static GetGameBundleId(): string;
	static GetFrameCount(): any;
	static GetEngineVersion(): string;
	static GetEditorProperty(UObject: UObject,PropertyName: string,PropertyValue?: number): {PropertyValue: number, $: boolean};
	static GetDisplayName(UObject: UObject): string;
	static GetDeviceId(): string;
	static GetDefaultLocale(): string;
	static GetDefaultLanguage(): string;
	static GetCurrentBundleState(PrimaryAssetId: PrimaryAssetId,bForceCurrentState: boolean,OutBundles?: string[]): {OutBundles: string[], $: boolean};
	static GetConvenientWindowedResolutions(Resolutions?: IntPoint[]): {Resolutions: IntPoint[], $: boolean};
	static GetConsoleVariableIntValue(VariableName: string): number;
	static GetConsoleVariableFloatValue(VariableName: string): number;
	static GetConsoleVariableBoolValue(VariableName: string): boolean;
	static GetComponentBounds(Component: SceneComponent,Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static GetCommandLine(): string;
	static GetClassFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): UnrealEngineClass;
	static GetClassDisplayName(Class: UnrealEngineClass): string;
	static GetBuildVersion(): string;
	static GetBuildConfiguration(): string;
	static GetAdIDCount(): number;
	static GetActorListFromComponentList(ComponentList: PrimitiveComponent[],ActorClassFilter: UnrealEngineClass,OutActorList?: Actor[]): {OutActorList: Actor[]};
	static GetActorBounds(Actor: Actor,Origin?: Vector,BoxExtent?: Vector): {Origin: Vector, BoxExtent: Vector};
	static ForceCloseAdBanner(): void;
	static FlushPersistentDebugLines(WorldContextObject: UObject): void;
	static FlushDebugStrings(WorldContextObject: UObject): void;
	static ExecuteConsoleCommand(WorldContextObject: UObject,Command: string,SpecificPlayer: PlayerController): void;
	static EqualEqual_SoftObjectReference(A: UObject,B: UObject): boolean;
	static EqualEqual_SoftClassReference(A: Class,B: Class): boolean;
	static EqualEqual_PrimaryAssetType(A: PrimaryAssetType,B: PrimaryAssetType): boolean;
	static EqualEqual_PrimaryAssetId(A: PrimaryAssetId,B: PrimaryAssetId): boolean;
	static EndTransaction(): number;
	static DrawDebugString(WorldContextObject: UObject,TextLocation: Vector,text: string,TestBaseActor: Actor,TextColor: LinearColor,Duration: number): void;
	static DrawDebugSphere(WorldContextObject: UObject,Center: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugPoint(WorldContextObject: UObject,position: Vector,Size: number,PointColor: LinearColor,Duration: number): void;
	static DrawDebugPlane(WorldContextObject: UObject,PlaneCoordinates: Plane,Location: Vector,Size: number,PlaneColor: LinearColor,Duration: number): void;
	static DrawDebugLine(WorldContextObject: UObject,LineStart: Vector,LineEnd: Vector,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugFrustum(WorldContextObject: UObject,FrustumTransform: Transform,FrustumColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugFloatHistoryTransform(WorldContextObject: UObject,FloatHistory: DebugFloatHistory,DrawTransform: Transform,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	static DrawDebugFloatHistoryLocation(WorldContextObject: UObject,FloatHistory: DebugFloatHistory,DrawLocation: Vector,DrawSize: Vector2D,DrawColor: LinearColor,Duration: number): void;
	static DrawDebugCylinder(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,Segments: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCoordinateSystem(WorldContextObject: UObject,AxisLoc: Vector,AxisRot: Rotator,Scale: number,Duration: number,Thickness: number): void;
	static DrawDebugConeInDegrees(WorldContextObject: UObject,Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCone(WorldContextObject: UObject,Origin: Vector,Direction: Vector,Length: number,AngleWidth: number,AngleHeight: number,NumSides: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCircle(WorldContextObject: UObject,Center: Vector,Radius: number,NumSegments: number,LineColor: LinearColor,Duration: number,Thickness: number,YAxis: Vector,ZAxis: Vector,bDrawAxis: boolean): void;
	static DrawDebugCapsule(WorldContextObject: UObject,Center: Vector,HalfHeight: number,Radius: number,Rotation: Rotator,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DrawDebugCamera(CameraActor: CameraActor,CameraColor: LinearColor,Duration: number): void;
	static DrawDebugBox(WorldContextObject: UObject,Center: Vector,Extent: Vector,LineColor: LinearColor,Rotation: Rotator,Duration: number,Thickness: number): void;
	static DrawDebugArrow(WorldContextObject: UObject,LineStart: Vector,LineEnd: Vector,ArrowSize: number,LineColor: LinearColor,Duration: number,Thickness: number): void;
	static DoesImplementInterface(TestObject: UObject,Interface: UnrealEngineClass): boolean;
	static DelayUntilNextTick(WorldContextObject: UObject,LatentInfo: LatentActionInfo): void;
	static Delay(WorldContextObject: UObject,Duration: number,LatentInfo: LatentActionInfo): void;
	static CreateCopyForUndoBuffer(ObjectToModify: UObject): void;
	static ConvertToRelativePath(Filename: string): string;
	static ConvertToAbsolutePath(Filename: string): string;
	static Conv_SoftObjPathToSoftObjRef(SoftObjectPath: SoftObjectPath): UObject;
	static Conv_SoftObjectReferenceToString(SoftObjectReference: UObject): string;
	static Conv_SoftObjectReferenceToObject(softobject: UObject): UObject;
	static Conv_SoftClassReferenceToString(SoftClassReference: Class): string;
	static Conv_SoftClassReferenceToClass(softclass: Class): UnrealEngineClass;
	static Conv_SoftClassPathToSoftClassRef(SoftClassPath: SoftClassPath): Class;
	static Conv_PrimaryAssetTypeToString(PrimaryAssetType: PrimaryAssetType): string;
	static Conv_PrimaryAssetIdToString(PrimaryAssetId: PrimaryAssetId): string;
	static Conv_ObjectToSoftObjectReference(UObject: UObject): UObject;
	static Conv_ObjectToClass(UObject: UObject,Class: UnrealEngineClass): UnrealEngineClass;
	static Conv_ClassToSoftClassReference(Class: UnrealEngineClass): Class;
	static ControlScreensaver(bAllowScreenSaver: boolean): void;
	static ComponentOverlapComponents(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static ComponentOverlapActors(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static CollectGarbage(): void;
	static CapsuleTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static CapsuleTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,Radius: number,HalfHeight: number,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static CapsuleOverlapComponents(WorldContextObject: UObject,CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static CapsuleOverlapActors(WorldContextObject: UObject,CapsulePos: Vector,Radius: number,HalfHeight: number,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static CanLaunchURL(URL: string): boolean;
	static CancelTransaction(index: number): void;
	static BreakSoftObjectPath(InSoftObjectPath: SoftObjectPath,PathString?: string): {PathString: string};
	static BreakSoftClassPath(InSoftClassPath: SoftClassPath,PathString?: string): {PathString: string};
	static BoxTraceSingleForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BoxTraceSingleByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BoxTraceSingle(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHit?: HitResult,bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHit: HitResult, $: boolean};
	static BoxTraceMultiForObjects(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceMultiByProfile(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxTraceMulti(WorldContextObject: UObject,Start: Vector,End: Vector,HalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,ActorsToIgnore: Actor[],DrawDebugType: EDrawDebugTrace,OutHits?: HitResult[],bIgnoreSelf?: boolean,TraceColor?: LinearColor,TraceHitColor?: LinearColor,DrawTime?: number): {OutHits: HitResult[], $: boolean};
	static BoxOverlapComponents(WorldContextObject: UObject,BoxPos: Vector,Extent: Vector,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	static BoxOverlapActors(WorldContextObject: UObject,BoxPos: Vector,BoxExtent: Vector,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	static BeginTransaction(Context: string,Description: string,PrimaryObject: UObject): number;
	static AddFloatHistorySample(Value: number,FloatHistory: DebugFloatHistory): DebugFloatHistory;
	static C(Other: UObject | any): KismetSystemLibrary;
}

declare class PolyglotTextData { 
	Category: ELocalizedTextSourceCategory;
	NativeCulture: string;
	Namespace: string;
	Key: string;
	NativeString: string;
	LocalizedStrings: any;
	bIsMinimalPatch: boolean;
	CachedText: string;
	clone() : PolyglotTextData;
	static C(Other: UObject | any): PolyglotTextData;
	IsPolyglotDataValid(IsValid?: boolean,ErrorMessage?: string): {IsValid: boolean, ErrorMessage: string};
	PolyglotDataToText(): string;
	static IsPolyglotDataValid(PolyglotData: PolyglotTextData,IsValid?: boolean,ErrorMessage?: string): {IsValid: boolean, ErrorMessage: string};
	static PolyglotDataToText(PolyglotData: PolyglotTextData): string;
}

declare type EFormatArgumentType = 'Int' | 'UInt' | 'Float' | 'Double' | 'Text' | 'Gender' | 'EFormatArgumentType_MAX';
declare var EFormatArgumentType : { Int:'Int',UInt:'UInt',Float:'Float',Double:'Double',Text:'Text',Gender:'Gender',EFormatArgumentType_MAX:'EFormatArgumentType_MAX', };
declare type ETextGender = 'Masculine' | 'Feminine' | 'Neuter' | 'ETextGender_MAX';
declare var ETextGender : { Masculine:'Masculine',Feminine:'Feminine',Neuter:'Neuter',ETextGender_MAX:'ETextGender_MAX', };
declare class FormatArgumentData { 
	ArgumentName: string;
	ArgumentValueType: EFormatArgumentType;
	ArgumentValue: string;
	ArgumentValueInt: any;
	ArgumentValueFloat: number;
	ArgumentValueDouble: any;
	ArgumentValueGender: ETextGender;
	clone() : FormatArgumentData;
	static C(Other: UObject | any): FormatArgumentData;
}

declare type ERoundingMode = 'HalfToEven' | 'HalfFromZero' | 'HalfToZero' | 'FromZero' | 'ToZero' | 'ToNegativeInfinity' | 'ToPositiveInfinity' | 'ERoundingMode_MAX';
declare var ERoundingMode : { HalfToEven:'HalfToEven',HalfFromZero:'HalfFromZero',HalfToZero:'HalfToZero',FromZero:'FromZero',ToZero:'ToZero',ToNegativeInfinity:'ToNegativeInfinity',ToPositiveInfinity:'ToPositiveInfinity',ERoundingMode_MAX:'ERoundingMode_MAX', };
declare class KismetTextLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): KismetTextLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetTextLibrary;
	static GetDefaultObject(): KismetTextLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetTextLibrary;
	static TextTrimTrailing(InText: string): string;
	static TextTrimPrecedingAndTrailing(InText: string): string;
	static TextTrimPreceding(InText: string): string;
	static TextToUpper(InText: string): string;
	static TextToLower(InText: string): string;
	static TextIsTransient(InText: string): boolean;
	static TextIsFromStringTable(text: string): boolean;
	static TextIsEmpty(InText: string): boolean;
	static TextIsCultureInvariant(InText: string): boolean;
	static TextFromStringTable(TableId: string,Key: string): string;
	static StringTableIdAndKeyFromText(text: string,OutTableId?: string,OutKey?: string): {OutTableId: string, OutKey: string, $: boolean};
	static PolyglotDataToText(PolyglotData: PolyglotTextData): string;
	static NotEqual_TextText(A: string,B: string): boolean;
	static NotEqual_IgnoreCase_TextText(A: string,B: string): boolean;
	static IsPolyglotDataValid(PolyglotData: PolyglotTextData,IsValid?: boolean,ErrorMessage?: string): {IsValid: boolean, ErrorMessage: string};
	static GetEmptyText(): string;
	static Format(InPattern: string,InArgs: FormatArgumentData[]): string;
	static FindTextInLocalizationTable(Namespace: string,Key: string,OutText?: string): {OutText: string, $: boolean};
	static EqualEqual_TextText(A: string,B: string): boolean;
	static EqualEqual_IgnoreCase_TextText(A: string,B: string): boolean;
	static Conv_VectorToText(InVec: Vector): string;
	static Conv_Vector2dToText(InVec: Vector2D): string;
	static Conv_TransformToText(InTrans: Transform): string;
	static Conv_TextToString(InText: string): string;
	static Conv_StringToText(InString: string): string;
	static Conv_RotatorToText(InRot: Rotator): string;
	static Conv_ObjectToText(InObj: UObject): string;
	static Conv_NameToText(InName: string): string;
	static Conv_IntToText(Value: number,bAlwaysSign: boolean,bUseGrouping: boolean,MinimumIntegralDigits: number,MaximumIntegralDigits: number): string;
	static Conv_Int64ToText(Value: any,bAlwaysSign: boolean,bUseGrouping: boolean,MinimumIntegralDigits: number,MaximumIntegralDigits: number): string;
	static Conv_FloatToText(Value: number,RoundingMode: ERoundingMode,bAlwaysSign: boolean,bUseGrouping: boolean,MinimumIntegralDigits: number,MaximumIntegralDigits: number,MinimumFractionalDigits: number,MaximumFractionalDigits: number): string;
	static Conv_DoubleToText(InDouble: any,RoundingMode: ERoundingMode,bAlwaysSign: boolean,bUseGrouping: boolean,MinimumIntegralDigits: number,MaximumIntegralDigits: number,MinimumFractionalDigits: number,MaximumFractionalDigits: number): string;
	static Conv_ColorToText(InColor: LinearColor): string;
	static Conv_ByteToText(Value: number): string;
	static Conv_BoolToText(InBool: boolean): string;
	static AsTimeZoneTime_DateTime(InDateTime: DateTime,InTimeZone: string): string;
	static AsTimeZoneDateTime_DateTime(InDateTime: DateTime,InTimeZone: string): string;
	static AsTimeZoneDate_DateTime(InDateTime: DateTime,InTimeZone: string): string;
	static AsTimespan_Timespan(InTimespan: Timespan): string;
	static AsTime_DateTime(In: DateTime): string;
	static AsPercent_Float(Value: number,RoundingMode: ERoundingMode,bAlwaysSign: boolean,bUseGrouping: boolean,MinimumIntegralDigits: number,MaximumIntegralDigits: number,MinimumFractionalDigits: number,MaximumFractionalDigits: number): string;
	static AsDateTime_DateTime(In: DateTime): string;
	static AsDate_DateTime(InDateTime: DateTime): string;
	static AsCurrencyBase(BaseValue: number,CurrencyCode: string): string;
	static AsCurrency_Integer(Value: number,RoundingMode: ERoundingMode,bAlwaysSign: boolean,bUseGrouping: boolean,MinimumIntegralDigits: number,MaximumIntegralDigits: number,MinimumFractionalDigits: number,MaximumFractionalDigits: number,CurrencyCode: string): string;
	static AsCurrency_Float(Value: number,RoundingMode: ERoundingMode,bAlwaysSign: boolean,bUseGrouping: boolean,MinimumIntegralDigits: number,MaximumIntegralDigits: number,MinimumFractionalDigits: number,MaximumFractionalDigits: number,CurrencyCode: string): string;
	static C(Other: UObject | any): KismetTextLibrary;
}

declare class LevelPartitionInterface extends Interface { 
	static Load(ResourceName: string): LevelPartitionInterface;
	static Find(Outer: UObject, ResourceName: string): LevelPartitionInterface;
	static GetDefaultObject(): LevelPartitionInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelPartitionInterface;
	static C(Other: UObject | any): LevelPartitionInterface;
}

declare class ActorContainer extends UObject { 
	Actors: any;
	static Load(ResourceName: string): ActorContainer;
	static Find(Outer: UObject, ResourceName: string): ActorContainer;
	static GetDefaultObject(): ActorContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorContainer;
	static C(Other: UObject | any): ActorContainer;
}

declare class LevelBounds extends Actor { 
	BoxComponent: BoxComponent;
	bAutoUpdateBounds: boolean;
	static GetDefaultObject(): LevelBounds;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelBounds;
	static C(Other: UObject | any): LevelBounds;
}

declare type ELevelInstanceRuntimeBehavior = 'None' | 'Embedded_Deprecated' | 'Partitioned' | 'LevelStreaming' | 'ELevelInstanceRuntimeBehavior_MAX';
declare var ELevelInstanceRuntimeBehavior : { None:'None',Embedded_Deprecated:'Embedded_Deprecated',Partitioned:'Partitioned',LevelStreaming:'LevelStreaming',ELevelInstanceRuntimeBehavior_MAX:'ELevelInstanceRuntimeBehavior_MAX', };
declare class LevelInstance extends Actor { 
	WorldAsset: World;
	CookedWorldAsset: World;
	DesiredRuntimeBehavior: ELevelInstanceRuntimeBehavior;
	static GetDefaultObject(): LevelInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstance;
	static C(Other: UObject | any): LevelInstance;
}

declare class LevelInstanceComponent extends SceneComponent { 
	static Load(ResourceName: string): LevelInstanceComponent;
	static Find(Outer: UObject, ResourceName: string): LevelInstanceComponent;
	static GetDefaultObject(): LevelInstanceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstanceComponent;
	static C(Other: UObject | any): LevelInstanceComponent;
}

declare class LevelInstanceEditorInstanceActor extends Actor { 
	static GetDefaultObject(): LevelInstanceEditorInstanceActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstanceEditorInstanceActor;
	static C(Other: UObject | any): LevelInstanceEditorInstanceActor;
}

declare class LevelStreamingAlwaysLoaded extends LevelStreaming { 
	static Load(ResourceName: string): LevelStreamingAlwaysLoaded;
	static Find(Outer: UObject, ResourceName: string): LevelStreamingAlwaysLoaded;
	static GetDefaultObject(): LevelStreamingAlwaysLoaded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingAlwaysLoaded;
	static C(Other: UObject | any): LevelStreamingAlwaysLoaded;
}

declare class LevelStreamingLevelInstanceEditor extends LevelStreamingAlwaysLoaded { 
	static Load(ResourceName: string): LevelStreamingLevelInstanceEditor;
	static Find(Outer: UObject, ResourceName: string): LevelStreamingLevelInstanceEditor;
	static GetDefaultObject(): LevelStreamingLevelInstanceEditor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingLevelInstanceEditor;
	static C(Other: UObject | any): LevelStreamingLevelInstanceEditor;
}

declare class LevelInstanceEditorObject extends UObject { 
	bMovedActors: boolean;
	OtherPackagesToSave: any[];
	static Load(ResourceName: string): LevelInstanceEditorObject;
	static Find(Outer: UObject, ResourceName: string): LevelInstanceEditorObject;
	static GetDefaultObject(): LevelInstanceEditorObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstanceEditorObject;
	static C(Other: UObject | any): LevelInstanceEditorObject;
}

declare class LevelInstancePivot extends Actor { 
	static GetDefaultObject(): LevelInstancePivot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstancePivot;
	static C(Other: UObject | any): LevelInstancePivot;
}

declare class LevelStreamingDynamic extends LevelStreaming { 
	bInitiallyLoaded: boolean;
	bInitiallyVisible: boolean;
	static Load(ResourceName: string): LevelStreamingDynamic;
	static Find(Outer: UObject, ResourceName: string): LevelStreamingDynamic;
	static GetDefaultObject(): LevelStreamingDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingDynamic;
	static LoadLevelInstanceBySoftObjectPtr(WorldContextObject: UObject,Level: World,Location: Vector,Rotation: Rotator,bOutSuccess?: boolean,OptionalLevelNameOverride?: string,OptionalLevelStreamingClass?: UnrealEngineClass,bLoadAsTempPackage?: boolean): {bOutSuccess: boolean, $: LevelStreamingDynamic};
	static LoadLevelInstance(WorldContextObject: UObject,LevelName: string,Location: Vector,Rotation: Rotator,bOutSuccess?: boolean,OptionalLevelNameOverride?: string,OptionalLevelStreamingClass?: UnrealEngineClass,bLoadAsTempPackage?: boolean): {bOutSuccess: boolean, $: LevelStreamingDynamic};
	static C(Other: UObject | any): LevelStreamingDynamic;
}

declare class LevelStreamingLevelInstance extends LevelStreamingDynamic { 
	static Load(ResourceName: string): LevelStreamingLevelInstance;
	static Find(Outer: UObject, ResourceName: string): LevelStreamingLevelInstance;
	static GetDefaultObject(): LevelStreamingLevelInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingLevelInstance;
	static C(Other: UObject | any): LevelStreamingLevelInstance;
}

declare class LevelInstanceSubsystem extends WorldSubsystem { 
	static Load(ResourceName: string): LevelInstanceSubsystem;
	static Find(Outer: UObject, ResourceName: string): LevelInstanceSubsystem;
	static GetDefaultObject(): LevelInstanceSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelInstanceSubsystem;
	static C(Other: UObject | any): LevelInstanceSubsystem;
}

declare class LevelStreamingPersistent extends LevelStreaming { 
	static Load(ResourceName: string): LevelStreamingPersistent;
	static Find(Outer: UObject, ResourceName: string): LevelStreamingPersistent;
	static GetDefaultObject(): LevelStreamingPersistent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingPersistent;
	static C(Other: UObject | any): LevelStreamingPersistent;
}

declare class LightmappedSurfaceCollection extends UObject { 
	SourceModel: Model;
	Surfaces: number[];
	static Load(ResourceName: string): LightmappedSurfaceCollection;
	static Find(Outer: UObject, ResourceName: string): LightmappedSurfaceCollection;
	static GetDefaultObject(): LightmappedSurfaceCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmappedSurfaceCollection;
	static C(Other: UObject | any): LightmappedSurfaceCollection;
}

declare class LightMapTexture2D extends Texture2D { 
	static Load(ResourceName: string): LightMapTexture2D;
	static Find(Outer: UObject, ResourceName: string): LightMapTexture2D;
	static GetDefaultObject(): LightMapTexture2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightMapTexture2D;
	static C(Other: UObject | any): LightMapTexture2D;
}

declare class LightMapVirtualTexture2D extends Texture2D { 
	TypeToLayer: any[];
	static Load(ResourceName: string): LightMapVirtualTexture2D;
	static Find(Outer: UObject, ResourceName: string): LightMapVirtualTexture2D;
	static GetDefaultObject(): LightMapVirtualTexture2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightMapVirtualTexture2D;
	static C(Other: UObject | any): LightMapVirtualTexture2D;
}

declare class LightmassCharacterIndirectDetailVolume extends Volume { 
	static GetDefaultObject(): LightmassCharacterIndirectDetailVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmassCharacterIndirectDetailVolume;
	static C(Other: UObject | any): LightmassCharacterIndirectDetailVolume;
}

declare class LightmassImportanceVolume extends Volume { 
	static GetDefaultObject(): LightmassImportanceVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmassImportanceVolume;
	static C(Other: UObject | any): LightmassImportanceVolume;
}

declare class LightmassPortalComponent extends SceneComponent { 
	PreviewBox: BoxComponent;
	static Load(ResourceName: string): LightmassPortalComponent;
	static Find(Outer: UObject, ResourceName: string): LightmassPortalComponent;
	static GetDefaultObject(): LightmassPortalComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmassPortalComponent;
	static C(Other: UObject | any): LightmassPortalComponent;
}

declare class LightmassPortal extends Actor { 
	PortalComponent: LightmassPortalComponent;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): LightmassPortal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmassPortal;
	static C(Other: UObject | any): LightmassPortal;
}

declare class LightmassPrimitiveSettingsObject extends UObject { 
	LightmassSettings: LightmassPrimitiveSettings;
	static Load(ResourceName: string): LightmassPrimitiveSettingsObject;
	static Find(Outer: UObject, ResourceName: string): LightmassPrimitiveSettingsObject;
	static GetDefaultObject(): LightmassPrimitiveSettingsObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmassPrimitiveSettingsObject;
	static C(Other: UObject | any): LightmassPrimitiveSettingsObject;
}

declare class LightWeightInstanceBlueprintFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): LightWeightInstanceBlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): LightWeightInstanceBlueprintFunctionLibrary;
	static GetDefaultObject(): LightWeightInstanceBlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightWeightInstanceBlueprintFunctionLibrary;
	static CreateNewLightWeightInstance(ActorClass: UnrealEngineClass,Transform: Transform,Layer: DataLayer,World: World): ActorInstanceHandle;
	static ConvertActorToLightWeightInstance(Actor: Actor): ActorInstanceHandle;
	static C(Other: UObject | any): LightWeightInstanceBlueprintFunctionLibrary;
}

declare class ActorInstanceHandleInterface extends UObject { 
	static Load(ResourceName: string): ActorInstanceHandleInterface;
	static Find(Outer: UObject, ResourceName: string): ActorInstanceHandleInterface;
	static GetDefaultObject(): ActorInstanceHandleInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorInstanceHandleInterface;
	static C(Other: UObject | any): ActorInstanceHandleInterface;
}

declare class LightWeightInstanceManager extends Actor { 
	RepresentedClass: UnrealEngineClass;
	AcceptedClass: UnrealEngineClass;
	InstanceTransforms: Transform[];
	FreeIndices: number[];
	ValidIndices: boolean[];
	static GetDefaultObject(): LightWeightInstanceManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightWeightInstanceManager;
	OnRep_Transforms(): void;
	static C(Other: UObject | any): LightWeightInstanceManager;
}

declare class LightWeightInstanceStaticMeshManager extends LightWeightInstanceManager { 
	StaticMesh: StaticMesh;
	InstancedStaticMeshComponent: HierarchicalInstancedStaticMeshComponent;
	RenderingIndicesToDataIndices: number[];
	DataIndicesToRenderingIndices: number[];
	static GetDefaultObject(): LightWeightInstanceStaticMeshManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightWeightInstanceStaticMeshManager;
	OnRep_StaticMesh(): void;
	static C(Other: UObject | any): LightWeightInstanceStaticMeshManager;
}

declare class LODActor extends Actor { 
	StaticMeshComponent: StaticMeshComponent;
	InstancedStaticMeshComponents: any;
	Proxy: HLODProxy;
	Key: string;
	LODDrawDistance: number;
	LODLevel: number;
	SubActors: Actor[];
	CachedNumHLODLevels: number;
	NumTrianglesInSubActors: any;
	NumTrianglesInMergedMesh: any;
	bOverrideMaterialMergeSettings: boolean;
	MaterialSettings: MaterialProxySettings;
	bOverrideTransitionScreenSize: boolean;
	TransitionScreenSize: number;
	bOverrideScreenSize: boolean;
	ScreenSize: number;
	LODActorTag: string;
	bBuiltFromHLODDesc: boolean;
	ProxyDesc: HLODProxyDesc;
	static GetDefaultObject(): LODActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LODActor;
	static C(Other: UObject | any): LODActor;
}

declare type ESyncOption = 'Drive' | 'Passive' | 'Disabled' | 'ESyncOption_MAX';
declare var ESyncOption : { Drive:'Drive',Passive:'Passive',Disabled:'Disabled',ESyncOption_MAX:'ESyncOption_MAX', };
declare class ComponentSync { 
	Name: string;
	SyncOption: ESyncOption;
	clone() : ComponentSync;
	static C(Other: UObject | any): ComponentSync;
}

declare class LODSyncComponent extends ActorComponent { 
	NumLODs: number;
	ForcedLOD: number;
	MinLOD: number;
	ComponentsToSync: ComponentSync[];
	CustomLODMapping: any;
	CurrentLOD: number;
	CurrentNumLODs: number;
	DriveComponents: PrimitiveComponent[];
	SubComponents: PrimitiveComponent[];
	static Load(ResourceName: string): LODSyncComponent;
	static Find(Outer: UObject, ResourceName: string): LODSyncComponent;
	static GetDefaultObject(): LODSyncComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LODSyncComponent;
	GetLODSyncDebugText(): string;
	static C(Other: UObject | any): LODSyncComponent;
}

declare class LODSyncInterface extends Interface { 
	static Load(ResourceName: string): LODSyncInterface;
	static Find(Outer: UObject, ResourceName: string): LODSyncInterface;
	static GetDefaultObject(): LODSyncInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LODSyncInterface;
	static C(Other: UObject | any): LODSyncInterface;
}

declare class MaterialExpressionAbs extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionAbs;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAbs;
	static GetDefaultObject(): MaterialExpressionAbs;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAbs;
	static C(Other: UObject | any): MaterialExpressionAbs;
}

declare class MaterialExpressionAbsorptionMediumMaterialOutput extends MaterialExpressionCustomOutput { 
	TransmittanceColor: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionAbsorptionMediumMaterialOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAbsorptionMediumMaterialOutput;
	static GetDefaultObject(): MaterialExpressionAbsorptionMediumMaterialOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAbsorptionMediumMaterialOutput;
	static C(Other: UObject | any): MaterialExpressionAbsorptionMediumMaterialOutput;
}

declare class MaterialExpressionActorPositionWS extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionActorPositionWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionActorPositionWS;
	static GetDefaultObject(): MaterialExpressionActorPositionWS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionActorPositionWS;
	static C(Other: UObject | any): MaterialExpressionActorPositionWS;
}

declare class MaterialExpressionAdd extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	ConstA: number;
	ConstB: number;
	static Load(ResourceName: string): MaterialExpressionAdd;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAdd;
	static GetDefaultObject(): MaterialExpressionAdd;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAdd;
	static C(Other: UObject | any): MaterialExpressionAdd;
}

declare type EMaterialSamplerType = 'SAMPLERTYPE_Color' | 'SAMPLERTYPE_Grayscale' | 'SAMPLERTYPE_Alpha' | 'SAMPLERTYPE_Normal' | 'SAMPLERTYPE_Masks' | 'SAMPLERTYPE_DistanceFieldFont' | 'SAMPLERTYPE_LinearColor' | 'SAMPLERTYPE_LinearGrayscale' | 'SAMPLERTYPE_Data' | 'SAMPLERTYPE_External' | 'SAMPLERTYPE_VirtualColor' | 'SAMPLERTYPE_VirtualGrayscale' | 'SAMPLERTYPE_VirtualAlpha' | 'SAMPLERTYPE_VirtualNormal' | 'SAMPLERTYPE_VirtualMasks' | 'SAMPLERTYPE_VirtualLinearColor' | 'SAMPLERTYPE_VirtualLinearGrayscale' | 'SAMPLERTYPE_MAX';
declare var EMaterialSamplerType : { SAMPLERTYPE_Color:'SAMPLERTYPE_Color',SAMPLERTYPE_Grayscale:'SAMPLERTYPE_Grayscale',SAMPLERTYPE_Alpha:'SAMPLERTYPE_Alpha',SAMPLERTYPE_Normal:'SAMPLERTYPE_Normal',SAMPLERTYPE_Masks:'SAMPLERTYPE_Masks',SAMPLERTYPE_DistanceFieldFont:'SAMPLERTYPE_DistanceFieldFont',SAMPLERTYPE_LinearColor:'SAMPLERTYPE_LinearColor',SAMPLERTYPE_LinearGrayscale:'SAMPLERTYPE_LinearGrayscale',SAMPLERTYPE_Data:'SAMPLERTYPE_Data',SAMPLERTYPE_External:'SAMPLERTYPE_External',SAMPLERTYPE_VirtualColor:'SAMPLERTYPE_VirtualColor',SAMPLERTYPE_VirtualGrayscale:'SAMPLERTYPE_VirtualGrayscale',SAMPLERTYPE_VirtualAlpha:'SAMPLERTYPE_VirtualAlpha',SAMPLERTYPE_VirtualNormal:'SAMPLERTYPE_VirtualNormal',SAMPLERTYPE_VirtualMasks:'SAMPLERTYPE_VirtualMasks',SAMPLERTYPE_VirtualLinearColor:'SAMPLERTYPE_VirtualLinearColor',SAMPLERTYPE_VirtualLinearGrayscale:'SAMPLERTYPE_VirtualLinearGrayscale',SAMPLERTYPE_MAX:'SAMPLERTYPE_MAX', };
declare class MaterialExpressionTextureBase extends MaterialExpression { 
	Texture: Texture;
	SamplerType: EMaterialSamplerType;
	IsDefaultMeshpaintTexture: boolean;
	static Load(ResourceName: string): MaterialExpressionTextureBase;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureBase;
	static GetDefaultObject(): MaterialExpressionTextureBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureBase;
	static C(Other: UObject | any): MaterialExpressionTextureBase;
}

declare type ETextureMipValueMode = 'TMVM_None' | 'TMVM_MipLevel' | 'TMVM_MipBias' | 'TMVM_Derivative' | 'TMVM_MAX';
declare var ETextureMipValueMode : { TMVM_None:'TMVM_None',TMVM_MipLevel:'TMVM_MipLevel',TMVM_MipBias:'TMVM_MipBias',TMVM_Derivative:'TMVM_Derivative',TMVM_MAX:'TMVM_MAX', };
declare type ESamplerSourceMode = 'SSM_FromTextureAsset' | 'SSM_Wrap_WorldGroupSettings' | 'SSM_Clamp_WorldGroupSettings' | 'SSM_MAX';
declare var ESamplerSourceMode : { SSM_FromTextureAsset:'SSM_FromTextureAsset',SSM_Wrap_WorldGroupSettings:'SSM_Wrap_WorldGroupSettings',SSM_Clamp_WorldGroupSettings:'SSM_Clamp_WorldGroupSettings',SSM_MAX:'SSM_MAX', };
declare class MaterialExpressionTextureSample extends MaterialExpressionTextureBase { 
	Coordinates: ExpressionInput;
	TextureObject: ExpressionInput;
	MipValue: ExpressionInput;
	CoordinatesDX: ExpressionInput;
	CoordinatesDY: ExpressionInput;
	AutomaticViewMipBiasValue: ExpressionInput;
	MipValueMode: ETextureMipValueMode;
	SamplerSource: ESamplerSourceMode;
	AutomaticViewMipBias: boolean;
	ConstCoordinate: number;
	ConstMipValue: number;
	static Load(ResourceName: string): MaterialExpressionTextureSample;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSample;
	static GetDefaultObject(): MaterialExpressionTextureSample;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSample;
	static C(Other: UObject | any): MaterialExpressionTextureSample;
}

declare class MaterialExpressionTextureSampleParameter extends MaterialExpressionTextureSample { 
	ParameterName: string;
	ExpressionGUID: Guid;
	Group: string;
	SortPriority: number;
	ChannelNames: ParameterChannelNames;
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameter;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameter;
	static C(Other: UObject | any): MaterialExpressionTextureSampleParameter;
}

declare class MaterialExpressionTextureSampleParameter2D extends MaterialExpressionTextureSampleParameter { 
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameter2D;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameter2D;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameter2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameter2D;
	static C(Other: UObject | any): MaterialExpressionTextureSampleParameter2D;
}

declare type ETextureColorChannel = 'TCC_Red' | 'TCC_Green' | 'TCC_Blue' | 'TCC_Alpha' | 'TCC_MAX';
declare var ETextureColorChannel : { TCC_Red:'TCC_Red',TCC_Green:'TCC_Green',TCC_Blue:'TCC_Blue',TCC_Alpha:'TCC_Alpha',TCC_MAX:'TCC_MAX', };
declare class MaterialExpressionAntialiasedTextureMask extends MaterialExpressionTextureSampleParameter2D { 
	Threshold: number;
	Channel: ETextureColorChannel;
	static Load(ResourceName: string): MaterialExpressionAntialiasedTextureMask;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAntialiasedTextureMask;
	static GetDefaultObject(): MaterialExpressionAntialiasedTextureMask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAntialiasedTextureMask;
	static C(Other: UObject | any): MaterialExpressionAntialiasedTextureMask;
}

declare class MaterialExpressionAppendVector extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionAppendVector;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAppendVector;
	static GetDefaultObject(): MaterialExpressionAppendVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAppendVector;
	static C(Other: UObject | any): MaterialExpressionAppendVector;
}

declare class MaterialExpressionArccosine extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionArccosine;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionArccosine;
	static GetDefaultObject(): MaterialExpressionArccosine;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionArccosine;
	static C(Other: UObject | any): MaterialExpressionArccosine;
}

declare class MaterialExpressionArccosineFast extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionArccosineFast;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionArccosineFast;
	static GetDefaultObject(): MaterialExpressionArccosineFast;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionArccosineFast;
	static C(Other: UObject | any): MaterialExpressionArccosineFast;
}

declare class MaterialExpressionArcsine extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionArcsine;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionArcsine;
	static GetDefaultObject(): MaterialExpressionArcsine;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionArcsine;
	static C(Other: UObject | any): MaterialExpressionArcsine;
}

declare class MaterialExpressionArcsineFast extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionArcsineFast;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionArcsineFast;
	static GetDefaultObject(): MaterialExpressionArcsineFast;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionArcsineFast;
	static C(Other: UObject | any): MaterialExpressionArcsineFast;
}

declare class MaterialExpressionArctangent extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionArctangent;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionArctangent;
	static GetDefaultObject(): MaterialExpressionArctangent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionArctangent;
	static C(Other: UObject | any): MaterialExpressionArctangent;
}

declare class MaterialExpressionArctangent2 extends MaterialExpression { 
	Y: ExpressionInput;
	X: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionArctangent2;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionArctangent2;
	static GetDefaultObject(): MaterialExpressionArctangent2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionArctangent2;
	static C(Other: UObject | any): MaterialExpressionArctangent2;
}

declare class MaterialExpressionArctangent2Fast extends MaterialExpression { 
	Y: ExpressionInput;
	X: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionArctangent2Fast;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionArctangent2Fast;
	static GetDefaultObject(): MaterialExpressionArctangent2Fast;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionArctangent2Fast;
	static C(Other: UObject | any): MaterialExpressionArctangent2Fast;
}

declare class MaterialExpressionArctangentFast extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionArctangentFast;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionArctangentFast;
	static GetDefaultObject(): MaterialExpressionArctangentFast;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionArctangentFast;
	static C(Other: UObject | any): MaterialExpressionArctangentFast;
}

declare class MaterialExpressionAtmosphericFogColor extends MaterialExpression { 
	WorldPosition: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionAtmosphericFogColor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAtmosphericFogColor;
	static GetDefaultObject(): MaterialExpressionAtmosphericFogColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAtmosphericFogColor;
	static C(Other: UObject | any): MaterialExpressionAtmosphericFogColor;
}

declare class MaterialExpressionAtmosphericLightColor extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionAtmosphericLightColor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAtmosphericLightColor;
	static GetDefaultObject(): MaterialExpressionAtmosphericLightColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAtmosphericLightColor;
	static C(Other: UObject | any): MaterialExpressionAtmosphericLightColor;
}

declare class MaterialExpressionAtmosphericLightVector extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionAtmosphericLightVector;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAtmosphericLightVector;
	static GetDefaultObject(): MaterialExpressionAtmosphericLightVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAtmosphericLightVector;
	static C(Other: UObject | any): MaterialExpressionAtmosphericLightVector;
}

declare class MaterialExpressionBentNormalCustomOutput extends MaterialExpressionCustomOutput { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionBentNormalCustomOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionBentNormalCustomOutput;
	static GetDefaultObject(): MaterialExpressionBentNormalCustomOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionBentNormalCustomOutput;
	static C(Other: UObject | any): MaterialExpressionBentNormalCustomOutput;
}

declare class MaterialExpressionBinaryOp extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	ConstA: number;
	ConstB: number;
	static Load(ResourceName: string): MaterialExpressionBinaryOp;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionBinaryOp;
	static GetDefaultObject(): MaterialExpressionBinaryOp;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionBinaryOp;
	static C(Other: UObject | any): MaterialExpressionBinaryOp;
}

declare class MaterialExpressionLess extends MaterialExpressionBinaryOp { 
	static Load(ResourceName: string): MaterialExpressionLess;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionLess;
	static GetDefaultObject(): MaterialExpressionLess;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLess;
	static C(Other: UObject | any): MaterialExpressionLess;
}

declare class MaterialExpressionBlackBody extends MaterialExpression { 
	Temp: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionBlackBody;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionBlackBody;
	static GetDefaultObject(): MaterialExpressionBlackBody;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionBlackBody;
	static C(Other: UObject | any): MaterialExpressionBlackBody;
}

declare type EMaterialAttributeBlend = 'Blend' | 'UseA' | 'UseB' | 'EMaterialAttributeBlend_MAX';
declare var EMaterialAttributeBlend : { Blend:'Blend',UseA:'UseA',UseB:'UseB',EMaterialAttributeBlend_MAX:'EMaterialAttributeBlend_MAX', };
declare class MaterialExpressionBlendMaterialAttributes extends MaterialExpression { 
	A: MaterialAttributesInput;
	B: MaterialAttributesInput;
	Alpha: ExpressionInput;
	PixelAttributeBlendType: EMaterialAttributeBlend;
	VertexAttributeBlendType: EMaterialAttributeBlend;
	static Load(ResourceName: string): MaterialExpressionBlendMaterialAttributes;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionBlendMaterialAttributes;
	static GetDefaultObject(): MaterialExpressionBlendMaterialAttributes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionBlendMaterialAttributes;
	static C(Other: UObject | any): MaterialExpressionBlendMaterialAttributes;
}

declare class MaterialExpressionBreakMaterialAttributes extends MaterialExpression { 
	MaterialAttributes: MaterialAttributesInput;
	static Load(ResourceName: string): MaterialExpressionBreakMaterialAttributes;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionBreakMaterialAttributes;
	static GetDefaultObject(): MaterialExpressionBreakMaterialAttributes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionBreakMaterialAttributes;
	static C(Other: UObject | any): MaterialExpressionBreakMaterialAttributes;
}

declare class MaterialExpressionBumpOffset extends MaterialExpression { 
	Coordinate: ExpressionInput;
	Height: ExpressionInput;
	HeightRatioInput: ExpressionInput;
	HeightRatio: number;
	ReferencePlane: number;
	ConstCoordinate: any;
	static Load(ResourceName: string): MaterialExpressionBumpOffset;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionBumpOffset;
	static GetDefaultObject(): MaterialExpressionBumpOffset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionBumpOffset;
	static C(Other: UObject | any): MaterialExpressionBumpOffset;
}

declare class MaterialExpressionCameraPositionWS extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionCameraPositionWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCameraPositionWS;
	static GetDefaultObject(): MaterialExpressionCameraPositionWS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCameraPositionWS;
	static C(Other: UObject | any): MaterialExpressionCameraPositionWS;
}

declare class MaterialExpressionCameraVectorWS extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionCameraVectorWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCameraVectorWS;
	static GetDefaultObject(): MaterialExpressionCameraVectorWS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCameraVectorWS;
	static C(Other: UObject | any): MaterialExpressionCameraVectorWS;
}

declare class MaterialExpressionCeil extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionCeil;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCeil;
	static GetDefaultObject(): MaterialExpressionCeil;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCeil;
	static C(Other: UObject | any): MaterialExpressionCeil;
}

declare class MaterialExpressionParameter extends MaterialExpression { 
	ParameterName: string;
	ExpressionGUID: Guid;
	Group: string;
	SortPriority: number;
	static Load(ResourceName: string): MaterialExpressionParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParameter;
	static GetDefaultObject(): MaterialExpressionParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParameter;
	static C(Other: UObject | any): MaterialExpressionParameter;
}

declare class MaterialExpressionVectorParameter extends MaterialExpressionParameter { 
	DefaultValue: LinearColor;
	bUseCustomPrimitiveData: boolean;
	PrimitiveDataIndex: number;
	ChannelNames: ParameterChannelNames;
	static Load(ResourceName: string): MaterialExpressionVectorParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVectorParameter;
	static GetDefaultObject(): MaterialExpressionVectorParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVectorParameter;
	static C(Other: UObject | any): MaterialExpressionVectorParameter;
}

declare type EChannelMaskParameterColor = 'Red' | 'Green' | 'Blue' | 'Alpha' | 'EChannelMaskParameterColor_MAX';
declare var EChannelMaskParameterColor : { Red:'Red',Green:'Green',Blue:'Blue',Alpha:'Alpha',EChannelMaskParameterColor_MAX:'EChannelMaskParameterColor_MAX', };
declare class MaterialExpressionChannelMaskParameter extends MaterialExpressionVectorParameter { 
	MaskChannel: EChannelMaskParameterColor;
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionChannelMaskParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionChannelMaskParameter;
	static GetDefaultObject(): MaterialExpressionChannelMaskParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionChannelMaskParameter;
	static C(Other: UObject | any): MaterialExpressionChannelMaskParameter;
}

declare type EClampMode = 'CMODE_Clamp' | 'CMODE_ClampMin' | 'CMODE_ClampMax' | 'CMODE_MAX';
declare var EClampMode : { CMODE_Clamp:'CMODE_Clamp',CMODE_ClampMin:'CMODE_ClampMin',CMODE_ClampMax:'CMODE_ClampMax',CMODE_MAX:'CMODE_MAX', };
declare class MaterialExpressionClamp extends MaterialExpression { 
	Input: ExpressionInput;
	Min: ExpressionInput;
	Max: ExpressionInput;
	ClampMode: EClampMode;
	MinDefault: number;
	MaxDefault: number;
	static Load(ResourceName: string): MaterialExpressionClamp;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionClamp;
	static GetDefaultObject(): MaterialExpressionClamp;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionClamp;
	static C(Other: UObject | any): MaterialExpressionClamp;
}

declare class MaterialExpressionClearCoatNormalCustomOutput extends MaterialExpressionCustomOutput { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionClearCoatNormalCustomOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionClearCoatNormalCustomOutput;
	static GetDefaultObject(): MaterialExpressionClearCoatNormalCustomOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionClearCoatNormalCustomOutput;
	static C(Other: UObject | any): MaterialExpressionClearCoatNormalCustomOutput;
}

declare class MaterialExpressionCloudSampleAttribute extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionCloudSampleAttribute;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCloudSampleAttribute;
	static GetDefaultObject(): MaterialExpressionCloudSampleAttribute;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCloudSampleAttribute;
	static C(Other: UObject | any): MaterialExpressionCloudSampleAttribute;
}

declare class MaterialExpressionCollectionParameter extends MaterialExpression { 
	Collection: MaterialParameterCollection;
	ParameterName: string;
	ParameterId: Guid;
	static Load(ResourceName: string): MaterialExpressionCollectionParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCollectionParameter;
	static GetDefaultObject(): MaterialExpressionCollectionParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCollectionParameter;
	static C(Other: UObject | any): MaterialExpressionCollectionParameter;
}

declare class MaterialExpressionComponentMask extends MaterialExpression { 
	Input: ExpressionInput;
	R: boolean;
	G: boolean;
	B: boolean;
	A: boolean;
	static Load(ResourceName: string): MaterialExpressionComponentMask;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionComponentMask;
	static GetDefaultObject(): MaterialExpressionComponentMask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionComponentMask;
	static C(Other: UObject | any): MaterialExpressionComponentMask;
}

declare class MaterialExpressionRerouteBase extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionRerouteBase;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionRerouteBase;
	static GetDefaultObject(): MaterialExpressionRerouteBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionRerouteBase;
	static C(Other: UObject | any): MaterialExpressionRerouteBase;
}

declare class MaterialExpressionReroute extends MaterialExpressionRerouteBase { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionReroute;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionReroute;
	static GetDefaultObject(): MaterialExpressionReroute;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionReroute;
	static C(Other: UObject | any): MaterialExpressionReroute;
}

declare class CompositeReroute { 
	Name: string;
	Expression: MaterialExpressionReroute;
	clone() : CompositeReroute;
	static C(Other: UObject | any): CompositeReroute;
}

declare class MaterialExpressionPinBase extends MaterialExpression { 
	ReroutePins: CompositeReroute[];
	PinDirection: EEdGraphPinDirection;
	static Load(ResourceName: string): MaterialExpressionPinBase;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPinBase;
	static GetDefaultObject(): MaterialExpressionPinBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPinBase;
	static C(Other: UObject | any): MaterialExpressionPinBase;
}

declare class MaterialExpressionComposite extends MaterialExpression { 
	SubgraphName: string;
	InputExpressions: MaterialExpressionPinBase;
	OutputExpressions: MaterialExpressionPinBase;
	static Load(ResourceName: string): MaterialExpressionComposite;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionComposite;
	static GetDefaultObject(): MaterialExpressionComposite;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionComposite;
	static C(Other: UObject | any): MaterialExpressionComposite;
}

declare class MaterialExpressionConstant extends MaterialExpression { 
	R: number;
	static Load(ResourceName: string): MaterialExpressionConstant;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionConstant;
	static GetDefaultObject(): MaterialExpressionConstant;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionConstant;
	static C(Other: UObject | any): MaterialExpressionConstant;
}

declare class MaterialExpressionConstant2Vector extends MaterialExpression { 
	R: number;
	G: number;
	static Load(ResourceName: string): MaterialExpressionConstant2Vector;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionConstant2Vector;
	static GetDefaultObject(): MaterialExpressionConstant2Vector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionConstant2Vector;
	static C(Other: UObject | any): MaterialExpressionConstant2Vector;
}

declare class MaterialExpressionConstant3Vector extends MaterialExpression { 
	Constant: LinearColor;
	static Load(ResourceName: string): MaterialExpressionConstant3Vector;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionConstant3Vector;
	static GetDefaultObject(): MaterialExpressionConstant3Vector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionConstant3Vector;
	static C(Other: UObject | any): MaterialExpressionConstant3Vector;
}

declare class MaterialExpressionConstant4Vector extends MaterialExpression { 
	Constant: LinearColor;
	static Load(ResourceName: string): MaterialExpressionConstant4Vector;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionConstant4Vector;
	static GetDefaultObject(): MaterialExpressionConstant4Vector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionConstant4Vector;
	static C(Other: UObject | any): MaterialExpressionConstant4Vector;
}

declare class MaterialExpressionConstantBiasScale extends MaterialExpression { 
	Input: ExpressionInput;
	Bias: number;
	Scale: number;
	static Load(ResourceName: string): MaterialExpressionConstantBiasScale;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionConstantBiasScale;
	static GetDefaultObject(): MaterialExpressionConstantBiasScale;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionConstantBiasScale;
	static C(Other: UObject | any): MaterialExpressionConstantBiasScale;
}

declare class MaterialExpressionCosine extends MaterialExpression { 
	Input: ExpressionInput;
	Period: number;
	static Load(ResourceName: string): MaterialExpressionCosine;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCosine;
	static GetDefaultObject(): MaterialExpressionCosine;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCosine;
	static C(Other: UObject | any): MaterialExpressionCosine;
}

declare class MaterialExpressionCrossProduct extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionCrossProduct;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCrossProduct;
	static GetDefaultObject(): MaterialExpressionCrossProduct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCrossProduct;
	static C(Other: UObject | any): MaterialExpressionCrossProduct;
}

declare class MaterialExpressionScalarParameter extends MaterialExpressionParameter { 
	DefaultValue: number;
	bUseCustomPrimitiveData: boolean;
	PrimitiveDataIndex: number;
	SliderMin: number;
	SliderMax: number;
	static Load(ResourceName: string): MaterialExpressionScalarParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionScalarParameter;
	static GetDefaultObject(): MaterialExpressionScalarParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionScalarParameter;
	static C(Other: UObject | any): MaterialExpressionScalarParameter;
}

declare class MaterialExpressionCurveAtlasRowParameter extends MaterialExpressionScalarParameter { 
	Curve: CurveLinearColor;
	Atlas: CurveLinearColorAtlas;
	InputTime: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionCurveAtlasRowParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCurveAtlasRowParameter;
	static GetDefaultObject(): MaterialExpressionCurveAtlasRowParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCurveAtlasRowParameter;
	static C(Other: UObject | any): MaterialExpressionCurveAtlasRowParameter;
}

declare type ECustomMaterialOutputType = 'CMOT_Float1' | 'CMOT_Float2' | 'CMOT_Float3' | 'CMOT_Float4' | 'CMOT_MaterialAttributes' | 'CMOT_MAX';
declare var ECustomMaterialOutputType : { CMOT_Float1:'CMOT_Float1',CMOT_Float2:'CMOT_Float2',CMOT_Float3:'CMOT_Float3',CMOT_Float4:'CMOT_Float4',CMOT_MaterialAttributes:'CMOT_MaterialAttributes',CMOT_MAX:'CMOT_MAX', };
declare class CustomInput { 
	InputName: string;
	Input: ExpressionInput;
	clone() : CustomInput;
	static C(Other: UObject | any): CustomInput;
}

declare class CustomOutput { 
	OutputName: string;
	OutputType: ECustomMaterialOutputType;
	clone() : CustomOutput;
	static C(Other: UObject | any): CustomOutput;
}

declare class CustomDefine { 
	DefineName: string;
	DefineValue: string;
	clone() : CustomDefine;
	static C(Other: UObject | any): CustomDefine;
}

declare class MaterialExpressionCustom extends MaterialExpression { 
	Code: string;
	OutputType: ECustomMaterialOutputType;
	Description: string;
	Inputs: CustomInput[];
	AdditionalOutputs: CustomOutput[];
	AdditionalDefines: CustomDefine[];
	IncludeFilePaths: string[];
	static Load(ResourceName: string): MaterialExpressionCustom;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCustom;
	static GetDefaultObject(): MaterialExpressionCustom;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCustom;
	static C(Other: UObject | any): MaterialExpressionCustom;
}

declare type EDBufferTextureId = 'DBT_A' | 'DBT_B' | 'DBT_C' | 'DBT_MAX';
declare var EDBufferTextureId : { DBT_A:'DBT_A',DBT_B:'DBT_B',DBT_C:'DBT_C',DBT_MAX:'DBT_MAX', };
declare class MaterialExpressionDBufferTexture extends MaterialExpression { 
	Coordinates: ExpressionInput;
	DBufferTextureId: EDBufferTextureId;
	static Load(ResourceName: string): MaterialExpressionDBufferTexture;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDBufferTexture;
	static GetDefaultObject(): MaterialExpressionDBufferTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDBufferTexture;
	static C(Other: UObject | any): MaterialExpressionDBufferTexture;
}

declare class MaterialExpressionDDX extends MaterialExpression { 
	Value: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionDDX;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDDX;
	static GetDefaultObject(): MaterialExpressionDDX;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDDX;
	static C(Other: UObject | any): MaterialExpressionDDX;
}

declare class MaterialExpressionDDY extends MaterialExpression { 
	Value: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionDDY;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDDY;
	static GetDefaultObject(): MaterialExpressionDDY;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDDY;
	static C(Other: UObject | any): MaterialExpressionDDY;
}

declare class MaterialExpressionDecalDerivative extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionDecalDerivative;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDecalDerivative;
	static GetDefaultObject(): MaterialExpressionDecalDerivative;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDecalDerivative;
	static C(Other: UObject | any): MaterialExpressionDecalDerivative;
}

declare class MaterialExpressionDecalLifetimeOpacity extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionDecalLifetimeOpacity;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDecalLifetimeOpacity;
	static GetDefaultObject(): MaterialExpressionDecalLifetimeOpacity;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDecalLifetimeOpacity;
	static C(Other: UObject | any): MaterialExpressionDecalLifetimeOpacity;
}

declare class MaterialExpressionDecalMipmapLevel extends MaterialExpression { 
	TextureSize: ExpressionInput;
	ConstWidth: number;
	ConstHeight: number;
	static Load(ResourceName: string): MaterialExpressionDecalMipmapLevel;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDecalMipmapLevel;
	static GetDefaultObject(): MaterialExpressionDecalMipmapLevel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDecalMipmapLevel;
	static C(Other: UObject | any): MaterialExpressionDecalMipmapLevel;
}

declare class MaterialExpressionDeltaTime extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionDeltaTime;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDeltaTime;
	static GetDefaultObject(): MaterialExpressionDeltaTime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDeltaTime;
	static C(Other: UObject | any): MaterialExpressionDeltaTime;
}

declare class MaterialExpressionDepthFade extends MaterialExpression { 
	InOpacity: ExpressionInput;
	FadeDistance: ExpressionInput;
	OpacityDefault: number;
	FadeDistanceDefault: number;
	static Load(ResourceName: string): MaterialExpressionDepthFade;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDepthFade;
	static GetDefaultObject(): MaterialExpressionDepthFade;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDepthFade;
	static C(Other: UObject | any): MaterialExpressionDepthFade;
}

declare type EDepthOfFieldFunctionValue = 'TDOF_NearAndFarMask' | 'TDOF_NearMask' | 'TDOF_FarMask' | 'TDOF_CircleOfConfusionRadius' | 'TDOF_MAX';
declare var EDepthOfFieldFunctionValue : { TDOF_NearAndFarMask:'TDOF_NearAndFarMask',TDOF_NearMask:'TDOF_NearMask',TDOF_FarMask:'TDOF_FarMask',TDOF_CircleOfConfusionRadius:'TDOF_CircleOfConfusionRadius',TDOF_MAX:'TDOF_MAX', };
declare class MaterialExpressionDepthOfFieldFunction extends MaterialExpression { 
	FunctionValue: EDepthOfFieldFunctionValue;
	Depth: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionDepthOfFieldFunction;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDepthOfFieldFunction;
	static GetDefaultObject(): MaterialExpressionDepthOfFieldFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDepthOfFieldFunction;
	static C(Other: UObject | any): MaterialExpressionDepthOfFieldFunction;
}

declare class MaterialExpressionDeriveNormalZ extends MaterialExpression { 
	InXY: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionDeriveNormalZ;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDeriveNormalZ;
	static GetDefaultObject(): MaterialExpressionDeriveNormalZ;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDeriveNormalZ;
	static C(Other: UObject | any): MaterialExpressionDeriveNormalZ;
}

declare class MaterialExpressionDesaturation extends MaterialExpression { 
	Input: ExpressionInput;
	Fraction: ExpressionInput;
	LuminanceFactors: LinearColor;
	static Load(ResourceName: string): MaterialExpressionDesaturation;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDesaturation;
	static GetDefaultObject(): MaterialExpressionDesaturation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDesaturation;
	static C(Other: UObject | any): MaterialExpressionDesaturation;
}

declare class MaterialExpressionDistance extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionDistance;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDistance;
	static GetDefaultObject(): MaterialExpressionDistance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDistance;
	static C(Other: UObject | any): MaterialExpressionDistance;
}

declare class MaterialExpressionDistanceCullFade extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionDistanceCullFade;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDistanceCullFade;
	static GetDefaultObject(): MaterialExpressionDistanceCullFade;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDistanceCullFade;
	static C(Other: UObject | any): MaterialExpressionDistanceCullFade;
}

declare class MaterialExpressionDistanceFieldGradient extends MaterialExpression { 
	position: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionDistanceFieldGradient;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDistanceFieldGradient;
	static GetDefaultObject(): MaterialExpressionDistanceFieldGradient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDistanceFieldGradient;
	static C(Other: UObject | any): MaterialExpressionDistanceFieldGradient;
}

declare class MaterialExpressionDistanceFieldsRenderingSwitch extends MaterialExpression { 
	No: ExpressionInput;
	Yes: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionDistanceFieldsRenderingSwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDistanceFieldsRenderingSwitch;
	static GetDefaultObject(): MaterialExpressionDistanceFieldsRenderingSwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDistanceFieldsRenderingSwitch;
	static C(Other: UObject | any): MaterialExpressionDistanceFieldsRenderingSwitch;
}

declare class MaterialExpressionDistanceToNearestSurface extends MaterialExpression { 
	position: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionDistanceToNearestSurface;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDistanceToNearestSurface;
	static GetDefaultObject(): MaterialExpressionDistanceToNearestSurface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDistanceToNearestSurface;
	static C(Other: UObject | any): MaterialExpressionDistanceToNearestSurface;
}

declare class MaterialExpressionDivide extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	ConstA: number;
	ConstB: number;
	static Load(ResourceName: string): MaterialExpressionDivide;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDivide;
	static GetDefaultObject(): MaterialExpressionDivide;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDivide;
	static C(Other: UObject | any): MaterialExpressionDivide;
}

declare class MaterialExpressionDotProduct extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionDotProduct;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDotProduct;
	static GetDefaultObject(): MaterialExpressionDotProduct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDotProduct;
	static C(Other: UObject | any): MaterialExpressionDotProduct;
}

declare class MaterialExpressionDoubleVectorParameter extends MaterialExpressionParameter { 
	DefaultValue: Vector4d;
	static Load(ResourceName: string): MaterialExpressionDoubleVectorParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDoubleVectorParameter;
	static GetDefaultObject(): MaterialExpressionDoubleVectorParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDoubleVectorParameter;
	static C(Other: UObject | any): MaterialExpressionDoubleVectorParameter;
}

declare class MaterialExpressionDynamicParameter extends MaterialExpression { 
	ParamNames: string[];
	DefaultValue: LinearColor;
	ParameterIndex: any;
	static Load(ResourceName: string): MaterialExpressionDynamicParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDynamicParameter;
	static GetDefaultObject(): MaterialExpressionDynamicParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDynamicParameter;
	static C(Other: UObject | any): MaterialExpressionDynamicParameter;
}

declare class MaterialExpressionEyeAdaptation extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionEyeAdaptation;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionEyeAdaptation;
	static GetDefaultObject(): MaterialExpressionEyeAdaptation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionEyeAdaptation;
	static C(Other: UObject | any): MaterialExpressionEyeAdaptation;
}

declare class MaterialExpressionEyeAdaptationInverse extends MaterialExpression { 
	LightValueInput: ExpressionInput;
	AlphaInput: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionEyeAdaptationInverse;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionEyeAdaptationInverse;
	static GetDefaultObject(): MaterialExpressionEyeAdaptationInverse;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionEyeAdaptationInverse;
	static C(Other: UObject | any): MaterialExpressionEyeAdaptationInverse;
}

declare class MaterialExpressionFeatureLevelSwitch extends MaterialExpression { 
	Default: ExpressionInput;
	Inputs: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionFeatureLevelSwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFeatureLevelSwitch;
	static GetDefaultObject(): MaterialExpressionFeatureLevelSwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFeatureLevelSwitch;
	static C(Other: UObject | any): MaterialExpressionFeatureLevelSwitch;
}

declare class MaterialExpressionFloor extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionFloor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFloor;
	static GetDefaultObject(): MaterialExpressionFloor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFloor;
	static C(Other: UObject | any): MaterialExpressionFloor;
}

declare class MaterialExpressionFmod extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionFmod;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFmod;
	static GetDefaultObject(): MaterialExpressionFmod;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFmod;
	static C(Other: UObject | any): MaterialExpressionFmod;
}

declare class MaterialExpressionFontSample extends MaterialExpression { 
	Font: Font;
	FontTexturePage: number;
	static Load(ResourceName: string): MaterialExpressionFontSample;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFontSample;
	static GetDefaultObject(): MaterialExpressionFontSample;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFontSample;
	static C(Other: UObject | any): MaterialExpressionFontSample;
}

declare class MaterialExpressionFontSampleParameter extends MaterialExpressionFontSample { 
	ParameterName: string;
	ExpressionGUID: Guid;
	Group: string;
	SortPriority: number;
	static Load(ResourceName: string): MaterialExpressionFontSampleParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFontSampleParameter;
	static GetDefaultObject(): MaterialExpressionFontSampleParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFontSampleParameter;
	static C(Other: UObject | any): MaterialExpressionFontSampleParameter;
}

declare class MaterialExpressionForLoop extends MaterialExpression { 
	LoopBody: ExpressionExecOutput;
	Completed: ExpressionExecOutput;
	StartIndex: ExpressionInput;
	EndIndex: ExpressionInput;
	IndexStep: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionForLoop;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionForLoop;
	static GetDefaultObject(): MaterialExpressionForLoop;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionForLoop;
	static C(Other: UObject | any): MaterialExpressionForLoop;
}

declare class MaterialExpressionFrac extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionFrac;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFrac;
	static GetDefaultObject(): MaterialExpressionFrac;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFrac;
	static C(Other: UObject | any): MaterialExpressionFrac;
}

declare class MaterialExpressionFresnel extends MaterialExpression { 
	ExponentIn: ExpressionInput;
	Exponent: number;
	BaseReflectFractionIn: ExpressionInput;
	BaseReflectFraction: number;
	Normal: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionFresnel;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFresnel;
	static GetDefaultObject(): MaterialExpressionFresnel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFresnel;
	static C(Other: UObject | any): MaterialExpressionFresnel;
}

declare class MaterialExpressionGenericConstant extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionGenericConstant;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionGenericConstant;
	static GetDefaultObject(): MaterialExpressionGenericConstant;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionGenericConstant;
	static C(Other: UObject | any): MaterialExpressionGenericConstant;
}

declare class MaterialExpressionConstantDouble extends MaterialExpressionGenericConstant { 
	Value: any;
	static Load(ResourceName: string): MaterialExpressionConstantDouble;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionConstantDouble;
	static GetDefaultObject(): MaterialExpressionConstantDouble;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionConstantDouble;
	static C(Other: UObject | any): MaterialExpressionConstantDouble;
}

declare class MaterialExpressionGetLocal extends MaterialExpression { 
	LocalName: string;
	static Load(ResourceName: string): MaterialExpressionGetLocal;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionGetLocal;
	static GetDefaultObject(): MaterialExpressionGetLocal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionGetLocal;
	static C(Other: UObject | any): MaterialExpressionGetLocal;
}

declare class MaterialExpressionGetMaterialAttributes extends MaterialExpression { 
	MaterialAttributes: MaterialAttributesInput;
	AttributeGetTypes: Guid[];
	static Load(ResourceName: string): MaterialExpressionGetMaterialAttributes;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionGetMaterialAttributes;
	static GetDefaultObject(): MaterialExpressionGetMaterialAttributes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionGetMaterialAttributes;
	static C(Other: UObject | any): MaterialExpressionGetMaterialAttributes;
}

declare class MaterialExpressionGIReplace extends MaterialExpression { 
	Default: ExpressionInput;
	StaticIndirect: ExpressionInput;
	DynamicIndirect: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionGIReplace;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionGIReplace;
	static GetDefaultObject(): MaterialExpressionGIReplace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionGIReplace;
	static C(Other: UObject | any): MaterialExpressionGIReplace;
}

declare class MaterialExpressionHairAttributes extends MaterialExpression { 
	bUseTangentSpace: boolean;
	static Load(ResourceName: string): MaterialExpressionHairAttributes;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionHairAttributes;
	static GetDefaultObject(): MaterialExpressionHairAttributes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionHairAttributes;
	static C(Other: UObject | any): MaterialExpressionHairAttributes;
}

declare class MaterialExpressionHairColor extends MaterialExpression { 
	Melanin: ExpressionInput;
	Redness: ExpressionInput;
	DyeColor: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionHairColor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionHairColor;
	static GetDefaultObject(): MaterialExpressionHairColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionHairColor;
	static C(Other: UObject | any): MaterialExpressionHairColor;
}

declare class MaterialExpressionIf extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	AGreaterThanB: ExpressionInput;
	AEqualsB: ExpressionInput;
	ALessThanB: ExpressionInput;
	EqualsThreshold: number;
	ConstB: number;
	ConstAEqualsB: number;
	static Load(ResourceName: string): MaterialExpressionIf;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionIf;
	static GetDefaultObject(): MaterialExpressionIf;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionIf;
	static C(Other: UObject | any): MaterialExpressionIf;
}

declare class MaterialExpressionIfThenElse extends MaterialExpression { 
	then: ExpressionExecOutput;
	else: ExpressionExecOutput;
	Condition: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionIfThenElse;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionIfThenElse;
	static GetDefaultObject(): MaterialExpressionIfThenElse;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionIfThenElse;
	static C(Other: UObject | any): MaterialExpressionIfThenElse;
}

declare class MaterialExpressionInverseLinearInterpolate extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	Value: ExpressionInput;
	ConstA: number;
	ConstB: number;
	ConstValue: number;
	bClampResult: boolean;
	static Load(ResourceName: string): MaterialExpressionInverseLinearInterpolate;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionInverseLinearInterpolate;
	static GetDefaultObject(): MaterialExpressionInverseLinearInterpolate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionInverseLinearInterpolate;
	static C(Other: UObject | any): MaterialExpressionInverseLinearInterpolate;
}

declare class MaterialExpressionLightmapUVs extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionLightmapUVs;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionLightmapUVs;
	static GetDefaultObject(): MaterialExpressionLightmapUVs;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLightmapUVs;
	static C(Other: UObject | any): MaterialExpressionLightmapUVs;
}

declare class MaterialExpressionLightmassReplace extends MaterialExpression { 
	Realtime: ExpressionInput;
	Lightmass: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionLightmassReplace;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionLightmassReplace;
	static GetDefaultObject(): MaterialExpressionLightmassReplace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLightmassReplace;
	static C(Other: UObject | any): MaterialExpressionLightmassReplace;
}

declare class MaterialExpressionLightVector extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionLightVector;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionLightVector;
	static GetDefaultObject(): MaterialExpressionLightVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLightVector;
	static C(Other: UObject | any): MaterialExpressionLightVector;
}

declare class MaterialExpressionLinearInterpolate extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	Alpha: ExpressionInput;
	ConstA: number;
	ConstB: number;
	ConstAlpha: number;
	static Load(ResourceName: string): MaterialExpressionLinearInterpolate;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionLinearInterpolate;
	static GetDefaultObject(): MaterialExpressionLinearInterpolate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLinearInterpolate;
	static C(Other: UObject | any): MaterialExpressionLinearInterpolate;
}

declare class MaterialExpressionLogarithm10 extends MaterialExpression { 
	X: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionLogarithm10;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionLogarithm10;
	static GetDefaultObject(): MaterialExpressionLogarithm10;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLogarithm10;
	static C(Other: UObject | any): MaterialExpressionLogarithm10;
}

declare class MaterialExpressionLogarithm2 extends MaterialExpression { 
	X: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionLogarithm2;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionLogarithm2;
	static GetDefaultObject(): MaterialExpressionLogarithm2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLogarithm2;
	static C(Other: UObject | any): MaterialExpressionLogarithm2;
}

declare class MaterialExpressionMakeMaterialAttributes extends MaterialExpression { 
	BaseColor: ExpressionInput;
	Metallic: ExpressionInput;
	Specular: ExpressionInput;
	Roughness: ExpressionInput;
	Anisotropy: ExpressionInput;
	EmissiveColor: ExpressionInput;
	Opacity: ExpressionInput;
	OpacityMask: ExpressionInput;
	Normal: ExpressionInput;
	Tangent: ExpressionInput;
	WorldPositionOffset: ExpressionInput;
	SubsurfaceColor: ExpressionInput;
	ClearCoat: ExpressionInput;
	ClearCoatRoughness: ExpressionInput;
	AmbientOcclusion: ExpressionInput;
	Refraction: ExpressionInput;
	CustomizedUVs: ExpressionInput;
	PixelDepthOffset: ExpressionInput;
	ShadingModel: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionMakeMaterialAttributes;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMakeMaterialAttributes;
	static GetDefaultObject(): MaterialExpressionMakeMaterialAttributes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMakeMaterialAttributes;
	static C(Other: UObject | any): MaterialExpressionMakeMaterialAttributes;
}

declare class MaterialExpressionMapARPassthroughCameraUV extends MaterialExpression { 
	Coordinates: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionMapARPassthroughCameraUV;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMapARPassthroughCameraUV;
	static GetDefaultObject(): MaterialExpressionMapARPassthroughCameraUV;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMapARPassthroughCameraUV;
	static C(Other: UObject | any): MaterialExpressionMapARPassthroughCameraUV;
}

declare class MaterialExpressionMaterialAttributeLayers extends MaterialExpression { 
	Input: MaterialAttributesInput;
	DefaultLayers: MaterialLayersFunctions;
	LayerCallers: MaterialExpressionMaterialFunctionCall[];
	NumActiveLayerCallers: number;
	BlendCallers: MaterialExpressionMaterialFunctionCall[];
	NumActiveBlendCallers: number;
	bIsLayerGraphBuilt: boolean;
	static Load(ResourceName: string): MaterialExpressionMaterialAttributeLayers;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMaterialAttributeLayers;
	static GetDefaultObject(): MaterialExpressionMaterialAttributeLayers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMaterialAttributeLayers;
	static C(Other: UObject | any): MaterialExpressionMaterialAttributeLayers;
}

declare class MaterialExpressionMaterialLayerOutput extends MaterialExpressionFunctionOutput { 
	static Load(ResourceName: string): MaterialExpressionMaterialLayerOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMaterialLayerOutput;
	static GetDefaultObject(): MaterialExpressionMaterialLayerOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMaterialLayerOutput;
	static C(Other: UObject | any): MaterialExpressionMaterialLayerOutput;
}

declare class MaterialExpressionMaterialProxyReplace extends MaterialExpression { 
	Realtime: ExpressionInput;
	MaterialProxy: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionMaterialProxyReplace;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMaterialProxyReplace;
	static GetDefaultObject(): MaterialExpressionMaterialProxyReplace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMaterialProxyReplace;
	static C(Other: UObject | any): MaterialExpressionMaterialProxyReplace;
}

declare class MaterialExpressionMax extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	ConstA: number;
	ConstB: number;
	static Load(ResourceName: string): MaterialExpressionMax;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMax;
	static GetDefaultObject(): MaterialExpressionMax;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMax;
	static C(Other: UObject | any): MaterialExpressionMax;
}

declare class MaterialExpressionMin extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	ConstA: number;
	ConstB: number;
	static Load(ResourceName: string): MaterialExpressionMin;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMin;
	static GetDefaultObject(): MaterialExpressionMin;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMin;
	static C(Other: UObject | any): MaterialExpressionMin;
}

declare class MaterialExpressionMultiply extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	ConstA: number;
	ConstB: number;
	static Load(ResourceName: string): MaterialExpressionMultiply;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMultiply;
	static GetDefaultObject(): MaterialExpressionMultiply;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMultiply;
	static C(Other: UObject | any): MaterialExpressionMultiply;
}

declare class MaterialExpressionNamedRerouteBase extends MaterialExpressionRerouteBase { 
	static Load(ResourceName: string): MaterialExpressionNamedRerouteBase;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionNamedRerouteBase;
	static GetDefaultObject(): MaterialExpressionNamedRerouteBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionNamedRerouteBase;
	static C(Other: UObject | any): MaterialExpressionNamedRerouteBase;
}

declare class MaterialExpressionNamedRerouteDeclaration extends MaterialExpressionNamedRerouteBase { 
	Input: ExpressionInput;
	Name: string;
	NodeColor: LinearColor;
	VariableGuid: Guid;
	static Load(ResourceName: string): MaterialExpressionNamedRerouteDeclaration;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionNamedRerouteDeclaration;
	static GetDefaultObject(): MaterialExpressionNamedRerouteDeclaration;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionNamedRerouteDeclaration;
	static C(Other: UObject | any): MaterialExpressionNamedRerouteDeclaration;
}

declare class MaterialExpressionNamedRerouteUsage extends MaterialExpressionNamedRerouteBase { 
	Declaration: MaterialExpressionNamedRerouteDeclaration;
	DeclarationGuid: Guid;
	static Load(ResourceName: string): MaterialExpressionNamedRerouteUsage;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionNamedRerouteUsage;
	static GetDefaultObject(): MaterialExpressionNamedRerouteUsage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionNamedRerouteUsage;
	static C(Other: UObject | any): MaterialExpressionNamedRerouteUsage;
}

declare type ENoiseFunction = 'NOISEFUNCTION_SimplexTex' | 'NOISEFUNCTION_GradientTex' | 'NOISEFUNCTION_GradientTex3D' | 'NOISEFUNCTION_GradientALU' | 'NOISEFUNCTION_ValueALU' | 'NOISEFUNCTION_VoronoiALU' | 'NOISEFUNCTION_MAX';
declare var ENoiseFunction : { NOISEFUNCTION_SimplexTex:'NOISEFUNCTION_SimplexTex',NOISEFUNCTION_GradientTex:'NOISEFUNCTION_GradientTex',NOISEFUNCTION_GradientTex3D:'NOISEFUNCTION_GradientTex3D',NOISEFUNCTION_GradientALU:'NOISEFUNCTION_GradientALU',NOISEFUNCTION_ValueALU:'NOISEFUNCTION_ValueALU',NOISEFUNCTION_VoronoiALU:'NOISEFUNCTION_VoronoiALU',NOISEFUNCTION_MAX:'NOISEFUNCTION_MAX', };
declare class MaterialExpressionNoise extends MaterialExpression { 
	position: ExpressionInput;
	FilterWidth: ExpressionInput;
	Scale: number;
	Quality: number;
	NoiseFunction: ENoiseFunction;
	bTurbulence: boolean;
	Levels: number;
	OutputMin: number;
	OutputMax: number;
	LevelScale: number;
	bTiling: boolean;
	RepeatSize: any;
	static Load(ResourceName: string): MaterialExpressionNoise;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionNoise;
	static GetDefaultObject(): MaterialExpressionNoise;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionNoise;
	static C(Other: UObject | any): MaterialExpressionNoise;
}

declare class MaterialExpressionNormalize extends MaterialExpression { 
	VectorInput: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionNormalize;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionNormalize;
	static GetDefaultObject(): MaterialExpressionNormalize;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionNormalize;
	static C(Other: UObject | any): MaterialExpressionNormalize;
}

declare class MaterialExpressionObjectBounds extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionObjectBounds;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionObjectBounds;
	static GetDefaultObject(): MaterialExpressionObjectBounds;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionObjectBounds;
	static C(Other: UObject | any): MaterialExpressionObjectBounds;
}

declare class MaterialExpressionObjectOrientation extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionObjectOrientation;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionObjectOrientation;
	static GetDefaultObject(): MaterialExpressionObjectOrientation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionObjectOrientation;
	static C(Other: UObject | any): MaterialExpressionObjectOrientation;
}

declare class MaterialExpressionObjectPositionWS extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionObjectPositionWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionObjectPositionWS;
	static GetDefaultObject(): MaterialExpressionObjectPositionWS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionObjectPositionWS;
	static C(Other: UObject | any): MaterialExpressionObjectPositionWS;
}

declare class MaterialExpressionObjectRadius extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionObjectRadius;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionObjectRadius;
	static GetDefaultObject(): MaterialExpressionObjectRadius;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionObjectRadius;
	static C(Other: UObject | any): MaterialExpressionObjectRadius;
}

declare class MaterialExpressionOneMinus extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionOneMinus;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionOneMinus;
	static GetDefaultObject(): MaterialExpressionOneMinus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionOneMinus;
	static C(Other: UObject | any): MaterialExpressionOneMinus;
}

declare class MaterialExpressionPanner extends MaterialExpression { 
	Coordinate: ExpressionInput;
	Time: ExpressionInput;
	Speed: ExpressionInput;
	SpeedX: number;
	SpeedY: number;
	ConstCoordinate: any;
	bFractionalPart: boolean;
	static Load(ResourceName: string): MaterialExpressionPanner;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPanner;
	static GetDefaultObject(): MaterialExpressionPanner;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPanner;
	static C(Other: UObject | any): MaterialExpressionPanner;
}

declare class MaterialExpressionParticleColor extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionParticleColor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleColor;
	static GetDefaultObject(): MaterialExpressionParticleColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleColor;
	static C(Other: UObject | any): MaterialExpressionParticleColor;
}

declare class MaterialExpressionParticleDirection extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionParticleDirection;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleDirection;
	static GetDefaultObject(): MaterialExpressionParticleDirection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleDirection;
	static C(Other: UObject | any): MaterialExpressionParticleDirection;
}

declare class MaterialExpressionParticleMacroUV extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionParticleMacroUV;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleMacroUV;
	static GetDefaultObject(): MaterialExpressionParticleMacroUV;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleMacroUV;
	static C(Other: UObject | any): MaterialExpressionParticleMacroUV;
}

declare class MaterialExpressionParticleMotionBlurFade extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionParticleMotionBlurFade;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleMotionBlurFade;
	static GetDefaultObject(): MaterialExpressionParticleMotionBlurFade;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleMotionBlurFade;
	static C(Other: UObject | any): MaterialExpressionParticleMotionBlurFade;
}

declare class MaterialExpressionParticlePositionWS extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionParticlePositionWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticlePositionWS;
	static GetDefaultObject(): MaterialExpressionParticlePositionWS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticlePositionWS;
	static C(Other: UObject | any): MaterialExpressionParticlePositionWS;
}

declare class MaterialExpressionParticleRadius extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionParticleRadius;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleRadius;
	static GetDefaultObject(): MaterialExpressionParticleRadius;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleRadius;
	static C(Other: UObject | any): MaterialExpressionParticleRadius;
}

declare class MaterialExpressionParticleRandom extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionParticleRandom;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleRandom;
	static GetDefaultObject(): MaterialExpressionParticleRandom;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleRandom;
	static C(Other: UObject | any): MaterialExpressionParticleRandom;
}

declare class MaterialExpressionParticleRelativeTime extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionParticleRelativeTime;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleRelativeTime;
	static GetDefaultObject(): MaterialExpressionParticleRelativeTime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleRelativeTime;
	static C(Other: UObject | any): MaterialExpressionParticleRelativeTime;
}

declare class MaterialExpressionParticleSize extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionParticleSize;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleSize;
	static GetDefaultObject(): MaterialExpressionParticleSize;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleSize;
	static C(Other: UObject | any): MaterialExpressionParticleSize;
}

declare class MaterialExpressionParticleSpeed extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionParticleSpeed;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleSpeed;
	static GetDefaultObject(): MaterialExpressionParticleSpeed;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleSpeed;
	static C(Other: UObject | any): MaterialExpressionParticleSpeed;
}

declare class MaterialExpressionParticleSubUV extends MaterialExpressionTextureSample { 
	bBlend: boolean;
	static Load(ResourceName: string): MaterialExpressionParticleSubUV;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleSubUV;
	static GetDefaultObject(): MaterialExpressionParticleSubUV;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleSubUV;
	static C(Other: UObject | any): MaterialExpressionParticleSubUV;
}

declare class MaterialExpressionParticleSubUVProperties extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionParticleSubUVProperties;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleSubUVProperties;
	static GetDefaultObject(): MaterialExpressionParticleSubUVProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleSubUVProperties;
	static C(Other: UObject | any): MaterialExpressionParticleSubUVProperties;
}

declare class MaterialExpressionPathTracingQualitySwitch extends MaterialExpression { 
	Normal: ExpressionInput;
	PathTraced: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionPathTracingQualitySwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPathTracingQualitySwitch;
	static GetDefaultObject(): MaterialExpressionPathTracingQualitySwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPathTracingQualitySwitch;
	static C(Other: UObject | any): MaterialExpressionPathTracingQualitySwitch;
}

declare class MaterialExpressionPerInstanceCustomData extends MaterialExpression { 
	DefaultValue: ExpressionInput;
	ConstDefaultValue: number;
	DataIndex: any;
	static Load(ResourceName: string): MaterialExpressionPerInstanceCustomData;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPerInstanceCustomData;
	static GetDefaultObject(): MaterialExpressionPerInstanceCustomData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPerInstanceCustomData;
	static C(Other: UObject | any): MaterialExpressionPerInstanceCustomData;
}

declare class MaterialExpressionPerInstanceCustomData3Vector extends MaterialExpression { 
	DefaultValue: ExpressionInput;
	ConstDefaultValue: LinearColor;
	DataIndex: any;
	static Load(ResourceName: string): MaterialExpressionPerInstanceCustomData3Vector;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPerInstanceCustomData3Vector;
	static GetDefaultObject(): MaterialExpressionPerInstanceCustomData3Vector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPerInstanceCustomData3Vector;
	static C(Other: UObject | any): MaterialExpressionPerInstanceCustomData3Vector;
}

declare class MaterialExpressionPerInstanceFadeAmount extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionPerInstanceFadeAmount;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPerInstanceFadeAmount;
	static GetDefaultObject(): MaterialExpressionPerInstanceFadeAmount;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPerInstanceFadeAmount;
	static C(Other: UObject | any): MaterialExpressionPerInstanceFadeAmount;
}

declare class MaterialExpressionPerInstanceRandom extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionPerInstanceRandom;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPerInstanceRandom;
	static GetDefaultObject(): MaterialExpressionPerInstanceRandom;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPerInstanceRandom;
	static C(Other: UObject | any): MaterialExpressionPerInstanceRandom;
}

declare class MaterialExpressionPixelDepth extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionPixelDepth;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPixelDepth;
	static GetDefaultObject(): MaterialExpressionPixelDepth;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPixelDepth;
	static C(Other: UObject | any): MaterialExpressionPixelDepth;
}

declare class MaterialExpressionPixelNormalWS extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionPixelNormalWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPixelNormalWS;
	static GetDefaultObject(): MaterialExpressionPixelNormalWS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPixelNormalWS;
	static C(Other: UObject | any): MaterialExpressionPixelNormalWS;
}

declare class MaterialExpressionPower extends MaterialExpression { 
	Base: ExpressionInput;
	Exponent: ExpressionInput;
	ConstExponent: number;
	static Load(ResourceName: string): MaterialExpressionPower;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPower;
	static GetDefaultObject(): MaterialExpressionPower;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPower;
	static C(Other: UObject | any): MaterialExpressionPower;
}

declare class MaterialExpressionPrecomputedAOMask extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionPrecomputedAOMask;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPrecomputedAOMask;
	static GetDefaultObject(): MaterialExpressionPrecomputedAOMask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPrecomputedAOMask;
	static C(Other: UObject | any): MaterialExpressionPrecomputedAOMask;
}

declare class MaterialExpressionPreSkinnedLocalBounds extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionPreSkinnedLocalBounds;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPreSkinnedLocalBounds;
	static GetDefaultObject(): MaterialExpressionPreSkinnedLocalBounds;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPreSkinnedLocalBounds;
	static C(Other: UObject | any): MaterialExpressionPreSkinnedLocalBounds;
}

declare class MaterialExpressionPreSkinnedNormal extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionPreSkinnedNormal;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPreSkinnedNormal;
	static GetDefaultObject(): MaterialExpressionPreSkinnedNormal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPreSkinnedNormal;
	static C(Other: UObject | any): MaterialExpressionPreSkinnedNormal;
}

declare class MaterialExpressionPreSkinnedPosition extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionPreSkinnedPosition;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPreSkinnedPosition;
	static GetDefaultObject(): MaterialExpressionPreSkinnedPosition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPreSkinnedPosition;
	static C(Other: UObject | any): MaterialExpressionPreSkinnedPosition;
}

declare class MaterialExpressionPreviousFrameSwitch extends MaterialExpression { 
	CurrentFrame: ExpressionInput;
	PreviousFrame: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionPreviousFrameSwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPreviousFrameSwitch;
	static GetDefaultObject(): MaterialExpressionPreviousFrameSwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPreviousFrameSwitch;
	static C(Other: UObject | any): MaterialExpressionPreviousFrameSwitch;
}

declare class MaterialExpressionQualitySwitch extends MaterialExpression { 
	Default: ExpressionInput;
	Inputs: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionQualitySwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionQualitySwitch;
	static GetDefaultObject(): MaterialExpressionQualitySwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionQualitySwitch;
	static C(Other: UObject | any): MaterialExpressionQualitySwitch;
}

declare class MaterialExpressionRayTracingQualitySwitch extends MaterialExpression { 
	Normal: ExpressionInput;
	RayTraced: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionRayTracingQualitySwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionRayTracingQualitySwitch;
	static GetDefaultObject(): MaterialExpressionRayTracingQualitySwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionRayTracingQualitySwitch;
	static C(Other: UObject | any): MaterialExpressionRayTracingQualitySwitch;
}

declare class MaterialExpressionReflectionCapturePassSwitch extends MaterialExpression { 
	Default: ExpressionInput;
	Reflection: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionReflectionCapturePassSwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionReflectionCapturePassSwitch;
	static GetDefaultObject(): MaterialExpressionReflectionCapturePassSwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionReflectionCapturePassSwitch;
	static C(Other: UObject | any): MaterialExpressionReflectionCapturePassSwitch;
}

declare class MaterialExpressionReflectionVectorWS extends MaterialExpression { 
	CustomWorldNormal: ExpressionInput;
	bNormalizeCustomWorldNormal: boolean;
	static Load(ResourceName: string): MaterialExpressionReflectionVectorWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionReflectionVectorWS;
	static GetDefaultObject(): MaterialExpressionReflectionVectorWS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionReflectionVectorWS;
	static C(Other: UObject | any): MaterialExpressionReflectionVectorWS;
}

declare class MaterialExpressionRotateAboutAxis extends MaterialExpression { 
	NormalizedRotationAxis: ExpressionInput;
	RotationAngle: ExpressionInput;
	PivotPoint: ExpressionInput;
	position: ExpressionInput;
	Period: number;
	static Load(ResourceName: string): MaterialExpressionRotateAboutAxis;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionRotateAboutAxis;
	static GetDefaultObject(): MaterialExpressionRotateAboutAxis;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionRotateAboutAxis;
	static C(Other: UObject | any): MaterialExpressionRotateAboutAxis;
}

declare class MaterialExpressionRotator extends MaterialExpression { 
	Coordinate: ExpressionInput;
	Time: ExpressionInput;
	CenterX: number;
	CenterY: number;
	Speed: number;
	ConstCoordinate: any;
	static Load(ResourceName: string): MaterialExpressionRotator;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionRotator;
	static GetDefaultObject(): MaterialExpressionRotator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionRotator;
	static C(Other: UObject | any): MaterialExpressionRotator;
}

declare class MaterialExpressionRound extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionRound;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionRound;
	static GetDefaultObject(): MaterialExpressionRound;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionRound;
	static C(Other: UObject | any): MaterialExpressionRound;
}

declare class MaterialExpressionRuntimeVirtualTextureOutput extends MaterialExpressionCustomOutput { 
	BaseColor: ExpressionInput;
	Specular: ExpressionInput;
	Roughness: ExpressionInput;
	Normal: ExpressionInput;
	WorldHeight: ExpressionInput;
	Opacity: ExpressionInput;
	mask: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionRuntimeVirtualTextureOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionRuntimeVirtualTextureOutput;
	static GetDefaultObject(): MaterialExpressionRuntimeVirtualTextureOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionRuntimeVirtualTextureOutput;
	static C(Other: UObject | any): MaterialExpressionRuntimeVirtualTextureOutput;
}

declare class MaterialExpressionRuntimeVirtualTextureReplace extends MaterialExpression { 
	Default: ExpressionInput;
	VirtualTextureOutput: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionRuntimeVirtualTextureReplace;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionRuntimeVirtualTextureReplace;
	static GetDefaultObject(): MaterialExpressionRuntimeVirtualTextureReplace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionRuntimeVirtualTextureReplace;
	static C(Other: UObject | any): MaterialExpressionRuntimeVirtualTextureReplace;
}

declare type ERuntimeVirtualTextureMipValueMode = 'RVTMVM_None' | 'RVTMVM_MipLevel' | 'RVTMVM_MipBias' | 'RVTMVM_RecalculateDerivatives' | 'RVTMVM_MAX';
declare var ERuntimeVirtualTextureMipValueMode : { RVTMVM_None:'RVTMVM_None',RVTMVM_MipLevel:'RVTMVM_MipLevel',RVTMVM_MipBias:'RVTMVM_MipBias',RVTMVM_RecalculateDerivatives:'RVTMVM_RecalculateDerivatives',RVTMVM_MAX:'RVTMVM_MAX', };
declare type ERuntimeVirtualTextureTextureAddressMode = 'RVTTA_Clamp' | 'RVTTA_Wrap' | 'RVTTA_MAX';
declare var ERuntimeVirtualTextureTextureAddressMode : { RVTTA_Clamp:'RVTTA_Clamp',RVTTA_Wrap:'RVTTA_Wrap',RVTTA_MAX:'RVTTA_MAX', };
declare class MaterialExpressionRuntimeVirtualTextureSample extends MaterialExpression { 
	Coordinates: ExpressionInput;
	WorldPosition: ExpressionInput;
	MipValue: ExpressionInput;
	VirtualTexture: RuntimeVirtualTexture;
	MaterialType: ERuntimeVirtualTextureMaterialType;
	bSinglePhysicalSpace: boolean;
	bAdaptive: boolean;
	MipValueMode: ERuntimeVirtualTextureMipValueMode;
	TextureAddressMode: ERuntimeVirtualTextureTextureAddressMode;
	static Load(ResourceName: string): MaterialExpressionRuntimeVirtualTextureSample;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionRuntimeVirtualTextureSample;
	static GetDefaultObject(): MaterialExpressionRuntimeVirtualTextureSample;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionRuntimeVirtualTextureSample;
	static C(Other: UObject | any): MaterialExpressionRuntimeVirtualTextureSample;
}

declare class MaterialExpressionRuntimeVirtualTextureSampleParameter extends MaterialExpressionRuntimeVirtualTextureSample { 
	ParameterName: string;
	ExpressionGUID: Guid;
	Group: string;
	SortPriority: number;
	static Load(ResourceName: string): MaterialExpressionRuntimeVirtualTextureSampleParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionRuntimeVirtualTextureSampleParameter;
	static GetDefaultObject(): MaterialExpressionRuntimeVirtualTextureSampleParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionRuntimeVirtualTextureSampleParameter;
	static C(Other: UObject | any): MaterialExpressionRuntimeVirtualTextureSampleParameter;
}

declare type EFieldVectorType = 'Vector_LinearForce' | 'Vector_LinearVelocity' | 'Vector_AngularVelocity' | 'Vector_AngularTorque' | 'Vector_PositionTarget' | 'Vector_InitialLinearVelocity' | 'Vector_InitialAngularVelocity' | 'Vector_TargetMax' | 'Vector_MAX';
declare var EFieldVectorType : { Vector_LinearForce:'Vector_LinearForce',Vector_LinearVelocity:'Vector_LinearVelocity',Vector_AngularVelocity:'Vector_AngularVelocity',Vector_AngularTorque:'Vector_AngularTorque',Vector_PositionTarget:'Vector_PositionTarget',Vector_InitialLinearVelocity:'Vector_InitialLinearVelocity',Vector_InitialAngularVelocity:'Vector_InitialAngularVelocity',Vector_TargetMax:'Vector_TargetMax',Vector_MAX:'Vector_MAX', };
declare class MaterialExpressionSamplePhysicsVectorField extends MaterialExpression { 
	WorldPosition: ExpressionInput;
	FieldTarget: EFieldVectorType;
	static Load(ResourceName: string): MaterialExpressionSamplePhysicsVectorField;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSamplePhysicsVectorField;
	static GetDefaultObject(): MaterialExpressionSamplePhysicsVectorField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSamplePhysicsVectorField;
	static C(Other: UObject | any): MaterialExpressionSamplePhysicsVectorField;
}

declare type EFieldScalarType = 'Scalar_ExternalClusterStrain' | 'Scalar_Kill' | 'Scalar_DisableThreshold' | 'Scalar_SleepingThreshold' | 'Scalar_InternalClusterStrain' | 'Scalar_DynamicConstraint' | 'Scalar_TargetMax' | 'Scalar_MAX';
declare var EFieldScalarType : { Scalar_ExternalClusterStrain:'Scalar_ExternalClusterStrain',Scalar_Kill:'Scalar_Kill',Scalar_DisableThreshold:'Scalar_DisableThreshold',Scalar_SleepingThreshold:'Scalar_SleepingThreshold',Scalar_InternalClusterStrain:'Scalar_InternalClusterStrain',Scalar_DynamicConstraint:'Scalar_DynamicConstraint',Scalar_TargetMax:'Scalar_TargetMax',Scalar_MAX:'Scalar_MAX', };
declare class MaterialExpressionSamplePhysicsScalarField extends MaterialExpression { 
	WorldPosition: ExpressionInput;
	FieldTarget: EFieldScalarType;
	static Load(ResourceName: string): MaterialExpressionSamplePhysicsScalarField;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSamplePhysicsScalarField;
	static GetDefaultObject(): MaterialExpressionSamplePhysicsScalarField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSamplePhysicsScalarField;
	static C(Other: UObject | any): MaterialExpressionSamplePhysicsScalarField;
}

declare type EFieldIntegerType = 'Integer_DynamicState' | 'Integer_ActivateDisabled' | 'Integer_CollisionGroup' | 'Integer_PositionAnimated' | 'Integer_PositionStatic' | 'Integer_TargetMax' | 'Integer_MAX';
declare var EFieldIntegerType : { Integer_DynamicState:'Integer_DynamicState',Integer_ActivateDisabled:'Integer_ActivateDisabled',Integer_CollisionGroup:'Integer_CollisionGroup',Integer_PositionAnimated:'Integer_PositionAnimated',Integer_PositionStatic:'Integer_PositionStatic',Integer_TargetMax:'Integer_TargetMax',Integer_MAX:'Integer_MAX', };
declare class MaterialExpressionSamplePhysicsIntegerField extends MaterialExpression { 
	WorldPosition: ExpressionInput;
	FieldTarget: EFieldIntegerType;
	static Load(ResourceName: string): MaterialExpressionSamplePhysicsIntegerField;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSamplePhysicsIntegerField;
	static GetDefaultObject(): MaterialExpressionSamplePhysicsIntegerField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSamplePhysicsIntegerField;
	static C(Other: UObject | any): MaterialExpressionSamplePhysicsIntegerField;
}

declare class MaterialExpressionSaturate extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionSaturate;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSaturate;
	static GetDefaultObject(): MaterialExpressionSaturate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSaturate;
	static C(Other: UObject | any): MaterialExpressionSaturate;
}

declare type EMaterialSceneAttributeInputMode = 'Coordinates' | 'OffsetFraction' | 'EMaterialSceneAttributeInputMode_MAX';
declare var EMaterialSceneAttributeInputMode : { Coordinates:'Coordinates',OffsetFraction:'OffsetFraction',EMaterialSceneAttributeInputMode_MAX:'EMaterialSceneAttributeInputMode_MAX', };
declare class MaterialExpressionSceneColor extends MaterialExpression { 
	InputMode: EMaterialSceneAttributeInputMode;
	Input: ExpressionInput;
	OffsetFraction: ExpressionInput;
	ConstInput: Vector2D;
	static Load(ResourceName: string): MaterialExpressionSceneColor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSceneColor;
	static GetDefaultObject(): MaterialExpressionSceneColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSceneColor;
	static C(Other: UObject | any): MaterialExpressionSceneColor;
}

declare class MaterialExpressionSceneDepth extends MaterialExpression { 
	InputMode: EMaterialSceneAttributeInputMode;
	Input: ExpressionInput;
	Coordinates: ExpressionInput;
	ConstInput: Vector2D;
	static Load(ResourceName: string): MaterialExpressionSceneDepth;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSceneDepth;
	static GetDefaultObject(): MaterialExpressionSceneDepth;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSceneDepth;
	static C(Other: UObject | any): MaterialExpressionSceneDepth;
}

declare class MaterialExpressionSceneDepthWithoutWater extends MaterialExpression { 
	InputMode: EMaterialSceneAttributeInputMode;
	Input: ExpressionInput;
	ConstInput: Vector2D;
	FallbackDepth: number;
	static Load(ResourceName: string): MaterialExpressionSceneDepthWithoutWater;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSceneDepthWithoutWater;
	static GetDefaultObject(): MaterialExpressionSceneDepthWithoutWater;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSceneDepthWithoutWater;
	static C(Other: UObject | any): MaterialExpressionSceneDepthWithoutWater;
}

declare class MaterialExpressionSceneTexelSize extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionSceneTexelSize;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSceneTexelSize;
	static GetDefaultObject(): MaterialExpressionSceneTexelSize;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSceneTexelSize;
	static C(Other: UObject | any): MaterialExpressionSceneTexelSize;
}

declare type ESceneTextureId = 'PPI_SceneColor' | 'PPI_SceneDepth' | 'PPI_DiffuseColor' | 'PPI_SpecularColor' | 'PPI_SubsurfaceColor' | 'PPI_BaseColor' | 'PPI_Specular' | 'PPI_Metallic' | 'PPI_WorldNormal' | 'PPI_SeparateTranslucency' | 'PPI_Opacity' | 'PPI_Roughness' | 'PPI_MaterialAO' | 'PPI_CustomDepth' | 'PPI_PostProcessInput0' | 'PPI_PostProcessInput1' | 'PPI_PostProcessInput2' | 'PPI_PostProcessInput3' | 'PPI_PostProcessInput4' | 'PPI_PostProcessInput5' | 'PPI_PostProcessInput6' | 'PPI_DecalMask' | 'PPI_ShadingModelColor' | 'PPI_ShadingModelID' | 'PPI_AmbientOcclusion' | 'PPI_CustomStencil' | 'PPI_StoredBaseColor' | 'PPI_StoredSpecular' | 'PPI_Velocity' | 'PPI_WorldTangent' | 'PPI_Anisotropy' | 'PPI_MAX';
declare var ESceneTextureId : { PPI_SceneColor:'PPI_SceneColor',PPI_SceneDepth:'PPI_SceneDepth',PPI_DiffuseColor:'PPI_DiffuseColor',PPI_SpecularColor:'PPI_SpecularColor',PPI_SubsurfaceColor:'PPI_SubsurfaceColor',PPI_BaseColor:'PPI_BaseColor',PPI_Specular:'PPI_Specular',PPI_Metallic:'PPI_Metallic',PPI_WorldNormal:'PPI_WorldNormal',PPI_SeparateTranslucency:'PPI_SeparateTranslucency',PPI_Opacity:'PPI_Opacity',PPI_Roughness:'PPI_Roughness',PPI_MaterialAO:'PPI_MaterialAO',PPI_CustomDepth:'PPI_CustomDepth',PPI_PostProcessInput0:'PPI_PostProcessInput0',PPI_PostProcessInput1:'PPI_PostProcessInput1',PPI_PostProcessInput2:'PPI_PostProcessInput2',PPI_PostProcessInput3:'PPI_PostProcessInput3',PPI_PostProcessInput4:'PPI_PostProcessInput4',PPI_PostProcessInput5:'PPI_PostProcessInput5',PPI_PostProcessInput6:'PPI_PostProcessInput6',PPI_DecalMask:'PPI_DecalMask',PPI_ShadingModelColor:'PPI_ShadingModelColor',PPI_ShadingModelID:'PPI_ShadingModelID',PPI_AmbientOcclusion:'PPI_AmbientOcclusion',PPI_CustomStencil:'PPI_CustomStencil',PPI_StoredBaseColor:'PPI_StoredBaseColor',PPI_StoredSpecular:'PPI_StoredSpecular',PPI_Velocity:'PPI_Velocity',PPI_WorldTangent:'PPI_WorldTangent',PPI_Anisotropy:'PPI_Anisotropy',PPI_MAX:'PPI_MAX', };
declare class MaterialExpressionSceneTexture extends MaterialExpression { 
	Coordinates: ExpressionInput;
	SceneTextureId: ESceneTextureId;
	bFiltered: boolean;
	static Load(ResourceName: string): MaterialExpressionSceneTexture;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSceneTexture;
	static GetDefaultObject(): MaterialExpressionSceneTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSceneTexture;
	static C(Other: UObject | any): MaterialExpressionSceneTexture;
}

declare class MaterialExpressionScreenPosition extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionScreenPosition;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionScreenPosition;
	static GetDefaultObject(): MaterialExpressionScreenPosition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionScreenPosition;
	static C(Other: UObject | any): MaterialExpressionScreenPosition;
}

declare class MaterialExpressionSetLocal extends MaterialExpression { 
	exec: ExpressionExecOutput;
	Value: ExpressionInput;
	LocalName: string;
	static Load(ResourceName: string): MaterialExpressionSetLocal;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSetLocal;
	static GetDefaultObject(): MaterialExpressionSetLocal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSetLocal;
	static C(Other: UObject | any): MaterialExpressionSetLocal;
}

declare class MaterialExpressionSetMaterialAttributes extends MaterialExpression { 
	Inputs: ExpressionInput[];
	AttributeSetTypes: Guid[];
	static Load(ResourceName: string): MaterialExpressionSetMaterialAttributes;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSetMaterialAttributes;
	static GetDefaultObject(): MaterialExpressionSetMaterialAttributes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSetMaterialAttributes;
	static C(Other: UObject | any): MaterialExpressionSetMaterialAttributes;
}

declare class MaterialExpressionShaderStageSwitch extends MaterialExpression { 
	PixelShader: ExpressionInput;
	VertexShader: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionShaderStageSwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionShaderStageSwitch;
	static GetDefaultObject(): MaterialExpressionShaderStageSwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionShaderStageSwitch;
	static C(Other: UObject | any): MaterialExpressionShaderStageSwitch;
}

declare class MaterialExpressionShadingModel extends MaterialExpression { 
	ShadingModel: EMaterialShadingModel;
	static Load(ResourceName: string): MaterialExpressionShadingModel;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionShadingModel;
	static GetDefaultObject(): MaterialExpressionShadingModel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionShadingModel;
	static C(Other: UObject | any): MaterialExpressionShadingModel;
}

declare class MaterialExpressionShadingPathSwitch extends MaterialExpression { 
	Default: ExpressionInput;
	Inputs: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionShadingPathSwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionShadingPathSwitch;
	static GetDefaultObject(): MaterialExpressionShadingPathSwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionShadingPathSwitch;
	static C(Other: UObject | any): MaterialExpressionShadingPathSwitch;
}

declare class MaterialExpressionShadowReplace extends MaterialExpression { 
	Default: ExpressionInput;
	Shadow: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionShadowReplace;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionShadowReplace;
	static GetDefaultObject(): MaterialExpressionShadowReplace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionShadowReplace;
	static C(Other: UObject | any): MaterialExpressionShadowReplace;
}

declare class MaterialExpressionSign extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionSign;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSign;
	static GetDefaultObject(): MaterialExpressionSign;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSign;
	static C(Other: UObject | any): MaterialExpressionSign;
}

declare class MaterialExpressionSine extends MaterialExpression { 
	Input: ExpressionInput;
	Period: number;
	static Load(ResourceName: string): MaterialExpressionSine;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSine;
	static GetDefaultObject(): MaterialExpressionSine;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSine;
	static C(Other: UObject | any): MaterialExpressionSine;
}

declare class MaterialExpressionSingleLayerWaterMaterialOutput extends MaterialExpressionCustomOutput { 
	ScatteringCoefficients: ExpressionInput;
	AbsorptionCoefficients: ExpressionInput;
	PhaseG: ExpressionInput;
	ColorScaleBehindWater: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionSingleLayerWaterMaterialOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSingleLayerWaterMaterialOutput;
	static GetDefaultObject(): MaterialExpressionSingleLayerWaterMaterialOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSingleLayerWaterMaterialOutput;
	static C(Other: UObject | any): MaterialExpressionSingleLayerWaterMaterialOutput;
}

declare class MaterialExpressionSkyAtmosphereLightDirection extends MaterialExpression { 
	LightIndex: number;
	static Load(ResourceName: string): MaterialExpressionSkyAtmosphereLightDirection;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSkyAtmosphereLightDirection;
	static GetDefaultObject(): MaterialExpressionSkyAtmosphereLightDirection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSkyAtmosphereLightDirection;
	static C(Other: UObject | any): MaterialExpressionSkyAtmosphereLightDirection;
}

declare class MaterialExpressionSkyAtmosphereLightIlluminance extends MaterialExpression { 
	LightIndex: number;
	WorldPosition: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionSkyAtmosphereLightIlluminance;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSkyAtmosphereLightIlluminance;
	static GetDefaultObject(): MaterialExpressionSkyAtmosphereLightIlluminance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSkyAtmosphereLightIlluminance;
	static C(Other: UObject | any): MaterialExpressionSkyAtmosphereLightIlluminance;
}

declare class MaterialExpressionSkyAtmosphereLightDiskLuminance extends MaterialExpression { 
	LightIndex: number;
	static Load(ResourceName: string): MaterialExpressionSkyAtmosphereLightDiskLuminance;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSkyAtmosphereLightDiskLuminance;
	static GetDefaultObject(): MaterialExpressionSkyAtmosphereLightDiskLuminance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSkyAtmosphereLightDiskLuminance;
	static C(Other: UObject | any): MaterialExpressionSkyAtmosphereLightDiskLuminance;
}

declare class MaterialExpressionSkyAtmosphereAerialPerspective extends MaterialExpression { 
	WorldPosition: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionSkyAtmosphereAerialPerspective;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSkyAtmosphereAerialPerspective;
	static GetDefaultObject(): MaterialExpressionSkyAtmosphereAerialPerspective;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSkyAtmosphereAerialPerspective;
	static C(Other: UObject | any): MaterialExpressionSkyAtmosphereAerialPerspective;
}

declare class MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
	static GetDefaultObject(): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
	static C(Other: UObject | any): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
}

declare class MaterialExpressionSkyAtmosphereViewLuminance extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionSkyAtmosphereViewLuminance;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSkyAtmosphereViewLuminance;
	static GetDefaultObject(): MaterialExpressionSkyAtmosphereViewLuminance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSkyAtmosphereViewLuminance;
	static C(Other: UObject | any): MaterialExpressionSkyAtmosphereViewLuminance;
}

declare class MaterialExpressionSkyLightEnvMapSample extends MaterialExpression { 
	Direction: ExpressionInput;
	Roughness: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionSkyLightEnvMapSample;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSkyLightEnvMapSample;
	static GetDefaultObject(): MaterialExpressionSkyLightEnvMapSample;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSkyLightEnvMapSample;
	static C(Other: UObject | any): MaterialExpressionSkyLightEnvMapSample;
}

declare class MaterialExpressionSmoothStep extends MaterialExpression { 
	Min: ExpressionInput;
	Max: ExpressionInput;
	Value: ExpressionInput;
	ConstMin: number;
	ConstMax: number;
	ConstValue: number;
	static Load(ResourceName: string): MaterialExpressionSmoothStep;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSmoothStep;
	static GetDefaultObject(): MaterialExpressionSmoothStep;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSmoothStep;
	static C(Other: UObject | any): MaterialExpressionSmoothStep;
}

declare class MaterialExpressionSobol extends MaterialExpression { 
	Cell: ExpressionInput;
	index: ExpressionInput;
	Seed: ExpressionInput;
	ConstIndex: any;
	ConstSeed: Vector2D;
	static Load(ResourceName: string): MaterialExpressionSobol;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSobol;
	static GetDefaultObject(): MaterialExpressionSobol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSobol;
	static C(Other: UObject | any): MaterialExpressionSobol;
}

declare type ESpeedTreeGeometryType = 'STG_Branch' | 'STG_Frond' | 'STG_Leaf' | 'STG_FacingLeaf' | 'STG_Billboard' | 'STG_MAX';
declare var ESpeedTreeGeometryType : { STG_Branch:'STG_Branch',STG_Frond:'STG_Frond',STG_Leaf:'STG_Leaf',STG_FacingLeaf:'STG_FacingLeaf',STG_Billboard:'STG_Billboard',STG_MAX:'STG_MAX', };
declare type ESpeedTreeWindType = 'STW_None' | 'STW_Fastest' | 'STW_Fast' | 'STW_Better' | 'STW_Best' | 'STW_Palm' | 'STW_BestPlus' | 'STW_MAX';
declare var ESpeedTreeWindType : { STW_None:'STW_None',STW_Fastest:'STW_Fastest',STW_Fast:'STW_Fast',STW_Better:'STW_Better',STW_Best:'STW_Best',STW_Palm:'STW_Palm',STW_BestPlus:'STW_BestPlus',STW_MAX:'STW_MAX', };
declare type ESpeedTreeLODType = 'STLOD_Pop' | 'STLOD_Smooth' | 'STLOD_MAX';
declare var ESpeedTreeLODType : { STLOD_Pop:'STLOD_Pop',STLOD_Smooth:'STLOD_Smooth',STLOD_MAX:'STLOD_MAX', };
declare class MaterialExpressionSpeedTree extends MaterialExpression { 
	GeometryInput: ExpressionInput;
	WindInput: ExpressionInput;
	LODInput: ExpressionInput;
	ExtraBendWS: ExpressionInput;
	GeometryType: ESpeedTreeGeometryType;
	WindType: ESpeedTreeWindType;
	LODType: ESpeedTreeLODType;
	BillboardThreshold: number;
	bAccurateWindVelocities: boolean;
	static Load(ResourceName: string): MaterialExpressionSpeedTree;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSpeedTree;
	static GetDefaultObject(): MaterialExpressionSpeedTree;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSpeedTree;
	static C(Other: UObject | any): MaterialExpressionSpeedTree;
}

declare class MaterialExpressionSphereMask extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	Radius: ExpressionInput;
	Hardness: ExpressionInput;
	AttenuationRadius: number;
	HardnessPercent: number;
	static Load(ResourceName: string): MaterialExpressionSphereMask;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSphereMask;
	static GetDefaultObject(): MaterialExpressionSphereMask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSphereMask;
	static C(Other: UObject | any): MaterialExpressionSphereMask;
}

declare class MaterialExpressionSphericalParticleOpacity extends MaterialExpression { 
	Density: ExpressionInput;
	ConstantDensity: number;
	static Load(ResourceName: string): MaterialExpressionSphericalParticleOpacity;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSphericalParticleOpacity;
	static GetDefaultObject(): MaterialExpressionSphericalParticleOpacity;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSphericalParticleOpacity;
	static C(Other: UObject | any): MaterialExpressionSphericalParticleOpacity;
}

declare class MaterialExpressionSquareRoot extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionSquareRoot;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSquareRoot;
	static GetDefaultObject(): MaterialExpressionSquareRoot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSquareRoot;
	static C(Other: UObject | any): MaterialExpressionSquareRoot;
}

declare class MaterialExpressionStaticBool extends MaterialExpression { 
	Value: boolean;
	static Load(ResourceName: string): MaterialExpressionStaticBool;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticBool;
	static GetDefaultObject(): MaterialExpressionStaticBool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticBool;
	static C(Other: UObject | any): MaterialExpressionStaticBool;
}

declare class MaterialExpressionStaticBoolParameter extends MaterialExpressionParameter { 
	DefaultValue: boolean;
	static Load(ResourceName: string): MaterialExpressionStaticBoolParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticBoolParameter;
	static GetDefaultObject(): MaterialExpressionStaticBoolParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticBoolParameter;
	static C(Other: UObject | any): MaterialExpressionStaticBoolParameter;
}

declare class MaterialExpressionStaticComponentMaskParameter extends MaterialExpressionParameter { 
	Input: ExpressionInput;
	DefaultR: boolean;
	DefaultG: boolean;
	DefaultB: boolean;
	DefaultA: boolean;
	static Load(ResourceName: string): MaterialExpressionStaticComponentMaskParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticComponentMaskParameter;
	static GetDefaultObject(): MaterialExpressionStaticComponentMaskParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticComponentMaskParameter;
	static C(Other: UObject | any): MaterialExpressionStaticComponentMaskParameter;
}

declare class MaterialExpressionStaticSwitch extends MaterialExpression { 
	DefaultValue: boolean;
	A: ExpressionInput;
	B: ExpressionInput;
	Value: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStaticSwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticSwitch;
	static GetDefaultObject(): MaterialExpressionStaticSwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticSwitch;
	static C(Other: UObject | any): MaterialExpressionStaticSwitch;
}

declare class MaterialExpressionStaticSwitchParameter extends MaterialExpressionStaticBoolParameter { 
	A: ExpressionInput;
	B: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStaticSwitchParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticSwitchParameter;
	static GetDefaultObject(): MaterialExpressionStaticSwitchParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticSwitchParameter;
	static C(Other: UObject | any): MaterialExpressionStaticSwitchParameter;
}

declare class MaterialExpressionStep extends MaterialExpression { 
	Y: ExpressionInput;
	X: ExpressionInput;
	ConstY: number;
	ConstX: number;
	static Load(ResourceName: string): MaterialExpressionStep;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStep;
	static GetDefaultObject(): MaterialExpressionStep;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStep;
	static C(Other: UObject | any): MaterialExpressionStep;
}

declare class MaterialExpressionStrataBSDF extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionStrataBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataBSDF;
	static GetDefaultObject(): MaterialExpressionStrataBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataBSDF;
}

declare class StrataMaterialInfo { 
	ShadingModelField: number;
	bHasShadingModelFromExpression: number;
	SubsurfaceProfiles: SubsurfaceProfile[];
	clone() : StrataMaterialInfo;
	static C(Other: UObject | any): StrataMaterialInfo;
}

declare class MaterialExpressionStrataLegacyConversion extends MaterialExpressionStrataBSDF { 
	BaseColor: ExpressionInput;
	Metallic: ExpressionInput;
	Specular: ExpressionInput;
	Roughness: ExpressionInput;
	Anisotropy: ExpressionInput;
	EmissiveColor: ExpressionInput;
	Normal: ExpressionInput;
	Tangent: ExpressionInput;
	SubsurfaceColor: ExpressionInput;
	ClearCoat: ExpressionInput;
	ClearCoatRoughness: ExpressionInput;
	Opacity: ExpressionInput;
	TransmittanceColor: ExpressionInput;
	WaterScatteringCoefficients: ExpressionInput;
	WaterAbsorptionCoefficients: ExpressionInput;
	WaterPhaseG: ExpressionInput;
	ColorScaleBehindWater: ExpressionInput;
	ClearCoatNormal: ExpressionInput;
	ShadingModel: ExpressionInput;
	SubsurfaceProfile: SubsurfaceProfile;
	ConvertedStrataMaterialInfo: StrataMaterialInfo;
	static Load(ResourceName: string): MaterialExpressionStrataLegacyConversion;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataLegacyConversion;
	static GetDefaultObject(): MaterialExpressionStrataLegacyConversion;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataLegacyConversion;
	static C(Other: UObject | any): MaterialExpressionStrataLegacyConversion;
}

declare class MaterialExpressionStrataSlabBSDF extends MaterialExpressionStrataBSDF { 
	BaseColor: ExpressionInput;
	EdgeColor: ExpressionInput;
	Metallic: ExpressionInput;
	Specular: ExpressionInput;
	DiffuseAlbedo: ExpressionInput;
	F0: ExpressionInput;
	F90: ExpressionInput;
	Roughness: ExpressionInput;
	Anisotropy: ExpressionInput;
	Normal: ExpressionInput;
	Tangent: ExpressionInput;
	SSSDMFP: ExpressionInput;
	SSSDMFPScale: ExpressionInput;
	EmissiveColor: ExpressionInput;
	Haziness: ExpressionInput;
	ThinFilmThickness: ExpressionInput;
	Thickness: ExpressionInput;
	FuzzAmount: ExpressionInput;
	FuzzColor: ExpressionInput;
	SubsurfaceProfile: SubsurfaceProfile;
	bUseMetalness: boolean;
	static Load(ResourceName: string): MaterialExpressionStrataSlabBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataSlabBSDF;
	static GetDefaultObject(): MaterialExpressionStrataSlabBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataSlabBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataSlabBSDF;
}

declare class MaterialExpressionStrataVolumetricFogCloudBSDF extends MaterialExpressionStrataBSDF { 
	Albedo: ExpressionInput;
	Extinction: ExpressionInput;
	EmissiveColor: ExpressionInput;
	AmbientOcclusion: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataVolumetricFogCloudBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataVolumetricFogCloudBSDF;
	static GetDefaultObject(): MaterialExpressionStrataVolumetricFogCloudBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataVolumetricFogCloudBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataVolumetricFogCloudBSDF;
}

declare class MaterialExpressionStrataUnlitBSDF extends MaterialExpressionStrataBSDF { 
	EmissiveColor: ExpressionInput;
	TransmittanceColor: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataUnlitBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataUnlitBSDF;
	static GetDefaultObject(): MaterialExpressionStrataUnlitBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataUnlitBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataUnlitBSDF;
}

declare class MaterialExpressionStrataHairBSDF extends MaterialExpressionStrataBSDF { 
	BaseColor: ExpressionInput;
	Scatter: ExpressionInput;
	Specular: ExpressionInput;
	Roughness: ExpressionInput;
	Backlit: ExpressionInput;
	Tangent: ExpressionInput;
	EmissiveColor: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataHairBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataHairBSDF;
	static GetDefaultObject(): MaterialExpressionStrataHairBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataHairBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataHairBSDF;
}

declare class MaterialExpressionStrataSingleLayerWaterBSDF extends MaterialExpressionStrataBSDF { 
	BaseColor: ExpressionInput;
	Metallic: ExpressionInput;
	Specular: ExpressionInput;
	Roughness: ExpressionInput;
	Normal: ExpressionInput;
	EmissiveColor: ExpressionInput;
	TopMaterialOpacity: ExpressionInput;
	WaterAlbedo: ExpressionInput;
	WaterExtinction: ExpressionInput;
	WaterPhaseG: ExpressionInput;
	ColorScaleBehindWater: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataSingleLayerWaterBSDF;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataSingleLayerWaterBSDF;
	static GetDefaultObject(): MaterialExpressionStrataSingleLayerWaterBSDF;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataSingleLayerWaterBSDF;
	static C(Other: UObject | any): MaterialExpressionStrataSingleLayerWaterBSDF;
}

declare class MaterialExpressionStrataHorizontalMixing extends MaterialExpressionStrataBSDF { 
	Background: ExpressionInput;
	Foreground: ExpressionInput;
	Mix: ExpressionInput;
	bUseParameterBlending: boolean;
	static Load(ResourceName: string): MaterialExpressionStrataHorizontalMixing;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataHorizontalMixing;
	static GetDefaultObject(): MaterialExpressionStrataHorizontalMixing;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataHorizontalMixing;
	static C(Other: UObject | any): MaterialExpressionStrataHorizontalMixing;
}

declare class MaterialExpressionStrataVerticalLayering extends MaterialExpressionStrataBSDF { 
	Top: ExpressionInput;
	Base: ExpressionInput;
	bUseParameterBlending: boolean;
	static Load(ResourceName: string): MaterialExpressionStrataVerticalLayering;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataVerticalLayering;
	static GetDefaultObject(): MaterialExpressionStrataVerticalLayering;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataVerticalLayering;
	static C(Other: UObject | any): MaterialExpressionStrataVerticalLayering;
}

declare class MaterialExpressionStrataAdd extends MaterialExpressionStrataBSDF { 
	A: ExpressionInput;
	B: ExpressionInput;
	bUseParameterBlending: boolean;
	static Load(ResourceName: string): MaterialExpressionStrataAdd;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataAdd;
	static GetDefaultObject(): MaterialExpressionStrataAdd;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataAdd;
	static C(Other: UObject | any): MaterialExpressionStrataAdd;
}

declare class MaterialExpressionStrataWeight extends MaterialExpressionStrataBSDF { 
	A: ExpressionInput;
	Weight: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataWeight;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataWeight;
	static GetDefaultObject(): MaterialExpressionStrataWeight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataWeight;
	static C(Other: UObject | any): MaterialExpressionStrataWeight;
}

declare class MaterialExpressionStrataTransmittanceToMFP extends MaterialExpressionStrataBSDF { 
	TransmittanceColor: ExpressionInput;
	Thickness: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionStrataTransmittanceToMFP;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStrataTransmittanceToMFP;
	static GetDefaultObject(): MaterialExpressionStrataTransmittanceToMFP;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStrataTransmittanceToMFP;
	static C(Other: UObject | any): MaterialExpressionStrataTransmittanceToMFP;
}

declare class MaterialExpressionSubtract extends MaterialExpression { 
	A: ExpressionInput;
	B: ExpressionInput;
	ConstA: number;
	ConstB: number;
	static Load(ResourceName: string): MaterialExpressionSubtract;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSubtract;
	static GetDefaultObject(): MaterialExpressionSubtract;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSubtract;
	static C(Other: UObject | any): MaterialExpressionSubtract;
}

declare class MaterialExpressionTangent extends MaterialExpression { 
	Input: ExpressionInput;
	Period: number;
	static Load(ResourceName: string): MaterialExpressionTangent;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTangent;
	static GetDefaultObject(): MaterialExpressionTangent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTangent;
	static C(Other: UObject | any): MaterialExpressionTangent;
}

declare class MaterialExpressionTangentOutput extends MaterialExpressionCustomOutput { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionTangentOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTangentOutput;
	static GetDefaultObject(): MaterialExpressionTangentOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTangentOutput;
	static C(Other: UObject | any): MaterialExpressionTangentOutput;
}

declare class MaterialExpressionTemporalSobol extends MaterialExpression { 
	index: ExpressionInput;
	Seed: ExpressionInput;
	ConstIndex: any;
	ConstSeed: Vector2D;
	static Load(ResourceName: string): MaterialExpressionTemporalSobol;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTemporalSobol;
	static GetDefaultObject(): MaterialExpressionTemporalSobol;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTemporalSobol;
	static C(Other: UObject | any): MaterialExpressionTemporalSobol;
}

declare class MaterialExpressionTextureCoordinate extends MaterialExpression { 
	CoordinateIndex: number;
	UTiling: number;
	VTiling: number;
	UnMirrorU: boolean;
	UnMirrorV: boolean;
	static Load(ResourceName: string): MaterialExpressionTextureCoordinate;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureCoordinate;
	static GetDefaultObject(): MaterialExpressionTextureCoordinate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureCoordinate;
	static C(Other: UObject | any): MaterialExpressionTextureCoordinate;
}

declare class MaterialExpressionTextureObject extends MaterialExpressionTextureBase { 
	static Load(ResourceName: string): MaterialExpressionTextureObject;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureObject;
	static GetDefaultObject(): MaterialExpressionTextureObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureObject;
	static C(Other: UObject | any): MaterialExpressionTextureObject;
}

declare class MaterialExpressionTextureObjectParameter extends MaterialExpressionTextureSampleParameter { 
	static Load(ResourceName: string): MaterialExpressionTextureObjectParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureObjectParameter;
	static GetDefaultObject(): MaterialExpressionTextureObjectParameter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureObjectParameter;
	static C(Other: UObject | any): MaterialExpressionTextureObjectParameter;
}

declare type EMaterialExposedTextureProperty = 'TMTM_TextureSize' | 'TMTM_TexelSize' | 'TMTM_MAX';
declare var EMaterialExposedTextureProperty : { TMTM_TextureSize:'TMTM_TextureSize',TMTM_TexelSize:'TMTM_TexelSize',TMTM_MAX:'TMTM_MAX', };
declare class MaterialExpressionTextureProperty extends MaterialExpression { 
	TextureObject: ExpressionInput;
	Property: EMaterialExposedTextureProperty;
	static Load(ResourceName: string): MaterialExpressionTextureProperty;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureProperty;
	static GetDefaultObject(): MaterialExpressionTextureProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureProperty;
	static C(Other: UObject | any): MaterialExpressionTextureProperty;
}

declare class MaterialExpressionTextureSampleParameter2DArray extends MaterialExpressionTextureSampleParameter { 
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameter2DArray;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameter2DArray;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameter2DArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameter2DArray;
	static C(Other: UObject | any): MaterialExpressionTextureSampleParameter2DArray;
}

declare class MaterialExpressionTextureSampleParameterCube extends MaterialExpressionTextureSampleParameter { 
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameterCube;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameterCube;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameterCube;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameterCube;
	static C(Other: UObject | any): MaterialExpressionTextureSampleParameterCube;
}

declare class MaterialExpressionTextureSampleParameterCubeArray extends MaterialExpressionTextureSampleParameter { 
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameterCubeArray;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameterCubeArray;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameterCubeArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameterCubeArray;
	static C(Other: UObject | any): MaterialExpressionTextureSampleParameterCubeArray;
}

declare class MaterialExpressionTextureSampleParameterSubUV extends MaterialExpressionTextureSampleParameter2D { 
	bBlend: boolean;
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameterSubUV;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameterSubUV;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameterSubUV;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameterSubUV;
	static C(Other: UObject | any): MaterialExpressionTextureSampleParameterSubUV;
}

declare class MaterialExpressionTextureSampleParameterVolume extends MaterialExpressionTextureSampleParameter { 
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameterVolume;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameterVolume;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameterVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameterVolume;
	static C(Other: UObject | any): MaterialExpressionTextureSampleParameterVolume;
}

declare class MaterialExpressionThinTranslucentMaterialOutput extends MaterialExpressionCustomOutput { 
	TransmittanceColor: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionThinTranslucentMaterialOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionThinTranslucentMaterialOutput;
	static GetDefaultObject(): MaterialExpressionThinTranslucentMaterialOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionThinTranslucentMaterialOutput;
	static C(Other: UObject | any): MaterialExpressionThinTranslucentMaterialOutput;
}

declare class MaterialExpressionTime extends MaterialExpression { 
	bIgnorePause: boolean;
	bOverride_Period: boolean;
	Period: number;
	static Load(ResourceName: string): MaterialExpressionTime;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTime;
	static GetDefaultObject(): MaterialExpressionTime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTime;
	static C(Other: UObject | any): MaterialExpressionTime;
}

declare type EMaterialVectorCoordTransformSource = 'TRANSFORMSOURCE_Tangent' | 'TRANSFORMSOURCE_Local' | 'TRANSFORMSOURCE_World' | 'TRANSFORMSOURCE_View' | 'TRANSFORMSOURCE_Camera' | 'TRANSFORMSOURCE_ParticleWorld' | 'TRANSFORMSOURCE_Instance' | 'TRANSFORMSOURCE_MAX';
declare var EMaterialVectorCoordTransformSource : { TRANSFORMSOURCE_Tangent:'TRANSFORMSOURCE_Tangent',TRANSFORMSOURCE_Local:'TRANSFORMSOURCE_Local',TRANSFORMSOURCE_World:'TRANSFORMSOURCE_World',TRANSFORMSOURCE_View:'TRANSFORMSOURCE_View',TRANSFORMSOURCE_Camera:'TRANSFORMSOURCE_Camera',TRANSFORMSOURCE_ParticleWorld:'TRANSFORMSOURCE_ParticleWorld',TRANSFORMSOURCE_Instance:'TRANSFORMSOURCE_Instance',TRANSFORMSOURCE_MAX:'TRANSFORMSOURCE_MAX', };
declare type EMaterialVectorCoordTransform = 'TRANSFORM_Tangent' | 'TRANSFORM_Local' | 'TRANSFORM_World' | 'TRANSFORM_View' | 'TRANSFORM_Camera' | 'TRANSFORM_ParticleWorld' | 'TRANSFORM_Instance' | 'TRANSFORM_MAX';
declare var EMaterialVectorCoordTransform : { TRANSFORM_Tangent:'TRANSFORM_Tangent',TRANSFORM_Local:'TRANSFORM_Local',TRANSFORM_World:'TRANSFORM_World',TRANSFORM_View:'TRANSFORM_View',TRANSFORM_Camera:'TRANSFORM_Camera',TRANSFORM_ParticleWorld:'TRANSFORM_ParticleWorld',TRANSFORM_Instance:'TRANSFORM_Instance',TRANSFORM_MAX:'TRANSFORM_MAX', };
declare class MaterialExpressionTransform extends MaterialExpression { 
	Input: ExpressionInput;
	TransformSourceType: EMaterialVectorCoordTransformSource;
	TransformType: EMaterialVectorCoordTransform;
	static Load(ResourceName: string): MaterialExpressionTransform;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTransform;
	static GetDefaultObject(): MaterialExpressionTransform;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTransform;
	static C(Other: UObject | any): MaterialExpressionTransform;
}

declare type EMaterialPositionTransformSource = 'TRANSFORMPOSSOURCE_Local' | 'TRANSFORMPOSSOURCE_World' | 'TRANSFORMPOSSOURCE_TranslatedWorld' | 'TRANSFORMPOSSOURCE_View' | 'TRANSFORMPOSSOURCE_Camera' | 'TRANSFORMPOSSOURCE_Particle' | 'TRANSFORMPOSSOURCE_Instance' | 'TRANSFORMPOSSOURCE_MAX';
declare var EMaterialPositionTransformSource : { TRANSFORMPOSSOURCE_Local:'TRANSFORMPOSSOURCE_Local',TRANSFORMPOSSOURCE_World:'TRANSFORMPOSSOURCE_World',TRANSFORMPOSSOURCE_TranslatedWorld:'TRANSFORMPOSSOURCE_TranslatedWorld',TRANSFORMPOSSOURCE_View:'TRANSFORMPOSSOURCE_View',TRANSFORMPOSSOURCE_Camera:'TRANSFORMPOSSOURCE_Camera',TRANSFORMPOSSOURCE_Particle:'TRANSFORMPOSSOURCE_Particle',TRANSFORMPOSSOURCE_Instance:'TRANSFORMPOSSOURCE_Instance',TRANSFORMPOSSOURCE_MAX:'TRANSFORMPOSSOURCE_MAX', };
declare class MaterialExpressionTransformPosition extends MaterialExpression { 
	Input: ExpressionInput;
	TransformSourceType: EMaterialPositionTransformSource;
	TransformType: EMaterialPositionTransformSource;
	static Load(ResourceName: string): MaterialExpressionTransformPosition;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTransformPosition;
	static GetDefaultObject(): MaterialExpressionTransformPosition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTransformPosition;
	static C(Other: UObject | any): MaterialExpressionTransformPosition;
}

declare class MaterialExpressionTruncate extends MaterialExpression { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionTruncate;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTruncate;
	static GetDefaultObject(): MaterialExpressionTruncate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTruncate;
	static C(Other: UObject | any): MaterialExpressionTruncate;
}

declare class MaterialExpressionTwoSidedSign extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionTwoSidedSign;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTwoSidedSign;
	static GetDefaultObject(): MaterialExpressionTwoSidedSign;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTwoSidedSign;
	static C(Other: UObject | any): MaterialExpressionTwoSidedSign;
}

declare type EVectorNoiseFunction = 'VNF_CellnoiseALU' | 'VNF_VectorALU' | 'VNF_GradientALU' | 'VNF_CurlALU' | 'VNF_VoronoiALU' | 'VNF_MAX';
declare var EVectorNoiseFunction : { VNF_CellnoiseALU:'VNF_CellnoiseALU',VNF_VectorALU:'VNF_VectorALU',VNF_GradientALU:'VNF_GradientALU',VNF_CurlALU:'VNF_CurlALU',VNF_VoronoiALU:'VNF_VoronoiALU',VNF_MAX:'VNF_MAX', };
declare class MaterialExpressionVectorNoise extends MaterialExpression { 
	position: ExpressionInput;
	NoiseFunction: EVectorNoiseFunction;
	Quality: number;
	bTiling: boolean;
	TileSize: any;
	static Load(ResourceName: string): MaterialExpressionVectorNoise;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVectorNoise;
	static GetDefaultObject(): MaterialExpressionVectorNoise;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVectorNoise;
	static C(Other: UObject | any): MaterialExpressionVectorNoise;
}

declare class MaterialExpressionVertexColor extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionVertexColor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVertexColor;
	static GetDefaultObject(): MaterialExpressionVertexColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVertexColor;
	static C(Other: UObject | any): MaterialExpressionVertexColor;
}

declare class MaterialExpressionVertexInterpolator extends MaterialExpressionCustomOutput { 
	Input: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionVertexInterpolator;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVertexInterpolator;
	static GetDefaultObject(): MaterialExpressionVertexInterpolator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVertexInterpolator;
	static C(Other: UObject | any): MaterialExpressionVertexInterpolator;
}

declare class MaterialExpressionVertexNormalWS extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionVertexNormalWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVertexNormalWS;
	static GetDefaultObject(): MaterialExpressionVertexNormalWS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVertexNormalWS;
	static C(Other: UObject | any): MaterialExpressionVertexNormalWS;
}

declare class MaterialExpressionVertexTangentWS extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionVertexTangentWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVertexTangentWS;
	static GetDefaultObject(): MaterialExpressionVertexTangentWS;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVertexTangentWS;
	static C(Other: UObject | any): MaterialExpressionVertexTangentWS;
}

declare type EMaterialExposedViewProperty = 'MEVP_BufferSize' | 'MEVP_FieldOfView' | 'MEVP_TanHalfFieldOfView' | 'MEVP_ViewSize' | 'MEVP_WorldSpaceViewPosition' | 'MEVP_WorldSpaceCameraPosition' | 'MEVP_ViewportOffset' | 'MEVP_TemporalSampleCount' | 'MEVP_TemporalSampleIndex' | 'MEVP_TemporalSampleOffset' | 'MEVP_RuntimeVirtualTextureOutputLevel' | 'MEVP_RuntimeVirtualTextureOutputDerivative' | 'MEVP_PreExposure' | 'MEVP_RuntimeVirtualTextureMaxLevel' | 'MEVP_MAX';
declare var EMaterialExposedViewProperty : { MEVP_BufferSize:'MEVP_BufferSize',MEVP_FieldOfView:'MEVP_FieldOfView',MEVP_TanHalfFieldOfView:'MEVP_TanHalfFieldOfView',MEVP_ViewSize:'MEVP_ViewSize',MEVP_WorldSpaceViewPosition:'MEVP_WorldSpaceViewPosition',MEVP_WorldSpaceCameraPosition:'MEVP_WorldSpaceCameraPosition',MEVP_ViewportOffset:'MEVP_ViewportOffset',MEVP_TemporalSampleCount:'MEVP_TemporalSampleCount',MEVP_TemporalSampleIndex:'MEVP_TemporalSampleIndex',MEVP_TemporalSampleOffset:'MEVP_TemporalSampleOffset',MEVP_RuntimeVirtualTextureOutputLevel:'MEVP_RuntimeVirtualTextureOutputLevel',MEVP_RuntimeVirtualTextureOutputDerivative:'MEVP_RuntimeVirtualTextureOutputDerivative',MEVP_PreExposure:'MEVP_PreExposure',MEVP_RuntimeVirtualTextureMaxLevel:'MEVP_RuntimeVirtualTextureMaxLevel',MEVP_MAX:'MEVP_MAX', };
declare class MaterialExpressionViewProperty extends MaterialExpression { 
	Property: EMaterialExposedViewProperty;
	static Load(ResourceName: string): MaterialExpressionViewProperty;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionViewProperty;
	static GetDefaultObject(): MaterialExpressionViewProperty;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionViewProperty;
	static C(Other: UObject | any): MaterialExpressionViewProperty;
}

declare class MaterialExpressionViewSize extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionViewSize;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionViewSize;
	static GetDefaultObject(): MaterialExpressionViewSize;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionViewSize;
	static C(Other: UObject | any): MaterialExpressionViewSize;
}

declare class MaterialExpressionVirtualTextureFeatureSwitch extends MaterialExpression { 
	No: ExpressionInput;
	Yes: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionVirtualTextureFeatureSwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVirtualTextureFeatureSwitch;
	static GetDefaultObject(): MaterialExpressionVirtualTextureFeatureSwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVirtualTextureFeatureSwitch;
	static C(Other: UObject | any): MaterialExpressionVirtualTextureFeatureSwitch;
}

declare class MaterialExpressionVolumetricAdvancedMaterialInput extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionVolumetricAdvancedMaterialInput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVolumetricAdvancedMaterialInput;
	static GetDefaultObject(): MaterialExpressionVolumetricAdvancedMaterialInput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVolumetricAdvancedMaterialInput;
	static C(Other: UObject | any): MaterialExpressionVolumetricAdvancedMaterialInput;
}

declare class MaterialExpressionVolumetricAdvancedMaterialOutput extends MaterialExpressionCustomOutput { 
	PhaseG: ExpressionInput;
	PhaseG2: ExpressionInput;
	PhaseBlend: ExpressionInput;
	MultiScatteringContribution: ExpressionInput;
	MultiScatteringOcclusion: ExpressionInput;
	MultiScatteringEccentricity: ExpressionInput;
	ConservativeDensity: ExpressionInput;
	ConstPhaseG: number;
	ConstPhaseG2: number;
	ConstPhaseBlend: number;
	PerSamplePhaseEvaluation: boolean;
	MultiScatteringApproximationOctaveCount: any;
	ConstMultiScatteringContribution: number;
	ConstMultiScatteringOcclusion: number;
	ConstMultiScatteringEccentricity: number;
	bGroundContribution: boolean;
	bGrayScaleMaterial: boolean;
	bRayMarchVolumeShadow: boolean;
	static Load(ResourceName: string): MaterialExpressionVolumetricAdvancedMaterialOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVolumetricAdvancedMaterialOutput;
	static GetDefaultObject(): MaterialExpressionVolumetricAdvancedMaterialOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVolumetricAdvancedMaterialOutput;
	static C(Other: UObject | any): MaterialExpressionVolumetricAdvancedMaterialOutput;
}

declare class MaterialExpressionWhileLoop extends MaterialExpression { 
	LoopBody: ExpressionExecOutput;
	Completed: ExpressionExecOutput;
	Condition: ExpressionInput;
	static Load(ResourceName: string): MaterialExpressionWhileLoop;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionWhileLoop;
	static GetDefaultObject(): MaterialExpressionWhileLoop;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionWhileLoop;
	static C(Other: UObject | any): MaterialExpressionWhileLoop;
}

declare type EWorldPositionIncludedOffsets = 'WPT_Default' | 'WPT_ExcludeAllShaderOffsets' | 'WPT_CameraRelative' | 'WPT_CameraRelativeNoOffsets' | 'WPT_MAX';
declare var EWorldPositionIncludedOffsets : { WPT_Default:'WPT_Default',WPT_ExcludeAllShaderOffsets:'WPT_ExcludeAllShaderOffsets',WPT_CameraRelative:'WPT_CameraRelative',WPT_CameraRelativeNoOffsets:'WPT_CameraRelativeNoOffsets',WPT_MAX:'WPT_MAX', };
declare class MaterialExpressionWorldPosition extends MaterialExpression { 
	WorldPositionShaderOffset: EWorldPositionIncludedOffsets;
	static Load(ResourceName: string): MaterialExpressionWorldPosition;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionWorldPosition;
	static GetDefaultObject(): MaterialExpressionWorldPosition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionWorldPosition;
	static C(Other: UObject | any): MaterialExpressionWorldPosition;
}

declare class MaterialFunctionMaterialLayer extends MaterialFunction { 
	static Load(ResourceName: string): MaterialFunctionMaterialLayer;
	static Find(Outer: UObject, ResourceName: string): MaterialFunctionMaterialLayer;
	static GetDefaultObject(): MaterialFunctionMaterialLayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunctionMaterialLayer;
	static C(Other: UObject | any): MaterialFunctionMaterialLayer;
}

declare class MaterialFunctionMaterialLayerInstance extends MaterialFunctionInstance { 
	static Load(ResourceName: string): MaterialFunctionMaterialLayerInstance;
	static Find(Outer: UObject, ResourceName: string): MaterialFunctionMaterialLayerInstance;
	static GetDefaultObject(): MaterialFunctionMaterialLayerInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunctionMaterialLayerInstance;
	static C(Other: UObject | any): MaterialFunctionMaterialLayerInstance;
}

declare class MaterialFunctionMaterialLayerBlend extends MaterialFunction { 
	static Load(ResourceName: string): MaterialFunctionMaterialLayerBlend;
	static Find(Outer: UObject, ResourceName: string): MaterialFunctionMaterialLayerBlend;
	static GetDefaultObject(): MaterialFunctionMaterialLayerBlend;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunctionMaterialLayerBlend;
	static C(Other: UObject | any): MaterialFunctionMaterialLayerBlend;
}

declare class MaterialFunctionMaterialLayerBlendInstance extends MaterialFunctionInstance { 
	static Load(ResourceName: string): MaterialFunctionMaterialLayerBlendInstance;
	static Find(Outer: UObject, ResourceName: string): MaterialFunctionMaterialLayerBlendInstance;
	static GetDefaultObject(): MaterialFunctionMaterialLayerBlendInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunctionMaterialLayerBlendInstance;
	static C(Other: UObject | any): MaterialFunctionMaterialLayerBlendInstance;
}

declare class MaterialInstanceActor extends Actor { 
	TargetActors: Actor[];
	static GetDefaultObject(): MaterialInstanceActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceActor;
	static C(Other: UObject | any): MaterialInstanceActor;
}

declare class MatineeActorCameraAnim extends MatineeActor { 
	CameraAnim: CameraAnim;
	static GetDefaultObject(): MatineeActorCameraAnim;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeActorCameraAnim;
	static C(Other: UObject | any): MatineeActorCameraAnim;
}

declare class MatineeAnimInterface extends Interface { 
	static Load(ResourceName: string): MatineeAnimInterface;
	static Find(Outer: UObject, ResourceName: string): MatineeAnimInterface;
	static GetDefaultObject(): MatineeAnimInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeAnimInterface;
	static C(Other: UObject | any): MatineeAnimInterface;
}

declare class MatineeInterface extends Interface { 
	static Load(ResourceName: string): MatineeInterface;
	static Find(Outer: UObject, ResourceName: string): MatineeInterface;
	static GetDefaultObject(): MatineeInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeInterface;
	static C(Other: UObject | any): MatineeInterface;
}

declare class MeshMergeCullingVolume extends Volume { 
	static GetDefaultObject(): MeshMergeCullingVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshMergeCullingVolume;
	static C(Other: UObject | any): MeshMergeCullingVolume;
}

declare class MeshSimplificationSettings extends DeveloperSettings { 
	MeshReductionModuleName: string;
	bMeshReductionBackwardCompatible: boolean;
	static Load(ResourceName: string): MeshSimplificationSettings;
	static Find(Outer: UObject, ResourceName: string): MeshSimplificationSettings;
	static GetDefaultObject(): MeshSimplificationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshSimplificationSettings;
	static C(Other: UObject | any): MeshSimplificationSettings;
}

declare class MeshVertexPainterKismetLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MeshVertexPainterKismetLibrary;
	static Find(Outer: UObject, ResourceName: string): MeshVertexPainterKismetLibrary;
	static GetDefaultObject(): MeshVertexPainterKismetLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshVertexPainterKismetLibrary;
	static RemovePaintedVertices(StaticMeshComponent: StaticMeshComponent): void;
	static PaintVerticesSingleColor(StaticMeshComponent: StaticMeshComponent,FillColor: LinearColor,bConvertToSRGB: boolean): void;
	static PaintVerticesLerpAlongAxis(StaticMeshComponent: StaticMeshComponent,StartColor: LinearColor,EndColor: LinearColor,Axis: EVertexPaintAxis,bConvertToSRGB: boolean): void;
	static C(Other: UObject | any): MeshVertexPainterKismetLibrary;
}

declare class PurchaseInfo { 
	Identifier: string;
	DisplayName: string;
	DisplayDescription: string;
	DisplayPrice: string;
	clone() : PurchaseInfo;
	static C(Other: UObject | any): PurchaseInfo;
}

declare class MicroTransactionBase extends PlatformInterfaceBase { 
	AvailableProducts: PurchaseInfo[];
	LastError: string;
	LastErrorSolution: string;
	static Load(ResourceName: string): MicroTransactionBase;
	static Find(Outer: UObject, ResourceName: string): MicroTransactionBase;
	static GetDefaultObject(): MicroTransactionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MicroTransactionBase;
	static C(Other: UObject | any): MicroTransactionBase;
}

declare class NavAgentInterface extends Interface { 
	static Load(ResourceName: string): NavAgentInterface;
	static Find(Outer: UObject, ResourceName: string): NavAgentInterface;
	static GetDefaultObject(): NavAgentInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavAgentInterface;
	static C(Other: UObject | any): NavAgentInterface;
}

declare class NavEdgeProviderInterface extends Interface { 
	static Load(ResourceName: string): NavEdgeProviderInterface;
	static Find(Outer: UObject, ResourceName: string): NavEdgeProviderInterface;
	static GetDefaultObject(): NavEdgeProviderInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavEdgeProviderInterface;
	static C(Other: UObject | any): NavEdgeProviderInterface;
}

declare class NavigationDataChunkActor extends PartitionActor { 
	NavDataChunks: NavigationDataChunk[];
	DataChunkActorBounds: Box;
	static GetDefaultObject(): NavigationDataChunkActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationDataChunkActor;
	static C(Other: UObject | any): NavigationDataChunkActor;
}

declare class NavigationDataInterface extends Interface { 
	static Load(ResourceName: string): NavigationDataInterface;
	static Find(Outer: UObject, ResourceName: string): NavigationDataInterface;
	static GetDefaultObject(): NavigationDataInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationDataInterface;
	static C(Other: UObject | any): NavigationDataInterface;
}

declare class NullNavSysConfig extends NavigationSystemConfig { 
	static Load(ResourceName: string): NullNavSysConfig;
	static Find(Outer: UObject, ResourceName: string): NullNavSysConfig;
	static GetDefaultObject(): NullNavSysConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NullNavSysConfig;
	static C(Other: UObject | any): NullNavSysConfig;
}

declare class NavPathObserverInterface extends Interface { 
	static Load(ResourceName: string): NavPathObserverInterface;
	static Find(Outer: UObject, ResourceName: string): NavPathObserverInterface;
	static GetDefaultObject(): NavPathObserverInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavPathObserverInterface;
	static C(Other: UObject | any): NavPathObserverInterface;
}

declare class NavRelevantInterface extends Interface { 
	static Load(ResourceName: string): NavRelevantInterface;
	static Find(Outer: UObject, ResourceName: string): NavRelevantInterface;
	static GetDefaultObject(): NavRelevantInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavRelevantInterface;
	static C(Other: UObject | any): NavRelevantInterface;
}

declare class SimulatedClientNetConnection extends NetConnection { 
	static Load(ResourceName: string): SimulatedClientNetConnection;
	static Find(Outer: UObject, ResourceName: string): SimulatedClientNetConnection;
	static GetDefaultObject(): SimulatedClientNetConnection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SimulatedClientNetConnection;
	static C(Other: UObject | any): SimulatedClientNetConnection;
}

declare class NetFaultConfig extends EscalationManagerConfig { 
	static Load(ResourceName: string): NetFaultConfig;
	static Find(Outer: UObject, ResourceName: string): NetFaultConfig;
	static GetDefaultObject(): NetFaultConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetFaultConfig;
	static C(Other: UObject | any): NetFaultConfig;
}

declare class NetPushModelHelpers extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): NetPushModelHelpers;
	static Find(Outer: UObject, ResourceName: string): NetPushModelHelpers;
	static GetDefaultObject(): NetPushModelHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetPushModelHelpers;
	static MarkPropertyDirtyFromRepIndex(UObject: UObject,RepIndex: number,PropertyName: string): void;
	static MarkPropertyDirty(UObject: UObject,PropertyName: string): void;
	static C(Other: UObject | any): NetPushModelHelpers;
}

declare class NetworkPredictionInterface extends Interface { 
	static Load(ResourceName: string): NetworkPredictionInterface;
	static Find(Outer: UObject, ResourceName: string): NetworkPredictionInterface;
	static GetDefaultObject(): NetworkPredictionInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetworkPredictionInterface;
	static C(Other: UObject | any): NetworkPredictionInterface;
}

declare class NetworkEmulationProfileDescription { 
	ProfileName: string;
	Tooltip: string;
	clone() : NetworkEmulationProfileDescription;
	static C(Other: UObject | any): NetworkEmulationProfileDescription;
}

declare class NetworkSettings extends DeveloperSettings { 
	bVerifyPeer: boolean;
	bEnableMultiplayerWorldOriginRebasing: boolean;
	MaxRepArraySize: number;
	MaxRepArrayMemory: number;
	NetworkEmulationProfiles: NetworkEmulationProfileDescription[];
	static Load(ResourceName: string): NetworkSettings;
	static Find(Outer: UObject, ResourceName: string): NetworkSettings;
	static GetDefaultObject(): NetworkSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetworkSettings;
	static C(Other: UObject | any): NetworkSettings;
}

declare class NodeMappingProviderInterface extends Interface { 
	static Load(ResourceName: string): NodeMappingProviderInterface;
	static Find(Outer: UObject, ResourceName: string): NodeMappingProviderInterface;
	static GetDefaultObject(): NodeMappingProviderInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NodeMappingProviderInterface;
	static C(Other: UObject | any): NodeMappingProviderInterface;
}

declare class Note extends Actor { 
	text: string;
	SpriteComponent: BillboardComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): Note;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Note;
	static C(Other: UObject | any): Note;
}

declare class ObjectElementAssetDataInterface extends UObject { 
	static Load(ResourceName: string): ObjectElementAssetDataInterface;
	static Find(Outer: UObject, ResourceName: string): ObjectElementAssetDataInterface;
	static GetDefaultObject(): ObjectElementAssetDataInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectElementAssetDataInterface;
	static C(Other: UObject | any): ObjectElementAssetDataInterface;
}

declare class ObjectElementCounterInterface extends UObject { 
	static Load(ResourceName: string): ObjectElementCounterInterface;
	static Find(Outer: UObject, ResourceName: string): ObjectElementCounterInterface;
	static GetDefaultObject(): ObjectElementCounterInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectElementCounterInterface;
	static C(Other: UObject | any): ObjectElementCounterInterface;
}

declare class ObjectElementObjectInterface extends UObject { 
	static Load(ResourceName: string): ObjectElementObjectInterface;
	static Find(Outer: UObject, ResourceName: string): ObjectElementObjectInterface;
	static GetDefaultObject(): ObjectElementObjectInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectElementObjectInterface;
	static C(Other: UObject | any): ObjectElementObjectInterface;
}

declare class ObjectLibrary extends UObject { 
	ObjectBaseClass: UnrealEngineClass;
	bHasBlueprintClasses: boolean;
	Objects: UObject[];
	WeakObjects: any[];
	bUseWeakReferences: boolean;
	bIsFullyLoaded: boolean;
	static Load(ResourceName: string): ObjectLibrary;
	static Find(Outer: UObject, ResourceName: string): ObjectLibrary;
	static GetDefaultObject(): ObjectLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectLibrary;
	static C(Other: UObject | any): ObjectLibrary;
}

declare class ObjectReferencer extends UObject { 
	ReferencedObjects: UObject[];
	static Load(ResourceName: string): ObjectReferencer;
	static Find(Outer: UObject, ResourceName: string): ObjectReferencer;
	static GetDefaultObject(): ObjectReferencer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectReferencer;
	static C(Other: UObject | any): ObjectReferencer;
}

declare class ObjectTraceWorldSubsystem extends WorldSubsystem { 
	static Load(ResourceName: string): ObjectTraceWorldSubsystem;
	static Find(Outer: UObject, ResourceName: string): ObjectTraceWorldSubsystem;
	static GetDefaultObject(): ObjectTraceWorldSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectTraceWorldSubsystem;
	static C(Other: UObject | any): ObjectTraceWorldSubsystem;
}

declare class OnlineBlueprintCallProxyBase extends BlueprintAsyncActionBase { 
	static Load(ResourceName: string): OnlineBlueprintCallProxyBase;
	static Find(Outer: UObject, ResourceName: string): OnlineBlueprintCallProxyBase;
	static GetDefaultObject(): OnlineBlueprintCallProxyBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBlueprintCallProxyBase;
	static C(Other: UObject | any): OnlineBlueprintCallProxyBase;
}

declare class OnlineEngineInterface extends UObject { 
	static Load(ResourceName: string): OnlineEngineInterface;
	static Find(Outer: UObject, ResourceName: string): OnlineEngineInterface;
	static GetDefaultObject(): OnlineEngineInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineEngineInterface;
	static C(Other: UObject | any): OnlineEngineInterface;
}

declare class PackageMapClient extends PackageMap { 
	static Load(ResourceName: string): PackageMapClient;
	static Find(Outer: UObject, ResourceName: string): PackageMapClient;
	static GetDefaultObject(): PackageMapClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PackageMapClient;
	static C(Other: UObject | any): PackageMapClient;
}

declare class PackedLevelActor extends LevelInstance { 
	BlueprintAsset: Blueprint;
	PackedBPDependencies: Blueprint[];
	PackedVersion: Guid;
	static GetDefaultObject(): PackedLevelActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PackedLevelActor;
	static C(Other: UObject | any): PackedLevelActor;
}

declare class PainCausingVolume extends PhysicsVolume { 
	bPainCausing: boolean;
	DamagePerSec: number;
	DamageType: UnrealEngineClass;
	PainInterval: number;
	bEntryPain: boolean;
	BACKUP_bPainCausing: boolean;
	DamageInstigator: Controller;
	static GetDefaultObject(): PainCausingVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PainCausingVolume;
	static C(Other: UObject | any): PainCausingVolume;
}

declare class ParticleModuleAccelerationBase extends ParticleModule { 
	bAlwaysInWorldSpace: boolean;
	static Load(ResourceName: string): ParticleModuleAccelerationBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationBase;
	static GetDefaultObject(): ParticleModuleAccelerationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationBase;
	static C(Other: UObject | any): ParticleModuleAccelerationBase;
}

declare class ParticleModuleAcceleration extends ParticleModuleAccelerationBase { 
	Acceleration: RawDistributionVector;
	bApplyOwnerScale: boolean;
	static Load(ResourceName: string): ParticleModuleAcceleration;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAcceleration;
	static GetDefaultObject(): ParticleModuleAcceleration;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAcceleration;
	static C(Other: UObject | any): ParticleModuleAcceleration;
}

declare class ParticleModuleAccelerationConstant extends ParticleModuleAccelerationBase { 
	Acceleration: Vector;
	static Load(ResourceName: string): ParticleModuleAccelerationConstant;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationConstant;
	static GetDefaultObject(): ParticleModuleAccelerationConstant;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationConstant;
	static C(Other: UObject | any): ParticleModuleAccelerationConstant;
}

declare class ParticleModuleAccelerationDrag extends ParticleModuleAccelerationBase { 
	DragCoefficient: DistributionFloat;
	DragCoefficientRaw: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleAccelerationDrag;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationDrag;
	static GetDefaultObject(): ParticleModuleAccelerationDrag;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationDrag;
	static C(Other: UObject | any): ParticleModuleAccelerationDrag;
}

declare class ParticleModuleAccelerationDragScaleOverLife extends ParticleModuleAccelerationBase { 
	DragScale: DistributionFloat;
	DragScaleRaw: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleAccelerationDragScaleOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationDragScaleOverLife;
	static GetDefaultObject(): ParticleModuleAccelerationDragScaleOverLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationDragScaleOverLife;
	static C(Other: UObject | any): ParticleModuleAccelerationDragScaleOverLife;
}

declare class ParticleModuleAccelerationOverLifetime extends ParticleModuleAccelerationBase { 
	AccelOverLife: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleAccelerationOverLifetime;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationOverLifetime;
	static GetDefaultObject(): ParticleModuleAccelerationOverLifetime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationOverLifetime;
	static C(Other: UObject | any): ParticleModuleAccelerationOverLifetime;
}

declare class ParticleModuleAttractorBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleAttractorBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorBase;
	static GetDefaultObject(): ParticleModuleAttractorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorBase;
	static C(Other: UObject | any): ParticleModuleAttractorBase;
}

declare class ParticleModuleAttractorLine extends ParticleModuleAttractorBase { 
	EndPoint0: Vector;
	EndPoint1: Vector;
	Range: RawDistributionFloat;
	Strength: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleAttractorLine;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorLine;
	static GetDefaultObject(): ParticleModuleAttractorLine;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorLine;
	static C(Other: UObject | any): ParticleModuleAttractorLine;
}

declare type EAttractorParticleSelectionMethod = 'EAPSM_Random' | 'EAPSM_Sequential' | 'EAPSM_MAX';
declare var EAttractorParticleSelectionMethod : { EAPSM_Random:'EAPSM_Random',EAPSM_Sequential:'EAPSM_Sequential',EAPSM_MAX:'EAPSM_MAX', };
declare class ParticleModuleAttractorParticle extends ParticleModuleAttractorBase { 
	EmitterName: string;
	Range: RawDistributionFloat;
	bStrengthByDistance: boolean;
	Strength: RawDistributionFloat;
	bAffectBaseVelocity: boolean;
	SelectionMethod: EAttractorParticleSelectionMethod;
	bRenewSource: boolean;
	bInheritSourceVel: boolean;
	LastSelIndex: number;
	static Load(ResourceName: string): ParticleModuleAttractorParticle;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorParticle;
	static GetDefaultObject(): ParticleModuleAttractorParticle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorParticle;
	static C(Other: UObject | any): ParticleModuleAttractorParticle;
}

declare class ParticleModuleAttractorPoint extends ParticleModuleAttractorBase { 
	position: RawDistributionVector;
	Range: RawDistributionFloat;
	Strength: RawDistributionFloat;
	StrengthByDistance: boolean;
	bAffectBaseVelocity: boolean;
	bOverrideVelocity: boolean;
	bUseWorldSpacePosition: boolean;
	Positive_X: boolean;
	Positive_Y: boolean;
	Positive_Z: boolean;
	Negative_X: boolean;
	Negative_Y: boolean;
	Negative_Z: boolean;
	static Load(ResourceName: string): ParticleModuleAttractorPoint;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorPoint;
	static GetDefaultObject(): ParticleModuleAttractorPoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorPoint;
	static C(Other: UObject | any): ParticleModuleAttractorPoint;
}

declare class ParticleModuleAttractorPointGravity extends ParticleModuleAttractorBase { 
	position: Vector;
	Radius: number;
	Strength: DistributionFloat;
	StrengthRaw: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleAttractorPointGravity;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorPointGravity;
	static GetDefaultObject(): ParticleModuleAttractorPointGravity;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorPointGravity;
	static C(Other: UObject | any): ParticleModuleAttractorPointGravity;
}

declare class ParticleModuleBeamBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleBeamBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamBase;
	static GetDefaultObject(): ParticleModuleBeamBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamBase;
	static C(Other: UObject | any): ParticleModuleBeamBase;
}

declare type BeamModifierType = 'PEB2MT_Source' | 'PEB2MT_Target' | 'PEB2MT_MAX';
declare var BeamModifierType : { PEB2MT_Source:'PEB2MT_Source',PEB2MT_Target:'PEB2MT_Target',PEB2MT_MAX:'PEB2MT_MAX', };
declare class BeamModifierOptions { 
	bModify: boolean;
	bScale: boolean;
	bLock: boolean;
	clone() : BeamModifierOptions;
	static C(Other: UObject | any): BeamModifierOptions;
}

declare class ParticleModuleBeamModifier extends ParticleModuleBeamBase { 
	ModifierType: BeamModifierType;
	PositionOptions: BeamModifierOptions;
	position: RawDistributionVector;
	TangentOptions: BeamModifierOptions;
	Tangent: RawDistributionVector;
	bAbsoluteTangent: boolean;
	StrengthOptions: BeamModifierOptions;
	Strength: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleBeamModifier;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamModifier;
	static GetDefaultObject(): ParticleModuleBeamModifier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamModifier;
	static C(Other: UObject | any): ParticleModuleBeamModifier;
}

declare class ParticleModuleBeamNoise extends ParticleModuleBeamBase { 
	bLowFreq_Enabled: boolean;
	Frequency: number;
	Frequency_LowRange: number;
	NoiseRange: RawDistributionVector;
	NoiseRangeScale: RawDistributionFloat;
	bNRScaleEmitterTime: boolean;
	NoiseSpeed: RawDistributionVector;
	bSmooth: boolean;
	NoiseLockRadius: number;
	bNoiseLock: boolean;
	bOscillate: boolean;
	NoiseLockTime: number;
	NoiseTension: number;
	bUseNoiseTangents: boolean;
	NoiseTangentStrength: RawDistributionFloat;
	NoiseTessellation: number;
	bTargetNoise: boolean;
	FrequencyDistance: number;
	bApplyNoiseScale: boolean;
	NoiseScale: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleBeamNoise;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamNoise;
	static GetDefaultObject(): ParticleModuleBeamNoise;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamNoise;
	static C(Other: UObject | any): ParticleModuleBeamNoise;
}

declare type Beam2SourceTargetMethod = 'PEB2STM_Default' | 'PEB2STM_UserSet' | 'PEB2STM_Emitter' | 'PEB2STM_Particle' | 'PEB2STM_Actor' | 'PEB2STM_MAX';
declare var Beam2SourceTargetMethod : { PEB2STM_Default:'PEB2STM_Default',PEB2STM_UserSet:'PEB2STM_UserSet',PEB2STM_Emitter:'PEB2STM_Emitter',PEB2STM_Particle:'PEB2STM_Particle',PEB2STM_Actor:'PEB2STM_Actor',PEB2STM_MAX:'PEB2STM_MAX', };
declare type Beam2SourceTargetTangentMethod = 'PEB2STTM_Direct' | 'PEB2STTM_UserSet' | 'PEB2STTM_Distribution' | 'PEB2STTM_Emitter' | 'PEB2STTM_MAX';
declare var Beam2SourceTargetTangentMethod : { PEB2STTM_Direct:'PEB2STTM_Direct',PEB2STTM_UserSet:'PEB2STTM_UserSet',PEB2STTM_Distribution:'PEB2STTM_Distribution',PEB2STTM_Emitter:'PEB2STTM_Emitter',PEB2STTM_MAX:'PEB2STTM_MAX', };
declare class ParticleModuleBeamSource extends ParticleModuleBeamBase { 
	SourceMethod: Beam2SourceTargetMethod;
	SourceName: string;
	bSourceAbsolute: boolean;
	Source: RawDistributionVector;
	bLockSource: boolean;
	SourceTangentMethod: Beam2SourceTargetTangentMethod;
	SourceTangent: RawDistributionVector;
	bLockSourceTangent: boolean;
	SourceStrength: RawDistributionFloat;
	bLockSourceStength: boolean;
	static Load(ResourceName: string): ParticleModuleBeamSource;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamSource;
	static GetDefaultObject(): ParticleModuleBeamSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamSource;
	static C(Other: UObject | any): ParticleModuleBeamSource;
}

declare class ParticleModuleBeamTarget extends ParticleModuleBeamBase { 
	TargetMethod: Beam2SourceTargetMethod;
	TargetName: string;
	Target: RawDistributionVector;
	bTargetAbsolute: boolean;
	bLockTarget: boolean;
	TargetTangentMethod: Beam2SourceTargetTangentMethod;
	TargetTangent: RawDistributionVector;
	bLockTargetTangent: boolean;
	TargetStrength: RawDistributionFloat;
	bLockTargetStength: boolean;
	LockRadius: number;
	static Load(ResourceName: string): ParticleModuleBeamTarget;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamTarget;
	static GetDefaultObject(): ParticleModuleBeamTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamTarget;
	static C(Other: UObject | any): ParticleModuleBeamTarget;
}

declare class ParticleModuleCameraBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleCameraBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCameraBase;
	static GetDefaultObject(): ParticleModuleCameraBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCameraBase;
	static C(Other: UObject | any): ParticleModuleCameraBase;
}

declare type EParticleCameraOffsetUpdateMethod = 'EPCOUM_DirectSet' | 'EPCOUM_Additive' | 'EPCOUM_Scalar' | 'EPCOUM_MAX';
declare var EParticleCameraOffsetUpdateMethod : { EPCOUM_DirectSet:'EPCOUM_DirectSet',EPCOUM_Additive:'EPCOUM_Additive',EPCOUM_Scalar:'EPCOUM_Scalar',EPCOUM_MAX:'EPCOUM_MAX', };
declare class ParticleModuleCameraOffset extends ParticleModuleCameraBase { 
	CameraOffset: RawDistributionFloat;
	bSpawnTimeOnly: boolean;
	UpdateMethod: EParticleCameraOffsetUpdateMethod;
	static Load(ResourceName: string): ParticleModuleCameraOffset;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCameraOffset;
	static GetDefaultObject(): ParticleModuleCameraOffset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCameraOffset;
	static C(Other: UObject | any): ParticleModuleCameraOffset;
}

declare class ParticleModuleCollisionBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleCollisionBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCollisionBase;
	static GetDefaultObject(): ParticleModuleCollisionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCollisionBase;
	static C(Other: UObject | any): ParticleModuleCollisionBase;
}

declare type EParticleCollisionComplete = 'EPCC_Kill' | 'EPCC_Freeze' | 'EPCC_HaltCollisions' | 'EPCC_FreezeTranslation' | 'EPCC_FreezeRotation' | 'EPCC_FreezeMovement' | 'EPCC_MAX';
declare var EParticleCollisionComplete : { EPCC_Kill:'EPCC_Kill',EPCC_Freeze:'EPCC_Freeze',EPCC_HaltCollisions:'EPCC_HaltCollisions',EPCC_FreezeTranslation:'EPCC_FreezeTranslation',EPCC_FreezeRotation:'EPCC_FreezeRotation',EPCC_FreezeMovement:'EPCC_FreezeMovement',EPCC_MAX:'EPCC_MAX', };
declare class ParticleModuleCollision extends ParticleModuleCollisionBase { 
	DampingFactor: RawDistributionVector;
	DampingFactorRotation: RawDistributionVector;
	MaxCollisions: RawDistributionFloat;
	CollisionCompletionOption: EParticleCollisionComplete;
	CollisionTypes: EObjectTypeQuery[];
	bApplyPhysics: boolean;
	bIgnoreTriggerVolumes: boolean;
	ParticleMass: RawDistributionFloat;
	DirScalar: number;
	bPawnsDoNotDecrementCount: boolean;
	bOnlyVerticalNormalsDecrementCount: boolean;
	VerticalFudgeFactor: number;
	DelayAmount: RawDistributionFloat;
	bDropDetail: boolean;
	bCollideOnlyIfVisible: boolean;
	bIgnoreSourceActor: boolean;
	MaxCollisionDistance: number;
	static Load(ResourceName: string): ParticleModuleCollision;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCollision;
	static GetDefaultObject(): ParticleModuleCollision;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCollision;
	static C(Other: UObject | any): ParticleModuleCollision;
}

declare type EParticleCollisionResponse = 'Bounce' | 'Stop' | 'Kill' | 'EParticleCollisionResponse_MAX';
declare var EParticleCollisionResponse : { Bounce:'Bounce',Stop:'Stop',Kill:'Kill',EParticleCollisionResponse_MAX:'EParticleCollisionResponse_MAX', };
declare type EParticleCollisionMode = 'SceneDepth' | 'DistanceField' | 'EParticleCollisionMode_MAX';
declare var EParticleCollisionMode : { SceneDepth:'SceneDepth',DistanceField:'DistanceField',EParticleCollisionMode_MAX:'EParticleCollisionMode_MAX', };
declare class ParticleModuleCollisionGPU extends ParticleModuleCollisionBase { 
	Resilience: RawDistributionFloat;
	ResilienceScaleOverLife: RawDistributionFloat;
	Friction: number;
	RandomSpread: number;
	RandomDistribution: number;
	RadiusScale: number;
	RadiusBias: number;
	Response: EParticleCollisionResponse;
	CollisionMode: EParticleCollisionMode;
	static Load(ResourceName: string): ParticleModuleCollisionGPU;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCollisionGPU;
	static GetDefaultObject(): ParticleModuleCollisionGPU;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCollisionGPU;
	static C(Other: UObject | any): ParticleModuleCollisionGPU;
}

declare class ParticleModuleColorBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleColorBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColorBase;
	static GetDefaultObject(): ParticleModuleColorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColorBase;
	static C(Other: UObject | any): ParticleModuleColorBase;
}

declare class ParticleModuleColor extends ParticleModuleColorBase { 
	StartColor: RawDistributionVector;
	StartAlpha: RawDistributionFloat;
	bClampAlpha: boolean;
	static Load(ResourceName: string): ParticleModuleColor;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColor;
	static GetDefaultObject(): ParticleModuleColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColor;
	static C(Other: UObject | any): ParticleModuleColor;
}

declare class ParticleModuleColorOverLife extends ParticleModuleColorBase { 
	ColorOverLife: RawDistributionVector;
	AlphaOverLife: RawDistributionFloat;
	bClampAlpha: boolean;
	static Load(ResourceName: string): ParticleModuleColorOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColorOverLife;
	static GetDefaultObject(): ParticleModuleColorOverLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColorOverLife;
	static C(Other: UObject | any): ParticleModuleColorOverLife;
}

declare class ParticleModuleColorScaleOverLife extends ParticleModuleColorBase { 
	ColorScaleOverLife: RawDistributionVector;
	AlphaScaleOverLife: RawDistributionFloat;
	bEmitterTime: boolean;
	static Load(ResourceName: string): ParticleModuleColorScaleOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColorScaleOverLife;
	static GetDefaultObject(): ParticleModuleColorScaleOverLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColorScaleOverLife;
	static C(Other: UObject | any): ParticleModuleColorScaleOverLife;
}

declare class ParticleRandomSeedInfo { 
	ParameterName: string;
	bGetSeedFromInstance: boolean;
	bInstanceSeedIsIndex: boolean;
	bResetSeedOnEmitterLooping: boolean;
	bRandomlySelectSeedArray: boolean;
	RandomSeeds: number[];
	clone() : ParticleRandomSeedInfo;
	static C(Other: UObject | any): ParticleRandomSeedInfo;
}

declare class ParticleModuleColor_Seeded extends ParticleModuleColor { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleColor_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColor_Seeded;
	static GetDefaultObject(): ParticleModuleColor_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColor_Seeded;
	static C(Other: UObject | any): ParticleModuleColor_Seeded;
}

declare class ParticleModuleEventReceiverKillParticles extends ParticleModuleEventReceiverBase { 
	bStopSpawning: boolean;
	static Load(ResourceName: string): ParticleModuleEventReceiverKillParticles;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventReceiverKillParticles;
	static GetDefaultObject(): ParticleModuleEventReceiverKillParticles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventReceiverKillParticles;
	static C(Other: UObject | any): ParticleModuleEventReceiverKillParticles;
}

declare class ParticleModuleEventReceiverSpawn extends ParticleModuleEventReceiverBase { 
	SpawnCount: RawDistributionFloat;
	bUseParticleTime: boolean;
	bUsePSysLocation: boolean;
	bInheritVelocity: boolean;
	InheritVelocityScale: RawDistributionVector;
	PhysicalMaterials: PhysicalMaterial[];
	bBanPhysicalMaterials: boolean;
	static Load(ResourceName: string): ParticleModuleEventReceiverSpawn;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventReceiverSpawn;
	static GetDefaultObject(): ParticleModuleEventReceiverSpawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventReceiverSpawn;
	static C(Other: UObject | any): ParticleModuleEventReceiverSpawn;
}

declare class ParticleModuleKillBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleKillBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleKillBase;
	static GetDefaultObject(): ParticleModuleKillBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleKillBase;
	static C(Other: UObject | any): ParticleModuleKillBase;
}

declare class ParticleModuleKillBox extends ParticleModuleKillBase { 
	LowerLeftCorner: RawDistributionVector;
	UpperRightCorner: RawDistributionVector;
	bAbsolute: boolean;
	bKillInside: boolean;
	bAxisAlignedAndFixedSize: boolean;
	static Load(ResourceName: string): ParticleModuleKillBox;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleKillBox;
	static GetDefaultObject(): ParticleModuleKillBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleKillBox;
	static C(Other: UObject | any): ParticleModuleKillBox;
}

declare class ParticleModuleKillHeight extends ParticleModuleKillBase { 
	Height: RawDistributionFloat;
	bAbsolute: boolean;
	bFloor: boolean;
	bApplyPSysScale: boolean;
	static Load(ResourceName: string): ParticleModuleKillHeight;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleKillHeight;
	static GetDefaultObject(): ParticleModuleKillHeight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleKillHeight;
	static C(Other: UObject | any): ParticleModuleKillHeight;
}

declare class ParticleModuleLifetimeBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleLifetimeBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLifetimeBase;
	static GetDefaultObject(): ParticleModuleLifetimeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLifetimeBase;
	static C(Other: UObject | any): ParticleModuleLifetimeBase;
}

declare class ParticleModuleLifetime extends ParticleModuleLifetimeBase { 
	LifeTime: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleLifetime;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLifetime;
	static GetDefaultObject(): ParticleModuleLifetime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLifetime;
	static C(Other: UObject | any): ParticleModuleLifetime;
}

declare class ParticleModuleLifetime_Seeded extends ParticleModuleLifetime { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleLifetime_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLifetime_Seeded;
	static GetDefaultObject(): ParticleModuleLifetime_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLifetime_Seeded;
	static C(Other: UObject | any): ParticleModuleLifetime_Seeded;
}

declare class ParticleModuleLightBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleLightBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLightBase;
	static GetDefaultObject(): ParticleModuleLightBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLightBase;
	static C(Other: UObject | any): ParticleModuleLightBase;
}

declare class ParticleModuleLight extends ParticleModuleLightBase { 
	bUseInverseSquaredFalloff: boolean;
	bAffectsTranslucency: boolean;
	bPreviewLightRadius: boolean;
	SpawnFraction: number;
	ColorScaleOverLife: RawDistributionVector;
	BrightnessOverLife: RawDistributionFloat;
	RadiusScale: RawDistributionFloat;
	LightExponent: RawDistributionFloat;
	LightingChannels: LightingChannels;
	VolumetricScatteringIntensity: number;
	bHighQualityLights: boolean;
	bShadowCastingLights: boolean;
	static Load(ResourceName: string): ParticleModuleLight;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLight;
	static GetDefaultObject(): ParticleModuleLight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLight;
	static C(Other: UObject | any): ParticleModuleLight;
}

declare class ParticleModuleLight_Seeded extends ParticleModuleLight { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleLight_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLight_Seeded;
	static GetDefaultObject(): ParticleModuleLight_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLight_Seeded;
	static C(Other: UObject | any): ParticleModuleLight_Seeded;
}

declare class ParticleModuleLocationBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleLocationBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationBase;
	static GetDefaultObject(): ParticleModuleLocationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationBase;
	static C(Other: UObject | any): ParticleModuleLocationBase;
}

declare class ParticleModuleLocation extends ParticleModuleLocationBase { 
	StartLocation: RawDistributionVector;
	DistributeOverNPoints: number;
	DistributeThreshold: number;
	static Load(ResourceName: string): ParticleModuleLocation;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocation;
	static GetDefaultObject(): ParticleModuleLocation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocation;
	static C(Other: UObject | any): ParticleModuleLocation;
}

declare type ELocationBoneSocketSource = 'BONESOCKETSOURCE_Bones' | 'BONESOCKETSOURCE_Sockets' | 'BONESOCKETSOURCE_MAX';
declare var ELocationBoneSocketSource : { BONESOCKETSOURCE_Bones:'BONESOCKETSOURCE_Bones',BONESOCKETSOURCE_Sockets:'BONESOCKETSOURCE_Sockets',BONESOCKETSOURCE_MAX:'BONESOCKETSOURCE_MAX', };
declare class LocationBoneSocketInfo { 
	BoneSocketName: string;
	Offset: Vector;
	clone() : LocationBoneSocketInfo;
	static C(Other: UObject | any): LocationBoneSocketInfo;
}

declare type ELocationBoneSocketSelectionMethod = 'BONESOCKETSEL_Sequential' | 'BONESOCKETSEL_Random' | 'BONESOCKETSEL_MAX';
declare var ELocationBoneSocketSelectionMethod : { BONESOCKETSEL_Sequential:'BONESOCKETSEL_Sequential',BONESOCKETSEL_Random:'BONESOCKETSEL_Random',BONESOCKETSEL_MAX:'BONESOCKETSEL_MAX', };
declare class ParticleModuleLocationBoneSocket extends ParticleModuleLocationBase { 
	SourceType: ELocationBoneSocketSource;
	UniversalOffset: Vector;
	SourceLocations: LocationBoneSocketInfo[];
	SelectionMethod: ELocationBoneSocketSelectionMethod;
	bUpdatePositionEachFrame: boolean;
	bOrientMeshEmitters: boolean;
	bInheritBoneVelocity: boolean;
	InheritVelocityScale: number;
	SkelMeshActorParamName: string;
	NumPreSelectedIndices: number;
	EditorSkelMesh: SkeletalMesh;
	static Load(ResourceName: string): ParticleModuleLocationBoneSocket;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationBoneSocket;
	static GetDefaultObject(): ParticleModuleLocationBoneSocket;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationBoneSocket;
	static C(Other: UObject | any): ParticleModuleLocationBoneSocket;
}

declare class ParticleModuleLocationDirect extends ParticleModuleLocationBase { 
	Location: RawDistributionVector;
	LocationOffset: RawDistributionVector;
	ScaleFactor: RawDistributionVector;
	Direction: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleLocationDirect;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationDirect;
	static GetDefaultObject(): ParticleModuleLocationDirect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationDirect;
	static C(Other: UObject | any): ParticleModuleLocationDirect;
}

declare type ELocationEmitterSelectionMethod = 'ELESM_Random' | 'ELESM_Sequential' | 'ELESM_MAX';
declare var ELocationEmitterSelectionMethod : { ELESM_Random:'ELESM_Random',ELESM_Sequential:'ELESM_Sequential',ELESM_MAX:'ELESM_MAX', };
declare class ParticleModuleLocationEmitter extends ParticleModuleLocationBase { 
	EmitterName: string;
	SelectionMethod: ELocationEmitterSelectionMethod;
	InheritSourceVelocity: boolean;
	InheritSourceVelocityScale: number;
	bInheritSourceRotation: boolean;
	InheritSourceRotationScale: number;
	static Load(ResourceName: string): ParticleModuleLocationEmitter;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationEmitter;
	static GetDefaultObject(): ParticleModuleLocationEmitter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationEmitter;
	static C(Other: UObject | any): ParticleModuleLocationEmitter;
}

declare class ParticleModuleLocationEmitterDirect extends ParticleModuleLocationBase { 
	EmitterName: string;
	static Load(ResourceName: string): ParticleModuleLocationEmitterDirect;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationEmitterDirect;
	static GetDefaultObject(): ParticleModuleLocationEmitterDirect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationEmitterDirect;
	static C(Other: UObject | any): ParticleModuleLocationEmitterDirect;
}

declare class ParticleModuleLocationPrimitiveBase extends ParticleModuleLocationBase { 
	Positive_X: boolean;
	Positive_Y: boolean;
	Positive_Z: boolean;
	Negative_X: boolean;
	Negative_Y: boolean;
	Negative_Z: boolean;
	SurfaceOnly: boolean;
	Velocity: boolean;
	VelocityScale: RawDistributionFloat;
	StartLocation: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveBase;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveBase;
	static C(Other: UObject | any): ParticleModuleLocationPrimitiveBase;
}

declare type CylinderHeightAxis = 'PMLPC_HEIGHTAXIS_X' | 'PMLPC_HEIGHTAXIS_Y' | 'PMLPC_HEIGHTAXIS_Z' | 'PMLPC_HEIGHTAXIS_MAX';
declare var CylinderHeightAxis : { PMLPC_HEIGHTAXIS_X:'PMLPC_HEIGHTAXIS_X',PMLPC_HEIGHTAXIS_Y:'PMLPC_HEIGHTAXIS_Y',PMLPC_HEIGHTAXIS_Z:'PMLPC_HEIGHTAXIS_Z',PMLPC_HEIGHTAXIS_MAX:'PMLPC_HEIGHTAXIS_MAX', };
declare class ParticleModuleLocationPrimitiveCylinder extends ParticleModuleLocationPrimitiveBase { 
	RadialVelocity: boolean;
	StartRadius: RawDistributionFloat;
	StartHeight: RawDistributionFloat;
	HeightAxis: CylinderHeightAxis;
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveCylinder;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveCylinder;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveCylinder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveCylinder;
	static C(Other: UObject | any): ParticleModuleLocationPrimitiveCylinder;
}

declare class ParticleModuleLocationPrimitiveCylinder_Seeded extends ParticleModuleLocationPrimitiveCylinder { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveCylinder_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveCylinder_Seeded;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveCylinder_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveCylinder_Seeded;
	static C(Other: UObject | any): ParticleModuleLocationPrimitiveCylinder_Seeded;
}

declare class ParticleModuleLocationPrimitiveSphere extends ParticleModuleLocationPrimitiveBase { 
	StartRadius: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveSphere;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveSphere;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveSphere;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveSphere;
	static C(Other: UObject | any): ParticleModuleLocationPrimitiveSphere;
}

declare class ParticleModuleLocationPrimitiveSphere_Seeded extends ParticleModuleLocationPrimitiveSphere { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveSphere_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveSphere_Seeded;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveSphere_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveSphere_Seeded;
	static C(Other: UObject | any): ParticleModuleLocationPrimitiveSphere_Seeded;
}

declare class ParticleModuleLocationPrimitiveTriangle extends ParticleModuleLocationBase { 
	StartOffset: RawDistributionVector;
	Height: RawDistributionFloat;
	Angle: RawDistributionFloat;
	Thickness: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveTriangle;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveTriangle;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveTriangle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveTriangle;
	static C(Other: UObject | any): ParticleModuleLocationPrimitiveTriangle;
}

declare type ELocationSkelVertSurfaceSource = 'VERTSURFACESOURCE_Vert' | 'VERTSURFACESOURCE_Surface' | 'VERTSURFACESOURCE_MAX';
declare var ELocationSkelVertSurfaceSource : { VERTSURFACESOURCE_Vert:'VERTSURFACESOURCE_Vert',VERTSURFACESOURCE_Surface:'VERTSURFACESOURCE_Surface',VERTSURFACESOURCE_MAX:'VERTSURFACESOURCE_MAX', };
declare class ParticleModuleLocationSkelVertSurface extends ParticleModuleLocationBase { 
	SourceType: ELocationSkelVertSurfaceSource;
	UniversalOffset: Vector;
	bUpdatePositionEachFrame: boolean;
	bOrientMeshEmitters: boolean;
	bInheritBoneVelocity: boolean;
	InheritVelocityScale: number;
	SkelMeshActorParamName: string;
	EditorSkelMesh: SkeletalMesh;
	ValidAssociatedBones: string[];
	bEnforceNormalCheck: boolean;
	NormalToCompare: Vector;
	NormalCheckToleranceDegrees: number;
	NormalCheckTolerance: number;
	ValidMaterialIndices: number[];
	bInheritVertexColor: boolean;
	bInheritUV: boolean;
	InheritUVChannel: any;
	static Load(ResourceName: string): ParticleModuleLocationSkelVertSurface;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationSkelVertSurface;
	static GetDefaultObject(): ParticleModuleLocationSkelVertSurface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationSkelVertSurface;
	static C(Other: UObject | any): ParticleModuleLocationSkelVertSurface;
}

declare class ParticleModuleLocationWorldOffset extends ParticleModuleLocation { 
	static Load(ResourceName: string): ParticleModuleLocationWorldOffset;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationWorldOffset;
	static GetDefaultObject(): ParticleModuleLocationWorldOffset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationWorldOffset;
	static C(Other: UObject | any): ParticleModuleLocationWorldOffset;
}

declare class ParticleModuleLocationWorldOffset_Seeded extends ParticleModuleLocationWorldOffset { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleLocationWorldOffset_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationWorldOffset_Seeded;
	static GetDefaultObject(): ParticleModuleLocationWorldOffset_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationWorldOffset_Seeded;
	static C(Other: UObject | any): ParticleModuleLocationWorldOffset_Seeded;
}

declare class ParticleModuleLocation_Seeded extends ParticleModuleLocation { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleLocation_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocation_Seeded;
	static GetDefaultObject(): ParticleModuleLocation_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocation_Seeded;
	static C(Other: UObject | any): ParticleModuleLocation_Seeded;
}

declare class ParticleModuleMaterialBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleMaterialBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMaterialBase;
	static GetDefaultObject(): ParticleModuleMaterialBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMaterialBase;
	static C(Other: UObject | any): ParticleModuleMaterialBase;
}

declare class ParticleModuleMeshMaterial extends ParticleModuleMaterialBase { 
	MeshMaterials: MaterialInterface[];
	static Load(ResourceName: string): ParticleModuleMeshMaterial;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshMaterial;
	static GetDefaultObject(): ParticleModuleMeshMaterial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshMaterial;
	static C(Other: UObject | any): ParticleModuleMeshMaterial;
}

declare class ParticleModuleRotationBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleRotationBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationBase;
	static GetDefaultObject(): ParticleModuleRotationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationBase;
	static C(Other: UObject | any): ParticleModuleRotationBase;
}

declare class ParticleModuleMeshRotation extends ParticleModuleRotationBase { 
	StartRotation: RawDistributionVector;
	bInheritParent: boolean;
	static Load(ResourceName: string): ParticleModuleMeshRotation;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotation;
	static GetDefaultObject(): ParticleModuleMeshRotation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotation;
	static C(Other: UObject | any): ParticleModuleMeshRotation;
}

declare class ParticleModuleRotationRateBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleRotationRateBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationRateBase;
	static GetDefaultObject(): ParticleModuleRotationRateBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationRateBase;
	static C(Other: UObject | any): ParticleModuleRotationRateBase;
}

declare class ParticleModuleMeshRotationRate extends ParticleModuleRotationRateBase { 
	StartRotationRate: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleMeshRotationRate;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotationRate;
	static GetDefaultObject(): ParticleModuleMeshRotationRate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotationRate;
	static C(Other: UObject | any): ParticleModuleMeshRotationRate;
}

declare class ParticleModuleMeshRotationRateMultiplyLife extends ParticleModuleRotationRateBase { 
	LifeMultiplier: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleMeshRotationRateMultiplyLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotationRateMultiplyLife;
	static GetDefaultObject(): ParticleModuleMeshRotationRateMultiplyLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotationRateMultiplyLife;
	static C(Other: UObject | any): ParticleModuleMeshRotationRateMultiplyLife;
}

declare class ParticleModuleMeshRotationRateOverLife extends ParticleModuleRotationRateBase { 
	RotRate: RawDistributionVector;
	bScaleRotRate: boolean;
	static Load(ResourceName: string): ParticleModuleMeshRotationRateOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotationRateOverLife;
	static GetDefaultObject(): ParticleModuleMeshRotationRateOverLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotationRateOverLife;
	static C(Other: UObject | any): ParticleModuleMeshRotationRateOverLife;
}

declare class ParticleModuleMeshRotationRate_Seeded extends ParticleModuleMeshRotationRate { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleMeshRotationRate_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotationRate_Seeded;
	static GetDefaultObject(): ParticleModuleMeshRotationRate_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotationRate_Seeded;
	static C(Other: UObject | any): ParticleModuleMeshRotationRate_Seeded;
}

declare class ParticleModuleMeshRotation_Seeded extends ParticleModuleMeshRotation { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleMeshRotation_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotation_Seeded;
	static GetDefaultObject(): ParticleModuleMeshRotation_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotation_Seeded;
	static C(Other: UObject | any): ParticleModuleMeshRotation_Seeded;
}

declare class ParticleModuleOrientationBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleOrientationBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleOrientationBase;
	static GetDefaultObject(): ParticleModuleOrientationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrientationBase;
	static C(Other: UObject | any): ParticleModuleOrientationBase;
}

declare type EParticleAxisLock = 'EPAL_NONE' | 'EPAL_X' | 'EPAL_Y' | 'EPAL_Z' | 'EPAL_NEGATIVE_X' | 'EPAL_NEGATIVE_Y' | 'EPAL_NEGATIVE_Z' | 'EPAL_ROTATE_X' | 'EPAL_ROTATE_Y' | 'EPAL_ROTATE_Z' | 'EPAL_MAX';
declare var EParticleAxisLock : { EPAL_NONE:'EPAL_NONE',EPAL_X:'EPAL_X',EPAL_Y:'EPAL_Y',EPAL_Z:'EPAL_Z',EPAL_NEGATIVE_X:'EPAL_NEGATIVE_X',EPAL_NEGATIVE_Y:'EPAL_NEGATIVE_Y',EPAL_NEGATIVE_Z:'EPAL_NEGATIVE_Z',EPAL_ROTATE_X:'EPAL_ROTATE_X',EPAL_ROTATE_Y:'EPAL_ROTATE_Y',EPAL_ROTATE_Z:'EPAL_ROTATE_Z',EPAL_MAX:'EPAL_MAX', };
declare class ParticleModuleOrientationAxisLock extends ParticleModuleOrientationBase { 
	LockAxisFlags: EParticleAxisLock;
	static Load(ResourceName: string): ParticleModuleOrientationAxisLock;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleOrientationAxisLock;
	static GetDefaultObject(): ParticleModuleOrientationAxisLock;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrientationAxisLock;
	static C(Other: UObject | any): ParticleModuleOrientationAxisLock;
}

declare class ParticleModuleParameterBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleParameterBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleParameterBase;
	static GetDefaultObject(): ParticleModuleParameterBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleParameterBase;
	static C(Other: UObject | any): ParticleModuleParameterBase;
}

declare type EEmitterDynamicParameterValue = 'EDPV_UserSet' | 'EDPV_AutoSet' | 'EDPV_VelocityX' | 'EDPV_VelocityY' | 'EDPV_VelocityZ' | 'EDPV_VelocityMag' | 'EDPV_MAX';
declare var EEmitterDynamicParameterValue : { EDPV_UserSet:'EDPV_UserSet',EDPV_AutoSet:'EDPV_AutoSet',EDPV_VelocityX:'EDPV_VelocityX',EDPV_VelocityY:'EDPV_VelocityY',EDPV_VelocityZ:'EDPV_VelocityZ',EDPV_VelocityMag:'EDPV_VelocityMag',EDPV_MAX:'EDPV_MAX', };
declare class EmitterDynamicParameter { 
	ParamName: string;
	bUseEmitterTime: boolean;
	bSpawnTimeOnly: boolean;
	ValueMethod: EEmitterDynamicParameterValue;
	bScaleVelocityByParamValue: boolean;
	ParamValue: RawDistributionFloat;
	clone() : EmitterDynamicParameter;
	static C(Other: UObject | any): EmitterDynamicParameter;
}

declare class ParticleModuleParameterDynamic extends ParticleModuleParameterBase { 
	DynamicParams: EmitterDynamicParameter[];
	UpdateFlags: number;
	bUsesVelocity: boolean;
	static Load(ResourceName: string): ParticleModuleParameterDynamic;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleParameterDynamic;
	static GetDefaultObject(): ParticleModuleParameterDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleParameterDynamic;
	static C(Other: UObject | any): ParticleModuleParameterDynamic;
}

declare class ParticleModuleParameterDynamic_Seeded extends ParticleModuleParameterDynamic { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleParameterDynamic_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleParameterDynamic_Seeded;
	static GetDefaultObject(): ParticleModuleParameterDynamic_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleParameterDynamic_Seeded;
	static C(Other: UObject | any): ParticleModuleParameterDynamic_Seeded;
}

declare class ParticleModulePivotOffset extends ParticleModuleLocationBase { 
	PivotOffset: Vector2D;
	static Load(ResourceName: string): ParticleModulePivotOffset;
	static Find(Outer: UObject, ResourceName: string): ParticleModulePivotOffset;
	static GetDefaultObject(): ParticleModulePivotOffset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModulePivotOffset;
	static C(Other: UObject | any): ParticleModulePivotOffset;
}

declare class ParticleModuleRotation extends ParticleModuleRotationBase { 
	StartRotation: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleRotation;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotation;
	static GetDefaultObject(): ParticleModuleRotation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotation;
	static C(Other: UObject | any): ParticleModuleRotation;
}

declare class ParticleModuleRotationOverLifetime extends ParticleModuleRotationBase { 
	RotationOverLife: RawDistributionFloat;
	Scale: boolean;
	static Load(ResourceName: string): ParticleModuleRotationOverLifetime;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationOverLifetime;
	static GetDefaultObject(): ParticleModuleRotationOverLifetime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationOverLifetime;
	static C(Other: UObject | any): ParticleModuleRotationOverLifetime;
}

declare class ParticleModuleRotationRate extends ParticleModuleRotationRateBase { 
	StartRotationRate: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleRotationRate;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationRate;
	static GetDefaultObject(): ParticleModuleRotationRate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationRate;
	static C(Other: UObject | any): ParticleModuleRotationRate;
}

declare class ParticleModuleRotationRateMultiplyLife extends ParticleModuleRotationRateBase { 
	LifeMultiplier: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleRotationRateMultiplyLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationRateMultiplyLife;
	static GetDefaultObject(): ParticleModuleRotationRateMultiplyLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationRateMultiplyLife;
	static C(Other: UObject | any): ParticleModuleRotationRateMultiplyLife;
}

declare class ParticleModuleRotationRate_Seeded extends ParticleModuleRotationRate { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleRotationRate_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationRate_Seeded;
	static GetDefaultObject(): ParticleModuleRotationRate_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationRate_Seeded;
	static C(Other: UObject | any): ParticleModuleRotationRate_Seeded;
}

declare class ParticleModuleRotation_Seeded extends ParticleModuleRotation { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleRotation_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotation_Seeded;
	static GetDefaultObject(): ParticleModuleRotation_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotation_Seeded;
	static C(Other: UObject | any): ParticleModuleRotation_Seeded;
}

declare class ParticleModuleSizeBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleSizeBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSizeBase;
	static GetDefaultObject(): ParticleModuleSizeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSizeBase;
	static C(Other: UObject | any): ParticleModuleSizeBase;
}

declare class ParticleModuleSize extends ParticleModuleSizeBase { 
	StartSize: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleSize;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSize;
	static GetDefaultObject(): ParticleModuleSize;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSize;
	static C(Other: UObject | any): ParticleModuleSize;
}

declare class ParticleModuleSizeMultiplyLife extends ParticleModuleSizeBase { 
	LifeMultiplier: RawDistributionVector;
	MultiplyX: boolean;
	MultiplyY: boolean;
	MultiplyZ: boolean;
	static Load(ResourceName: string): ParticleModuleSizeMultiplyLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSizeMultiplyLife;
	static GetDefaultObject(): ParticleModuleSizeMultiplyLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSizeMultiplyLife;
	static C(Other: UObject | any): ParticleModuleSizeMultiplyLife;
}

declare class ParticleModuleSizeScale extends ParticleModuleSizeBase { 
	SizeScale: RawDistributionVector;
	EnableX: boolean;
	EnableY: boolean;
	EnableZ: boolean;
	static Load(ResourceName: string): ParticleModuleSizeScale;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSizeScale;
	static GetDefaultObject(): ParticleModuleSizeScale;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSizeScale;
	static C(Other: UObject | any): ParticleModuleSizeScale;
}

declare class ParticleModuleSizeScaleBySpeed extends ParticleModuleSizeBase { 
	SpeedScale: Vector2D;
	MaxScale: Vector2D;
	static Load(ResourceName: string): ParticleModuleSizeScaleBySpeed;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSizeScaleBySpeed;
	static GetDefaultObject(): ParticleModuleSizeScaleBySpeed;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSizeScaleBySpeed;
	static C(Other: UObject | any): ParticleModuleSizeScaleBySpeed;
}

declare class ParticleModuleSize_Seeded extends ParticleModuleSize { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleSize_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSize_Seeded;
	static GetDefaultObject(): ParticleModuleSize_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSize_Seeded;
	static C(Other: UObject | any): ParticleModuleSize_Seeded;
}

declare class ParticleModuleSourceMovement extends ParticleModuleLocationBase { 
	SourceMovementScale: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleSourceMovement;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSourceMovement;
	static GetDefaultObject(): ParticleModuleSourceMovement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSourceMovement;
	static C(Other: UObject | any): ParticleModuleSourceMovement;
}

declare class ParticleModuleSpawnPerUnit extends ParticleModuleSpawnBase { 
	UnitScalar: number;
	MovementTolerance: number;
	SpawnPerUnit: RawDistributionFloat;
	MaxFrameDistance: number;
	bIgnoreSpawnRateWhenMoving: boolean;
	bIgnoreMovementAlongX: boolean;
	bIgnoreMovementAlongY: boolean;
	bIgnoreMovementAlongZ: boolean;
	static Load(ResourceName: string): ParticleModuleSpawnPerUnit;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSpawnPerUnit;
	static GetDefaultObject(): ParticleModuleSpawnPerUnit;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSpawnPerUnit;
	static C(Other: UObject | any): ParticleModuleSpawnPerUnit;
}

declare class ParticleModuleSubUVBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleSubUVBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSubUVBase;
	static GetDefaultObject(): ParticleModuleSubUVBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSubUVBase;
	static C(Other: UObject | any): ParticleModuleSubUVBase;
}

declare class SubUVAnimation extends UObject { 
	SubUVTexture: Texture2D;
	SubImages_Horizontal: number;
	SubImages_Vertical: number;
	BoundingMode: ESubUVBoundingVertexCount;
	OpacitySourceMode: EOpacitySourceMode;
	AlphaThreshold: number;
	static Load(ResourceName: string): SubUVAnimation;
	static Find(Outer: UObject, ResourceName: string): SubUVAnimation;
	static GetDefaultObject(): SubUVAnimation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubUVAnimation;
	static C(Other: UObject | any): SubUVAnimation;
}

declare class ParticleModuleSubUV extends ParticleModuleSubUVBase { 
	Animation: SubUVAnimation;
	SubImageIndex: RawDistributionFloat;
	bUseRealTime: boolean;
	static Load(ResourceName: string): ParticleModuleSubUV;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSubUV;
	static GetDefaultObject(): ParticleModuleSubUV;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSubUV;
	static C(Other: UObject | any): ParticleModuleSubUV;
}

declare class ParticleModuleSubUVMovie extends ParticleModuleSubUV { 
	bUseEmitterTime: boolean;
	FrameRate: RawDistributionFloat;
	StartingFrame: number;
	static Load(ResourceName: string): ParticleModuleSubUVMovie;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSubUVMovie;
	static GetDefaultObject(): ParticleModuleSubUVMovie;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSubUVMovie;
	static C(Other: UObject | any): ParticleModuleSubUVMovie;
}

declare class ParticleModuleTrailBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleTrailBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTrailBase;
	static GetDefaultObject(): ParticleModuleTrailBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTrailBase;
	static C(Other: UObject | any): ParticleModuleTrailBase;
}

declare type ETrail2SourceMethod = 'PET2SRCM_Default' | 'PET2SRCM_Particle' | 'PET2SRCM_Actor' | 'PET2SRCM_MAX';
declare var ETrail2SourceMethod : { PET2SRCM_Default:'PET2SRCM_Default',PET2SRCM_Particle:'PET2SRCM_Particle',PET2SRCM_Actor:'PET2SRCM_Actor',PET2SRCM_MAX:'PET2SRCM_MAX', };
declare type EParticleSourceSelectionMethod = 'EPSSM_Random' | 'EPSSM_Sequential' | 'EPSSM_MAX';
declare var EParticleSourceSelectionMethod : { EPSSM_Random:'EPSSM_Random',EPSSM_Sequential:'EPSSM_Sequential',EPSSM_MAX:'EPSSM_MAX', };
declare class ParticleModuleTrailSource extends ParticleModuleTrailBase { 
	SourceMethod: ETrail2SourceMethod;
	SourceName: string;
	SourceStrength: RawDistributionFloat;
	bLockSourceStength: boolean;
	SourceOffsetCount: number;
	SourceOffsetDefaults: Vector[];
	SelectionMethod: EParticleSourceSelectionMethod;
	bInheritRotation: boolean;
	static Load(ResourceName: string): ParticleModuleTrailSource;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTrailSource;
	static GetDefaultObject(): ParticleModuleTrailSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTrailSource;
	static C(Other: UObject | any): ParticleModuleTrailSource;
}

declare class ParticleModuleTypeDataAnimTrail extends ParticleModuleTypeDataBase { 
	bDeadTrailsOnDeactivate: boolean;
	bEnablePreviousTangentRecalculation: boolean;
	bTangentRecalculationEveryFrame: boolean;
	TilingDistance: number;
	DistanceTessellationStepSize: number;
	TangentTessellationStepSize: number;
	WidthTessellationStepSize: number;
	static Load(ResourceName: string): ParticleModuleTypeDataAnimTrail;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataAnimTrail;
	static GetDefaultObject(): ParticleModuleTypeDataAnimTrail;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataAnimTrail;
	static C(Other: UObject | any): ParticleModuleTypeDataAnimTrail;
}

declare type EBeam2Method = 'PEB2M_Distance' | 'PEB2M_Target' | 'PEB2M_Branch' | 'PEB2M_MAX';
declare var EBeam2Method : { PEB2M_Distance:'PEB2M_Distance',PEB2M_Target:'PEB2M_Target',PEB2M_Branch:'PEB2M_Branch',PEB2M_MAX:'PEB2M_MAX', };
declare type EBeamTaperMethod = 'PEBTM_None' | 'PEBTM_Full' | 'PEBTM_Partial' | 'PEBTM_MAX';
declare var EBeamTaperMethod : { PEBTM_None:'PEBTM_None',PEBTM_Full:'PEBTM_Full',PEBTM_Partial:'PEBTM_Partial',PEBTM_MAX:'PEBTM_MAX', };
declare class ParticleModuleTypeDataBeam2 extends ParticleModuleTypeDataBase { 
	BeamMethod: EBeam2Method;
	TextureTile: number;
	TextureTileDistance: number;
	Sheets: number;
	MaxBeamCount: number;
	Speed: number;
	InterpolationPoints: number;
	bAlwaysOn: boolean;
	UpVectorStepSize: number;
	BranchParentName: string;
	Distance: RawDistributionFloat;
	TaperMethod: EBeamTaperMethod;
	TaperFactor: RawDistributionFloat;
	TaperScale: RawDistributionFloat;
	RenderGeometry: boolean;
	RenderDirectLine: boolean;
	RenderLines: boolean;
	RenderTessellation: boolean;
	static Load(ResourceName: string): ParticleModuleTypeDataBeam2;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataBeam2;
	static GetDefaultObject(): ParticleModuleTypeDataBeam2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataBeam2;
	static C(Other: UObject | any): ParticleModuleTypeDataBeam2;
}

declare class VectorField extends UObject { 
	Bounds: Box;
	Intensity: number;
	static Load(ResourceName: string): VectorField;
	static Find(Outer: UObject, ResourceName: string): VectorField;
	static GetDefaultObject(): VectorField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorField;
	static C(Other: UObject | any): VectorField;
}

declare class GPUSpriteLocalVectorFieldInfo { 
	Field: VectorField;
	Transform: Transform;
	MinInitialRotation: Rotator;
	MaxInitialRotation: Rotator;
	RotationRate: Rotator;
	Intensity: number;
	Tightness: number;
	bIgnoreComponentTransform: boolean;
	bTileX: boolean;
	bTileY: boolean;
	bTileZ: boolean;
	bUseFixDT: boolean;
	clone() : GPUSpriteLocalVectorFieldInfo;
	static C(Other: UObject | any): GPUSpriteLocalVectorFieldInfo;
}

declare class FloatDistribution { 
	Table: DistributionLookupTable;
	clone() : FloatDistribution;
	static C(Other: UObject | any): FloatDistribution;
}

declare class GPUSpriteEmitterInfo { 
	RequiredModule: ParticleModuleRequired;
	SpawnModule: ParticleModuleSpawn;
	SpawnPerUnitModule: ParticleModuleSpawnPerUnit;
	SpawnModules: ParticleModule[];
	LocalVectorField: GPUSpriteLocalVectorFieldInfo;
	VectorFieldScale: FloatDistribution;
	DragCoefficient: FloatDistribution;
	PointAttractorStrength: FloatDistribution;
	Resilience: FloatDistribution;
	ConstantAcceleration: Vector;
	PointAttractorPosition: Vector;
	PointAttractorRadiusSq: number;
	OrbitOffsetBase: Vector;
	OrbitOffsetRange: Vector;
	InvMaxSize: Vector2D;
	InvRotationRateScale: number;
	MaxLifetime: number;
	MaxParticleCount: number;
	ScreenAlignment: EParticleScreenAlignment;
	LockAxisFlag: EParticleAxisLock;
	bEnableCollision: boolean;
	CollisionMode: EParticleCollisionMode;
	bRemoveHMDRoll: boolean;
	MinFacingCameraBlendDistance: number;
	MaxFacingCameraBlendDistance: number;
	DynamicColor: RawDistributionVector;
	DynamicAlpha: RawDistributionFloat;
	DynamicColorScale: RawDistributionVector;
	DynamicAlphaScale: RawDistributionFloat;
	clone() : GPUSpriteEmitterInfo;
	static C(Other: UObject | any): GPUSpriteEmitterInfo;
}

declare class GPUSpriteResourceData { 
	QuantizedColorSamples: Color[];
	QuantizedMiscSamples: Color[];
	QuantizedSimulationAttrSamples: Color[];
	ColorScale: Vector4;
	ColorBias: Vector4;
	MiscScale: Vector4;
	MiscBias: Vector4;
	SimulationAttrCurveScale: Vector4;
	SimulationAttrCurveBias: Vector4;
	SubImageSize: Vector4;
	SizeBySpeed: Vector4;
	ConstantAcceleration: Vector;
	OrbitOffsetBase: Vector;
	OrbitOffsetRange: Vector;
	OrbitFrequencyBase: Vector;
	OrbitFrequencyRange: Vector;
	OrbitPhaseBase: Vector;
	OrbitPhaseRange: Vector;
	GlobalVectorFieldScale: number;
	GlobalVectorFieldTightness: number;
	PerParticleVectorFieldScale: number;
	PerParticleVectorFieldBias: number;
	DragCoefficientScale: number;
	DragCoefficientBias: number;
	ResilienceScale: number;
	ResilienceBias: number;
	CollisionRadiusScale: number;
	CollisionRadiusBias: number;
	CollisionTimeBias: number;
	CollisionRandomSpread: number;
	CollisionRandomDistribution: number;
	OneMinusFriction: number;
	RotationRateScale: number;
	CameraMotionBlurAmount: number;
	ScreenAlignment: EParticleScreenAlignment;
	LockAxisFlag: EParticleAxisLock;
	PivotOffset: Vector2D;
	bRemoveHMDRoll: boolean;
	MinFacingCameraBlendDistance: number;
	MaxFacingCameraBlendDistance: number;
	clone() : GPUSpriteResourceData;
	static C(Other: UObject | any): GPUSpriteResourceData;
}

declare class ParticleModuleTypeDataGpu extends ParticleModuleTypeDataBase { 
	EmitterInfo: GPUSpriteEmitterInfo;
	ResourceData: GPUSpriteResourceData;
	CameraMotionBlurAmount: number;
	bClearExistingParticlesOnInit: boolean;
	static Load(ResourceName: string): ParticleModuleTypeDataGpu;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataGpu;
	static GetDefaultObject(): ParticleModuleTypeDataGpu;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataGpu;
	static C(Other: UObject | any): ParticleModuleTypeDataGpu;
}

declare type EMeshScreenAlignment = 'PSMA_MeshFaceCameraWithRoll' | 'PSMA_MeshFaceCameraWithSpin' | 'PSMA_MeshFaceCameraWithLockedAxis' | 'PSMA_MAX';
declare var EMeshScreenAlignment : { PSMA_MeshFaceCameraWithRoll:'PSMA_MeshFaceCameraWithRoll',PSMA_MeshFaceCameraWithSpin:'PSMA_MeshFaceCameraWithSpin',PSMA_MeshFaceCameraWithLockedAxis:'PSMA_MeshFaceCameraWithLockedAxis',PSMA_MAX:'PSMA_MAX', };
declare type EMeshCameraFacingUpAxis = 'CameraFacing_NoneUP' | 'CameraFacing_ZUp' | 'CameraFacing_NegativeZUp' | 'CameraFacing_YUp' | 'CameraFacing_NegativeYUp' | 'CameraFacing_MAX';
declare var EMeshCameraFacingUpAxis : { CameraFacing_NoneUP:'CameraFacing_NoneUP',CameraFacing_ZUp:'CameraFacing_ZUp',CameraFacing_NegativeZUp:'CameraFacing_NegativeZUp',CameraFacing_YUp:'CameraFacing_YUp',CameraFacing_NegativeYUp:'CameraFacing_NegativeYUp',CameraFacing_MAX:'CameraFacing_MAX', };
declare type EMeshCameraFacingOptions = 'XAxisFacing_NoUp' | 'XAxisFacing_ZUp' | 'XAxisFacing_NegativeZUp' | 'XAxisFacing_YUp' | 'XAxisFacing_NegativeYUp' | 'LockedAxis_ZAxisFacing' | 'LockedAxis_NegativeZAxisFacing' | 'LockedAxis_YAxisFacing' | 'LockedAxis_NegativeYAxisFacing' | 'VelocityAligned_ZAxisFacing' | 'VelocityAligned_NegativeZAxisFacing' | 'VelocityAligned_YAxisFacing' | 'VelocityAligned_NegativeYAxisFacing' | 'EMeshCameraFacingOptions_MAX';
declare var EMeshCameraFacingOptions : { XAxisFacing_NoUp:'XAxisFacing_NoUp',XAxisFacing_ZUp:'XAxisFacing_ZUp',XAxisFacing_NegativeZUp:'XAxisFacing_NegativeZUp',XAxisFacing_YUp:'XAxisFacing_YUp',XAxisFacing_NegativeYUp:'XAxisFacing_NegativeYUp',LockedAxis_ZAxisFacing:'LockedAxis_ZAxisFacing',LockedAxis_NegativeZAxisFacing:'LockedAxis_NegativeZAxisFacing',LockedAxis_YAxisFacing:'LockedAxis_YAxisFacing',LockedAxis_NegativeYAxisFacing:'LockedAxis_NegativeYAxisFacing',VelocityAligned_ZAxisFacing:'VelocityAligned_ZAxisFacing',VelocityAligned_NegativeZAxisFacing:'VelocityAligned_NegativeZAxisFacing',VelocityAligned_YAxisFacing:'VelocityAligned_YAxisFacing',VelocityAligned_NegativeYAxisFacing:'VelocityAligned_NegativeYAxisFacing',EMeshCameraFacingOptions_MAX:'EMeshCameraFacingOptions_MAX', };
declare class ParticleModuleTypeDataMesh extends ParticleModuleTypeDataBase { 
	Mesh: StaticMesh;
	LODSizeScale: number;
	bUseStaticMeshLODs: boolean;
	CastShadows: boolean;
	DoCollisions: boolean;
	MeshAlignment: EMeshScreenAlignment;
	bOverrideMaterial: boolean;
	bOverrideDefaultMotionBlurSettings: boolean;
	bEnableMotionBlur: boolean;
	RollPitchYawRange: RawDistributionVector;
	AxisLockOption: EParticleAxisLock;
	bCameraFacing: boolean;
	CameraFacingUpAxisOption: EMeshCameraFacingUpAxis;
	CameraFacingOption: EMeshCameraFacingOptions;
	bApplyParticleRotationAsSpin: boolean;
	bFaceCameraDirectionRatherThanPosition: boolean;
	bCollisionsConsiderPartilceSize: boolean;
	static Load(ResourceName: string): ParticleModuleTypeDataMesh;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataMesh;
	static GetDefaultObject(): ParticleModuleTypeDataMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataMesh;
	static C(Other: UObject | any): ParticleModuleTypeDataMesh;
}

declare type ETrailsRenderAxisOption = 'Trails_CameraUp' | 'Trails_SourceUp' | 'Trails_WorldUp' | 'Trails_MAX';
declare var ETrailsRenderAxisOption : { Trails_CameraUp:'Trails_CameraUp',Trails_SourceUp:'Trails_SourceUp',Trails_WorldUp:'Trails_WorldUp',Trails_MAX:'Trails_MAX', };
declare class ParticleModuleTypeDataRibbon extends ParticleModuleTypeDataBase { 
	MaxTessellationBetweenParticles: number;
	SheetsPerTrail: number;
	MaxTrailCount: number;
	MaxParticleInTrailCount: number;
	bDeadTrailsOnDeactivate: boolean;
	bDeadTrailsOnSourceLoss: boolean;
	bClipSourceSegement: boolean;
	bEnablePreviousTangentRecalculation: boolean;
	bTangentRecalculationEveryFrame: boolean;
	bSpawnInitialParticle: boolean;
	RenderAxis: ETrailsRenderAxisOption;
	TangentSpawningScalar: number;
	bRenderGeometry: boolean;
	bRenderSpawnPoints: boolean;
	bRenderTangents: boolean;
	bRenderTessellation: boolean;
	TilingDistance: number;
	DistanceTessellationStepSize: number;
	bEnableTangentDiffInterpScale: boolean;
	TangentTessellationScalar: number;
	static Load(ResourceName: string): ParticleModuleTypeDataRibbon;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataRibbon;
	static GetDefaultObject(): ParticleModuleTypeDataRibbon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataRibbon;
	static C(Other: UObject | any): ParticleModuleTypeDataRibbon;
}

declare class ParticleModuleVectorFieldBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleVectorFieldBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldBase;
	static GetDefaultObject(): ParticleModuleVectorFieldBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldBase;
	static C(Other: UObject | any): ParticleModuleVectorFieldBase;
}

declare class ParticleModuleVectorFieldGlobal extends ParticleModuleVectorFieldBase { 
	bOverrideGlobalVectorFieldTightness: boolean;
	GlobalVectorFieldScale: number;
	GlobalVectorFieldTightness: number;
	static Load(ResourceName: string): ParticleModuleVectorFieldGlobal;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldGlobal;
	static GetDefaultObject(): ParticleModuleVectorFieldGlobal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldGlobal;
	static C(Other: UObject | any): ParticleModuleVectorFieldGlobal;
}

declare class ParticleModuleVectorFieldLocal extends ParticleModuleVectorFieldBase { 
	VectorField: VectorField;
	RelativeTranslation: Vector;
	RelativeRotation: Rotator;
	RelativeScale3D: Vector;
	Intensity: number;
	Tightness: number;
	bIgnoreComponentTransform: boolean;
	bTileX: boolean;
	bTileY: boolean;
	bTileZ: boolean;
	bUseFixDT: boolean;
	static Load(ResourceName: string): ParticleModuleVectorFieldLocal;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldLocal;
	static GetDefaultObject(): ParticleModuleVectorFieldLocal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldLocal;
	static C(Other: UObject | any): ParticleModuleVectorFieldLocal;
}

declare class ParticleModuleVectorFieldRotation extends ParticleModuleVectorFieldBase { 
	MinInitialRotation: Vector;
	MaxInitialRotation: Vector;
	static Load(ResourceName: string): ParticleModuleVectorFieldRotation;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldRotation;
	static GetDefaultObject(): ParticleModuleVectorFieldRotation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldRotation;
	static C(Other: UObject | any): ParticleModuleVectorFieldRotation;
}

declare class ParticleModuleVectorFieldRotationRate extends ParticleModuleVectorFieldBase { 
	RotationRate: Vector;
	static Load(ResourceName: string): ParticleModuleVectorFieldRotationRate;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldRotationRate;
	static GetDefaultObject(): ParticleModuleVectorFieldRotationRate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldRotationRate;
	static C(Other: UObject | any): ParticleModuleVectorFieldRotationRate;
}

declare class ParticleModuleVectorFieldScale extends ParticleModuleVectorFieldBase { 
	VectorFieldScale: DistributionFloat;
	VectorFieldScaleRaw: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleVectorFieldScale;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldScale;
	static GetDefaultObject(): ParticleModuleVectorFieldScale;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldScale;
	static C(Other: UObject | any): ParticleModuleVectorFieldScale;
}

declare class ParticleModuleVectorFieldScaleOverLife extends ParticleModuleVectorFieldBase { 
	VectorFieldScaleOverLife: DistributionFloat;
	VectorFieldScaleOverLifeRaw: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleVectorFieldScaleOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldScaleOverLife;
	static GetDefaultObject(): ParticleModuleVectorFieldScaleOverLife;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldScaleOverLife;
	static C(Other: UObject | any): ParticleModuleVectorFieldScaleOverLife;
}

declare class ParticleModuleVelocityBase extends ParticleModule { 
	bInWorldSpace: boolean;
	bApplyOwnerScale: boolean;
	static Load(ResourceName: string): ParticleModuleVelocityBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocityBase;
	static GetDefaultObject(): ParticleModuleVelocityBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocityBase;
	static C(Other: UObject | any): ParticleModuleVelocityBase;
}

declare class ParticleModuleVelocity extends ParticleModuleVelocityBase { 
	StartVelocity: RawDistributionVector;
	StartVelocityRadial: RawDistributionFloat;
	static Load(ResourceName: string): ParticleModuleVelocity;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocity;
	static GetDefaultObject(): ParticleModuleVelocity;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocity;
	static C(Other: UObject | any): ParticleModuleVelocity;
}

declare class ParticleModuleVelocityCone extends ParticleModuleVelocityBase { 
	Angle: RawDistributionFloat;
	Velocity: RawDistributionFloat;
	Direction: Vector;
	static Load(ResourceName: string): ParticleModuleVelocityCone;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocityCone;
	static GetDefaultObject(): ParticleModuleVelocityCone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocityCone;
	static C(Other: UObject | any): ParticleModuleVelocityCone;
}

declare class ParticleModuleVelocityInheritParent extends ParticleModuleVelocityBase { 
	Scale: RawDistributionVector;
	static Load(ResourceName: string): ParticleModuleVelocityInheritParent;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocityInheritParent;
	static GetDefaultObject(): ParticleModuleVelocityInheritParent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocityInheritParent;
	static C(Other: UObject | any): ParticleModuleVelocityInheritParent;
}

declare class ParticleModuleVelocityOverLifetime extends ParticleModuleVelocityBase { 
	VelOverLife: RawDistributionVector;
	Absolute: boolean;
	static Load(ResourceName: string): ParticleModuleVelocityOverLifetime;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocityOverLifetime;
	static GetDefaultObject(): ParticleModuleVelocityOverLifetime;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocityOverLifetime;
	static C(Other: UObject | any): ParticleModuleVelocityOverLifetime;
}

declare class ParticleModuleVelocity_Seeded extends ParticleModuleVelocity { 
	RandomSeedInfo: ParticleRandomSeedInfo;
	static Load(ResourceName: string): ParticleModuleVelocity_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocity_Seeded;
	static GetDefaultObject(): ParticleModuleVelocity_Seeded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocity_Seeded;
	static C(Other: UObject | any): ParticleModuleVelocity_Seeded;
}

declare class ParticleSpriteEmitter extends ParticleEmitter { 
	static Load(ResourceName: string): ParticleSpriteEmitter;
	static Find(Outer: UObject, ResourceName: string): ParticleSpriteEmitter;
	static GetDefaultObject(): ParticleSpriteEmitter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSpriteEmitter;
	static C(Other: UObject | any): ParticleSpriteEmitter;
}

declare class PathFollowingAgentInterface extends Interface { 
	static Load(ResourceName: string): PathFollowingAgentInterface;
	static Find(Outer: UObject, ResourceName: string): PathFollowingAgentInterface;
	static GetDefaultObject(): PathFollowingAgentInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PathFollowingAgentInterface;
	static C(Other: UObject | any): PathFollowingAgentInterface;
}

declare class PawnNoiseEmitterComponent extends ActorComponent { 
	bAIPerceptionSystemCompatibilityMode: boolean;
	LastRemoteNoisePosition: Vector;
	NoiseLifetime: number;
	LastRemoteNoiseVolume: number;
	LastRemoteNoiseTime: number;
	LastLocalNoiseVolume: number;
	LastLocalNoiseTime: number;
	static Load(ResourceName: string): PawnNoiseEmitterComponent;
	static Find(Outer: UObject, ResourceName: string): PawnNoiseEmitterComponent;
	static GetDefaultObject(): PawnNoiseEmitterComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnNoiseEmitterComponent;
	MakeNoise(NoiseMaker: Actor,Loudness: number,NoiseLocation: Vector): void;
	static C(Other: UObject | any): PawnNoiseEmitterComponent;
}

declare class PhysicalAnimationComponent extends ActorComponent { 
	StrengthMultiplyer: number;
	SkeletalMeshComponent: SkeletalMeshComponent;
	static Load(ResourceName: string): PhysicalAnimationComponent;
	static Find(Outer: UObject, ResourceName: string): PhysicalAnimationComponent;
	static GetDefaultObject(): PhysicalAnimationComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicalAnimationComponent;
	SetStrengthMultiplyer(InStrengthMultiplyer: number): void;
	SetSkeletalMeshComponent(InSkeletalMeshComponent: SkeletalMeshComponent): void;
	GetBodyTargetTransform(BodyName: string): Transform;
	ApplyPhysicalAnimationSettingsBelow(BodyName: string,PhysicalAnimationData: PhysicalAnimationData,bIncludeSelf: boolean): void;
	ApplyPhysicalAnimationSettings(BodyName: string,PhysicalAnimationData: PhysicalAnimationData): void;
	ApplyPhysicalAnimationProfileBelow(BodyName: string,ProfileName: string,bIncludeSelf: boolean,bClearNotFound: boolean): void;
	static C(Other: UObject | any): PhysicalAnimationComponent;
}

declare class RigidBodyBase extends Actor { 
	static GetDefaultObject(): RigidBodyBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RigidBodyBase;
	static C(Other: UObject | any): RigidBodyBase;
}

declare class ConstrainComponentPropName { 
	ComponentName: string;
	clone() : ConstrainComponentPropName;
	static C(Other: UObject | any): ConstrainComponentPropName;
}

declare type EConstraintFrame = 'Frame1' | 'Frame2' | 'EConstraintFrame_MAX';
declare var EConstraintFrame : { Frame1:'Frame1',Frame2:'Frame2',EConstraintFrame_MAX:'EConstraintFrame_MAX', };
declare class PhysicsConstraintComponent extends SceneComponent { 
	ConstraintActor1: Actor;
	ComponentName1: ConstrainComponentPropName;
	ConstraintActor2: Actor;
	ComponentName2: ConstrainComponentPropName;
	ConstraintSetup: PhysicsConstraintTemplate;
	OnConstraintBroken: UnrealEngineMulticastDelegate<(ConstraintIndex: number) => void>;
	OnPlasticDeformation: UnrealEngineMulticastDelegate<(ConstraintIndex: number) => void>;
	ConstraintInstance: ConstraintInstance;
	static Load(ResourceName: string): PhysicsConstraintComponent;
	static Find(Outer: UObject, ResourceName: string): PhysicsConstraintComponent;
	static GetDefaultObject(): PhysicsConstraintComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsConstraintComponent;
	SetOrientationDriveTwistAndSwing(bEnableTwistDrive: boolean,bEnableSwingDrive: boolean): void;
	SetOrientationDriveSLERP(bEnableSLERP: boolean): void;
	SetLinearZLimit(ConstraintType: ELinearConstraintMotion,LimitSize: number): void;
	SetLinearYLimit(ConstraintType: ELinearConstraintMotion,LimitSize: number): void;
	SetLinearXLimit(ConstraintType: ELinearConstraintMotion,LimitSize: number): void;
	SetLinearVelocityTarget(InVelTarget: Vector): void;
	SetLinearVelocityDrive(bEnableDriveX: boolean,bEnableDriveY: boolean,bEnableDriveZ: boolean): void;
	SetLinearPositionTarget(InPosTarget: Vector): void;
	SetLinearPositionDrive(bEnableDriveX: boolean,bEnableDriveY: boolean,bEnableDriveZ: boolean): void;
	SetLinearPlasticity(bLinearPlasticity: boolean,LinearPlasticityThreshold: number,PlasticityType: EConstraintPlasticityType): void;
	SetLinearDriveParams(PositionStrength: number,VelocityStrength: number,InForceLimit: number): void;
	SetLinearBreakable(bLinearBreakable: boolean,LinearBreakThreshold: number): void;
	SetDisableCollision(bDisableCollision: boolean): void;
	SetContactTransferScale(ContactTransferScale: number): void;
	SetConstraintReferencePosition(Frame: EConstraintFrame,RefPosition: Vector): void;
	SetConstraintReferenceOrientation(Frame: EConstraintFrame,PriAxis: Vector,SecAxis: Vector): void;
	SetConstraintReferenceFrame(Frame: EConstraintFrame,RefFrame: Transform): void;
	SetConstrainedComponents(Component1: PrimitiveComponent,BoneName1: string,Component2: PrimitiveComponent,BoneName2: string): void;
	SetAngularVelocityTarget(InVelTarget: Vector): void;
	SetAngularVelocityDriveTwistAndSwing(bEnableTwistDrive: boolean,bEnableSwingDrive: boolean): void;
	SetAngularVelocityDriveSLERP(bEnableSLERP: boolean): void;
	SetAngularVelocityDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean): void;
	SetAngularTwistLimit(ConstraintType: EAngularConstraintMotion,TwistLimitAngle: number): void;
	SetAngularSwing2Limit(MotionType: EAngularConstraintMotion,Swing2LimitAngle: number): void;
	SetAngularSwing1Limit(MotionType: EAngularConstraintMotion,Swing1LimitAngle: number): void;
	SetAngularPlasticity(bAngularPlasticity: boolean,AngularPlasticityThreshold: number): void;
	SetAngularOrientationTarget(InPosTarget: Rotator): void;
	SetAngularOrientationDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean): void;
	SetAngularDriveParams(PositionStrength: number,VelocityStrength: number,InForceLimit: number): void;
	SetAngularDriveMode(DriveMode: EAngularDriveMode): void;
	SetAngularBreakable(bAngularBreakable: boolean,AngularBreakThreshold: number): void;
	IsBroken(): boolean;
	GetCurrentTwist(): number;
	GetCurrentSwing2(): number;
	GetCurrentSwing1(): number;
	GetConstraintForce(OutLinearForce?: Vector,OutAngularForce?: Vector): {OutLinearForce: Vector, OutAngularForce: Vector};
	GetConstraint(): ConstraintInstanceAccessor;
	GetConstrainedComponents(OutComponent1?: PrimitiveComponent,OutBoneName1?: string,OutComponent2?: PrimitiveComponent,OutBoneName2?: string): {OutComponent1: PrimitiveComponent, OutBoneName1: string, OutComponent2: PrimitiveComponent, OutBoneName2: string};
	BreakConstraint(): void;
	static C(Other: UObject | any): PhysicsConstraintComponent;
}

declare class PhysicsConstraintActor extends RigidBodyBase { 
	ConstraintComp: PhysicsConstraintComponent;
	ConstraintActor1: Actor;
	ConstraintActor2: Actor;
	bDisableCollision: boolean;
	static GetDefaultObject(): PhysicsConstraintActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsConstraintActor;
	static C(Other: UObject | any): PhysicsConstraintActor;
}

declare class PhysicsHandleComponent extends ActorComponent { 
	GrabbedComponent: PrimitiveComponent;
	bSoftAngularConstraint: boolean;
	bSoftLinearConstraint: boolean;
	bInterpolateTarget: boolean;
	LinearDamping: number;
	LinearStiffness: number;
	AngularDamping: number;
	AngularStiffness: number;
	InterpolationSpeed: number;
	static Load(ResourceName: string): PhysicsHandleComponent;
	static Find(Outer: UObject, ResourceName: string): PhysicsHandleComponent;
	static GetDefaultObject(): PhysicsHandleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsHandleComponent;
	SetTargetRotation(NewRotation: Rotator): void;
	SetTargetLocationAndRotation(NewLocation: Vector,NewRotation: Rotator): void;
	SetTargetLocation(NewLocation: Vector): void;
	SetLinearStiffness(NewLinearStiffness: number): void;
	SetLinearDamping(NewLinearDamping: number): void;
	SetInterpolationSpeed(NewInterpolationSpeed: number): void;
	SetAngularStiffness(NewAngularStiffness: number): void;
	SetAngularDamping(NewAngularDamping: number): void;
	ReleaseComponent(): void;
	GrabComponentAtLocationWithRotation(Component: PrimitiveComponent,InBoneName: string,Location: Vector,Rotation: Rotator): void;
	GrabComponentAtLocation(Component: PrimitiveComponent,InBoneName: string,GrabLocation: Vector): void;
	GrabComponent(Component: PrimitiveComponent,InBoneName: string,GrabLocation: Vector,bConstrainRotation: boolean): void;
	GetTargetLocationAndRotation(TargetLocation?: Vector,TargetRotation?: Rotator): {TargetLocation: Vector, TargetRotation: Rotator};
	GetGrabbedComponent(): PrimitiveComponent;
	static C(Other: UObject | any): PhysicsHandleComponent;
}

declare class RigidBodyErrorCorrection { 
	PingExtrapolation: number;
	PingLimit: number;
	ErrorPerLinearDifference: number;
	ErrorPerAngularDifference: number;
	MaxRestoredStateError: number;
	MaxLinearHardSnapDistance: number;
	PositionLerp: number;
	AngleLerp: number;
	LinearVelocityCoefficient: number;
	AngularVelocityCoefficient: number;
	ErrorAccumulationSeconds: number;
	ErrorAccumulationDistanceSq: number;
	ErrorAccumulationSimilarity: number;
	clone() : RigidBodyErrorCorrection;
	static C(Other: UObject | any): RigidBodyErrorCorrection;
}

declare type ESettingsLockedAxis = 'None' | 'X' | 'Y' | 'Z' | 'Invalid' | 'ESettingsLockedAxis_MAX';
declare var ESettingsLockedAxis : { None:'None',X:'X',Y:'Y',Z:'Z',Invalid:'Invalid',ESettingsLockedAxis_MAX:'ESettingsLockedAxis_MAX', };
declare type ESettingsDOF = 'Full3D' | 'YZPlane' | 'XZPlane' | 'XYPlane' | 'ESettingsDOF_MAX';
declare var ESettingsDOF : { Full3D:'Full3D',YZPlane:'YZPlane',XZPlane:'XZPlane',XYPlane:'XYPlane',ESettingsDOF_MAX:'ESettingsDOF_MAX', };
declare class PhysicalSurfaceName { 
	Type: EPhysicalSurface;
	Name: string;
	clone() : PhysicalSurfaceName;
	static C(Other: UObject | any): PhysicalSurfaceName;
}

declare type EChaosThreadingMode = 'DedicatedThread' | 'TaskGraph' | 'SingleThread' | 'Num' | 'Invalid' | 'EChaosThreadingMode_MAX';
declare var EChaosThreadingMode : { DedicatedThread:'DedicatedThread',TaskGraph:'TaskGraph',SingleThread:'SingleThread',Num:'Num',Invalid:'Invalid',EChaosThreadingMode_MAX:'EChaosThreadingMode_MAX', };
declare type EChaosSolverTickMode = 'Fixed' | 'Variable' | 'VariableCapped' | 'VariableCappedWithTarget' | 'EChaosSolverTickMode_MAX';
declare var EChaosSolverTickMode : { Fixed:'Fixed',Variable:'Variable',VariableCapped:'VariableCapped',VariableCappedWithTarget:'VariableCappedWithTarget',EChaosSolverTickMode_MAX:'EChaosSolverTickMode_MAX', };
declare type EChaosBufferMode = 'Double' | 'Triple' | 'Num' | 'Invalid' | 'EChaosBufferMode_MAX';
declare var EChaosBufferMode : { Double:'Double',Triple:'Triple',Num:'Num',Invalid:'Invalid',EChaosBufferMode_MAX:'EChaosBufferMode_MAX', };
declare class ChaosPhysicsSettings { 
	DefaultThreadingModel: EChaosThreadingMode;
	DedicatedThreadTickMode: EChaosSolverTickMode;
	DedicatedThreadBufferMode: EChaosBufferMode;
	clone() : ChaosPhysicsSettings;
	static C(Other: UObject | any): ChaosPhysicsSettings;
}

declare class PhysicsSettings extends PhysicsSettingsCore { 
	PhysicErrorCorrection: RigidBodyErrorCorrection;
	LockedAxis: ESettingsLockedAxis;
	DefaultDegreesOfFreedom: ESettingsDOF;
	bSuppressFaceRemapTable: boolean;
	bSupportUVFromHitResults: boolean;
	bDisableActiveActors: boolean;
	bDisableKinematicStaticPairs: boolean;
	bDisableKinematicKinematicPairs: boolean;
	bDisableCCD: boolean;
	bEnableEnhancedDeterminism: boolean;
	AnimPhysicsMinDeltaTime: number;
	bSimulateAnimPhysicsAfterReset: boolean;
	MinPhysicsDeltaTime: number;
	MaxPhysicsDeltaTime: number;
	bSubstepping: boolean;
	bSubsteppingAsync: boolean;
	bTickPhysicsAsync: boolean;
	AsyncFixedTimeStepSize: number;
	MaxSubstepDeltaTime: number;
	MaxSubsteps: number;
	SyncSceneSmoothingFactor: number;
	InitialAverageFrameRate: number;
	PhysXTreeRebuildRate: number;
	PhysicalSurfaces: PhysicalSurfaceName[];
	DefaultBroadphaseSettings: BroadphaseSettings;
	MinDeltaVelocityForHitEvents: number;
	ChaosSettings: ChaosPhysicsSettings;
	static Load(ResourceName: string): PhysicsSettings;
	static Find(Outer: UObject, ResourceName: string): PhysicsSettings;
	static GetDefaultObject(): PhysicsSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsSettings;
	static C(Other: UObject | any): PhysicsSettings;
}

declare class PhysicsSpringComponent extends SceneComponent { 
	SpringStiffness: number;
	SpringDamping: number;
	SpringLengthAtRest: number;
	SpringRadius: number;
	SpringChannel: ECollisionChannel;
	bIgnoreSelf: boolean;
	SpringCompression: number;
	static Load(ResourceName: string): PhysicsSpringComponent;
	static Find(Outer: UObject, ResourceName: string): PhysicsSpringComponent;
	static GetDefaultObject(): PhysicsSpringComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsSpringComponent;
	GetSpringRestingPoint(): Vector;
	GetSpringDirection(): Vector;
	GetSpringCurrentEndPoint(): Vector;
	GetNormalizedCompressionScalar(): number;
	static C(Other: UObject | any): PhysicsSpringComponent;
}

declare class PhysicsThrusterComponent extends SceneComponent { 
	ThrustStrength: number;
	static Load(ResourceName: string): PhysicsThrusterComponent;
	static Find(Outer: UObject, ResourceName: string): PhysicsThrusterComponent;
	static GetDefaultObject(): PhysicsThrusterComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsThrusterComponent;
	static C(Other: UObject | any): PhysicsThrusterComponent;
}

declare class PhysicsThruster extends RigidBodyBase { 
	ThrusterComponent: PhysicsThrusterComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): PhysicsThruster;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsThruster;
	static C(Other: UObject | any): PhysicsThruster;
}

declare class SceneCapture extends Actor { 
	MeshComp: StaticMeshComponent;
	SceneComponent: SceneComponent;
	static GetDefaultObject(): SceneCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCapture;
	static C(Other: UObject | any): SceneCapture;
}

declare type ESceneCapturePrimitiveRenderMode = 'PRM_LegacySceneCapture' | 'PRM_RenderScenePrimitives' | 'PRM_UseShowOnlyList' | 'PRM_MAX';
declare var ESceneCapturePrimitiveRenderMode : { PRM_LegacySceneCapture:'PRM_LegacySceneCapture',PRM_RenderScenePrimitives:'PRM_RenderScenePrimitives',PRM_UseShowOnlyList:'PRM_UseShowOnlyList',PRM_MAX:'PRM_MAX', };
declare type ESceneCaptureSource = 'SCS_SceneColorHDR' | 'SCS_SceneColorHDRNoAlpha' | 'SCS_FinalColorLDR' | 'SCS_SceneColorSceneDepth' | 'SCS_SceneDepth' | 'SCS_DeviceDepth' | 'SCS_Normal' | 'SCS_BaseColor' | 'SCS_FinalColorHDR' | 'SCS_FinalToneCurveHDR' | 'SCS_MAX';
declare var ESceneCaptureSource : { SCS_SceneColorHDR:'SCS_SceneColorHDR',SCS_SceneColorHDRNoAlpha:'SCS_SceneColorHDRNoAlpha',SCS_FinalColorLDR:'SCS_FinalColorLDR',SCS_SceneColorSceneDepth:'SCS_SceneColorSceneDepth',SCS_SceneDepth:'SCS_SceneDepth',SCS_DeviceDepth:'SCS_DeviceDepth',SCS_Normal:'SCS_Normal',SCS_BaseColor:'SCS_BaseColor',SCS_FinalColorHDR:'SCS_FinalColorHDR',SCS_FinalToneCurveHDR:'SCS_FinalToneCurveHDR',SCS_MAX:'SCS_MAX', };
declare class EngineShowFlagsSetting { 
	ShowFlagName: string;
	Enabled: boolean;
	clone() : EngineShowFlagsSetting;
	static C(Other: UObject | any): EngineShowFlagsSetting;
}

declare class SceneCaptureComponent extends SceneComponent { 
	PrimitiveRenderMode: ESceneCapturePrimitiveRenderMode;
	CaptureSource: ESceneCaptureSource;
	bCaptureEveryFrame: boolean;
	bCaptureOnMovement: boolean;
	bAlwaysPersistRenderingState: boolean;
	HiddenComponents: any[];
	HiddenActors: Actor[];
	ShowOnlyComponents: any[];
	ShowOnlyActors: Actor[];
	LODDistanceFactor: number;
	MaxViewDistanceOverride: number;
	CaptureSortPriority: number;
	bUseRayTracingIfEnabled: boolean;
	ShowFlagSettings: EngineShowFlagsSetting[];
	ProfilingEventName: string;
	CaptureMesh: StaticMesh;
	static Load(ResourceName: string): SceneCaptureComponent;
	static Find(Outer: UObject, ResourceName: string): SceneCaptureComponent;
	static GetDefaultObject(): SceneCaptureComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCaptureComponent;
	ShowOnlyComponent(InComponent: PrimitiveComponent): void;
	ShowOnlyActorComponents(InActor: Actor,bIncludeFromChildActors: boolean): void;
	SetCaptureSortPriority(NewCaptureSortPriority: number): void;
	RemoveShowOnlyComponent(InComponent: PrimitiveComponent): void;
	RemoveShowOnlyActorComponents(InActor: Actor,bIncludeFromChildActors: boolean): void;
	HideComponent(InComponent: PrimitiveComponent): void;
	HideActorComponents(InActor: Actor,bIncludeFromChildActors: boolean): void;
	ClearShowOnlyComponents(): void;
	ClearHiddenComponents(): void;
	static C(Other: UObject | any): SceneCaptureComponent;
}

declare class PlanarReflectionComponent extends SceneCaptureComponent { 
	PreviewBox: BoxComponent;
	NormalDistortionStrength: number;
	PrefilterRoughness: number;
	PrefilterRoughnessDistance: number;
	ScreenPercentage: number;
	ExtraFOV: number;
	DistanceFromPlaneFadeStart: number;
	DistanceFromPlaneFadeEnd: number;
	DistanceFromPlaneFadeoutStart: number;
	DistanceFromPlaneFadeoutEnd: number;
	AngleFromPlaneFadeStart: number;
	AngleFromPlaneFadeEnd: number;
	bShowPreviewPlane: boolean;
	bRenderSceneTwoSided: boolean;
	CaptureMaterial: Material;
	static Load(ResourceName: string): PlanarReflectionComponent;
	static Find(Outer: UObject, ResourceName: string): PlanarReflectionComponent;
	static GetDefaultObject(): PlanarReflectionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlanarReflectionComponent;
	static C(Other: UObject | any): PlanarReflectionComponent;
}

declare class PlanarReflection extends SceneCapture { 
	PlanarReflectionComponent: PlanarReflectionComponent;
	SpriteComponent: BillboardComponent;
	bShowPreviewPlane: boolean;
	static GetDefaultObject(): PlanarReflection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlanarReflection;
	OnInterpToggle(bEnable: boolean): void;
	static C(Other: UObject | any): PlanarReflection;
}

declare class PlaneReflectionCapture extends ReflectionCapture { 
	static GetDefaultObject(): PlaneReflectionCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneReflectionCapture;
	static C(Other: UObject | any): PlaneReflectionCapture;
}

declare class PlaneReflectionCaptureComponent extends ReflectionCaptureComponent { 
	InfluenceRadiusScale: number;
	PreviewInfluenceRadius: DrawSphereComponent;
	PreviewCaptureBox: BoxComponent;
	static Load(ResourceName: string): PlaneReflectionCaptureComponent;
	static Find(Outer: UObject, ResourceName: string): PlaneReflectionCaptureComponent;
	static GetDefaultObject(): PlaneReflectionCaptureComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneReflectionCaptureComponent;
	static C(Other: UObject | any): PlaneReflectionCaptureComponent;
}

declare class PlatformEventsComponent extends ActorComponent { 
	PlatformChangedToLaptopModeDelegate: UnrealEngineMulticastDelegate<() => void>;
	PlatformChangedToTabletModeDelegate: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): PlatformEventsComponent;
	static Find(Outer: UObject, ResourceName: string): PlatformEventsComponent;
	static GetDefaultObject(): PlatformEventsComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformEventsComponent;
	SupportsConvertibleLaptops(): boolean;
	IsInTabletMode(): boolean;
	IsInLaptopMode(): boolean;
	static C(Other: UObject | any): PlatformEventsComponent;
}

declare class PlatformInterfaceWebResponse extends UObject { 
	OriginalURL: string;
	ResponseCode: number;
	Tag: number;
	StringResponse: string;
	BinaryResponse: number[];
	static Load(ResourceName: string): PlatformInterfaceWebResponse;
	static Find(Outer: UObject, ResourceName: string): PlatformInterfaceWebResponse;
	static GetDefaultObject(): PlatformInterfaceWebResponse;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformInterfaceWebResponse;
	GetNumHeaders(): number;
	GetHeaderValue(HeaderName: string): string;
	GetHeader(HeaderIndex: number,Header?: string,Value?: string): {Header: string, Value: string};
	static C(Other: UObject | any): PlatformInterfaceWebResponse;
}

declare class PlayerStart extends NavigationObjectBase { 
	PlayerStartTag: string;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): PlayerStart;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerStart;
	static C(Other: UObject | any): PlayerStart;
}

declare class PlayerStartPIE extends PlayerStart { 
	static GetDefaultObject(): PlayerStartPIE;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerStartPIE;
	static C(Other: UObject | any): PlayerStartPIE;
}

declare class PluginCommandlet extends Commandlet { 
	static Load(ResourceName: string): PluginCommandlet;
	static Find(Outer: UObject, ResourceName: string): PluginCommandlet;
	static GetDefaultObject(): PluginCommandlet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PluginCommandlet;
	static C(Other: UObject | any): PluginCommandlet;
}

declare class PointLight extends Light { 
	PointLightComponent: PointLightComponent;
	static GetDefaultObject(): PointLight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PointLight;
	SetRadius(NewRadius: number): void;
	SetLightFalloffExponent(NewLightFalloffExponent: number): void;
	static C(Other: UObject | any): PointLight;
}

declare class Polys extends UObject { 
	static Load(ResourceName: string): Polys;
	static Find(Outer: UObject, ResourceName: string): Polys;
	static GetDefaultObject(): Polys;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Polys;
	static C(Other: UObject | any): Polys;
}

declare type EBoneSpaces = 'WorldSpace' | 'ComponentSpace' | 'EBoneSpaces_MAX';
declare var EBoneSpaces : { WorldSpace:'WorldSpace',ComponentSpace:'ComponentSpace',EBoneSpaces_MAX:'EBoneSpaces_MAX', };
declare class PoseableMeshComponent extends SkinnedMeshComponent { 
	static Load(ResourceName: string): PoseableMeshComponent;
	static Find(Outer: UObject, ResourceName: string): PoseableMeshComponent;
	static GetDefaultObject(): PoseableMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PoseableMeshComponent;
	SetBoneTransformByName(BoneName: string,InTransform: Transform,BoneSpace: EBoneSpaces): void;
	SetBoneScaleByName(BoneName: string,InScale3D: Vector,BoneSpace: EBoneSpaces): void;
	SetBoneRotationByName(BoneName: string,InRotation: Rotator,BoneSpace: EBoneSpaces): void;
	SetBoneLocationByName(BoneName: string,InLocation: Vector,BoneSpace: EBoneSpaces): void;
	ResetBoneTransformByName(BoneName: string): void;
	GetBoneTransformByName(BoneName: string,BoneSpace: EBoneSpaces): Transform;
	GetBoneScaleByName(BoneName: string,BoneSpace: EBoneSpaces): Vector;
	GetBoneRotationByName(BoneName: string,BoneSpace: EBoneSpaces): Rotator;
	GetBoneLocationByName(BoneName: string,BoneSpace: EBoneSpaces): Vector;
	CopyPoseFromSkeletalComponent(InComponentToCopy: SkeletalMeshComponent): void;
	static C(Other: UObject | any): PoseableMeshComponent;
}

declare class PostProcessVolume extends Volume { 
	Settings: PostProcessSettings;
	Priority: number;
	BlendRadius: number;
	BlendWeight: number;
	bEnabled: boolean;
	bUnbound: boolean;
	static GetDefaultObject(): PostProcessVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PostProcessVolume;
	static C(Other: UObject | any): PostProcessVolume;
}

declare class PrecomputedVisibilityOverrideVolume extends Volume { 
	OverrideVisibleActors: Actor[];
	OverrideInvisibleActors: Actor[];
	OverrideInvisibleLevels: string[];
	static GetDefaultObject(): PrecomputedVisibilityOverrideVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrecomputedVisibilityOverrideVolume;
	static C(Other: UObject | any): PrecomputedVisibilityOverrideVolume;
}

declare class PrecomputedVisibilityVolume extends Volume { 
	static GetDefaultObject(): PrecomputedVisibilityVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrecomputedVisibilityVolume;
	static C(Other: UObject | any): PrecomputedVisibilityVolume;
}

declare class PreviewCollectionInterface extends Interface { 
	static Load(ResourceName: string): PreviewCollectionInterface;
	static Find(Outer: UObject, ResourceName: string): PreviewCollectionInterface;
	static GetDefaultObject(): PreviewCollectionInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PreviewCollectionInterface;
	static C(Other: UObject | any): PreviewCollectionInterface;
}

declare class PreviewMeshCollectionEntry { 
	SkeletalMesh: SkeletalMesh;
	clone() : PreviewMeshCollectionEntry;
	static C(Other: UObject | any): PreviewMeshCollectionEntry;
}

declare class PreviewMeshCollection extends DataAsset { 
	Skeleton: Skeleton;
	SkeletalMeshes: PreviewMeshCollectionEntry[];
	static Load(ResourceName: string): PreviewMeshCollection;
	static Find(Outer: UObject, ResourceName: string): PreviewMeshCollection;
	static GetDefaultObject(): PreviewMeshCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PreviewMeshCollection;
	static C(Other: UObject | any): PreviewMeshCollection;
}

declare class CollectionReference { 
	CollectionName: string;
	clone() : CollectionReference;
	static C(Other: UObject | any): CollectionReference;
}

declare class PrimaryAssetLabel extends PrimaryDataAsset { 
	Rules: PrimaryAssetRules;
	bLabelAssetsInMyDirectory: boolean;
	bIsRuntimeLabel: boolean;
	ExplicitAssets: UObject[];
	ExplicitBlueprints: Class[];
	AssetCollection: CollectionReference;
	static Load(ResourceName: string): PrimaryAssetLabel;
	static Find(Outer: UObject, ResourceName: string): PrimaryAssetLabel;
	static GetDefaultObject(): PrimaryAssetLabel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimaryAssetLabel;
	static C(Other: UObject | any): PrimaryAssetLabel;
}

declare class ProjectileMovementComponent extends MovementComponent { 
	InitialSpeed: number;
	MaxSpeed: number;
	bRotationFollowsVelocity: boolean;
	bRotationRemainsVertical: boolean;
	bShouldBounce: boolean;
	bInitialVelocityInLocalSpace: boolean;
	bForceSubStepping: boolean;
	bSimulationEnabled: boolean;
	bSweepCollision: boolean;
	bIsHomingProjectile: boolean;
	bBounceAngleAffectsFriction: boolean;
	bIsSliding: boolean;
	bInterpMovement: boolean;
	bInterpRotation: boolean;
	PreviousHitTime: number;
	PreviousHitNormal: Vector;
	ProjectileGravityScale: number;
	Buoyancy: number;
	Bounciness: number;
	Friction: number;
	BounceVelocityStopSimulatingThreshold: number;
	MinFrictionFraction: number;
	OnProjectileBounce: UnrealEngineMulticastDelegate<(ImpactResult: HitResult, ImpactVelocity: Vector) => void>;
	OnProjectileStop: UnrealEngineMulticastDelegate<(ImpactResult: HitResult) => void>;
	HomingAccelerationMagnitude: number;
	HomingTargetComponent: any;
	MaxSimulationTimeStep: number;
	MaxSimulationIterations: number;
	BounceAdditionalIterations: number;
	InterpLocationTime: number;
	InterpRotationTime: number;
	InterpLocationMaxLagDistance: number;
	InterpLocationSnapToTargetDistance: number;
	static Load(ResourceName: string): ProjectileMovementComponent;
	static Find(Outer: UObject, ResourceName: string): ProjectileMovementComponent;
	static GetDefaultObject(): ProjectileMovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProjectileMovementComponent;
	StopSimulating(HitResult: HitResult): void;
	SetVelocityInLocalSpace(NewVelocity: Vector): void;
	SetInterpolatedComponent(Component: SceneComponent): void;
	ResetInterpolation(): void;
	MoveInterpolationTarget(NewLocation: Vector,NewRotation: Rotator): void;
	LimitVelocity(NewVelocity: Vector): Vector;
	IsVelocityUnderSimulationThreshold(): boolean;
	IsInterpolationComplete(): boolean;
	static C(Other: UObject | any): ProjectileMovementComponent;
}

declare class ProxyLODMeshSimplificationSettings extends DeveloperSettings { 
	ProxyLODMeshReductionModuleName: string;
	static Load(ResourceName: string): ProxyLODMeshSimplificationSettings;
	static Find(Outer: UObject, ResourceName: string): ProxyLODMeshSimplificationSettings;
	static GetDefaultObject(): ProxyLODMeshSimplificationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProxyLODMeshSimplificationSettings;
	static C(Other: UObject | any): ProxyLODMeshSimplificationSettings;
}

declare class RadialForceComponent extends SceneComponent { 
	Radius: number;
	Falloff: ERadialImpulseFalloff;
	ImpulseStrength: number;
	bImpulseVelChange: boolean;
	bIgnoreOwningActor: boolean;
	ForceStrength: number;
	DestructibleDamage: number;
	ObjectTypesToAffect: EObjectTypeQuery[];
	static Load(ResourceName: string): RadialForceComponent;
	static Find(Outer: UObject, ResourceName: string): RadialForceComponent;
	static GetDefaultObject(): RadialForceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialForceComponent;
	RemoveObjectTypeToAffect(ObjectType: EObjectTypeQuery): void;
	FireImpulse(): void;
	AddObjectTypeToAffect(ObjectType: EObjectTypeQuery): void;
	static C(Other: UObject | any): RadialForceComponent;
}

declare class RadialForceActor extends RigidBodyBase { 
	ForceComponent: RadialForceComponent;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): RadialForceActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialForceActor;
	ToggleForce(): void;
	FireImpulse(): void;
	EnableForce(): void;
	DisableForce(): void;
	static C(Other: UObject | any): RadialForceActor;
}

declare class RectLightComponent extends LocalLightComponent { 
	SourceWidth: number;
	SourceHeight: number;
	BarnDoorAngle: number;
	BarnDoorLength: number;
	SourceTexture: Texture;
	static Load(ResourceName: string): RectLightComponent;
	static Find(Outer: UObject, ResourceName: string): RectLightComponent;
	static GetDefaultObject(): RectLightComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RectLightComponent;
	SetSourceWidth(bNewValue: number): void;
	SetSourceTexture(bNewValue: Texture): void;
	SetSourceHeight(NewValue: number): void;
	SetBarnDoorLength(NewValue: number): void;
	SetBarnDoorAngle(NewValue: number): void;
	static C(Other: UObject | any): RectLightComponent;
}

declare class RectLight extends Light { 
	RectLightComponent: RectLightComponent;
	static GetDefaultObject(): RectLight;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RectLight;
	static C(Other: UObject | any): RectLight;
}

declare type EMobileAntiAliasingMethod = 'None' | 'FXAA' | 'TemporalAA' | 'MSAA' | 'EMobileAntiAliasingMethod_MAX';
declare var EMobileAntiAliasingMethod : { None:'None',FXAA:'FXAA',TemporalAA:'TemporalAA',MSAA:'MSAA',EMobileAntiAliasingMethod_MAX:'EMobileAntiAliasingMethod_MAX', };
declare type EMobileFloatPrecisionMode = 'Half' | 'Full_MaterialExpressionOnly' | 'Full' | 'EMobileFloatPrecisionMode_MAX';
declare var EMobileFloatPrecisionMode : { Half:'Half',Full_MaterialExpressionOnly:'Full_MaterialExpressionOnly',Full:'Full',EMobileFloatPrecisionMode_MAX:'EMobileFloatPrecisionMode_MAX', };
declare type EShaderCompressionFormat = 'None' | 'LZ4' | 'Oodle' | 'Zlib' | 'EShaderCompressionFormat_MAX';
declare var EShaderCompressionFormat : { None:'None',LZ4:'LZ4',Oodle:'Oodle',Zlib:'Zlib',EShaderCompressionFormat_MAX:'EShaderCompressionFormat_MAX', };
declare type EWorkingColorSpace = 'sRGB' | 'Rec2020' | 'ACESAP0' | 'ACESAP1' | 'P3DCI' | 'P3D65' | 'Custom' | 'EWorkingColorSpace_MAX';
declare var EWorkingColorSpace : { sRGB:'sRGB',Rec2020:'Rec2020',ACESAP0:'ACESAP0',ACESAP1:'ACESAP1',P3DCI:'P3DCI',P3D65:'P3D65',Custom:'Custom',EWorkingColorSpace_MAX:'EWorkingColorSpace_MAX', };
declare type ELumenRayLightingMode = 'SurfaceCache' | 'HitLighting' | 'ELumenRayLightingMode_MAX';
declare var ELumenRayLightingMode : { SurfaceCache:'SurfaceCache',HitLighting:'HitLighting',ELumenRayLightingMode_MAX:'ELumenRayLightingMode_MAX', };
declare type ELumenSoftwareTracingMode = 'DetailTracing' | 'GlobalTracing' | 'ELumenSoftwareTracingMode_MAX';
declare var ELumenSoftwareTracingMode : { DetailTracing:'DetailTracing',GlobalTracing:'GlobalTracing',ELumenSoftwareTracingMode_MAX:'ELumenSoftwareTracingMode_MAX', };
declare type EShadowMapMethod = 'ShadowMaps' | 'VirtualShadowMaps' | 'EShadowMapMethod_MAX';
declare var EShadowMapMethod : { ShadowMaps:'ShadowMaps',VirtualShadowMaps:'VirtualShadowMaps',EShadowMapMethod_MAX:'EShadowMapMethod_MAX', };
declare type ETranslucentSortPolicy = 'SortByDistance' | 'SortByProjectedZ' | 'SortAlongAxis' | 'ETranslucentSortPolicy_MAX';
declare var ETranslucentSortPolicy : { SortByDistance:'SortByDistance',SortByProjectedZ:'SortByProjectedZ',SortAlongAxis:'SortAlongAxis',ETranslucentSortPolicy_MAX:'ETranslucentSortPolicy_MAX', };
declare type EFixedFoveationLevels = 'Disabled' | 'Low' | 'Medium' | 'High' | 'HighTop' | 'EFixedFoveationLevels_MAX';
declare var EFixedFoveationLevels : { Disabled:'Disabled',Low:'Low',Medium:'Medium',High:'High',HighTop:'HighTop',EFixedFoveationLevels_MAX:'EFixedFoveationLevels_MAX', };
declare type ECustomDepthStencil = 'Disabled' | 'Enabled' | 'EnabledOnDemand' | 'EnabledWithStencil' | 'ECustomDepthStencil_MAX';
declare var ECustomDepthStencil : { Disabled:'Disabled',Enabled:'Enabled',EnabledOnDemand:'EnabledOnDemand',EnabledWithStencil:'EnabledWithStencil',ECustomDepthStencil_MAX:'ECustomDepthStencil_MAX', };
declare type EAlphaChannelMode = 'Disabled' | 'LinearColorSpaceOnly' | 'AllowThroughTonemapper' | 'EAlphaChannelMode_MAX';
declare var EAlphaChannelMode : { Disabled:'Disabled',LinearColorSpaceOnly:'LinearColorSpaceOnly',AllowThroughTonemapper:'AllowThroughTonemapper',EAlphaChannelMode_MAX:'EAlphaChannelMode_MAX', };
declare type EAutoExposureMethodUI = 'AEM_Histogram' | 'AEM_Basic' | 'AEM_Manual' | 'AEM_MAX';
declare var EAutoExposureMethodUI : { AEM_Histogram:'AEM_Histogram',AEM_Basic:'AEM_Basic',AEM_Manual:'AEM_Manual',AEM_MAX:'AEM_MAX', };
declare type EAntiAliasingMethod = 'AAM_None' | 'AAM_FXAA' | 'AAM_TemporalAA' | 'AAM_MSAA' | 'AAM_TSR' | 'AAM_MAX';
declare var EAntiAliasingMethod : { AAM_None:'AAM_None',AAM_FXAA:'AAM_FXAA',AAM_TemporalAA:'AAM_TemporalAA',AAM_MSAA:'AAM_MSAA',AAM_TSR:'AAM_TSR',AAM_MAX:'AAM_MAX', };
declare type ECompositingSampleCount = 'One' | 'Two' | 'Four' | 'Eight' | 'ECompositingSampleCount_MAX';
declare var ECompositingSampleCount : { One:'One',Two:'Two',Four:'Four',Eight:'Eight',ECompositingSampleCount_MAX:'ECompositingSampleCount_MAX', };
declare type EDefaultBackBufferPixelFormat = 'DBBPF_B8G8R8A8' | 'DBBPF_A16B16G16R16_DEPRECATED' | 'DBBPF_FloatRGB_DEPRECATED' | 'DBBPF_FloatRGBA' | 'DBBPF_A2B10G10R10' | 'DBBPF_MAX';
declare var EDefaultBackBufferPixelFormat : { DBBPF_B8G8R8A8:'DBBPF_B8G8R8A8',DBBPF_A16B16G16R16_DEPRECATED:'DBBPF_A16B16G16R16_DEPRECATED',DBBPF_FloatRGB_DEPRECATED:'DBBPF_FloatRGB_DEPRECATED',DBBPF_FloatRGBA:'DBBPF_FloatRGBA',DBBPF_A2B10G10R10:'DBBPF_A2B10G10R10',DBBPF_MAX:'DBBPF_MAX', };
declare type EEarlyZPass = 'None' | 'OpaqueOnly' | 'OpaqueAndMasked' | 'Auto' | 'EEarlyZPass_MAX';
declare var EEarlyZPass : { None:'None',OpaqueOnly:'OpaqueOnly',OpaqueAndMasked:'OpaqueAndMasked',Auto:'Auto',EEarlyZPass_MAX:'EEarlyZPass_MAX', };
declare type EClearSceneOptions = 'NoClear' | 'HardwareClear' | 'QuadAtMaxZ' | 'EClearSceneOptions_MAX';
declare var EClearSceneOptions : { NoClear:'NoClear',HardwareClear:'HardwareClear',QuadAtMaxZ:'QuadAtMaxZ',EClearSceneOptions_MAX:'EClearSceneOptions_MAX', };
declare type EVelocityOutputPass = 'DepthPass' | 'BasePass' | 'AfterBasePass' | 'EVelocityOutputPass_MAX';
declare var EVelocityOutputPass : { DepthPass:'DepthPass',BasePass:'BasePass',AfterBasePass:'AfterBasePass',EVelocityOutputPass_MAX:'EVelocityOutputPass_MAX', };
declare type EVertexDeformationOutputsVelocity = 'Off' | 'On' | 'Auto' | 'EVertexDeformationOutputsVelocity_MAX';
declare var EVertexDeformationOutputsVelocity : { Off:'Off',On:'On',Auto:'Auto',EVertexDeformationOutputsVelocity_MAX:'EVertexDeformationOutputsVelocity_MAX', };
declare type EGBufferFormat = 'Force8BitsPerChannel' | 'Default' | 'HighPrecisionNormals' | 'Force16BitsPerChannel' | 'EGBufferFormat_MAX';
declare var EGBufferFormat : { Force8BitsPerChannel:'Force8BitsPerChannel',Default:'Default',HighPrecisionNormals:'HighPrecisionNormals',Force16BitsPerChannel:'Force16BitsPerChannel',EGBufferFormat_MAX:'EGBufferFormat_MAX', };
declare type ESkinCacheDefaultBehavior = 'Exclusive' | 'Inclusive' | 'ESkinCacheDefaultBehavior_MAX';
declare var ESkinCacheDefaultBehavior : { Exclusive:'Exclusive',Inclusive:'Inclusive',ESkinCacheDefaultBehavior_MAX:'ESkinCacheDefaultBehavior_MAX', };
declare type EMobilePlanarReflectionMode = 'Usual' | 'MobilePPRExclusive' | 'MobilePPR' | 'EMobilePlanarReflectionMode_MAX';
declare var EMobilePlanarReflectionMode : { Usual:'Usual',MobilePPRExclusive:'MobilePPRExclusive',MobilePPR:'MobilePPR',EMobilePlanarReflectionMode_MAX:'EMobilePlanarReflectionMode_MAX', };
declare class RendererSettings extends DeveloperSettings { 
	bMobileDisableVertexFog: boolean;
	MaxMobileCascades: number;
	MobileAntiAliasing: EMobileAntiAliasingMethod;
	MobileFloatPrecisionMode: EMobileFloatPrecisionMode;
	bMobileAllowDitheredLODTransition: boolean;
	bMobileVirtualTextures: boolean;
	bReflectionCaptureCompression: boolean;
	bDiscardUnusedQualityLevels: boolean;
	ShaderCompressionFormat: EShaderCompressionFormat;
	bOcclusionCulling: boolean;
	MinScreenRadiusForLights: number;
	MinScreenRadiusForEarlyZPass: number;
	MinScreenRadiusForCSMdepth: number;
	bPrecomputedVisibilityWarning: boolean;
	bTextureStreaming: boolean;
	bUseDXT5NormalMaps: boolean;
	bVirtualTextures: boolean;
	bVirtualTextureEnableAutoImport: boolean;
	bVirtualTexturedLightmaps: boolean;
	bVirtualTextureAnisotropicFiltering: boolean;
	VirtualTextureTileSize: any;
	VirtualTextureTileBorderSize: any;
	VirtualTextureFeedbackFactor: any;
	WorkingColorSpaceChoice: EWorkingColorSpace;
	RedChromaticityCoordinate: Vector2D;
	GreenChromaticityCoordinate: Vector2D;
	BlueChromaticityCoordinate: Vector2D;
	WhiteChromaticityCoordinate: Vector2D;
	bClearCoatEnableSecondNormal: boolean;
	DynamicGlobalIllumination: EDynamicGlobalIlluminationMethod;
	Reflections: EReflectionMethod;
	ReflectionCaptureResolution: number;
	ReflectionEnvironmentLightmapMixBasedOnRoughness: boolean;
	bUseHardwareRayTracingForLumen: boolean;
	LumenRayLightingMode: ELumenRayLightingMode;
	LumenSoftwareTracingMode: ELumenSoftwareTracingMode;
	ShadowMapMethod: EShadowMapMethod;
	bEnableRayTracing: boolean;
	bEnableRayTracingShadows: boolean;
	bEnableRayTracingSkylight: boolean;
	bEnableRayTracingTextureLOD: boolean;
	bEnablePathTracing: boolean;
	bGenerateMeshDistanceFields: boolean;
	DistanceFieldVoxelDensity: number;
	bAllowStaticLighting: boolean;
	bUseNormalMapsForStaticLighting: boolean;
	bForwardShading: boolean;
	bVertexFoggingForOpaque: boolean;
	bSeparateTranslucency: boolean;
	TranslucentSortPolicy: ETranslucentSortPolicy;
	TranslucentSortAxis: Vector;
	HMDFixedFoveationLevel: EFixedFoveationLevels;
	bHMDFixedFoveationDynamic: boolean;
	CustomDepthStencil: ECustomDepthStencil;
	bCustomDepthTaaJitter: boolean;
	bEnableAlphaChannelInPostProcessing: EAlphaChannelMode;
	bDefaultFeatureBloom: boolean;
	bDefaultFeatureAmbientOcclusion: boolean;
	bDefaultFeatureAmbientOcclusionStaticFraction: boolean;
	bDefaultFeatureAutoExposure: boolean;
	DefaultFeatureAutoExposure: EAutoExposureMethodUI;
	DefaultFeatureAutoExposureBias: number;
	bExtendDefaultLuminanceRangeInAutoExposureSettings: boolean;
	bDefaultFeatureMotionBlur: boolean;
	bDefaultFeatureLensFlare: boolean;
	bTemporalUpsampling: boolean;
	DefaultFeatureAntiAliasing: EAntiAliasingMethod;
	MSAASampleCount: ECompositingSampleCount;
	DefaultLightUnits: ELightUnits;
	DefaultBackBufferPixelFormat: EDefaultBackBufferPixelFormat;
	bRenderUnbuiltPreviewShadowsInGame: boolean;
	bStencilForLODDither: boolean;
	EarlyZPass: EEarlyZPass;
	bEarlyZPassOnlyMaterialMasking: boolean;
	bEnableCSMCaching: boolean;
	bDBuffer: boolean;
	ClearSceneMethod: EClearSceneOptions;
	VelocityPass: EVelocityOutputPass;
	VertexDeformationOutputsVelocity: EVertexDeformationOutputsVelocity;
	bSelectiveBasePassOutputs: boolean;
	bDefaultParticleCutouts: boolean;
	GPUSimulationTextureSizeX: number;
	GPUSimulationTextureSizeY: number;
	bGlobalClipPlane: boolean;
	GBufferFormat: EGBufferFormat;
	bUseGPUMorphTargets: boolean;
	bNvidiaAftermathEnabled: boolean;
	bMultiView: boolean;
	bMobilePostProcessing: boolean;
	bMobileMultiView: boolean;
	bMobileUseHWsRGBEncoding: boolean;
	bRoundRobinOcclusion: boolean;
	bODSCapture: boolean;
	bMeshStreaming: boolean;
	WireframeCullThreshold: number;
	bSupportStationarySkylight: boolean;
	bSupportLowQualityLightmaps: boolean;
	bSupportPointLightWholeSceneShadows: boolean;
	bSupportSkyAtmosphere: boolean;
	bSupportSkyAtmosphereAffectsHeightFog: boolean;
	bSupportCloudShadowOnForwardLitTranslucent: boolean;
	bMaterialRoughDiffuse: boolean;
	bMaterialEnergyConservation: boolean;
	bSupportSkinCacheShaders: boolean;
	DefaultSkinCacheBehavior: ESkinCacheDefaultBehavior;
	SkinCacheSceneMemoryLimitInMB: number;
	bMobileEnableStaticAndCSMShadowReceivers: boolean;
	bMobileEnableMovableLightCSMShaderCulling: boolean;
	bMobileEnableNoPrecomputedLightingCSMShader: boolean;
	bMobileAllowDistanceFieldShadows: boolean;
	bMobileAllowMovableDirectionalLights: boolean;
	MobileNumDynamicPointLights: any;
	bMobileAllowMovableSpotlights: boolean;
	bMobileAllowMovableSpotlightShadows: boolean;
	bSupport16BitBoneIndex: boolean;
	bGPUSkinLimit2BoneInfluences: boolean;
	bSupportDepthOnlyIndexBuffers: boolean;
	bSupportReversedIndexBuffers: boolean;
	bMobileAmbientOcclusion: boolean;
	bUseUnlimitedBoneInfluences: boolean;
	UnlimitedBonInfluencesThreshold: number;
	MaxSkinBones: PerPlatformInt;
	MobilePlanarReflectionMode: EMobilePlanarReflectionMode;
	bMobileSupportsGen4TAA: boolean;
	bStreamSkeletalMeshLODs: PerPlatformBool;
	bDiscardSkeletalMeshOptionalLODs: PerPlatformBool;
	VisualizeCalibrationColorMaterialPath: SoftObjectPath;
	VisualizeCalibrationCustomMaterialPath: SoftObjectPath;
	VisualizeCalibrationGrayscaleMaterialPath: SoftObjectPath;
	static Load(ResourceName: string): RendererSettings;
	static Find(Outer: UObject, ResourceName: string): RendererSettings;
	static GetDefaultObject(): RendererSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RendererSettings;
	static C(Other: UObject | any): RendererSettings;
}

declare class RendererOverrideSettings extends DeveloperSettings { 
	bSupportAllShaderPermutations: boolean;
	static Load(ResourceName: string): RendererOverrideSettings;
	static Find(Outer: UObject, ResourceName: string): RendererOverrideSettings;
	static GetDefaultObject(): RendererOverrideSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RendererOverrideSettings;
	static C(Other: UObject | any): RendererOverrideSettings;
}

declare class ReplayNetConnection extends NetConnection { 
	static Load(ResourceName: string): ReplayNetConnection;
	static Find(Outer: UObject, ResourceName: string): ReplayNetConnection;
	static GetDefaultObject(): ReplayNetConnection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReplayNetConnection;
	static C(Other: UObject | any): ReplayNetConnection;
}

declare class ReplaySubsystem extends GameInstanceSubsystem { 
	bLoadDefaultMapOnStop: boolean;
	static Load(ResourceName: string): ReplaySubsystem;
	static Find(Outer: UObject, ResourceName: string): ReplaySubsystem;
	static GetDefaultObject(): ReplaySubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReplaySubsystem;
	RequestCheckpoint(): void;
	IsRecording(): boolean;
	IsPlaying(): boolean;
	GetReplayCurrentTime(): number;
	GetActiveReplayName(): string;
	static C(Other: UObject | any): ReplaySubsystem;
}

declare class ReplicationConnectionDriver extends UObject { 
	static Load(ResourceName: string): ReplicationConnectionDriver;
	static Find(Outer: UObject, ResourceName: string): ReplicationConnectionDriver;
	static GetDefaultObject(): ReplicationConnectionDriver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReplicationConnectionDriver;
	static C(Other: UObject | any): ReplicationConnectionDriver;
}

declare class RotatingMovementComponent extends MovementComponent { 
	RotationRate: Rotator;
	PivotTranslation: Vector;
	bRotationInLocalSpace: boolean;
	static Load(ResourceName: string): RotatingMovementComponent;
	static Find(Outer: UObject, ResourceName: string): RotatingMovementComponent;
	static GetDefaultObject(): RotatingMovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RotatingMovementComponent;
	static C(Other: UObject | any): RotatingMovementComponent;
}

declare class RPCAnalyticsThreshold { 
	RPC: string;
	CountPerSec: number;
	TimePerSec: any;
	clone() : RPCAnalyticsThreshold;
	static C(Other: UObject | any): RPCAnalyticsThreshold;
}

declare class RPCDoSDetectionConfig extends UObject { 
	bRPCDoSDetection: boolean;
	bRPCDoSAnalytics: boolean;
	HitchTimeQuotaMS: number;
	HitchSuspendDetectionTimeMS: number;
	DetectionSeverity: string[];
	InitialConnectToleranceMS: number;
	RPCBlockWhitelist: string[];
	RPCAnalyticsThresholds: RPCAnalyticsThreshold[];
	RPCAnalyticsOverrideChance: any;
	static Load(ResourceName: string): RPCDoSDetectionConfig;
	static Find(Outer: UObject, ResourceName: string): RPCDoSDetectionConfig;
	static GetDefaultObject(): RPCDoSDetectionConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RPCDoSDetectionConfig;
	static C(Other: UObject | any): RPCDoSDetectionConfig;
}

declare class RuntimeOptionsBase extends UObject { 
	static Load(ResourceName: string): RuntimeOptionsBase;
	static Find(Outer: UObject, ResourceName: string): RuntimeOptionsBase;
	static GetDefaultObject(): RuntimeOptionsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeOptionsBase;
	static C(Other: UObject | any): RuntimeOptionsBase;
}

declare class VirtualTextureBuildSettings { 
	TileSize: number;
	TileBorderSize: number;
	bEnableCompressCrunch: boolean;
	bEnableCompressZlib: boolean;
	clone() : VirtualTextureBuildSettings;
	static C(Other: UObject | any): VirtualTextureBuildSettings;
}

declare class VirtualTexture2D extends Texture2D { 
	Settings: VirtualTextureBuildSettings;
	bContinuousUpdate: boolean;
	bSinglePhysicalSpace: boolean;
	static Load(ResourceName: string): VirtualTexture2D;
	static Find(Outer: UObject, ResourceName: string): VirtualTexture2D;
	static GetDefaultObject(): VirtualTexture2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualTexture2D;
	static C(Other: UObject | any): VirtualTexture2D;
}

declare class VirtualTextureBuilder extends UObject { 
	Texture: VirtualTexture2D;
	BuildHash: any;
	static Load(ResourceName: string): VirtualTextureBuilder;
	static Find(Outer: UObject, ResourceName: string): VirtualTextureBuilder;
	static GetDefaultObject(): VirtualTextureBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualTextureBuilder;
	static C(Other: UObject | any): VirtualTextureBuilder;
}

declare class RuntimeVirtualTextureComponent extends SceneComponent { 
	BoundsAlignActor: Actor;
	bSetBoundsButton: boolean;
	bSnapBoundsToLandscape: boolean;
	VirtualTexture: RuntimeVirtualTexture;
	bEnableScalability: boolean;
	ScalabilityGroup: any;
	bHidePrimitives: boolean;
	StreamingTexture: VirtualTextureBuilder;
	StreamLowMips: number;
	bBuildStreamingMipsButton: boolean;
	bUseStreamingLowMipsInEditor: boolean;
	bEnableCompressCrunch: boolean;
	bBuildDebugStreamingMips: boolean;
	static Load(ResourceName: string): RuntimeVirtualTextureComponent;
	static Find(Outer: UObject, ResourceName: string): RuntimeVirtualTextureComponent;
	static GetDefaultObject(): RuntimeVirtualTextureComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeVirtualTextureComponent;
	Invalidate(WorldBounds: BoxSphereBounds): void;
	static C(Other: UObject | any): RuntimeVirtualTextureComponent;
}

declare class RuntimeVirtualTextureVolume extends Actor { 
	VirtualTextureComponent: RuntimeVirtualTextureComponent;
	Box: BoxComponent;
	static GetDefaultObject(): RuntimeVirtualTextureVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeVirtualTextureVolume;
	static C(Other: UObject | any): RuntimeVirtualTextureVolume;
}

declare class RVOAvoidanceInterface extends Interface { 
	static Load(ResourceName: string): RVOAvoidanceInterface;
	static Find(Outer: UObject, ResourceName: string): RVOAvoidanceInterface;
	static GetDefaultObject(): RVOAvoidanceInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RVOAvoidanceInterface;
	static C(Other: UObject | any): RVOAvoidanceInterface;
}

declare class Scene extends UObject { 
	static Load(ResourceName: string): Scene;
	static Find(Outer: UObject, ResourceName: string): Scene;
	static GetDefaultObject(): Scene;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Scene;
	static C(Other: UObject | any): Scene;
}

declare type ESceneCaptureCompositeMode = 'SCCM_Overwrite' | 'SCCM_Additive' | 'SCCM_Composite' | 'SCCM_MAX';
declare var ESceneCaptureCompositeMode : { SCCM_Overwrite:'SCCM_Overwrite',SCCM_Additive:'SCCM_Additive',SCCM_Composite:'SCCM_Composite',SCCM_MAX:'SCCM_MAX', };
declare class SceneCaptureComponent2D extends SceneCaptureComponent { 
	ProjectionType: ECameraProjectionMode;
	FOVAngle: number;
	OrthoWidth: number;
	TextureTarget: TextureRenderTarget2D;
	CompositeMode: ESceneCaptureCompositeMode;
	PostProcessSettings: PostProcessSettings;
	PostProcessBlendWeight: number;
	bOverride_CustomNearClippingPlane: boolean;
	CustomNearClippingPlane: number;
	bUseCustomProjectionMatrix: boolean;
	CustomProjectionMatrix: Matrix;
	bUseFauxOrthoViewPos: boolean;
	bEnableOrthographicTiling: boolean;
	NumXTiles: number;
	NumYTiles: number;
	bEnableClipPlane: boolean;
	ClipPlaneBase: Vector;
	ClipPlaneNormal: Vector;
	bCameraCutThisFrame: boolean;
	bConsiderUnrenderedOpaquePixelAsFullyTranslucent: boolean;
	bDisableFlipCopyGLES: boolean;
	static Load(ResourceName: string): SceneCaptureComponent2D;
	static Find(Outer: UObject, ResourceName: string): SceneCaptureComponent2D;
	static GetDefaultObject(): SceneCaptureComponent2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCaptureComponent2D;
	CaptureScene(): void;
	static C(Other: UObject | any): SceneCaptureComponent2D;
}

declare class SceneCapture2D extends SceneCapture { 
	CaptureComponent2D: SceneCaptureComponent2D;
	static GetDefaultObject(): SceneCapture2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCapture2D;
	OnInterpToggle(bEnable: boolean): void;
	static C(Other: UObject | any): SceneCapture2D;
}

declare class TextureRenderTargetCube extends TextureRenderTarget { 
	SizeX: number;
	ClearColor: LinearColor;
	OverrideFormat: EPixelFormat;
	bHDR: boolean;
	bForceLinearGamma: boolean;
	static Load(ResourceName: string): TextureRenderTargetCube;
	static Find(Outer: UObject, ResourceName: string): TextureRenderTargetCube;
	static GetDefaultObject(): TextureRenderTargetCube;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureRenderTargetCube;
	static C(Other: UObject | any): TextureRenderTargetCube;
}

declare class SceneCaptureComponentCube extends SceneCaptureComponent { 
	TextureTarget: TextureRenderTargetCube;
	bCaptureRotation: boolean;
	TextureTargetLeft: TextureRenderTargetCube;
	TextureTargetRight: TextureRenderTargetCube;
	TextureTargetODS: TextureRenderTarget2D;
	IPD: number;
	static Load(ResourceName: string): SceneCaptureComponentCube;
	static Find(Outer: UObject, ResourceName: string): SceneCaptureComponentCube;
	static GetDefaultObject(): SceneCaptureComponentCube;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCaptureComponentCube;
	CaptureScene(): void;
	static C(Other: UObject | any): SceneCaptureComponentCube;
}

declare class SceneCaptureCube extends SceneCapture { 
	CaptureComponentCube: SceneCaptureComponentCube;
	static GetDefaultObject(): SceneCaptureCube;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCaptureCube;
	OnInterpToggle(bEnable: boolean): void;
	static C(Other: UObject | any): SceneCaptureCube;
}

declare type EShadowMapFlags = 'SMF_None' | 'SMF_Streamed' | 'SMF_MAX';
declare var EShadowMapFlags : { SMF_None:'SMF_None',SMF_Streamed:'SMF_Streamed',SMF_MAX:'SMF_MAX', };
declare class ShadowMapTexture2D extends Texture2D { 
	ShadowmapFlags: EShadowMapFlags;
	static Load(ResourceName: string): ShadowMapTexture2D;
	static Find(Outer: UObject, ResourceName: string): ShadowMapTexture2D;
	static GetDefaultObject(): ShadowMapTexture2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShadowMapTexture2D;
	static C(Other: UObject | any): ShadowMapTexture2D;
}

declare class SkeletalMeshSimplificationSettings extends DeveloperSettings { 
	SkeletalMeshReductionModuleName: string;
	static Load(ResourceName: string): SkeletalMeshSimplificationSettings;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshSimplificationSettings;
	static GetDefaultObject(): SkeletalMeshSimplificationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshSimplificationSettings;
	static C(Other: UObject | any): SkeletalMeshSimplificationSettings;
}

declare class SkyAtmosphere extends Info { 
	SkyAtmosphereComponent: SkyAtmosphereComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): SkyAtmosphere;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkyAtmosphere;
	static C(Other: UObject | any): SkyAtmosphere;
}

declare class SlateTextureAtlasInterface extends Interface { 
	static Load(ResourceName: string): SlateTextureAtlasInterface;
	static Find(Outer: UObject, ResourceName: string): SlateTextureAtlasInterface;
	static GetDefaultObject(): SlateTextureAtlasInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTextureAtlasInterface;
	static C(Other: UObject | any): SlateTextureAtlasInterface;
}

declare class SMInstanceElementAssetDataInterface extends UObject { 
	static Load(ResourceName: string): SMInstanceElementAssetDataInterface;
	static Find(Outer: UObject, ResourceName: string): SMInstanceElementAssetDataInterface;
	static GetDefaultObject(): SMInstanceElementAssetDataInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SMInstanceElementAssetDataInterface;
	static C(Other: UObject | any): SMInstanceElementAssetDataInterface;
}

declare class SMInstanceElementHierarchyInterface extends UObject { 
	static Load(ResourceName: string): SMInstanceElementHierarchyInterface;
	static Find(Outer: UObject, ResourceName: string): SMInstanceElementHierarchyInterface;
	static GetDefaultObject(): SMInstanceElementHierarchyInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SMInstanceElementHierarchyInterface;
	static C(Other: UObject | any): SMInstanceElementHierarchyInterface;
}

declare class SMInstanceElementIdMapTransactor extends UObject { 
	static Load(ResourceName: string): SMInstanceElementIdMapTransactor;
	static Find(Outer: UObject, ResourceName: string): SMInstanceElementIdMapTransactor;
	static GetDefaultObject(): SMInstanceElementIdMapTransactor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SMInstanceElementIdMapTransactor;
	static C(Other: UObject | any): SMInstanceElementIdMapTransactor;
}

declare class SMInstanceManager extends Interface { 
	static Load(ResourceName: string): SMInstanceManager;
	static Find(Outer: UObject, ResourceName: string): SMInstanceManager;
	static GetDefaultObject(): SMInstanceManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SMInstanceManager;
	static C(Other: UObject | any): SMInstanceManager;
}

declare class SMInstanceManagerProvider extends Interface { 
	static Load(ResourceName: string): SMInstanceManagerProvider;
	static Find(Outer: UObject, ResourceName: string): SMInstanceManagerProvider;
	static GetDefaultObject(): SMInstanceManagerProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SMInstanceManagerProvider;
	static C(Other: UObject | any): SMInstanceManagerProvider;
}

declare class SmokeTestCommandlet extends Commandlet { 
	static Load(ResourceName: string): SmokeTestCommandlet;
	static Find(Outer: UObject, ResourceName: string): SmokeTestCommandlet;
	static GetDefaultObject(): SmokeTestCommandlet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SmokeTestCommandlet;
	static C(Other: UObject | any): SmokeTestCommandlet;
}

declare class SoundEffectPresetWidgetInterface extends AudioPanelWidgetInterface { 
	static Load(ResourceName: string): SoundEffectPresetWidgetInterface;
	static Find(Outer: UObject, ResourceName: string): SoundEffectPresetWidgetInterface;
	static GetDefaultObject(): SoundEffectPresetWidgetInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectPresetWidgetInterface;
	OnPropertyChanged(Preset: SoundEffectPreset,PropertyName: string): void;
	OnConstructed(Preset: SoundEffectPreset): void;
	GetClass(): UnrealEngineClass;
	static C(Other: UObject | any): SoundEffectPresetWidgetInterface;
}

declare class SoundGroup { 
	SoundGroup: ESoundGroup;
	DisplayName: string;
	bAlwaysDecompressOnLoad: boolean;
	DecompressedDuration: number;
	clone() : SoundGroup;
	static C(Other: UObject | any): SoundGroup;
}

declare class SoundGroups extends UObject { 
	SoundGroupProfiles: SoundGroup[];
	static Load(ResourceName: string): SoundGroups;
	static Find(Outer: UObject, ResourceName: string): SoundGroups;
	static GetDefaultObject(): SoundGroups;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundGroups;
	static C(Other: UObject | any): SoundGroups;
}

declare class SoundNodeAssetReferencer extends SoundNode { 
	static Load(ResourceName: string): SoundNodeAssetReferencer;
	static Find(Outer: UObject, ResourceName: string): SoundNodeAssetReferencer;
	static GetDefaultObject(): SoundNodeAssetReferencer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeAssetReferencer;
	static C(Other: UObject | any): SoundNodeAssetReferencer;
}

declare class SoundNodeAttenuation extends SoundNode { 
	AttenuationSettings: SoundAttenuation;
	AttenuationOverrides: SoundAttenuationSettings;
	bOverrideAttenuation: boolean;
	static Load(ResourceName: string): SoundNodeAttenuation;
	static Find(Outer: UObject, ResourceName: string): SoundNodeAttenuation;
	static GetDefaultObject(): SoundNodeAttenuation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeAttenuation;
	static C(Other: UObject | any): SoundNodeAttenuation;
}

declare class SoundNodeBranch extends SoundNode { 
	BoolParameterName: string;
	static Load(ResourceName: string): SoundNodeBranch;
	static Find(Outer: UObject, ResourceName: string): SoundNodeBranch;
	static GetDefaultObject(): SoundNodeBranch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeBranch;
	static C(Other: UObject | any): SoundNodeBranch;
}

declare class SoundNodeConcatenator extends SoundNode { 
	InputVolume: number[];
	static Load(ResourceName: string): SoundNodeConcatenator;
	static Find(Outer: UObject, ResourceName: string): SoundNodeConcatenator;
	static GetDefaultObject(): SoundNodeConcatenator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeConcatenator;
	static C(Other: UObject | any): SoundNodeConcatenator;
}

declare class SoundNodeDelay extends SoundNode { 
	DelayMin: number;
	DelayMax: number;
	static Load(ResourceName: string): SoundNodeDelay;
	static Find(Outer: UObject, ResourceName: string): SoundNodeDelay;
	static GetDefaultObject(): SoundNodeDelay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeDelay;
	static C(Other: UObject | any): SoundNodeDelay;
}

declare class DialogueWaveParameter { 
	DialogueWave: DialogueWave;
	Context: DialogueContext;
	clone() : DialogueWaveParameter;
	static C(Other: UObject | any): DialogueWaveParameter;
}

declare class SoundNodeDialoguePlayer extends SoundNode { 
	DialogueWaveParameter: DialogueWaveParameter;
	bLooping: boolean;
	static Load(ResourceName: string): SoundNodeDialoguePlayer;
	static Find(Outer: UObject, ResourceName: string): SoundNodeDialoguePlayer;
	static GetDefaultObject(): SoundNodeDialoguePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeDialoguePlayer;
	static C(Other: UObject | any): SoundNodeDialoguePlayer;
}

declare class DistanceDatum { 
	FadeInDistanceStart: number;
	FadeInDistanceEnd: number;
	FadeOutDistanceStart: number;
	FadeOutDistanceEnd: number;
	Volume: number;
	clone() : DistanceDatum;
	static C(Other: UObject | any): DistanceDatum;
}

declare class SoundNodeDistanceCrossFade extends SoundNode { 
	CrossFadeInput: DistanceDatum[];
	static Load(ResourceName: string): SoundNodeDistanceCrossFade;
	static Find(Outer: UObject, ResourceName: string): SoundNodeDistanceCrossFade;
	static GetDefaultObject(): SoundNodeDistanceCrossFade;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeDistanceCrossFade;
	static C(Other: UObject | any): SoundNodeDistanceCrossFade;
}

declare class SoundNodeDoppler extends SoundNode { 
	DopplerIntensity: number;
	bUseSmoothing: boolean;
	SmoothingInterpSpeed: number;
	static Load(ResourceName: string): SoundNodeDoppler;
	static Find(Outer: UObject, ResourceName: string): SoundNodeDoppler;
	static GetDefaultObject(): SoundNodeDoppler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeDoppler;
	static C(Other: UObject | any): SoundNodeDoppler;
}

declare class SoundNodeEnveloper extends SoundNode { 
	LoopStart: number;
	LoopEnd: number;
	DurationAfterLoop: number;
	LoopCount: number;
	bLoopIndefinitely: boolean;
	bLoop: boolean;
	VolumeInterpCurve: DistributionFloatConstantCurve;
	PitchInterpCurve: DistributionFloatConstantCurve;
	VolumeCurve: RuntimeFloatCurve;
	PitchCurve: RuntimeFloatCurve;
	PitchMin: number;
	PitchMax: number;
	VolumeMin: number;
	VolumeMax: number;
	static Load(ResourceName: string): SoundNodeEnveloper;
	static Find(Outer: UObject, ResourceName: string): SoundNodeEnveloper;
	static GetDefaultObject(): SoundNodeEnveloper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeEnveloper;
	static C(Other: UObject | any): SoundNodeEnveloper;
}

declare class SoundNodeGroupControl extends SoundNode { 
	GroupSizes: number[];
	static Load(ResourceName: string): SoundNodeGroupControl;
	static Find(Outer: UObject, ResourceName: string): SoundNodeGroupControl;
	static GetDefaultObject(): SoundNodeGroupControl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeGroupControl;
	static C(Other: UObject | any): SoundNodeGroupControl;
}

declare class SoundNodeLooping extends SoundNode { 
	LoopCount: number;
	bLoopIndefinitely: boolean;
	static Load(ResourceName: string): SoundNodeLooping;
	static Find(Outer: UObject, ResourceName: string): SoundNodeLooping;
	static GetDefaultObject(): SoundNodeLooping;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeLooping;
	static C(Other: UObject | any): SoundNodeLooping;
}

declare class SoundNodeMature extends SoundNode { 
	static Load(ResourceName: string): SoundNodeMature;
	static Find(Outer: UObject, ResourceName: string): SoundNodeMature;
	static GetDefaultObject(): SoundNodeMature;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeMature;
	static C(Other: UObject | any): SoundNodeMature;
}

declare class SoundNodeMixer extends SoundNode { 
	InputVolume: number[];
	static Load(ResourceName: string): SoundNodeMixer;
	static Find(Outer: UObject, ResourceName: string): SoundNodeMixer;
	static GetDefaultObject(): SoundNodeMixer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeMixer;
	static C(Other: UObject | any): SoundNodeMixer;
}

declare class SoundNodeModulator extends SoundNode { 
	PitchMin: number;
	PitchMax: number;
	VolumeMin: number;
	VolumeMax: number;
	static Load(ResourceName: string): SoundNodeModulator;
	static Find(Outer: UObject, ResourceName: string): SoundNodeModulator;
	static GetDefaultObject(): SoundNodeModulator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeModulator;
	static C(Other: UObject | any): SoundNodeModulator;
}

declare type ModulationParamMode = 'MPM_Normal' | 'MPM_Abs' | 'MPM_Direct' | 'MPM_MAX';
declare var ModulationParamMode : { MPM_Normal:'MPM_Normal',MPM_Abs:'MPM_Abs',MPM_Direct:'MPM_Direct',MPM_MAX:'MPM_MAX', };
declare class ModulatorContinuousParams { 
	ParameterName: string;
	Default: number;
	MinInput: number;
	MaxInput: number;
	MinOutput: number;
	MaxOutput: number;
	ParamMode: ModulationParamMode;
	clone() : ModulatorContinuousParams;
	static C(Other: UObject | any): ModulatorContinuousParams;
}

declare class SoundNodeModulatorContinuous extends SoundNode { 
	PitchModulationParams: ModulatorContinuousParams;
	VolumeModulationParams: ModulatorContinuousParams;
	static Load(ResourceName: string): SoundNodeModulatorContinuous;
	static Find(Outer: UObject, ResourceName: string): SoundNodeModulatorContinuous;
	static GetDefaultObject(): SoundNodeModulatorContinuous;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeModulatorContinuous;
	static C(Other: UObject | any): SoundNodeModulatorContinuous;
}

declare class SoundNodeOscillator extends SoundNode { 
	bModulateVolume: boolean;
	bModulatePitch: boolean;
	AmplitudeMin: number;
	AmplitudeMax: number;
	FrequencyMin: number;
	FrequencyMax: number;
	OffsetMin: number;
	OffsetMax: number;
	CenterMin: number;
	CenterMax: number;
	static Load(ResourceName: string): SoundNodeOscillator;
	static Find(Outer: UObject, ResourceName: string): SoundNodeOscillator;
	static GetDefaultObject(): SoundNodeOscillator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeOscillator;
	static C(Other: UObject | any): SoundNodeOscillator;
}

declare class SoundNodeParamCrossFade extends SoundNodeDistanceCrossFade { 
	ParamName: string;
	static Load(ResourceName: string): SoundNodeParamCrossFade;
	static Find(Outer: UObject, ResourceName: string): SoundNodeParamCrossFade;
	static GetDefaultObject(): SoundNodeParamCrossFade;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeParamCrossFade;
	static C(Other: UObject | any): SoundNodeParamCrossFade;
}

declare class SoundNodeQualityLevel extends SoundNode { 
	CookedQualityLevelIndex: number;
	static Load(ResourceName: string): SoundNodeQualityLevel;
	static Find(Outer: UObject, ResourceName: string): SoundNodeQualityLevel;
	static GetDefaultObject(): SoundNodeQualityLevel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeQualityLevel;
	static C(Other: UObject | any): SoundNodeQualityLevel;
}

declare class SoundNodeRandom extends SoundNode { 
	Weights: number[];
	HasBeenUsed: boolean[];
	NumRandomUsed: number;
	PreselectAtLevelLoad: number;
	bShouldExcludeFromBranchCulling: boolean;
	bSoundCueExcludedFromBranchCulling: boolean;
	bRandomizeWithoutReplacement: boolean;
	PIEHiddenNodes: number[];
	static Load(ResourceName: string): SoundNodeRandom;
	static Find(Outer: UObject, ResourceName: string): SoundNodeRandom;
	static GetDefaultObject(): SoundNodeRandom;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeRandom;
	static C(Other: UObject | any): SoundNodeRandom;
}

declare class SoundNodeSoundClass extends SoundNode { 
	SoundClassOverride: SoundClass;
	static Load(ResourceName: string): SoundNodeSoundClass;
	static Find(Outer: UObject, ResourceName: string): SoundNodeSoundClass;
	static GetDefaultObject(): SoundNodeSoundClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeSoundClass;
	static C(Other: UObject | any): SoundNodeSoundClass;
}

declare class SoundNodeSwitch extends SoundNode { 
	IntParameterName: string;
	static Load(ResourceName: string): SoundNodeSwitch;
	static Find(Outer: UObject, ResourceName: string): SoundNodeSwitch;
	static GetDefaultObject(): SoundNodeSwitch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeSwitch;
	static C(Other: UObject | any): SoundNodeSwitch;
}

declare class SoundNodeWaveParam extends SoundNode { 
	WaveParameterName: string;
	static Load(ResourceName: string): SoundNodeWaveParam;
	static Find(Outer: UObject, ResourceName: string): SoundNodeWaveParam;
	static GetDefaultObject(): SoundNodeWaveParam;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeWaveParam;
	static C(Other: UObject | any): SoundNodeWaveParam;
}

declare class SoundNodeWavePlayer extends SoundNodeAssetReferencer { 
	SoundWaveAssetPtr: SoundWave;
	SoundWave: SoundWave;
	bLooping: boolean;
	static Load(ResourceName: string): SoundNodeWavePlayer;
	static Find(Outer: UObject, ResourceName: string): SoundNodeWavePlayer;
	static GetDefaultObject(): SoundNodeWavePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeWavePlayer;
	static C(Other: UObject | any): SoundNodeWavePlayer;
}

declare class SoundParameterControllerInterface extends AudioParameterControllerInterface { 
	static Load(ResourceName: string): SoundParameterControllerInterface;
	static Find(Outer: UObject, ResourceName: string): SoundParameterControllerInterface;
	static GetDefaultObject(): SoundParameterControllerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundParameterControllerInterface;
	static C(Other: UObject | any): SoundParameterControllerInterface;
}

declare class AudioParameterConversionStatics extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AudioParameterConversionStatics;
	static Find(Outer: UObject, ResourceName: string): AudioParameterConversionStatics;
	static GetDefaultObject(): AudioParameterConversionStatics;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioParameterConversionStatics;
	static StringToAudioParameter(Name: string,string: string): AudioParameter;
	static StringArrayToAudioParameter(Name: string,Strings: string[]): AudioParameter;
	static ObjectToAudioParameter(Name: string,UObject: UObject): AudioParameter;
	static ObjectArrayToAudioParameter(Name: string,Objects: UObject[]): AudioParameter;
	static IntegerToAudioParameter(Name: string,Integer: number): AudioParameter;
	static IntegerArrayToAudioParameter(Name: string,Integers: number[]): AudioParameter;
	static FloatToAudioParameter(Name: string,float: number): AudioParameter;
	static FloatArrayToAudioParameter(Name: string,Floats: number[]): AudioParameter;
	static BooleanToAudioParameter(Name: string,bool: boolean): AudioParameter;
	static BooleanArrayToAudioParameter(Name: string,Bools: boolean[]): AudioParameter;
	static C(Other: UObject | any): AudioParameterConversionStatics;
}

declare class SoundfieldSubmix extends SoundSubmixWithParentBase { 
	SoundfieldEncodingFormat: string;
	EncodingSettings: SoundfieldEncodingSettingsBase;
	SoundfieldEffectChain: SoundfieldEffectBase[];
	EncodingSettingsClass: UnrealEngineClass;
	static Load(ResourceName: string): SoundfieldSubmix;
	static Find(Outer: UObject, ResourceName: string): SoundfieldSubmix;
	static GetDefaultObject(): SoundfieldSubmix;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldSubmix;
	static C(Other: UObject | any): SoundfieldSubmix;
}

declare class EndpointSubmix extends SoundSubmixBase { 
	EndpointType: string;
	EndpointSettingsClass: UnrealEngineClass;
	EndpointSettings: AudioEndpointSettingsBase;
	static Load(ResourceName: string): EndpointSubmix;
	static Find(Outer: UObject, ResourceName: string): EndpointSubmix;
	static GetDefaultObject(): EndpointSubmix;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EndpointSubmix;
	static C(Other: UObject | any): EndpointSubmix;
}

declare class SoundfieldEndpointSubmix extends SoundSubmixBase { 
	SoundfieldEndpointType: string;
	EndpointSettingsClass: UnrealEngineClass;
	EndpointSettings: SoundfieldEndpointSettingsBase;
	EncodingSettingsClass: UnrealEngineClass;
	EncodingSettings: SoundfieldEncodingSettingsBase;
	SoundfieldEffectChain: SoundfieldEffectBase[];
	static Load(ResourceName: string): SoundfieldEndpointSubmix;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEndpointSubmix;
	static GetDefaultObject(): SoundfieldEndpointSubmix;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEndpointSubmix;
	static C(Other: UObject | any): SoundfieldEndpointSubmix;
}

declare class SoundSubmixWidgetInterface extends Interface { 
	static Load(ResourceName: string): SoundSubmixWidgetInterface;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixWidgetInterface;
	static GetDefaultObject(): SoundSubmixWidgetInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixWidgetInterface;
	OnConstructed(SoundSubmix: SoundSubmixBase): void;
	static C(Other: UObject | any): SoundSubmixWidgetInterface;
}

declare class SpectatorPawnMovement extends FloatingPawnMovement { 
	bIgnoreTimeDilation: boolean;
	static Load(ResourceName: string): SpectatorPawnMovement;
	static Find(Outer: UObject, ResourceName: string): SpectatorPawnMovement;
	static GetDefaultObject(): SpectatorPawnMovement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpectatorPawnMovement;
	static C(Other: UObject | any): SpectatorPawnMovement;
}

declare class SphereReflectionCapture extends ReflectionCapture { 
	DrawCaptureRadius: DrawSphereComponent;
	static GetDefaultObject(): SphereReflectionCapture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SphereReflectionCapture;
	static C(Other: UObject | any): SphereReflectionCapture;
}

declare class SphereReflectionCaptureComponent extends ReflectionCaptureComponent { 
	InfluenceRadius: number;
	CaptureDistanceScale: number;
	PreviewInfluenceRadius: DrawSphereComponent;
	static Load(ResourceName: string): SphereReflectionCaptureComponent;
	static Find(Outer: UObject, ResourceName: string): SphereReflectionCaptureComponent;
	static GetDefaultObject(): SphereReflectionCaptureComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SphereReflectionCaptureComponent;
	static C(Other: UObject | any): SphereReflectionCaptureComponent;
}

declare class SplineMeshActor extends Actor { 
	SplineMeshComponent: SplineMeshComponent;
	static GetDefaultObject(): SplineMeshActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMeshActor;
	static C(Other: UObject | any): SplineMeshActor;
}

declare class SpringArmComponent extends SceneComponent { 
	TargetArmLength: number;
	SocketOffset: Vector;
	TargetOffset: Vector;
	ProbeSize: number;
	ProbeChannel: ECollisionChannel;
	bDoCollisionTest: boolean;
	bUsePawnControlRotation: boolean;
	bInheritPitch: boolean;
	bInheritYaw: boolean;
	bInheritRoll: boolean;
	bEnableCameraLag: boolean;
	bEnableCameraRotationLag: boolean;
	bUseCameraLagSubstepping: boolean;
	bDrawDebugLagMarkers: boolean;
	CameraLagSpeed: number;
	CameraRotationLagSpeed: number;
	CameraLagMaxTimeStep: number;
	CameraLagMaxDistance: number;
	bClampToMaxPhysicsDeltaTime: boolean;
	static Load(ResourceName: string): SpringArmComponent;
	static Find(Outer: UObject, ResourceName: string): SpringArmComponent;
	static GetDefaultObject(): SpringArmComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpringArmComponent;
	IsCollisionFixApplied(): boolean;
	GetUnfixedCameraPosition(): Vector;
	GetTargetRotation(): Rotator;
	static C(Other: UObject | any): SpringArmComponent;
}

declare class StereoLayerShape extends UObject { 
	static Load(ResourceName: string): StereoLayerShape;
	static Find(Outer: UObject, ResourceName: string): StereoLayerShape;
	static GetDefaultObject(): StereoLayerShape;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerShape;
	static C(Other: UObject | any): StereoLayerShape;
}

declare class StereoLayerShapeQuad extends StereoLayerShape { 
	static Load(ResourceName: string): StereoLayerShapeQuad;
	static Find(Outer: UObject, ResourceName: string): StereoLayerShapeQuad;
	static GetDefaultObject(): StereoLayerShapeQuad;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerShapeQuad;
	static C(Other: UObject | any): StereoLayerShapeQuad;
}

declare class StereoLayerShapeCylinder extends StereoLayerShape { 
	Radius: number;
	OverlayArc: number;
	Height: number;
	static Load(ResourceName: string): StereoLayerShapeCylinder;
	static Find(Outer: UObject, ResourceName: string): StereoLayerShapeCylinder;
	static GetDefaultObject(): StereoLayerShapeCylinder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerShapeCylinder;
	SetRadius(InRadius: number): void;
	SetOverlayArc(InOverlayArc: number): void;
	SetHeight(InHeight: number): void;
	static C(Other: UObject | any): StereoLayerShapeCylinder;
}

declare class StereoLayerShapeCubemap extends StereoLayerShape { 
	static Load(ResourceName: string): StereoLayerShapeCubemap;
	static Find(Outer: UObject, ResourceName: string): StereoLayerShapeCubemap;
	static GetDefaultObject(): StereoLayerShapeCubemap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerShapeCubemap;
	static C(Other: UObject | any): StereoLayerShapeCubemap;
}

declare class EquirectProps { 
	LeftUVRect: Box2D;
	RightUVRect: Box2D;
	LeftScale: Vector2D;
	RightScale: Vector2D;
	LeftBias: Vector2D;
	RightBias: Vector2D;
	clone() : EquirectProps;
	static C(Other: UObject | any): EquirectProps;
}

declare class StereoLayerShapeEquirect extends StereoLayerShape { 
	LeftUVRect: Box2D;
	RightUVRect: Box2D;
	LeftScale: Vector2D;
	RightScale: Vector2D;
	LeftBias: Vector2D;
	RightBias: Vector2D;
	static Load(ResourceName: string): StereoLayerShapeEquirect;
	static Find(Outer: UObject, ResourceName: string): StereoLayerShapeEquirect;
	static GetDefaultObject(): StereoLayerShapeEquirect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerShapeEquirect;
	SetEquirectProps(InScaleBiases: EquirectProps): void;
	static C(Other: UObject | any): StereoLayerShapeEquirect;
}

declare type EStereoLayerType = 'SLT_WorldLocked' | 'SLT_TrackerLocked' | 'SLT_FaceLocked' | 'SLT_MAX';
declare var EStereoLayerType : { SLT_WorldLocked:'SLT_WorldLocked',SLT_TrackerLocked:'SLT_TrackerLocked',SLT_FaceLocked:'SLT_FaceLocked',SLT_MAX:'SLT_MAX', };
declare type EStereoLayerShape = 'SLSH_QuadLayer' | 'SLSH_CylinderLayer' | 'SLSH_CubemapLayer' | 'SLSH_EquirectLayer' | 'SLSH_MAX';
declare var EStereoLayerShape : { SLSH_QuadLayer:'SLSH_QuadLayer',SLSH_CylinderLayer:'SLSH_CylinderLayer',SLSH_CubemapLayer:'SLSH_CubemapLayer',SLSH_EquirectLayer:'SLSH_EquirectLayer',SLSH_MAX:'SLSH_MAX', };
declare class StereoLayerComponent extends SceneComponent { 
	bLiveTexture: boolean;
	bSupportsDepth: boolean;
	bNoAlphaChannel: boolean;
	Texture: Texture;
	LeftTexture: Texture;
	bQuadPreserveTextureRatio: boolean;
	QuadSize: Vector2D;
	UVRect: Box2D;
	CylinderRadius: number;
	CylinderOverlayArc: number;
	CylinderHeight: number;
	EquirectProps: EquirectProps;
	StereoLayerType: EStereoLayerType;
	StereoLayerShape: EStereoLayerShape;
	Shape: StereoLayerShape;
	Priority: number;
	static Load(ResourceName: string): StereoLayerComponent;
	static Find(Outer: UObject, ResourceName: string): StereoLayerComponent;
	static GetDefaultObject(): StereoLayerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerComponent;
	SetUVRect(InUVRect: Box2D): void;
	SetTexture(InTexture: Texture): void;
	SetQuadSize(InQuadSize: Vector2D): void;
	SetPriority(InPriority: number): void;
	SetLeftTexture(InTexture: Texture): void;
	SetEquirectProps(InScaleBiases: EquirectProps): void;
	MarkTextureForUpdate(): void;
	GetUVRect(): Box2D;
	GetTexture(): Texture;
	GetQuadSize(): Vector2D;
	GetPriority(): number;
	GetLeftTexture(): Texture;
	static C(Other: UObject | any): StereoLayerComponent;
}

declare class StereoLayerFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): StereoLayerFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): StereoLayerFunctionLibrary;
	static GetDefaultObject(): StereoLayerFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StereoLayerFunctionLibrary;
	static ShowSplashScreen(): void;
	static SetSplashScreen(Texture: Texture,Scale: Vector2D,Offset: Vector,bShowLoadingMovie: boolean,bShowOnSet: boolean): void;
	static HideSplashScreen(): void;
	static EnableAutoLoadingSplashScreen(InAutoShowEnabled: boolean): void;
	static C(Other: UObject | any): StereoLayerFunctionLibrary;
}

declare class StringTable extends UObject { 
	static Load(ResourceName: string): StringTable;
	static Find(Outer: UObject, ResourceName: string): StringTable;
	static GetDefaultObject(): StringTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StringTable;
	static C(Other: UObject | any): StringTable;
}

declare class SubsystemBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SubsystemBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): SubsystemBlueprintLibrary;
	static GetDefaultObject(): SubsystemBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubsystemBlueprintLibrary;
	static GetWorldSubsystem(ContextObject: UObject,Class: UnrealEngineClass): WorldSubsystem;
	static GetLocalPlayerSubSystemFromPlayerController(PlayerController: PlayerController,Class: UnrealEngineClass): LocalPlayerSubsystem;
	static GetLocalPlayerSubsystem(ContextObject: UObject,Class: UnrealEngineClass): LocalPlayerSubsystem;
	static GetGameInstanceSubsystem(ContextObject: UObject,Class: UnrealEngineClass): GameInstanceSubsystem;
	static GetEngineSubsystem(Class: UnrealEngineClass): EngineSubsystem;
	static GetAudioEngineSubsystem(ContextObject: UObject,Class: UnrealEngineClass): AudioEngineSubsystem;
	static C(Other: UObject | any): SubsystemBlueprintLibrary;
}

declare class SystemTimeTimecodeProvider extends TimecodeProvider { 
	FrameRate: FrameRate;
	bGenerateFullFrame: boolean;
	bUseHighPerformanceClock: boolean;
	static Load(ResourceName: string): SystemTimeTimecodeProvider;
	static Find(Outer: UObject, ResourceName: string): SystemTimeTimecodeProvider;
	static GetDefaultObject(): SystemTimeTimecodeProvider;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SystemTimeTimecodeProvider;
	static C(Other: UObject | any): SystemTimeTimecodeProvider;
}

declare class TargetPoint extends Actor { 
	SpriteComponent: BillboardComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): TargetPoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TargetPoint;
	static C(Other: UObject | any): TargetPoint;
}

declare class TextPropertyTestObject extends UObject { 
	DefaultedText: string;
	UndefaultedText: string;
	TransientText: string;
	static Load(ResourceName: string): TextPropertyTestObject;
	static Find(Outer: UObject, ResourceName: string): TextPropertyTestObject;
	static GetDefaultObject(): TextPropertyTestObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextPropertyTestObject;
	static C(Other: UObject | any): TextPropertyTestObject;
}

declare class TextRenderActor extends Actor { 
	TextRender: TextRenderComponent;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): TextRenderActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextRenderActor;
	static C(Other: UObject | any): TextRenderActor;
}

declare class TextureCubeArray extends Texture { 
	SourceTextures: TextureCube[];
	static Load(ResourceName: string): TextureCubeArray;
	static Find(Outer: UObject, ResourceName: string): TextureCubeArray;
	static GetDefaultObject(): TextureCubeArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureCubeArray;
	static C(Other: UObject | any): TextureCubeArray;
}

declare type ETextureEncodeEffort = 'Default' | 'Low' | 'Normal' | 'High' | 'ETextureEncodeEffort_MAX';
declare var ETextureEncodeEffort : { Default:'Default',Low:'Low',Normal:'Normal',High:'High',ETextureEncodeEffort_MAX:'ETextureEncodeEffort_MAX', };
declare type ETextureUniversalTiling = 'Disabled' | 'Enabled_256KB' | 'Enabled_64KB' | 'ETextureUniversalTiling_MAX';
declare var ETextureUniversalTiling : { Disabled:'Disabled',Enabled_256KB:'Enabled_256KB',Enabled_64KB:'Enabled_64KB',ETextureUniversalTiling_MAX:'ETextureUniversalTiling_MAX', };
declare type ETextureEncodeSpeed = 'Final' | 'FinalIfAvailable' | 'Fast' | 'ETextureEncodeSpeed_MAX';
declare var ETextureEncodeSpeed : { Final:'Final',FinalIfAvailable:'FinalIfAvailable',Fast:'Fast',ETextureEncodeSpeed_MAX:'ETextureEncodeSpeed_MAX', };
declare class TextureEncodingProjectSettings extends DeveloperSettings { 
	bFinalUsesRDO: boolean;
	FinalRDOLambda: any;
	FinalEffortLevel: ETextureEncodeEffort;
	FinalUniversalTiling: ETextureUniversalTiling;
	bFastUsesRDO: boolean;
	FastRDOLambda: any;
	FastEffortLevel: ETextureEncodeEffort;
	FastUniversalTiling: ETextureUniversalTiling;
	CookUsesSpeed: ETextureEncodeSpeed;
	EditorUsesSpeed: ETextureEncodeSpeed;
	static Load(ResourceName: string): TextureEncodingProjectSettings;
	static Find(Outer: UObject, ResourceName: string): TextureEncodingProjectSettings;
	static GetDefaultObject(): TextureEncodingProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureEncodingProjectSettings;
	static C(Other: UObject | any): TextureEncodingProjectSettings;
}

declare type ETextureEncodeSpeedOverride = 'Disabled' | 'Final' | 'FinalIfAvailable' | 'Fast' | 'ETextureEncodeSpeedOverride_MAX';
declare var ETextureEncodeSpeedOverride : { Disabled:'Disabled',Final:'Final',FinalIfAvailable:'FinalIfAvailable',Fast:'Fast',ETextureEncodeSpeedOverride_MAX:'ETextureEncodeSpeedOverride_MAX', };
declare class TextureEncodingUserSettings extends DeveloperSettings { 
	ForceEncodeSpeed: ETextureEncodeSpeedOverride;
	static Load(ResourceName: string): TextureEncodingUserSettings;
	static Find(Outer: UObject, ResourceName: string): TextureEncodingUserSettings;
	static GetDefaultObject(): TextureEncodingUserSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureEncodingUserSettings;
	static C(Other: UObject | any): TextureEncodingUserSettings;
}

declare class TextureMipDataProviderFactory extends AssetUserData { 
	static Load(ResourceName: string): TextureMipDataProviderFactory;
	static Find(Outer: UObject, ResourceName: string): TextureMipDataProviderFactory;
	static GetDefaultObject(): TextureMipDataProviderFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureMipDataProviderFactory;
	static C(Other: UObject | any): TextureMipDataProviderFactory;
}

declare class TimelineEventEntry { 
	Time: number;
	EventFunc: UnrealEngineDelegate<() => void>;
	clone() : TimelineEventEntry;
	static C(Other: UObject | any): TimelineEventEntry;
}

declare class TimelineVectorTrack { 
	VectorCurve: CurveVector;
	InterpFunc: UnrealEngineDelegate<(Output: Vector) => void>;
	TrackName: string;
	VectorPropertyName: string;
	clone() : TimelineVectorTrack;
	static C(Other: UObject | any): TimelineVectorTrack;
}

declare class TimelineFloatTrack { 
	FloatCurve: CurveFloat;
	InterpFunc: UnrealEngineDelegate<(Output: number) => void>;
	TrackName: string;
	FloatPropertyName: string;
	clone() : TimelineFloatTrack;
	static C(Other: UObject | any): TimelineFloatTrack;
}

declare class TimelineLinearColorTrack { 
	LinearColorCurve: CurveLinearColor;
	InterpFunc: UnrealEngineDelegate<(Output: LinearColor) => void>;
	TrackName: string;
	LinearColorPropertyName: string;
	clone() : TimelineLinearColorTrack;
	static C(Other: UObject | any): TimelineLinearColorTrack;
}

declare class Timeline { 
	LengthMode: ETimelineLengthMode;
	bLooping: boolean;
	bReversePlayback: boolean;
	bPlaying: boolean;
	Length: number;
	PlayRate: number;
	position: number;
	Events: TimelineEventEntry[];
	InterpVectors: TimelineVectorTrack[];
	InterpFloats: TimelineFloatTrack[];
	InterpLinearColors: TimelineLinearColorTrack[];
	TimelinePostUpdateFunc: UnrealEngineDelegate<() => void>;
	TimelineFinishedFunc: UnrealEngineDelegate<() => void>;
	PropertySetObject: any;
	DirectionPropertyName: string;
	clone() : Timeline;
	static C(Other: UObject | any): Timeline;
}

declare class TimelineComponent extends ActorComponent { 
	TheTimeline: Timeline;
	bIgnoreTimeDilation: boolean;
	static Load(ResourceName: string): TimelineComponent;
	static Find(Outer: UObject, ResourceName: string): TimelineComponent;
	static GetDefaultObject(): TimelineComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimelineComponent;
	Stop(): void;
	SetVectorCurve(NewVectorCurve: CurveVector,VectorTrackName: string): void;
	SetTimelineLengthMode(NewLengthMode: ETimelineLengthMode): void;
	SetTimelineLength(NewLength: number): void;
	SetPlayRate(NewRate: number): void;
	SetPlaybackPosition(NewPosition: number,bFireEvents: boolean,bFireUpdate: boolean): void;
	SetNewTime(NewTime: number): void;
	SetLooping(bNewLooping: boolean): void;
	SetLinearColorCurve(NewLinearColorCurve: CurveLinearColor,LinearColorTrackName: string): void;
	SetIgnoreTimeDilation(bNewIgnoreTimeDilation: boolean): void;
	SetFloatCurve(NewFloatCurve: CurveFloat,FloatTrackName: string): void;
	ReverseFromEnd(): void;
	Reverse(): void;
	PlayFromStart(): void;
	Play(): void;
	OnRep_Timeline(): void;
	IsReversing(): boolean;
	IsPlaying(): boolean;
	IsLooping(): boolean;
	GetTimelineLength(): number;
	GetScaledTimelineLength(): number;
	GetPlayRate(): number;
	GetPlaybackPosition(): number;
	GetIgnoreTimeDilation(): boolean;
	static C(Other: UObject | any): TimelineComponent;
}

declare class TireType extends DataAsset { 
	FrictionScale: number;
	static Load(ResourceName: string): TireType;
	static Find(Outer: UObject, ResourceName: string): TireType;
	static GetDefaultObject(): TireType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TireType;
	static C(Other: UObject | any): TireType;
}

declare class TriggerBase extends Actor { 
	CollisionComponent: ShapeComponent;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): TriggerBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TriggerBase;
	static C(Other: UObject | any): TriggerBase;
}

declare class TriggerBox extends TriggerBase { 
	static GetDefaultObject(): TriggerBox;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TriggerBox;
	static C(Other: UObject | any): TriggerBox;
}

declare class TriggerCapsule extends TriggerBase { 
	static GetDefaultObject(): TriggerCapsule;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TriggerCapsule;
	static C(Other: UObject | any): TriggerCapsule;
}

declare class TriggerSphere extends TriggerBase { 
	static GetDefaultObject(): TriggerSphere;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TriggerSphere;
	static C(Other: UObject | any): TriggerSphere;
}

declare class TriggerVolume extends Volume { 
	static GetDefaultObject(): TriggerVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TriggerVolume;
	static C(Other: UObject | any): TriggerVolume;
}

declare type ETwitterRequestMethod = 'TRM_Get' | 'TRM_Post' | 'TRM_Delete' | 'TRM_MAX';
declare var ETwitterRequestMethod : { TRM_Get:'TRM_Get',TRM_Post:'TRM_Post',TRM_Delete:'TRM_Delete',TRM_MAX:'TRM_MAX', };
declare class TwitterIntegrationBase extends PlatformInterfaceBase { 
	static Load(ResourceName: string): TwitterIntegrationBase;
	static Find(Outer: UObject, ResourceName: string): TwitterIntegrationBase;
	static GetDefaultObject(): TwitterIntegrationBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TwitterIntegrationBase;
	TwitterRequest(URL: string,ParamKeysAndValues: string[],RequestMethod: ETwitterRequestMethod,AccountIndex: number): boolean;
	ShowTweetUI(InitialMessage: string,URL: string,Picture: string): boolean;
	Init(): void;
	GetNumAccounts(): number;
	GetAccountName(AccountIndex: number): string;
	CanShowTweetUI(): boolean;
	AuthorizeAccounts(): boolean;
	static C(Other: UObject | any): TwitterIntegrationBase;
}

declare class TypedElementDeletionOptions { 
	bVerifyDeletionCanHappen: boolean;
	bWarnAboutReferences: boolean;
	bWarnAboutSoftReferences: boolean;
	clone() : TypedElementDeletionOptions;
	static C(Other: UObject | any): TypedElementDeletionOptions;
}

declare class TypedElementCommonActions extends UObject { 
	static Load(ResourceName: string): TypedElementCommonActions;
	static Find(Outer: UObject, ResourceName: string): TypedElementCommonActions;
	static GetDefaultObject(): TypedElementCommonActions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementCommonActions;
	K2_DuplicateSelectedElements(SelectionSet: TypedElementSelectionSet,World: World,LocationOffset: Vector): ScriptTypedElementHandle[];
	DuplicateNormalizedElements(ElementList: ScriptTypedElementListProxy,World: World,LocationOffset: Vector): ScriptTypedElementHandle[];
	DeleteSelectedElements(SelectionSet: TypedElementSelectionSet,World: World,DeletionOptions: TypedElementDeletionOptions): boolean;
	DeleteNormalizedElements(ElementList: ScriptTypedElementListProxy,World: World,InSelectionSet: TypedElementSelectionSet,DeletionOptions: TypedElementDeletionOptions): boolean;
	static C(Other: UObject | any): TypedElementCommonActions;
}

declare type ETypedElementWorldType = 'Game' | 'Editor' | 'ETypedElementWorldType_MAX';
declare var ETypedElementWorldType : { Game:'Game',Editor:'Editor',ETypedElementWorldType_MAX:'ETypedElementWorldType_MAX', };
declare class TypedElementWorldInterface extends Interface { 
	static Load(ResourceName: string): TypedElementWorldInterface;
	static Find(Outer: UObject, ResourceName: string): TypedElementWorldInterface;
	static GetDefaultObject(): TypedElementWorldInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TypedElementWorldInterface;
	SetWorldTransform(InElementHandle: ScriptTypedElementHandle,InTransform: Transform): boolean;
	SetRelativeTransform(InElementHandle: ScriptTypedElementHandle,InTransform: Transform): boolean;
	SetPivotOffset(InElementHandle: ScriptTypedElementHandle,InPivotOffset: Vector): boolean;
	NotifyMovementStarted(InElementHandle: ScriptTypedElementHandle): void;
	NotifyMovementOngoing(InElementHandle: ScriptTypedElementHandle): void;
	NotifyMovementEnded(InElementHandle: ScriptTypedElementHandle): void;
	IsTemplateElement(InElementHandle: ScriptTypedElementHandle): boolean;
	GetWorldTransform(InElementHandle: ScriptTypedElementHandle,OutTransform?: Transform): {OutTransform: Transform, $: boolean};
	GetRelativeTransform(InElementHandle: ScriptTypedElementHandle,OutTransform?: Transform): {OutTransform: Transform, $: boolean};
	GetPivotOffset(InElementHandle: ScriptTypedElementHandle,OutPivotOffset?: Vector): {OutPivotOffset: Vector, $: boolean};
	GetOwnerWorld(InElementHandle: ScriptTypedElementHandle): World;
	GetOwnerLevel(InElementHandle: ScriptTypedElementHandle): Level;
	GetBounds(InElementHandle: ScriptTypedElementHandle,OutBounds?: BoxSphereBounds): {OutBounds: BoxSphereBounds, $: boolean};
	DuplicateElement(InElementHandle: ScriptTypedElementHandle,InWorld: World,InLocationOffset: Vector): ScriptTypedElementHandle;
	DeleteElement(InElementHandle: ScriptTypedElementHandle,InWorld: World,InSelectionSet: TypedElementSelectionSet,InDeletionOptions: TypedElementDeletionOptions): boolean;
	CanMoveElement(InElementHandle: ScriptTypedElementHandle,InWorldType: ETypedElementWorldType): boolean;
	CanEditElement(InElementHandle: ScriptTypedElementHandle): boolean;
	CanDuplicateElement(InElementHandle: ScriptTypedElementHandle): boolean;
	CanDeleteElement(InElementHandle: ScriptTypedElementHandle): boolean;
	static C(Other: UObject | any): TypedElementWorldInterface;
}

declare class UserDefinedEnum extends Enum { 
	UniqueNameIndex: any;
	EnumDescription: string;
	DisplayNameMap: any;
	static Load(ResourceName: string): UserDefinedEnum;
	static Find(Outer: UObject, ResourceName: string): UserDefinedEnum;
	static GetDefaultObject(): UserDefinedEnum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedEnum;
	static C(Other: UObject | any): UserDefinedEnum;
}

declare type ERenderFocusRule = 'Always' | 'NonPointer' | 'NavigationOnly' | 'Never' | 'ERenderFocusRule_MAX';
declare var ERenderFocusRule : { Always:'Always',NonPointer:'NonPointer',NavigationOnly:'NavigationOnly',Never:'Never',ERenderFocusRule_MAX:'ERenderFocusRule_MAX', };
declare type EUIScalingRule = 'ShortestSide' | 'LongestSide' | 'Horizontal' | 'Vertical' | 'ScaleToFit' | 'Custom' | 'EUIScalingRule_MAX';
declare var EUIScalingRule : { ShortestSide:'ShortestSide',LongestSide:'LongestSide',Horizontal:'Horizontal',Vertical:'Vertical',ScaleToFit:'ScaleToFit',Custom:'Custom',EUIScalingRule_MAX:'EUIScalingRule_MAX', };
declare class UserInterfaceSettings extends DeveloperSettings { 
	RenderFocusRule: ERenderFocusRule;
	HardwareCursors: any;
	SoftwareCursors: any;
	DefaultCursor: SoftClassPath;
	TextEditBeamCursor: SoftClassPath;
	CrosshairsCursor: SoftClassPath;
	HandCursor: SoftClassPath;
	GrabHandCursor: SoftClassPath;
	GrabHandClosedCursor: SoftClassPath;
	SlashedCircleCursor: SoftClassPath;
	ApplicationScale: number;
	UIScaleRule: EUIScalingRule;
	CustomScalingRuleClass: SoftClassPath;
	UIScaleCurve: RuntimeFloatCurve;
	bAllowHighDPIInGameMode: boolean;
	DesignScreenSize: IntPoint;
	bLoadWidgetsOnDedicatedServer: boolean;
	CursorClasses: UObject[];
	CustomScalingRuleClassInstance: UnrealEngineClass;
	CustomScalingRule: DPICustomScalingRule;
	static Load(ResourceName: string): UserInterfaceSettings;
	static Find(Outer: UObject, ResourceName: string): UserInterfaceSettings;
	static GetDefaultObject(): UserInterfaceSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserInterfaceSettings;
	static C(Other: UObject | any): UserInterfaceSettings;
}

declare type EVectorFieldConstructionOp = 'VFCO_Extrude' | 'VFCO_Revolve' | 'VFCO_MAX';
declare var EVectorFieldConstructionOp : { VFCO_Extrude:'VFCO_Extrude',VFCO_Revolve:'VFCO_Revolve',VFCO_MAX:'VFCO_MAX', };
declare class VectorFieldStatic extends VectorField { 
	SizeX: number;
	SizeY: number;
	SizeZ: number;
	bAllowCPUAccess: boolean;
	SourceFilePath: string;
	AssetImportData: AssetImportData;
	static Load(ResourceName: string): VectorFieldStatic;
	static Find(Outer: UObject, ResourceName: string): VectorFieldStatic;
	static GetDefaultObject(): VectorFieldStatic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorFieldStatic;
	static C(Other: UObject | any): VectorFieldStatic;
}

declare class VectorFieldAnimated extends VectorField { 
	Texture: Texture2D;
	ConstructionOp: EVectorFieldConstructionOp;
	VolumeSizeX: number;
	VolumeSizeY: number;
	VolumeSizeZ: number;
	SubImagesX: number;
	SubImagesY: number;
	FrameCount: number;
	FramesPerSecond: number;
	bLoop: boolean;
	NoiseField: VectorFieldStatic;
	NoiseScale: number;
	NoiseMax: number;
	static Load(ResourceName: string): VectorFieldAnimated;
	static Find(Outer: UObject, ResourceName: string): VectorFieldAnimated;
	static GetDefaultObject(): VectorFieldAnimated;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorFieldAnimated;
	static C(Other: UObject | any): VectorFieldAnimated;
}

declare class VectorFieldComponent extends PrimitiveComponent { 
	VectorField: VectorField;
	Intensity: number;
	Tightness: number;
	bPreviewVectorField: boolean;
	static Load(ResourceName: string): VectorFieldComponent;
	static Find(Outer: UObject, ResourceName: string): VectorFieldComponent;
	static GetDefaultObject(): VectorFieldComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorFieldComponent;
	SetIntensity(NewIntensity: number): void;
	static C(Other: UObject | any): VectorFieldComponent;
}

declare class VectorFieldVolume extends Actor { 
	VectorFieldComponent: VectorFieldComponent;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): VectorFieldVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorFieldVolume;
	static C(Other: UObject | any): VectorFieldVolume;
}

declare class ViewportStatsSubsystem extends WorldSubsystem { 
	static Load(ResourceName: string): ViewportStatsSubsystem;
	static Find(Outer: UObject, ResourceName: string): ViewportStatsSubsystem;
	static GetDefaultObject(): ViewportStatsSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportStatsSubsystem;
	RemoveDisplayDelegate(IndexToRemove: number): void;
	AddTimedDisplay(text: string,Color: LinearColor,Duration: number,DisplayOffset: Vector2D): void;
	static C(Other: UObject | any): ViewportStatsSubsystem;
}

declare class VirtualTexture extends UObject { 
	static Load(ResourceName: string): VirtualTexture;
	static Find(Outer: UObject, ResourceName: string): VirtualTexture;
	static GetDefaultObject(): VirtualTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualTexture;
	static C(Other: UObject | any): VirtualTexture;
}

declare class LightMapVirtualTexture extends VirtualTexture { 
	static Load(ResourceName: string): LightMapVirtualTexture;
	static Find(Outer: UObject, ResourceName: string): LightMapVirtualTexture;
	static GetDefaultObject(): LightMapVirtualTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightMapVirtualTexture;
	static C(Other: UObject | any): LightMapVirtualTexture;
}

declare class VirtualTextureSpacePoolConfig { 
	MinTileSize: number;
	MaxTileSize: number;
	Formats: EPixelFormat[];
	SizeInMegabyte: number;
	bEnableResidencyMipMapBias: boolean;
	bAllowSizeScale: boolean;
	ScalabilityGroup: any;
	MinScaledSizeInMegabyte: number;
	MaxScaledSizeInMegabyte: number;
	clone() : VirtualTextureSpacePoolConfig;
	static C(Other: UObject | any): VirtualTextureSpacePoolConfig;
}

declare class VirtualTexturePoolConfig extends UObject { 
	DefaultSizeInMegabyte: number;
	Pools: VirtualTextureSpacePoolConfig[];
	static Load(ResourceName: string): VirtualTexturePoolConfig;
	static Find(Outer: UObject, ResourceName: string): VirtualTexturePoolConfig;
	static GetDefaultObject(): VirtualTexturePoolConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualTexturePoolConfig;
	static C(Other: UObject | any): VirtualTexturePoolConfig;
}

declare class VisualLoggerAutomationTests extends UObject { 
	static Load(ResourceName: string): VisualLoggerAutomationTests;
	static Find(Outer: UObject, ResourceName: string): VisualLoggerAutomationTests;
	static GetDefaultObject(): VisualLoggerAutomationTests;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerAutomationTests;
	static C(Other: UObject | any): VisualLoggerAutomationTests;
}

declare class VisualLoggerDebugSnapshotInterface extends Interface { 
	static Load(ResourceName: string): VisualLoggerDebugSnapshotInterface;
	static Find(Outer: UObject, ResourceName: string): VisualLoggerDebugSnapshotInterface;
	static GetDefaultObject(): VisualLoggerDebugSnapshotInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerDebugSnapshotInterface;
	static C(Other: UObject | any): VisualLoggerDebugSnapshotInterface;
}

declare class VisualLoggerFilterVolume extends Volume { 
	static GetDefaultObject(): VisualLoggerFilterVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerFilterVolume;
	static C(Other: UObject | any): VisualLoggerFilterVolume;
}

declare class VisualLoggerKismetLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): VisualLoggerKismetLibrary;
	static Find(Outer: UObject, ResourceName: string): VisualLoggerKismetLibrary;
	static GetDefaultObject(): VisualLoggerKismetLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerKismetLibrary;
	static RedirectVislog(SourceOwner: UObject,DestinationOwner: UObject): void;
	static LogText(WorldContextObject: UObject,text: string,LogCategory: string,bAddToMessageLog: boolean): void;
	static LogSegment(WorldContextObject: UObject,SegmentStart: Vector,SegmentEnd: Vector,text: string,ObjectColor: LinearColor,Thickness: number,CategoryName: string,bAddToMessageLog: boolean): void;
	static LogLocation(WorldContextObject: UObject,Location: Vector,text: string,ObjectColor: LinearColor,Radius: number,LogCategory: string,bAddToMessageLog: boolean): void;
	static LogBox(WorldContextObject: UObject,BoxShape: Box,text: string,ObjectColor: LinearColor,LogCategory: string,bAddToMessageLog: boolean): void;
	static EnableRecording(bEnabled: boolean): void;
	static C(Other: UObject | any): VisualLoggerKismetLibrary;
}

declare class VoiceChannel extends Channel { 
	static Load(ResourceName: string): VoiceChannel;
	static Find(Outer: UObject, ResourceName: string): VoiceChannel;
	static GetDefaultObject(): VoiceChannel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VoiceChannel;
	static C(Other: UObject | any): VoiceChannel;
}

declare class VoiceSettings { 
	ComponentToAttachTo: SceneComponent;
	AttenuationSettings: SoundAttenuation;
	SourceEffectChain: SoundEffectSourcePresetChain;
	clone() : VoiceSettings;
	static C(Other: UObject | any): VoiceSettings;
}

declare class VOIPTalker extends ActorComponent { 
	Settings: VoiceSettings;
	static Load(ResourceName: string): VOIPTalker;
	static Find(Outer: UObject, ResourceName: string): VOIPTalker;
	static GetDefaultObject(): VOIPTalker;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VOIPTalker;
	RegisterWithPlayerState(OwningState: PlayerState): void;
	GetVoiceLevel(): number;
	static CreateTalkerForPlayer(OwningState: PlayerState): VOIPTalker;
	BPOnTalkingEnd(): void;
	BPOnTalkingBegin(AudioComponent: AudioComponent): void;
	static C(Other: UObject | any): VOIPTalker;
}

declare class VOIPStatics extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): VOIPStatics;
	static Find(Outer: UObject, ResourceName: string): VOIPStatics;
	static GetDefaultObject(): VOIPStatics;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VOIPStatics;
	static SetMicThreshold(InThreshold: number): void;
	static C(Other: UObject | any): VOIPStatics;
}

declare class VolumetricCloudComponent extends SceneComponent { 
	LayerBottomAltitude: number;
	LayerHeight: number;
	TracingStartMaxDistance: number;
	TracingMaxDistance: number;
	PlanetRadius: number;
	GroundAlbedo: Color;
	Material: MaterialInterface;
	bUsePerSampleAtmosphericLightTransmittance: boolean;
	SkyLightCloudBottomOcclusion: number;
	ViewSampleCountScale: number;
	ReflectionViewSampleCountScale: number;
	ReflectionSampleCountScale: number;
	ShadowViewSampleCountScale: number;
	ShadowReflectionViewSampleCountScale: number;
	ShadowReflectionSampleCountScale: number;
	ShadowTracingDistance: number;
	StopTracingTransmittanceThreshold: number;
	static Load(ResourceName: string): VolumetricCloudComponent;
	static Find(Outer: UObject, ResourceName: string): VolumetricCloudComponent;
	static GetDefaultObject(): VolumetricCloudComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VolumetricCloudComponent;
	SetViewSampleCountScale(NewValue: number): void;
	SetTracingStartMaxDistance(NewValue: number): void;
	SetTracingMaxDistance(NewValue: number): void;
	SetStopTracingTransmittanceThreshold(NewValue: number): void;
	SetSkyLightCloudBottomOcclusion(NewValue: number): void;
	SetShadowViewSampleCountScale(NewValue: number): void;
	SetShadowTracingDistance(NewValue: number): void;
	SetShadowReflectionViewSampleCountScale(NewValue: number): void;
	SetShadowReflectionSampleCountScale(NewValue: number): void;
	SetReflectionViewSampleCountScale(NewValue: number): void;
	SetReflectionSampleCountScale(NewValue: number): void;
	SetPlanetRadius(NewValue: number): void;
	SetMaterial(NewValue: MaterialInterface): void;
	SetLayerHeight(NewValue: number): void;
	SetLayerBottomAltitude(NewValue: number): void;
	SetGroundAlbedo(NewValue: Color): void;
	SetbUsePerSampleAtmosphericLightTransmittance(NewValue: boolean): void;
	static C(Other: UObject | any): VolumetricCloudComponent;
}

declare class VolumetricCloud extends Info { 
	VolumetricCloudComponent: VolumetricCloudComponent;
	static GetDefaultObject(): VolumetricCloud;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VolumetricCloud;
	static C(Other: UObject | any): VolumetricCloud;
}

declare class VolumetricLightmapDensityVolume extends Volume { 
	AllowedMipLevelRange: Int32Interval;
	static GetDefaultObject(): VolumetricLightmapDensityVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VolumetricLightmapDensityVolume;
	static C(Other: UObject | any): VolumetricLightmapDensityVolume;
}

declare type EWindSourceType = 'Directional' | 'Point' | 'EWindSourceType_MAX';
declare var EWindSourceType : { Directional:'Directional',Point:'Point',EWindSourceType_MAX:'EWindSourceType_MAX', };
declare class WindDirectionalSourceComponent extends SceneComponent { 
	Strength: number;
	Speed: number;
	MinGustAmount: number;
	MaxGustAmount: number;
	Radius: number;
	bPointWind: boolean;
	static Load(ResourceName: string): WindDirectionalSourceComponent;
	static Find(Outer: UObject, ResourceName: string): WindDirectionalSourceComponent;
	static GetDefaultObject(): WindDirectionalSourceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindDirectionalSourceComponent;
	SetWindType(InNewType: EWindSourceType): void;
	SetStrength(InNewStrength: number): void;
	SetSpeed(InNewSpeed: number): void;
	SetRadius(InNewRadius: number): void;
	SetMinimumGustAmount(InNewMinGust: number): void;
	SetMaximumGustAmount(InNewMaxGust: number): void;
	static C(Other: UObject | any): WindDirectionalSourceComponent;
}

declare class WindDirectionalSource extends Info { 
	Component: WindDirectionalSourceComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): WindDirectionalSource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindDirectionalSource;
	static C(Other: UObject | any): WindDirectionalSource;
}

declare class WorldPartitionEditorCell extends UObject { 
	static Load(ResourceName: string): WorldPartitionEditorCell;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionEditorCell;
	static GetDefaultObject(): WorldPartitionEditorCell;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionEditorCell;
	static C(Other: UObject | any): WorldPartitionEditorCell;
}

declare class WorldPartitionEditorPerProjectUserSettings extends UObject { 
	bHideEditorDataLayers: boolean;
	bHideRuntimeDataLayers: boolean;
	bHideDataLayerActors: boolean;
	bHideUnloadedActors: boolean;
	bShowOnlySelectedActors: boolean;
	bHighlightSelectedDataLayers: boolean;
	bDisableLoadingOfLastLoadedCells: boolean;
	bBugItGoLoadCells: boolean;
	bShowCellCoords: boolean;
	PerWorldEditorSettings: any;
	static Load(ResourceName: string): WorldPartitionEditorPerProjectUserSettings;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionEditorPerProjectUserSettings;
	static GetDefaultObject(): WorldPartitionEditorPerProjectUserSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionEditorPerProjectUserSettings;
	static C(Other: UObject | any): WorldPartitionEditorPerProjectUserSettings;
}

declare class WorldPartitionEditorSpatialHash extends WorldPartitionEditorHash { 
	CellSize: number;
	WantedCellSize: number;
	Cells: any;
	AlwaysLoadedCell: WorldPartitionEditorCell;
	WorldImage: SoftObjectPath;
	WorldImageTopLeftW: Vector2D;
	WorldImageBottomRightW: Vector2D;
	static Load(ResourceName: string): WorldPartitionEditorSpatialHash;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionEditorSpatialHash;
	static GetDefaultObject(): WorldPartitionEditorSpatialHash;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionEditorSpatialHash;
	static C(Other: UObject | any): WorldPartitionEditorSpatialHash;
}

declare class WorldPartitionLevelStreamingDynamic extends LevelStreamingDynamic { 
	RuntimeLevel: Level;
	bShouldBeAlwaysLoaded: boolean;
	UnsavedActorsContainer: ActorContainer;
	StreamingCell: any;
	OuterWorldPartition: any;
	static Load(ResourceName: string): WorldPartitionLevelStreamingDynamic;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionLevelStreamingDynamic;
	static GetDefaultObject(): WorldPartitionLevelStreamingDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionLevelStreamingDynamic;
	static C(Other: UObject | any): WorldPartitionLevelStreamingDynamic;
}

declare class WorldPartitionLevelStreamingPolicy extends WorldPartitionStreamingPolicy { 
	ActorToCellRemapping: any;
	SubObjectsToCellRemapping: any;
	static Load(ResourceName: string): WorldPartitionLevelStreamingPolicy;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionLevelStreamingPolicy;
	static GetDefaultObject(): WorldPartitionLevelStreamingPolicy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionLevelStreamingPolicy;
	static C(Other: UObject | any): WorldPartitionLevelStreamingPolicy;
}

declare class WorldPartitionMiniMap extends Info { 
	MiniMapWorldBounds: Box;
	UVOffset: Box2D;
	MiniMapTexture: Texture2D;
	ExcludedDataLayers: any;
	MiniMapTileSize: number;
	static GetDefaultObject(): WorldPartitionMiniMap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionMiniMap;
	static C(Other: UObject | any): WorldPartitionMiniMap;
}

declare class WorldPartitionReplay extends Actor { 
	StreamingSourceNames: string[];
	static GetDefaultObject(): WorldPartitionReplay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionReplay;
	static C(Other: UObject | any): WorldPartitionReplay;
}

declare class WorldPartitionRuntimeSpatialHashCell extends WorldPartitionRuntimeCell { 
	position: Vector;
	Extent: number;
	Level: number;
	UnsavedActorsContainer: ActorContainer;
	static Load(ResourceName: string): WorldPartitionRuntimeSpatialHashCell;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionRuntimeSpatialHashCell;
	static GetDefaultObject(): WorldPartitionRuntimeSpatialHashCell;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionRuntimeSpatialHashCell;
	static C(Other: UObject | any): WorldPartitionRuntimeSpatialHashCell;
}

declare class WorldPartitionRuntimeCellObjectMapping { 
	Package: string;
	Path: string;
	ContainerID: ActorContainerID;
	ContainerTransform: Transform;
	ContainerPackage: string;
	LoadedPath: string;
	clone() : WorldPartitionRuntimeCellObjectMapping;
	static C(Other: UObject | any): WorldPartitionRuntimeCellObjectMapping;
}

declare class WorldPartitionRuntimeLevelStreamingCell extends WorldPartitionRuntimeSpatialHashCell { 
	Packages: WorldPartitionRuntimeCellObjectMapping[];
	ActorFolders: any;
	LevelStreaming: WorldPartitionLevelStreamingDynamic;
	static Load(ResourceName: string): WorldPartitionRuntimeLevelStreamingCell;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionRuntimeLevelStreamingCell;
	static GetDefaultObject(): WorldPartitionRuntimeLevelStreamingCell;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionRuntimeLevelStreamingCell;
	OnLevelShown(): void;
	OnLevelHidden(): void;
	static C(Other: UObject | any): WorldPartitionRuntimeLevelStreamingCell;
}

declare class SpatialHashRuntimeGrid { 
	GridName: string;
	CellSize: number;
	LoadingRange: number;
	bBlockOnSlowStreaming: boolean;
	Priority: number;
	DebugColor: LinearColor;
	bClientOnlyVisible: boolean;
	HLODLayer: HLODLayer;
	clone() : SpatialHashRuntimeGrid;
	static C(Other: UObject | any): SpatialHashRuntimeGrid;
}

declare class SpatialHashRuntimeGridInfo extends Info { 
	GridSettings: SpatialHashRuntimeGrid;
	static GetDefaultObject(): SpatialHashRuntimeGridInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpatialHashRuntimeGridInfo;
	static C(Other: UObject | any): SpatialHashRuntimeGridInfo;
}

declare class WorldPartitionRuntimeSpatialHashGridPreviewer { 
	Material: Material;
	Mid: MaterialInstanceDynamic;
	Volume: PostProcessVolume;
	clone() : WorldPartitionRuntimeSpatialHashGridPreviewer;
	static C(Other: UObject | any): WorldPartitionRuntimeSpatialHashGridPreviewer;
}

declare class SpatialHashStreamingGridLayerCell { 
	GridCells: WorldPartitionRuntimeSpatialHashCell[];
	clone() : SpatialHashStreamingGridLayerCell;
	static C(Other: UObject | any): SpatialHashStreamingGridLayerCell;
}

declare class SpatialHashStreamingGridLevel { 
	LayerCells: SpatialHashStreamingGridLayerCell[];
	LayerCellsMapping: any;
	clone() : SpatialHashStreamingGridLevel;
	static C(Other: UObject | any): SpatialHashStreamingGridLevel;
}

declare class SpatialHashStreamingGrid { 
	GridName: string;
	Origin: Vector;
	CellSize: number;
	LoadingRange: number;
	bBlockOnSlowStreaming: boolean;
	DebugColor: LinearColor;
	GridLevels: SpatialHashStreamingGridLevel[];
	WorldBounds: Box;
	bClientOnlyVisible: boolean;
	HLODLayer: HLODLayer;
	clone() : SpatialHashStreamingGrid;
	static C(Other: UObject | any): SpatialHashStreamingGrid;
}

declare class WorldPartitionRuntimeSpatialHash extends WorldPartitionRuntimeHash { 
	Grids: SpatialHashRuntimeGrid[];
	bPreviewGrids: boolean;
	GridPreviewer: WorldPartitionRuntimeSpatialHashGridPreviewer;
	StreamingGrids: SpatialHashStreamingGrid[];
	static Load(ResourceName: string): WorldPartitionRuntimeSpatialHash;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionRuntimeSpatialHash;
	static GetDefaultObject(): WorldPartitionRuntimeSpatialHash;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionRuntimeSpatialHash;
	static C(Other: UObject | any): WorldPartitionRuntimeSpatialHash;
}

declare class StreamingSourceShape { 
	bUseGridLoadingRange: boolean;
	Radius: number;
	bIsSector: boolean;
	SectorAngle: number;
	Location: Vector;
	Rotation: Rotator;
	clone() : StreamingSourceShape;
	static C(Other: UObject | any): StreamingSourceShape;
}

declare type EStreamingSourcePriority = 'Highest' | 'High' | 'Normal' | 'Low' | 'Lowest' | 'Default' | 'EStreamingSourcePriority_MAX';
declare var EStreamingSourcePriority : { Highest:'Highest',High:'High',Normal:'Normal',Low:'Low',Lowest:'Lowest',Default:'Default',EStreamingSourcePriority_MAX:'EStreamingSourcePriority_MAX', };
declare type EStreamingSourceTargetState = 'Loaded' | 'Activated' | 'EStreamingSourceTargetState_MAX';
declare var EStreamingSourceTargetState : { Loaded:'Loaded',Activated:'Activated',EStreamingSourceTargetState_MAX:'EStreamingSourceTargetState_MAX', };
declare class WorldPartitionStreamingSourceComponent extends ActorComponent { 
	DefaultVisualizerLoadingRange: number;
	TargetGrid: string;
	DebugColor: Color;
	TargetHLODLayer: HLODLayer;
	Shapes: StreamingSourceShape[];
	Priority: EStreamingSourcePriority;
	bStreamingSourceEnabled: boolean;
	TargetState: EStreamingSourceTargetState;
	static Load(ResourceName: string): WorldPartitionStreamingSourceComponent;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionStreamingSourceComponent;
	static GetDefaultObject(): WorldPartitionStreamingSourceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionStreamingSourceComponent;
	IsStreamingSourceEnabled(): boolean;
	IsStreamingCompleted(): boolean;
	EnableStreamingSource(): void;
	DisableStreamingSource(): void;
	static C(Other: UObject | any): WorldPartitionStreamingSourceComponent;
}

declare type EWorldPartitionRuntimeCellState = 'Unloaded' | 'Loaded' | 'Activated' | 'EWorldPartitionRuntimeCellState_MAX';
declare var EWorldPartitionRuntimeCellState : { Unloaded:'Unloaded',Loaded:'Loaded',Activated:'Activated',EWorldPartitionRuntimeCellState_MAX:'EWorldPartitionRuntimeCellState_MAX', };
declare class WorldPartitionStreamingQuerySource { 
	Location: Vector;
	Radius: number;
	bUseGridLoadingRange: boolean;
	DataLayers: string[];
	bDataLayersOnly: boolean;
	bSpatialQuery: boolean;
	clone() : WorldPartitionStreamingQuerySource;
	static C(Other: UObject | any): WorldPartitionStreamingQuerySource;
}

declare class WorldPartitionSubsystem extends TickableWorldSubsystem { 
	static Load(ResourceName: string): WorldPartitionSubsystem;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionSubsystem;
	static GetDefaultObject(): WorldPartitionSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionSubsystem;
	IsStreamingCompleted(QueryState: EWorldPartitionRuntimeCellState,QuerySources: WorldPartitionStreamingQuerySource[],bExactState: boolean): boolean;
	static C(Other: UObject | any): WorldPartitionSubsystem;
}

declare class WorldPartitionVolume extends Volume { 
	static GetDefaultObject(): WorldPartitionVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionVolume;
	static C(Other: UObject | any): WorldPartitionVolume;
}

declare class HierarchicalLODSetup extends UObject { 
	HierarchicalLODSetup: HierarchicalSimplification[];
	OverrideBaseMaterial: MaterialInterface;
	static Load(ResourceName: string): HierarchicalLODSetup;
	static Find(Outer: UObject, ResourceName: string): HierarchicalLODSetup;
	static GetDefaultObject(): HierarchicalLODSetup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HierarchicalLODSetup;
	static C(Other: UObject | any): HierarchicalLODSetup;
}

declare class MoviePlayerSettings extends UObject { 
	bWaitForMoviesToComplete: boolean;
	bMoviesAreSkippable: boolean;
	StartupMovies: string[];
	static Load(ResourceName: string): MoviePlayerSettings;
	static Find(Outer: UObject, ResourceName: string): MoviePlayerSettings;
	static GetDefaultObject(): MoviePlayerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MoviePlayerSettings;
	static C(Other: UObject | any): MoviePlayerSettings;
}

declare class SHAHashData { 
	Hash: number;
	clone() : SHAHashData;
	static C(Other: UObject | any): SHAHashData;
}

declare class ChunkPartData { 
	Guid: Guid;
	Offset: any;
	Size: any;
	clone() : ChunkPartData;
	static C(Other: UObject | any): ChunkPartData;
}

declare class FileManifestData { 
	Filename: string;
	FileHash: SHAHashData;
	FileChunkParts: ChunkPartData[];
	InstallTags: string[];
	bIsUnixExecutable: boolean;
	SymlinkTarget: string;
	bIsReadOnly: boolean;
	bIsCompressed: boolean;
	clone() : FileManifestData;
	static C(Other: UObject | any): FileManifestData;
}

declare class ChunkInfoData { 
	Guid: Guid;
	Hash: any;
	ShaHash: SHAHashData;
	FileSize: any;
	GroupNumber: number;
	clone() : ChunkInfoData;
	static C(Other: UObject | any): ChunkInfoData;
}

declare class CustomFieldData { 
	Key: string;
	Value: string;
	clone() : CustomFieldData;
	static C(Other: UObject | any): CustomFieldData;
}

declare class BuildPatchManifest extends UObject { 
	ManifestFileVersion: number;
	bIsFileData: boolean;
	AppID: any;
	AppName: string;
	BuildVersion: string;
	LaunchExe: string;
	LaunchCommand: string;
	PrereqIds: any;
	PrereqName: string;
	PrereqPath: string;
	PrereqArgs: string;
	FileManifestList: FileManifestData[];
	ChunkList: ChunkInfoData[];
	CustomFields: CustomFieldData[];
	static Load(ResourceName: string): BuildPatchManifest;
	static Find(Outer: UObject, ResourceName: string): BuildPatchManifest;
	static GetDefaultObject(): BuildPatchManifest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BuildPatchManifest;
	static C(Other: UObject | any): BuildPatchManifest;
}

declare class SoundFactory extends Factory { 
	bAutoCreateCue: boolean;
	bIncludeAttenuationNode: boolean;
	bIncludeLoopingNode: boolean;
	bIncludeModulatorNode: boolean;
	CueVolume: number;
	CuePackageSuffix: string;
	static Load(ResourceName: string): SoundFactory;
	static Find(Outer: UObject, ResourceName: string): SoundFactory;
	static GetDefaultObject(): SoundFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundFactory;
	static C(Other: UObject | any): SoundFactory;
}

declare class ReimportSoundFactory extends SoundFactory { 
	static Load(ResourceName: string): ReimportSoundFactory;
	static Find(Outer: UObject, ResourceName: string): ReimportSoundFactory;
	static GetDefaultObject(): ReimportSoundFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportSoundFactory;
	static C(Other: UObject | any): ReimportSoundFactory;
}

declare type EClusterConnectionTypeEnum = 'Chaos_PointImplicit' | 'Chaos_DelaunayTriangulation' | 'Chaos_MinimalSpanningSubsetDelaunayTriangulation' | 'Chaos_PointImplicitAugmentedWithMinimalDelaunay' | 'Chaos_None' | 'Chaos_EClsuterCreationParameters_Max' | 'Chaos_MAX';
declare var EClusterConnectionTypeEnum : { Chaos_PointImplicit:'Chaos_PointImplicit',Chaos_DelaunayTriangulation:'Chaos_DelaunayTriangulation',Chaos_MinimalSpanningSubsetDelaunayTriangulation:'Chaos_MinimalSpanningSubsetDelaunayTriangulation',Chaos_PointImplicitAugmentedWithMinimalDelaunay:'Chaos_PointImplicitAugmentedWithMinimalDelaunay',Chaos_None:'Chaos_None',Chaos_EClsuterCreationParameters_Max:'Chaos_EClsuterCreationParameters_Max',Chaos_MAX:'Chaos_MAX', };
declare class ChaosDebugSubstepControl { 
	bPause: boolean;
	bSubstep: boolean;
	bStep: boolean;
	clone() : ChaosDebugSubstepControl;
	static C(Other: UObject | any): ChaosDebugSubstepControl;
}

declare class ChaosEventListenerComponent extends ActorComponent { 
	static Load(ResourceName: string): ChaosEventListenerComponent;
	static Find(Outer: UObject, ResourceName: string): ChaosEventListenerComponent;
	static GetDefaultObject(): ChaosEventListenerComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosEventListenerComponent;
	static C(Other: UObject | any): ChaosEventListenerComponent;
}

declare class ChaosGameplayEventDispatcher extends ChaosEventListenerComponent { 
	CollisionEventRegistrations: any;
	BreakEventRegistrations: any;
	RemovalEventRegistrations: any;
	static Load(ResourceName: string): ChaosGameplayEventDispatcher;
	static Find(Outer: UObject, ResourceName: string): ChaosGameplayEventDispatcher;
	static GetDefaultObject(): ChaosGameplayEventDispatcher;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosGameplayEventDispatcher;
	static C(Other: UObject | any): ChaosGameplayEventDispatcher;
}

declare class ChaosSolverActor extends Actor { 
	Properties: ChaosSolverConfiguration;
	TimeStepMultiplier: number;
	CollisionIterations: number;
	PushOutIterations: number;
	PushOutPairIterations: number;
	ClusterConnectionFactor: number;
	ClusterUnionConnectionType: EClusterConnectionTypeEnum;
	DoGenerateCollisionData: boolean;
	CollisionFilterSettings: SolverCollisionFilterSettings;
	DoGenerateBreakingData: boolean;
	BreakingFilterSettings: SolverBreakingFilterSettings;
	DoGenerateTrailingData: boolean;
	TrailingFilterSettings: SolverTrailingFilterSettings;
	MassScale: number;
	bGenerateContactGraph: boolean;
	bHasFloor: boolean;
	FloorHeight: number;
	ChaosDebugSubstepControl: ChaosDebugSubstepControl;
	SpriteComponent: BillboardComponent;
	GameplayEventDispatcherComponent: ChaosGameplayEventDispatcher;
	static GetDefaultObject(): ChaosSolverActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolverActor;
	SetSolverActive(bActive: boolean): void;
	SetAsCurrentWorldSolver(): void;
	static C(Other: UObject | any): ChaosSolverActor;
}

declare class LinuxTargetSettings extends UObject { 
	SpatializationPlugin: string;
	ReverbPlugin: string;
	OcclusionPlugin: string;
	SoundCueCookQualityIndex: number;
	TargetedRHIs: string[];
	static Load(ResourceName: string): LinuxTargetSettings;
	static Find(Outer: UObject, ResourceName: string): LinuxTargetSettings;
	static GetDefaultObject(): LinuxTargetSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinuxTargetSettings;
	static C(Other: UObject | any): LinuxTargetSettings;
}

declare class VirtualizationFilterSettings extends UObject { 
	ExcludePackagePaths: string[];
	static Load(ResourceName: string): VirtualizationFilterSettings;
	static Find(Outer: UObject, ResourceName: string): VirtualizationFilterSettings;
	static GetDefaultObject(): VirtualizationFilterSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VirtualizationFilterSettings;
	static C(Other: UObject | any): VirtualizationFilterSettings;
}

declare class AudioBusFactory extends Factory { 
	static Load(ResourceName: string): AudioBusFactory;
	static Find(Outer: UObject, ResourceName: string): AudioBusFactory;
	static GetDefaultObject(): AudioBusFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioBusFactory;
	static C(Other: UObject | any): AudioBusFactory;
}

declare class AudioEditorSettings extends DeveloperSettings { 
	bPinSoundCueInAssetMenu: boolean;
	bPinSoundCueTemplateInAssetMenu: boolean;
	bPinSoundAttenuationInAssetMenu: boolean;
	bPinSoundConcurrencyInAssetMenu: boolean;
	static Load(ResourceName: string): AudioEditorSettings;
	static Find(Outer: UObject, ResourceName: string): AudioEditorSettings;
	static GetDefaultObject(): AudioEditorSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioEditorSettings;
	static C(Other: UObject | any): AudioEditorSettings;
}

declare class DialogueVoiceFactory extends Factory { 
	static Load(ResourceName: string): DialogueVoiceFactory;
	static Find(Outer: UObject, ResourceName: string): DialogueVoiceFactory;
	static GetDefaultObject(): DialogueVoiceFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DialogueVoiceFactory;
	static C(Other: UObject | any): DialogueVoiceFactory;
}

declare class DialogueWaveFactory extends Factory { 
	InitialSoundWave: SoundWave;
	InitialSpeakerVoice: DialogueVoice;
	HasSetInitialTargetVoice: boolean;
	InitialTargetVoices: DialogueVoice[];
	static Load(ResourceName: string): DialogueWaveFactory;
	static Find(Outer: UObject, ResourceName: string): DialogueWaveFactory;
	static GetDefaultObject(): DialogueWaveFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DialogueWaveFactory;
	static C(Other: UObject | any): DialogueWaveFactory;
}

declare class ReverbEffectFactory extends Factory { 
	static Load(ResourceName: string): ReverbEffectFactory;
	static Find(Outer: UObject, ResourceName: string): ReverbEffectFactory;
	static GetDefaultObject(): ReverbEffectFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReverbEffectFactory;
	static C(Other: UObject | any): ReverbEffectFactory;
}

declare class SoundAttenuationFactory extends Factory { 
	static Load(ResourceName: string): SoundAttenuationFactory;
	static Find(Outer: UObject, ResourceName: string): SoundAttenuationFactory;
	static GetDefaultObject(): SoundAttenuationFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundAttenuationFactory;
	static C(Other: UObject | any): SoundAttenuationFactory;
}

declare class SoundClassFactory extends Factory { 
	static Load(ResourceName: string): SoundClassFactory;
	static Find(Outer: UObject, ResourceName: string): SoundClassFactory;
	static GetDefaultObject(): SoundClassFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClassFactory;
	static C(Other: UObject | any): SoundClassFactory;
}

declare class SoundClassGraph extends EdGraph { 
	static Load(ResourceName: string): SoundClassGraph;
	static Find(Outer: UObject, ResourceName: string): SoundClassGraph;
	static GetDefaultObject(): SoundClassGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClassGraph;
	static C(Other: UObject | any): SoundClassGraph;
}

declare class SoundClassGraphNode extends EdGraphNode { 
	SoundClass: SoundClass;
	static Load(ResourceName: string): SoundClassGraphNode;
	static Find(Outer: UObject, ResourceName: string): SoundClassGraphNode;
	static GetDefaultObject(): SoundClassGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClassGraphNode;
	static C(Other: UObject | any): SoundClassGraphNode;
}

declare class SoundClassGraphSchema extends EdGraphSchema { 
	static Load(ResourceName: string): SoundClassGraphSchema;
	static Find(Outer: UObject, ResourceName: string): SoundClassGraphSchema;
	static GetDefaultObject(): SoundClassGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClassGraphSchema;
	static C(Other: UObject | any): SoundClassGraphSchema;
}

declare class SoundEffectSourcePresetClassTemplate extends ClassTemplate { 
	static Load(ResourceName: string): SoundEffectSourcePresetClassTemplate;
	static Find(Outer: UObject, ResourceName: string): SoundEffectSourcePresetClassTemplate;
	static GetDefaultObject(): SoundEffectSourcePresetClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectSourcePresetClassTemplate;
	static C(Other: UObject | any): SoundEffectSourcePresetClassTemplate;
}

declare class SoundEffectSubmixPresetClassTemplate extends ClassTemplate { 
	static Load(ResourceName: string): SoundEffectSubmixPresetClassTemplate;
	static Find(Outer: UObject, ResourceName: string): SoundEffectSubmixPresetClassTemplate;
	static GetDefaultObject(): SoundEffectSubmixPresetClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectSubmixPresetClassTemplate;
	static C(Other: UObject | any): SoundEffectSubmixPresetClassTemplate;
}

declare class SynthComponentClassTemplate extends ClassTemplate { 
	static Load(ResourceName: string): SynthComponentClassTemplate;
	static Find(Outer: UObject, ResourceName: string): SynthComponentClassTemplate;
	static GetDefaultObject(): SynthComponentClassTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SynthComponentClassTemplate;
	static C(Other: UObject | any): SynthComponentClassTemplate;
}

declare class SoundConcurrencyFactory extends Factory { 
	static Load(ResourceName: string): SoundConcurrencyFactory;
	static Find(Outer: UObject, ResourceName: string): SoundConcurrencyFactory;
	static GetDefaultObject(): SoundConcurrencyFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundConcurrencyFactory;
	static C(Other: UObject | any): SoundConcurrencyFactory;
}

declare class SoundCueFactoryNew extends Factory { 
	InitialSoundWave: SoundWave;
	InitialSoundWaves: any[];
	InitialDialogueWave: DialogueWave;
	InitialDialogueWaves: any[];
	static Load(ResourceName: string): SoundCueFactoryNew;
	static Find(Outer: UObject, ResourceName: string): SoundCueFactoryNew;
	static GetDefaultObject(): SoundCueFactoryNew;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueFactoryNew;
	static C(Other: UObject | any): SoundCueFactoryNew;
}

declare class SoundCueGraph extends EdGraph { 
	static Load(ResourceName: string): SoundCueGraph;
	static Find(Outer: UObject, ResourceName: string): SoundCueGraph;
	static GetDefaultObject(): SoundCueGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraph;
	static C(Other: UObject | any): SoundCueGraph;
}

declare class SoundCueGraphNode_Base extends EdGraphNode { 
	static Load(ResourceName: string): SoundCueGraphNode_Base;
	static Find(Outer: UObject, ResourceName: string): SoundCueGraphNode_Base;
	static GetDefaultObject(): SoundCueGraphNode_Base;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraphNode_Base;
	static C(Other: UObject | any): SoundCueGraphNode_Base;
}

declare class SoundCueGraphNode extends SoundCueGraphNode_Base { 
	SoundNode: SoundNode;
	static Load(ResourceName: string): SoundCueGraphNode;
	static Find(Outer: UObject, ResourceName: string): SoundCueGraphNode;
	static GetDefaultObject(): SoundCueGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraphNode;
	static C(Other: UObject | any): SoundCueGraphNode;
}

declare class SoundCueGraphNode_Root extends SoundCueGraphNode_Base { 
	static Load(ResourceName: string): SoundCueGraphNode_Root;
	static Find(Outer: UObject, ResourceName: string): SoundCueGraphNode_Root;
	static GetDefaultObject(): SoundCueGraphNode_Root;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraphNode_Root;
	static C(Other: UObject | any): SoundCueGraphNode_Root;
}

declare class SoundCueGraphSchema extends EdGraphSchema { 
	static Load(ResourceName: string): SoundCueGraphSchema;
	static Find(Outer: UObject, ResourceName: string): SoundCueGraphSchema;
	static GetDefaultObject(): SoundCueGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundCueGraphSchema;
	static C(Other: UObject | any): SoundCueGraphSchema;
}

declare class SoundMixFactory extends Factory { 
	static Load(ResourceName: string): SoundMixFactory;
	static Find(Outer: UObject, ResourceName: string): SoundMixFactory;
	static GetDefaultObject(): SoundMixFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundMixFactory;
	static C(Other: UObject | any): SoundMixFactory;
}

declare class SoundSourceBusFactory extends Factory { 
	static Load(ResourceName: string): SoundSourceBusFactory;
	static Find(Outer: UObject, ResourceName: string): SoundSourceBusFactory;
	static GetDefaultObject(): SoundSourceBusFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSourceBusFactory;
	static C(Other: UObject | any): SoundSourceBusFactory;
}

declare class SoundSourceEffectFactory extends Factory { 
	SoundEffectSourcepresetClass: UnrealEngineClass;
	static Load(ResourceName: string): SoundSourceEffectFactory;
	static Find(Outer: UObject, ResourceName: string): SoundSourceEffectFactory;
	static GetDefaultObject(): SoundSourceEffectFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSourceEffectFactory;
	static C(Other: UObject | any): SoundSourceEffectFactory;
}

declare class SoundSourceEffectChainFactory extends Factory { 
	static Load(ResourceName: string): SoundSourceEffectChainFactory;
	static Find(Outer: UObject, ResourceName: string): SoundSourceEffectChainFactory;
	static GetDefaultObject(): SoundSourceEffectChainFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSourceEffectChainFactory;
	static C(Other: UObject | any): SoundSourceEffectChainFactory;
}

declare class SoundSubmixEffectFactory extends Factory { 
	SoundEffectSubmixPresetClass: UnrealEngineClass;
	static Load(ResourceName: string): SoundSubmixEffectFactory;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixEffectFactory;
	static GetDefaultObject(): SoundSubmixEffectFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixEffectFactory;
	static C(Other: UObject | any): SoundSubmixEffectFactory;
}

declare class SoundSubmixFactory extends Factory { 
	static Load(ResourceName: string): SoundSubmixFactory;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixFactory;
	static GetDefaultObject(): SoundSubmixFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixFactory;
	static C(Other: UObject | any): SoundSubmixFactory;
}

declare class SoundfieldSubmixFactory extends Factory { 
	static Load(ResourceName: string): SoundfieldSubmixFactory;
	static Find(Outer: UObject, ResourceName: string): SoundfieldSubmixFactory;
	static GetDefaultObject(): SoundfieldSubmixFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldSubmixFactory;
	static C(Other: UObject | any): SoundfieldSubmixFactory;
}

declare class EndpointSubmixFactory extends Factory { 
	static Load(ResourceName: string): EndpointSubmixFactory;
	static Find(Outer: UObject, ResourceName: string): EndpointSubmixFactory;
	static GetDefaultObject(): EndpointSubmixFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EndpointSubmixFactory;
	static C(Other: UObject | any): EndpointSubmixFactory;
}

declare class SoundfieldEndpointSubmixFactory extends Factory { 
	static Load(ResourceName: string): SoundfieldEndpointSubmixFactory;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEndpointSubmixFactory;
	static GetDefaultObject(): SoundfieldEndpointSubmixFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEndpointSubmixFactory;
	static C(Other: UObject | any): SoundfieldEndpointSubmixFactory;
}

declare class SoundSubmixGraph extends EdGraph { 
	RootSoundSubmix: SoundSubmixBase;
	StaleRoots: SoundSubmixBase[];
	static Load(ResourceName: string): SoundSubmixGraph;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixGraph;
	static GetDefaultObject(): SoundSubmixGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixGraph;
	static C(Other: UObject | any): SoundSubmixGraph;
}

declare class SoundSubmixGraphNode extends EdGraphNode { 
	SoundSubmix: SoundSubmixBase;
	SubmixNodeUserWidget: UserWidget;
	static Load(ResourceName: string): SoundSubmixGraphNode;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixGraphNode;
	static GetDefaultObject(): SoundSubmixGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixGraphNode;
	static C(Other: UObject | any): SoundSubmixGraphNode;
}

declare class SoundSubmixGraphSchema extends EdGraphSchema { 
	static Load(ResourceName: string): SoundSubmixGraphSchema;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixGraphSchema;
	static GetDefaultObject(): SoundSubmixGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixGraphSchema;
	static C(Other: UObject | any): SoundSubmixGraphSchema;
}

declare class AnimationModifier extends UObject { 
	RevisionGuid: Guid;
	AppliedGuid: Guid;
	StoredNativeRevision: number;
	PreviouslyAppliedModifier: AnimationModifier;
	static Load(ResourceName: string): AnimationModifier;
	static Find(Outer: UObject, ResourceName: string): AnimationModifier;
	static GetDefaultObject(): AnimationModifier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationModifier;
	OnRevert(AnimationSequence: AnimSequence): void;
	OnApply(AnimationSequence: AnimSequence): void;
	static C(Other: UObject | any): AnimationModifier;
}

declare class AnimationModifiersAssetUserData extends AssetUserData { 
	AnimationModifierInstances: AnimationModifier[];
	static Load(ResourceName: string): AnimationModifiersAssetUserData;
	static Find(Outer: UObject, ResourceName: string): AnimationModifiersAssetUserData;
	static GetDefaultObject(): AnimationModifiersAssetUserData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationModifiersAssetUserData;
	static C(Other: UObject | any): AnimationModifiersAssetUserData;
}

declare class AnimationModifierSettings extends DeveloperSettings { 
	DefaultAnimationModifiers: UnrealEngineClass[];
	bApplyAnimationModifiersOnImport: boolean;
	static Load(ResourceName: string): AnimationModifierSettings;
	static Find(Outer: UObject, ResourceName: string): AnimationModifierSettings;
	static GetDefaultObject(): AnimationModifierSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationModifierSettings;
	static C(Other: UObject | any): AnimationModifierSettings;
}

declare class VariantDependency { 
	VariantSet: VariantSet;
	Variant: Variant;
	bEnabled: boolean;
	clone() : VariantDependency;
	static C(Other: UObject | any): VariantDependency;
}

declare class CapturedPropSegment { 
	PropertyName: string;
	PropertyIndex: number;
	ComponentName: string;
	clone() : CapturedPropSegment;
	static C(Other: UObject | any): CapturedPropSegment;
}

declare type EPropertyValueCategory = 'Undefined' | 'Generic' | 'RelativeLocation' | 'RelativeRotation' | 'RelativeScale3D' | 'Visibility' | 'Material' | 'Color' | 'Option' | 'EPropertyValueCategory_MAX';
declare var EPropertyValueCategory : { Undefined:'Undefined',Generic:'Generic',RelativeLocation:'RelativeLocation',RelativeRotation:'RelativeRotation',RelativeScale3D:'RelativeScale3D',Visibility:'Visibility',Material:'Material',Color:'Color',Option:'Option',EPropertyValueCategory_MAX:'EPropertyValueCategory_MAX', };
declare class PropertyValue extends UObject { 
	Properties: any[];
	PropertyIndices: number[];
	CapturedPropSegments: CapturedPropSegment[];
	FullDisplayString: string;
	PropertySetterName: string;
	PropertySetterParameterDefaults: any;
	bHasRecordedData: boolean;
	LeafPropertyClass: UnrealEngineClass;
	ValueBytes: number[];
	PropCategory: EPropertyValueCategory;
	DisplayOrder: any;
	static Load(ResourceName: string): PropertyValue;
	static Find(Outer: UObject, ResourceName: string): PropertyValue;
	static GetDefaultObject(): PropertyValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValue;
	HasRecordedData(): boolean;
	GetPropertyTooltip(): string;
	GetFullDisplayString(): string;
	static C(Other: UObject | any): PropertyValue;
}

declare class FunctionCaller { 
	FunctionName: string;
	FunctionEntry: any;
	DisplayOrder: any;
	clone() : FunctionCaller;
	static C(Other: UObject | any): FunctionCaller;
}

declare class VariantObjectBinding extends UObject { 
	CachedActorLabel: string;
	ObjectPtr: SoftObjectPath;
	LazyObjectPtr: any;
	CapturedProperties: PropertyValue[];
	FunctionCallers: FunctionCaller[];
	static Load(ResourceName: string): VariantObjectBinding;
	static Find(Outer: UObject, ResourceName: string): VariantObjectBinding;
	static GetDefaultObject(): VariantObjectBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VariantObjectBinding;
	static C(Other: UObject | any): VariantObjectBinding;
}

declare class Variant extends UObject { 
	Dependencies: VariantDependency[];
	DisplayText: string;
	ObjectBindings: VariantObjectBinding[];
	Thumbnail: Texture2D;
	static Load(ResourceName: string): Variant;
	static Find(Outer: UObject, ResourceName: string): Variant;
	static GetDefaultObject(): Variant;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Variant;
	SwitchOn(): void;
	SetThumbnailFromTexture(NewThumbnail: Texture2D): void;
	SetThumbnailFromFile(FilePath: string): void;
	SetThumbnailFromEditorViewport(): void;
	SetThumbnailFromCamera(WorldContextObject: UObject,CameraTransform: Transform,FOVDegrees: number,MinZ: number,Gamma: number): void;
	SetDisplayText(NewDisplayText: string): void;
	SetDependency(index: number,Dependency?: VariantDependency): {Dependency: VariantDependency};
	IsActive(): boolean;
	GetThumbnail(): Texture2D;
	GetParent(): VariantSet;
	GetNumDependencies(): number;
	GetNumActors(): number;
	GetDisplayText(): string;
	GetDependents(LevelVariantSets: LevelVariantSets,bOnlyEnabledDependencies: boolean): Variant[];
	GetDependency(index: number): VariantDependency;
	GetActor(ActorIndex: number): Actor;
	DeleteDependency(index: number): void;
	AddDependency(Dependency?: VariantDependency): {Dependency: VariantDependency, $: number};
	static C(Other: UObject | any): Variant;
}

declare class VariantSet extends UObject { 
	DisplayText: string;
	bExpanded: boolean;
	Variants: Variant[];
	Thumbnail: Texture2D;
	static Load(ResourceName: string): VariantSet;
	static Find(Outer: UObject, ResourceName: string): VariantSet;
	static GetDefaultObject(): VariantSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VariantSet;
	SetThumbnailFromTexture(NewThumbnail: Texture2D): void;
	SetThumbnailFromFile(FilePath: string): void;
	SetThumbnailFromEditorViewport(): void;
	SetThumbnailFromCamera(WorldContextObject: UObject,CameraTransform: Transform,FOVDegrees: number,MinZ: number,Gamma: number): void;
	SetDisplayText(NewDisplayText: string): void;
	GetVariantByName(VariantName: string): Variant;
	GetVariant(VariantIndex: number): Variant;
	GetThumbnail(): Texture2D;
	GetParent(): LevelVariantSets;
	GetNumVariants(): number;
	GetDisplayText(): string;
	static C(Other: UObject | any): VariantSet;
}

declare class LevelVariantSets extends UObject { 
	DirectorBlueprint: UObject;
	DirectorClass: UnrealEngineClass;
	VariantSets: VariantSet[];
	static Load(ResourceName: string): LevelVariantSets;
	static Find(Outer: UObject, ResourceName: string): LevelVariantSets;
	static GetDefaultObject(): LevelVariantSets;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelVariantSets;
	GetVariantSetByName(VariantSetName: string): VariantSet;
	GetVariantSet(VariantSetIndex: number): VariantSet;
	GetNumVariantSets(): number;
	static C(Other: UObject | any): LevelVariantSets;
}

declare class LevelVariantSetsActor extends Actor { 
	LevelVariantSets: SoftObjectPath;
	DirectorInstances: any;
	static GetDefaultObject(): LevelVariantSetsActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelVariantSetsActor;
	SwitchOnVariantByName(VariantSetName: string,VariantName: string): boolean;
	SwitchOnVariantByIndex(VariantSetIndex: number,VariantIndex: number): boolean;
	SetLevelVariantSets(InVariantSets: LevelVariantSets): void;
	GetLevelVariantSets(bLoad: boolean): LevelVariantSets;
	static C(Other: UObject | any): LevelVariantSetsActor;
}

declare class LevelVariantSetsFunctionDirector extends UObject { 
	static Load(ResourceName: string): LevelVariantSetsFunctionDirector;
	static Find(Outer: UObject, ResourceName: string): LevelVariantSetsFunctionDirector;
	static GetDefaultObject(): LevelVariantSetsFunctionDirector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelVariantSetsFunctionDirector;
	static C(Other: UObject | any): LevelVariantSetsFunctionDirector;
}

declare class PropertyValueTransform extends PropertyValue { 
	static Load(ResourceName: string): PropertyValueTransform;
	static Find(Outer: UObject, ResourceName: string): PropertyValueTransform;
	static GetDefaultObject(): PropertyValueTransform;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValueTransform;
	static C(Other: UObject | any): PropertyValueTransform;
}

declare class PropertyValueVisibility extends PropertyValue { 
	static Load(ResourceName: string): PropertyValueVisibility;
	static Find(Outer: UObject, ResourceName: string): PropertyValueVisibility;
	static GetDefaultObject(): PropertyValueVisibility;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValueVisibility;
	static C(Other: UObject | any): PropertyValueVisibility;
}

declare class PropertyValueColor extends PropertyValue { 
	static Load(ResourceName: string): PropertyValueColor;
	static Find(Outer: UObject, ResourceName: string): PropertyValueColor;
	static GetDefaultObject(): PropertyValueColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValueColor;
	static C(Other: UObject | any): PropertyValueColor;
}

declare class PropertyValueMaterial extends PropertyValue { 
	static Load(ResourceName: string): PropertyValueMaterial;
	static Find(Outer: UObject, ResourceName: string): PropertyValueMaterial;
	static GetDefaultObject(): PropertyValueMaterial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValueMaterial;
	static C(Other: UObject | any): PropertyValueMaterial;
}

declare class PropertyValueOption extends PropertyValue { 
	static Load(ResourceName: string): PropertyValueOption;
	static Find(Outer: UObject, ResourceName: string): PropertyValueOption;
	static GetDefaultObject(): PropertyValueOption;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValueOption;
	static C(Other: UObject | any): PropertyValueOption;
}

declare class PropertyValueSoftObject extends PropertyValue { 
	static Load(ResourceName: string): PropertyValueSoftObject;
	static Find(Outer: UObject, ResourceName: string): PropertyValueSoftObject;
	static GetDefaultObject(): PropertyValueSoftObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyValueSoftObject;
	static C(Other: UObject | any): PropertyValueSoftObject;
}

declare class SwitchActor extends Actor { 
	SceneComponent: SceneComponent;
	LastSelectedOption: number;
	static GetDefaultObject(): SwitchActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SwitchActor;
	SelectOption(OptionIndex: number): void;
	GetSelectedOption(): number;
	GetOptions(): Actor[];
	static C(Other: UObject | any): SwitchActor;
}

declare type EClothMassMode = 'UniformMass' | 'TotalMass' | 'Density' | 'MaxClothMassMode' | 'EClothMassMode_MAX';
declare var EClothMassMode : { UniformMass:'UniformMass',TotalMass:'TotalMass',Density:'Density',MaxClothMassMode:'MaxClothMassMode',EClothMassMode_MAX:'EClothMassMode_MAX', };
declare class ChaosClothWeightedValue { 
	Low: number;
	High: number;
	clone() : ChaosClothWeightedValue;
	static C(Other: UObject | any): ChaosClothWeightedValue;
}

declare type EChaosClothTetherMode = 'FastTetherFastLength' | 'AccurateTetherFastLength' | 'AccurateTetherAccurateLength' | 'MaxChaosClothTetherMode' | 'EChaosClothTetherMode_MAX';
declare var EChaosClothTetherMode : { FastTetherFastLength:'FastTetherFastLength',AccurateTetherFastLength:'AccurateTetherFastLength',AccurateTetherAccurateLength:'AccurateTetherAccurateLength',MaxChaosClothTetherMode:'MaxChaosClothTetherMode',EChaosClothTetherMode_MAX:'EChaosClothTetherMode_MAX', };
declare class ChaosClothConfig extends ClothConfigCommon { 
	MassMode: EClothMassMode;
	UniformMass: number;
	TotalMass: number;
	Density: number;
	MinPerParticleMass: number;
	EdgeStiffnessWeighted: ChaosClothWeightedValue;
	BendingStiffnessWeighted: ChaosClothWeightedValue;
	bUseBendingElements: boolean;
	AreaStiffnessWeighted: ChaosClothWeightedValue;
	VolumeStiffness: number;
	TetherStiffness: ChaosClothWeightedValue;
	TetherScale: ChaosClothWeightedValue;
	bUseGeodesicDistance: boolean;
	ShapeTargetStiffness: number;
	CollisionThickness: number;
	FrictionCoefficient: number;
	bUseCCD: boolean;
	bUseSelfCollisions: boolean;
	SelfCollisionThickness: number;
	bUseLegacyBackstop: boolean;
	DampingCoefficient: number;
	LocalDampingCoefficient: number;
	bUsePointBasedWindModel: boolean;
	Drag: ChaosClothWeightedValue;
	Lift: ChaosClothWeightedValue;
	bUseGravityOverride: boolean;
	GravityScale: number;
	Gravity: Vector;
	AnimDriveStiffness: ChaosClothWeightedValue;
	AnimDriveDamping: ChaosClothWeightedValue;
	LinearVelocityScale: Vector;
	AngularVelocityScale: number;
	FictitiousAngularScale: number;
	bUseTetrahedralConstraints: boolean;
	bUseThinShellVolumeConstraints: boolean;
	bUseContinuousCollisionDetection: boolean;
	EdgeStiffness: number;
	BendingStiffness: number;
	AreaStiffness: number;
	TetherMode: EChaosClothTetherMode;
	LimitScale: number;
	DragCoefficient: number;
	LiftCoefficient: number;
	AnimDriveSpringStiffness: number;
	StrainLimitingStiffness: number;
	static Load(ResourceName: string): ChaosClothConfig;
	static Find(Outer: UObject, ResourceName: string): ChaosClothConfig;
	static GetDefaultObject(): ChaosClothConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosClothConfig;
	static C(Other: UObject | any): ChaosClothConfig;
}

declare class ChaosClothSharedSimConfig extends ClothSharedConfigCommon { 
	IterationCount: number;
	MaxIterationCount: number;
	SubdivisionCount: number;
	SelfCollisionThickness: number;
	CollisionThickness: number;
	bUseDampingOverride: boolean;
	Damping: number;
	bUseGravityOverride: boolean;
	GravityScale: number;
	Gravity: Vector;
	bUseLocalSpaceSimulation: boolean;
	bUseXPBDConstraints: boolean;
	static Load(ResourceName: string): ChaosClothSharedSimConfig;
	static Find(Outer: UObject, ResourceName: string): ChaosClothSharedSimConfig;
	static GetDefaultObject(): ChaosClothSharedSimConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosClothSharedSimConfig;
	static C(Other: UObject | any): ChaosClothSharedSimConfig;
}

declare class ChaosClothingSimulationFactory extends ClothingSimulationFactory { 
	static Load(ResourceName: string): ChaosClothingSimulationFactory;
	static Find(Outer: UObject, ResourceName: string): ChaosClothingSimulationFactory;
	static GetDefaultObject(): ChaosClothingSimulationFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosClothingSimulationFactory;
	static C(Other: UObject | any): ChaosClothingSimulationFactory;
}

declare class ChaosClothingInteractor extends ClothingInteractor { 
	static Load(ResourceName: string): ChaosClothingInteractor;
	static Find(Outer: UObject, ResourceName: string): ChaosClothingInteractor;
	static GetDefaultObject(): ChaosClothingInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosClothingInteractor;
	SetWind(Drag: Vector2D,Lift: Vector2D,AirDensity: number,WindVelocity: Vector): void;
	SetVelocityScale(LinearVelocityScale: Vector,AngularVelocityScale: number,FictitiousAngularScale: number): void;
	SetMaterialLinear(EdgeStiffness: number,BendingStiffness: number,AreaStiffness: number): void;
	SetMaterial(EdgeStiffness: Vector2D,BendingStiffness: Vector2D,AreaStiffness: Vector2D): void;
	SetLongRangeAttachmentLinear(TetherStiffness: number,TetherScale: number): void;
	SetLongRangeAttachment(TetherStiffness: Vector2D,TetherScale: Vector2D): void;
	SetGravity(GravityScale: number,bIsGravityOverridden: boolean,GravityOverride: Vector): void;
	SetDamping(DampingCoefficient: number): void;
	SetCollision(CollisionThickness: number,FrictionCoefficient: number,bUseCCD: boolean,SelfCollisionThickness: number): void;
	SetBackstop(bEnabled: boolean): void;
	SetAnimDriveLinear(AnimDriveStiffness: number): void;
	SetAnimDrive(AnimDriveStiffness: Vector2D,AnimDriveDamping: Vector2D): void;
	SetAerodynamics(DragCoefficient: number,LiftCoefficient: number,WindVelocity: Vector): void;
	ResetAndTeleport(bReset: boolean,bTeleport: boolean): void;
	static C(Other: UObject | any): ChaosClothingInteractor;
}

declare class ChaosClothingSimulationInteractor extends ClothingSimulationInteractor { 
	static Load(ResourceName: string): ChaosClothingSimulationInteractor;
	static Find(Outer: UObject, ResourceName: string): ChaosClothingSimulationInteractor;
	static GetDefaultObject(): ChaosClothingSimulationInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosClothingSimulationInteractor;
	static C(Other: UObject | any): ChaosClothingSimulationInteractor;
}

declare class MovieSceneNiagaraTrack extends MovieSceneNameableTrack { 
	Sections: MovieSceneSection[];
	static Load(ResourceName: string): MovieSceneNiagaraTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneNiagaraTrack;
	static GetDefaultObject(): MovieSceneNiagaraTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneNiagaraTrack;
	static C(Other: UObject | any): MovieSceneNiagaraTrack;
}

declare class MovieSceneNiagaraParameterTrack extends MovieSceneNiagaraTrack { 
	Parameter: NiagaraVariable;
	static Load(ResourceName: string): MovieSceneNiagaraParameterTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneNiagaraParameterTrack;
	static GetDefaultObject(): MovieSceneNiagaraParameterTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneNiagaraParameterTrack;
	static C(Other: UObject | any): MovieSceneNiagaraParameterTrack;
}

declare class MovieSceneNiagaraBoolParameterTrack extends MovieSceneNiagaraParameterTrack { 
	static Load(ResourceName: string): MovieSceneNiagaraBoolParameterTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneNiagaraBoolParameterTrack;
	static GetDefaultObject(): MovieSceneNiagaraBoolParameterTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneNiagaraBoolParameterTrack;
	static C(Other: UObject | any): MovieSceneNiagaraBoolParameterTrack;
}

declare class MovieSceneNiagaraColorParameterTrack extends MovieSceneNiagaraParameterTrack { 
	static Load(ResourceName: string): MovieSceneNiagaraColorParameterTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneNiagaraColorParameterTrack;
	static GetDefaultObject(): MovieSceneNiagaraColorParameterTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneNiagaraColorParameterTrack;
	static C(Other: UObject | any): MovieSceneNiagaraColorParameterTrack;
}

declare class MovieSceneNiagaraFloatParameterTrack extends MovieSceneNiagaraParameterTrack { 
	static Load(ResourceName: string): MovieSceneNiagaraFloatParameterTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneNiagaraFloatParameterTrack;
	static GetDefaultObject(): MovieSceneNiagaraFloatParameterTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneNiagaraFloatParameterTrack;
	static C(Other: UObject | any): MovieSceneNiagaraFloatParameterTrack;
}

declare class MovieSceneNiagaraIntegerParameterTrack extends MovieSceneNiagaraParameterTrack { 
	static Load(ResourceName: string): MovieSceneNiagaraIntegerParameterTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneNiagaraIntegerParameterTrack;
	static GetDefaultObject(): MovieSceneNiagaraIntegerParameterTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneNiagaraIntegerParameterTrack;
	static C(Other: UObject | any): MovieSceneNiagaraIntegerParameterTrack;
}

declare type ENiagaraSystemSpawnSectionStartBehavior = 'Activate' | 'ENiagaraSystemSpawnSectionStartBehavior_MAX';
declare var ENiagaraSystemSpawnSectionStartBehavior : { Activate:'Activate',ENiagaraSystemSpawnSectionStartBehavior_MAX:'ENiagaraSystemSpawnSectionStartBehavior_MAX', };
declare type ENiagaraSystemSpawnSectionEvaluateBehavior = 'ActivateIfInactive' | 'None' | 'ENiagaraSystemSpawnSectionEvaluateBehavior_MAX';
declare var ENiagaraSystemSpawnSectionEvaluateBehavior : { ActivateIfInactive:'ActivateIfInactive',None:'None',ENiagaraSystemSpawnSectionEvaluateBehavior_MAX:'ENiagaraSystemSpawnSectionEvaluateBehavior_MAX', };
declare type ENiagaraSystemSpawnSectionEndBehavior = 'SetSystemInactive' | 'Deactivate' | 'None' | 'ENiagaraSystemSpawnSectionEndBehavior_MAX';
declare var ENiagaraSystemSpawnSectionEndBehavior : { SetSystemInactive:'SetSystemInactive',Deactivate:'Deactivate',None:'None',ENiagaraSystemSpawnSectionEndBehavior_MAX:'ENiagaraSystemSpawnSectionEndBehavior_MAX', };
declare class MovieSceneNiagaraSystemSpawnSection extends MovieSceneSection { 
	SectionStartBehavior: ENiagaraSystemSpawnSectionStartBehavior;
	SectionEvaluateBehavior: ENiagaraSystemSpawnSectionEvaluateBehavior;
	SectionEndBehavior: ENiagaraSystemSpawnSectionEndBehavior;
	AgeUpdateMode: ENiagaraAgeUpdateMode;
	bAllowScalability: boolean;
	static Load(ResourceName: string): MovieSceneNiagaraSystemSpawnSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneNiagaraSystemSpawnSection;
	static GetDefaultObject(): MovieSceneNiagaraSystemSpawnSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneNiagaraSystemSpawnSection;
	static C(Other: UObject | any): MovieSceneNiagaraSystemSpawnSection;
}

declare class MovieSceneNiagaraSystemTrack extends MovieSceneNiagaraTrack { 
	static Load(ResourceName: string): MovieSceneNiagaraSystemTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneNiagaraSystemTrack;
	static GetDefaultObject(): MovieSceneNiagaraSystemTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneNiagaraSystemTrack;
	static C(Other: UObject | any): MovieSceneNiagaraSystemTrack;
}

declare class MovieSceneNiagaraVectorParameterTrack extends MovieSceneNiagaraParameterTrack { 
	ChannelsUsed: number;
	static Load(ResourceName: string): MovieSceneNiagaraVectorParameterTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneNiagaraVectorParameterTrack;
	static GetDefaultObject(): MovieSceneNiagaraVectorParameterTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneNiagaraVectorParameterTrack;
	static C(Other: UObject | any): MovieSceneNiagaraVectorParameterTrack;
}

declare class NiagaraActor extends Actor { 
	NiagaraComponent: NiagaraComponent;
	SpriteComponent: BillboardComponent;
	ArrowComponent: ArrowComponent;
	bDestroyOnSystemFinish: boolean;
	static GetDefaultObject(): NiagaraActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraActor;
	SetDestroyOnSystemFinish(bShouldDestroyOnSystemFinish: boolean): void;
	OnNiagaraSystemFinished(FinishedComponent: NiagaraComponent): void;
	static C(Other: UObject | any): NiagaraActor;
}

declare class NiagaraComponentPool extends UObject { 
	WorldParticleSystemPools: any;
	static Load(ResourceName: string): NiagaraComponentPool;
	static Find(Outer: UObject, ResourceName: string): NiagaraComponentPool;
	static GetDefaultObject(): NiagaraComponentPool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraComponentPool;
	static C(Other: UObject | any): NiagaraComponentPool;
}

declare class NiagaraComponentPropertyBinding { 
	AttributeBinding: NiagaraVariableAttributeBinding;
	PropertyName: string;
	PropertyType: NiagaraTypeDefinition;
	MetadataSetterName: string;
	PropertySetterParameterDefaults: any;
	WritableValue: NiagaraVariable;
	clone() : NiagaraComponentPropertyBinding;
	static C(Other: UObject | any): NiagaraComponentPropertyBinding;
}

declare class NiagaraComponentRendererProperties extends NiagaraRendererProperties { 
	ComponentType: UnrealEngineClass;
	ComponentCountLimit: any;
	EnabledBinding: NiagaraVariableAttributeBinding;
	RendererVisibilityTagBinding: NiagaraVariableAttributeBinding;
	bAssignComponentsOnParticleID: boolean;
	bOnlyCreateComponentsOnParticleSpawn: boolean;
	bOnlyActivateNewlyAquiredComponents: boolean;
	bVisualizeComponents: boolean;
	RendererVisibility: number;
	TemplateComponent: SceneComponent;
	PropertyBindings: NiagaraComponentPropertyBinding[];
	static Load(ResourceName: string): NiagaraComponentRendererProperties;
	static Find(Outer: UObject, ResourceName: string): NiagaraComponentRendererProperties;
	static GetDefaultObject(): NiagaraComponentRendererProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraComponentRendererProperties;
	static C(Other: UObject | any): NiagaraComponentRendererProperties;
}

declare class NiagaraComponentSettings extends UObject { 
	SuppressActivationList: any;
	ForceAutoPooolingList: any;
	SuppressEmitterList: any;
	GPUEmitterAllowList: any;
	GpuDataInterfaceDenyList: any;
	static Load(ResourceName: string): NiagaraComponentSettings;
	static Find(Outer: UObject, ResourceName: string): NiagaraComponentSettings;
	static GetDefaultObject(): NiagaraComponentSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraComponentSettings;
	static C(Other: UObject | any): NiagaraComponentSettings;
}

declare class NiagaraUserParameterBinding { 
	Parameter: NiagaraVariable;
	clone() : NiagaraUserParameterBinding;
	static C(Other: UObject | any): NiagaraUserParameterBinding;
}

declare class NiagaraDataInterface2DArrayTexture extends NiagaraDataInterface { 
	Texture: Texture2DArray;
	TextureUserParameter: NiagaraUserParameterBinding;
	static Load(ResourceName: string): NiagaraDataInterface2DArrayTexture;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterface2DArrayTexture;
	static GetDefaultObject(): NiagaraDataInterface2DArrayTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterface2DArrayTexture;
	static C(Other: UObject | any): NiagaraDataInterface2DArrayTexture;
}

declare class NiagaraDataInterfaceActorComponent extends NiagaraDataInterface { 
	bRequireCurrentFrameData: boolean;
	SourceActor: any;
	ActorOrComponentParameter: NiagaraUserParameterBinding;
	static Load(ResourceName: string): NiagaraDataInterfaceActorComponent;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceActorComponent;
	static GetDefaultObject(): NiagaraDataInterfaceActorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceActorComponent;
	static C(Other: UObject | any): NiagaraDataInterfaceActorComponent;
}

declare class NiagaraDataInterfaceRWBase extends NiagaraDataInterface { 
	static Load(ResourceName: string): NiagaraDataInterfaceRWBase;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceRWBase;
	static GetDefaultObject(): NiagaraDataInterfaceRWBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceRWBase;
	static C(Other: UObject | any): NiagaraDataInterfaceRWBase;
}

declare type ENiagaraGpuSyncMode = 'None' | 'SyncCpuToGpu' | 'SyncGpuToCpu' | 'SyncBoth' | 'ENiagaraGpuSyncMode_MAX';
declare var ENiagaraGpuSyncMode : { None:'None',SyncCpuToGpu:'SyncCpuToGpu',SyncGpuToCpu:'SyncGpuToCpu',SyncBoth:'SyncBoth',ENiagaraGpuSyncMode_MAX:'ENiagaraGpuSyncMode_MAX', };
declare class NiagaraDataInterfaceArray extends NiagaraDataInterfaceRWBase { 
	GpuSyncMode: ENiagaraGpuSyncMode;
	MaxElements: number;
	static Load(ResourceName: string): NiagaraDataInterfaceArray;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceArray;
	static GetDefaultObject(): NiagaraDataInterfaceArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceArray;
	static C(Other: UObject | any): NiagaraDataInterfaceArray;
}

declare class NiagaraDataInterfaceArrayFloat extends NiagaraDataInterfaceArray { 
	FloatData: number[];
	static Load(ResourceName: string): NiagaraDataInterfaceArrayFloat;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceArrayFloat;
	static GetDefaultObject(): NiagaraDataInterfaceArrayFloat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceArrayFloat;
	static C(Other: UObject | any): NiagaraDataInterfaceArrayFloat;
}

declare class NiagaraDataInterfaceArrayFloat2 extends NiagaraDataInterfaceArray { 
	FloatData: Vector2D[];
	static Load(ResourceName: string): NiagaraDataInterfaceArrayFloat2;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceArrayFloat2;
	static GetDefaultObject(): NiagaraDataInterfaceArrayFloat2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceArrayFloat2;
	static C(Other: UObject | any): NiagaraDataInterfaceArrayFloat2;
}

declare class NiagaraDataInterfaceArrayFloat3 extends NiagaraDataInterfaceArray { 
	FloatData: Vector[];
	static Load(ResourceName: string): NiagaraDataInterfaceArrayFloat3;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceArrayFloat3;
	static GetDefaultObject(): NiagaraDataInterfaceArrayFloat3;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceArrayFloat3;
	static C(Other: UObject | any): NiagaraDataInterfaceArrayFloat3;
}

declare class NiagaraPosition extends Vector3f { 
	clone() : NiagaraPosition;
	static C(Other: UObject | any): NiagaraPosition;
}

declare class NiagaraDataInterfaceArrayPosition extends NiagaraDataInterfaceArray { 
	PositionData: NiagaraPosition[];
	static Load(ResourceName: string): NiagaraDataInterfaceArrayPosition;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceArrayPosition;
	static GetDefaultObject(): NiagaraDataInterfaceArrayPosition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceArrayPosition;
	static C(Other: UObject | any): NiagaraDataInterfaceArrayPosition;
}

declare class NiagaraDataInterfaceArrayFloat4 extends NiagaraDataInterfaceArray { 
	FloatData: Vector4[];
	static Load(ResourceName: string): NiagaraDataInterfaceArrayFloat4;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceArrayFloat4;
	static GetDefaultObject(): NiagaraDataInterfaceArrayFloat4;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceArrayFloat4;
	static C(Other: UObject | any): NiagaraDataInterfaceArrayFloat4;
}

declare class NiagaraDataInterfaceArrayColor extends NiagaraDataInterfaceArray { 
	ColorData: LinearColor[];
	static Load(ResourceName: string): NiagaraDataInterfaceArrayColor;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceArrayColor;
	static GetDefaultObject(): NiagaraDataInterfaceArrayColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceArrayColor;
	static C(Other: UObject | any): NiagaraDataInterfaceArrayColor;
}

declare class NiagaraDataInterfaceArrayQuat extends NiagaraDataInterfaceArray { 
	QuatData: Quat[];
	static Load(ResourceName: string): NiagaraDataInterfaceArrayQuat;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceArrayQuat;
	static GetDefaultObject(): NiagaraDataInterfaceArrayQuat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceArrayQuat;
	static C(Other: UObject | any): NiagaraDataInterfaceArrayQuat;
}

declare class NiagaraDataInterfaceArrayFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): NiagaraDataInterfaceArrayFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceArrayFunctionLibrary;
	static GetDefaultObject(): NiagaraDataInterfaceArrayFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceArrayFunctionLibrary;
	static SetNiagaraArrayVectorValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: Vector,bSizeToFit: boolean): void;
	static SetNiagaraArrayVector4Value(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: Vector4,bSizeToFit: boolean): void;
	static SetNiagaraArrayVector4(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: Vector4[]): void;
	static SetNiagaraArrayVector2DValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: Vector2D,bSizeToFit: boolean): void;
	static SetNiagaraArrayVector2D(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: Vector2D[]): void;
	static SetNiagaraArrayVector(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: Vector[]): void;
	static SetNiagaraArrayQuatValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: Quat,bSizeToFit: boolean): void;
	static SetNiagaraArrayQuat(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: Quat[]): void;
	static SetNiagaraArrayPositionValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: Vector,bSizeToFit: boolean): void;
	static SetNiagaraArrayPosition(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: Vector[]): void;
	static SetNiagaraArrayInt32Value(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: number,bSizeToFit: boolean): void;
	static SetNiagaraArrayInt32(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: number[]): void;
	static SetNiagaraArrayFloatValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: number,bSizeToFit: boolean): void;
	static SetNiagaraArrayFloat(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: number[]): void;
	static SetNiagaraArrayColorValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: LinearColor,bSizeToFit: boolean): void;
	static SetNiagaraArrayColor(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: LinearColor[]): void;
	static SetNiagaraArrayBoolValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: boolean,bSizeToFit: boolean): void;
	static SetNiagaraArrayBool(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: boolean[]): void;
	static GetNiagaraArrayVectorValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): Vector;
	static GetNiagaraArrayVector4Value(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): Vector4;
	static GetNiagaraArrayVector4(NiagaraSystem: NiagaraComponent,OverrideName: string): Vector4[];
	static GetNiagaraArrayVector2DValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): Vector2D;
	static GetNiagaraArrayVector2D(NiagaraSystem: NiagaraComponent,OverrideName: string): Vector2D[];
	static GetNiagaraArrayVector(NiagaraSystem: NiagaraComponent,OverrideName: string): Vector[];
	static GetNiagaraArrayQuatValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): Quat;
	static GetNiagaraArrayQuat(NiagaraSystem: NiagaraComponent,OverrideName: string): Quat[];
	static GetNiagaraArrayPositionValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): Vector;
	static GetNiagaraArrayPosition(NiagaraSystem: NiagaraComponent,OverrideName: string): Vector[];
	static GetNiagaraArrayInt32Value(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): number;
	static GetNiagaraArrayInt32(NiagaraSystem: NiagaraComponent,OverrideName: string): number[];
	static GetNiagaraArrayFloatValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): number;
	static GetNiagaraArrayFloat(NiagaraSystem: NiagaraComponent,OverrideName: string): number[];
	static GetNiagaraArrayColorValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): LinearColor;
	static GetNiagaraArrayColor(NiagaraSystem: NiagaraComponent,OverrideName: string): LinearColor[];
	static GetNiagaraArrayBoolValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): boolean;
	static GetNiagaraArrayBool(NiagaraSystem: NiagaraComponent,OverrideName: string): boolean[];
	static C(Other: UObject | any): NiagaraDataInterfaceArrayFunctionLibrary;
}

declare class NiagaraDataInterfaceArrayInt32 extends NiagaraDataInterfaceArray { 
	IntData: number[];
	static Load(ResourceName: string): NiagaraDataInterfaceArrayInt32;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceArrayInt32;
	static GetDefaultObject(): NiagaraDataInterfaceArrayInt32;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceArrayInt32;
	static C(Other: UObject | any): NiagaraDataInterfaceArrayInt32;
}

declare class NiagaraDataInterfaceArrayBool extends NiagaraDataInterfaceArray { 
	BoolData: boolean[];
	static Load(ResourceName: string): NiagaraDataInterfaceArrayBool;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceArrayBool;
	static GetDefaultObject(): NiagaraDataInterfaceArrayBool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceArrayBool;
	static C(Other: UObject | any): NiagaraDataInterfaceArrayBool;
}

declare class NiagaraID { 
	index: number;
	AcquireTag: number;
	clone() : NiagaraID;
	static C(Other: UObject | any): NiagaraID;
}

declare class NiagaraDataInterfaceArrayNiagaraID extends NiagaraDataInterfaceArray { 
	IntData: NiagaraID[];
	static Load(ResourceName: string): NiagaraDataInterfaceArrayNiagaraID;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceArrayNiagaraID;
	static GetDefaultObject(): NiagaraDataInterfaceArrayNiagaraID;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceArrayNiagaraID;
	static C(Other: UObject | any): NiagaraDataInterfaceArrayNiagaraID;
}

declare type ENDICollisionQuery_AsyncGpuTraceProvider = 'Default' | 'HWRT' | 'GSDF' | 'None' | 'ENDICollisionQuery_MAX';
declare var ENDICollisionQuery_AsyncGpuTraceProvider : { Default:'Default',HWRT:'HWRT',GSDF:'GSDF',None:'None',ENDICollisionQuery_MAX:'ENDICollisionQuery_MAX', };
declare class NiagaraDataInterfaceAsyncGpuTrace extends NiagaraDataInterface { 
	MaxTracesPerParticle: number;
	MaxRetraces: number;
	TraceProvider: ENDICollisionQuery_AsyncGpuTraceProvider;
	static Load(ResourceName: string): NiagaraDataInterfaceAsyncGpuTrace;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceAsyncGpuTrace;
	static GetDefaultObject(): NiagaraDataInterfaceAsyncGpuTrace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceAsyncGpuTrace;
	static C(Other: UObject | any): NiagaraDataInterfaceAsyncGpuTrace;
}

declare class NiagaraDataInterfaceAudioSubmix extends NiagaraDataInterface { 
	Submix: SoundSubmix;
	static Load(ResourceName: string): NiagaraDataInterfaceAudioSubmix;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceAudioSubmix;
	static GetDefaultObject(): NiagaraDataInterfaceAudioSubmix;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceAudioSubmix;
	static C(Other: UObject | any): NiagaraDataInterfaceAudioSubmix;
}

declare class NiagaraDataInterfaceAudioOscilloscope extends NiagaraDataInterface { 
	Submix: SoundSubmix;
	Resolution: number;
	ScopeInMilliseconds: number;
	static Load(ResourceName: string): NiagaraDataInterfaceAudioOscilloscope;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceAudioOscilloscope;
	static GetDefaultObject(): NiagaraDataInterfaceAudioOscilloscope;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceAudioOscilloscope;
	static C(Other: UObject | any): NiagaraDataInterfaceAudioOscilloscope;
}

declare class NiagaraDataInterfaceAudioPlayer extends NiagaraDataInterface { 
	SoundToPlay: SoundBase;
	Attenuation: SoundAttenuation;
	Concurrency: SoundConcurrency;
	ParameterNames: string[];
	bLimitPlaysPerTick: boolean;
	MaxPlaysPerTick: number;
	bStopWhenComponentIsDestroyed: boolean;
	bOnlyActiveDuringGameplay: boolean;
	static Load(ResourceName: string): NiagaraDataInterfaceAudioPlayer;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceAudioPlayer;
	static GetDefaultObject(): NiagaraDataInterfaceAudioPlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceAudioPlayer;
	static C(Other: UObject | any): NiagaraDataInterfaceAudioPlayer;
}

declare class NiagaraDataInterfaceAudioSpectrum extends NiagaraDataInterfaceAudioSubmix { 
	Resolution: number;
	MinimumFrequency: number;
	MaximumFrequency: number;
	NoiseFloorDb: number;
	static Load(ResourceName: string): NiagaraDataInterfaceAudioSpectrum;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceAudioSpectrum;
	static GetDefaultObject(): NiagaraDataInterfaceAudioSpectrum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceAudioSpectrum;
	static C(Other: UObject | any): NiagaraDataInterfaceAudioSpectrum;
}

declare class NiagaraDataInterfaceCamera extends NiagaraDataInterface { 
	PlayerControllerIndex: number;
	bRequireCurrentFrameData: boolean;
	static Load(ResourceName: string): NiagaraDataInterfaceCamera;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceCamera;
	static GetDefaultObject(): NiagaraDataInterfaceCamera;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceCamera;
	static C(Other: UObject | any): NiagaraDataInterfaceCamera;
}

declare class NiagaraDataInterfaceCollisionQuery extends NiagaraDataInterface { 
	static Load(ResourceName: string): NiagaraDataInterfaceCollisionQuery;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceCollisionQuery;
	static GetDefaultObject(): NiagaraDataInterfaceCollisionQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceCollisionQuery;
	static C(Other: UObject | any): NiagaraDataInterfaceCollisionQuery;
}

declare class NiagaraDataInterfaceCurveBase extends NiagaraDataInterface { 
	ShaderLUT: number[];
	LUTMinTime: number;
	LUTMaxTime: number;
	LUTInvTimeRange: number;
	LUTNumSamplesMinusOne: number;
	bUseLUT: boolean;
	bExposeCurve: boolean;
	bOptimizeLUT: boolean;
	bOverrideOptimizeThreshold: boolean;
	HasEditorData: boolean;
	OptimizeThreshold: number;
	ExposedName: string;
	ExposedTexture: Texture2D;
	static Load(ResourceName: string): NiagaraDataInterfaceCurveBase;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceCurveBase;
	static GetDefaultObject(): NiagaraDataInterfaceCurveBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceCurveBase;
	static C(Other: UObject | any): NiagaraDataInterfaceCurveBase;
}

declare class NiagaraDataInterfaceColorCurve extends NiagaraDataInterfaceCurveBase { 
	RedCurve: RichCurve;
	GreenCurve: RichCurve;
	BlueCurve: RichCurve;
	AlphaCurve: RichCurve;
	static Load(ResourceName: string): NiagaraDataInterfaceColorCurve;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceColorCurve;
	static GetDefaultObject(): NiagaraDataInterfaceColorCurve;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceColorCurve;
	static C(Other: UObject | any): NiagaraDataInterfaceColorCurve;
}

declare class NiagaraDataInterfaceCubeTexture extends NiagaraDataInterface { 
	Texture: TextureCube;
	TextureUserParameter: NiagaraUserParameterBinding;
	static Load(ResourceName: string): NiagaraDataInterfaceCubeTexture;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceCubeTexture;
	static GetDefaultObject(): NiagaraDataInterfaceCubeTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceCubeTexture;
	static C(Other: UObject | any): NiagaraDataInterfaceCubeTexture;
}

declare class NiagaraDataInterfaceCurlNoise extends NiagaraDataInterface { 
	Seed: any;
	static Load(ResourceName: string): NiagaraDataInterfaceCurlNoise;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceCurlNoise;
	static GetDefaultObject(): NiagaraDataInterfaceCurlNoise;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceCurlNoise;
	static C(Other: UObject | any): NiagaraDataInterfaceCurlNoise;
}

declare class NiagaraDataInterfaceCurve extends NiagaraDataInterfaceCurveBase { 
	Curve: RichCurve;
	static Load(ResourceName: string): NiagaraDataInterfaceCurve;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceCurve;
	static GetDefaultObject(): NiagaraDataInterfaceCurve;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceCurve;
	static C(Other: UObject | any): NiagaraDataInterfaceCurve;
}

declare class NiagaraDataInterfaceDebugDraw extends NiagaraDataInterface { 
	OverrideMaxLineInstances: any;
	static Load(ResourceName: string): NiagaraDataInterfaceDebugDraw;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceDebugDraw;
	static GetDefaultObject(): NiagaraDataInterfaceDebugDraw;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceDebugDraw;
	static C(Other: UObject | any): NiagaraDataInterfaceDebugDraw;
}

declare type ENiagaraDataInterfaceEmitterBindingMode = 'Self' | 'Other' | 'ENiagaraDataInterfaceEmitterBindingMode_MAX';
declare var ENiagaraDataInterfaceEmitterBindingMode : { Self:'Self',Other:'Other',ENiagaraDataInterfaceEmitterBindingMode_MAX:'ENiagaraDataInterfaceEmitterBindingMode_MAX', };
declare class NiagaraDataInterfaceEmitterBinding { 
	BindingMode: ENiagaraDataInterfaceEmitterBindingMode;
	EmitterName: string;
	clone() : NiagaraDataInterfaceEmitterBinding;
	static C(Other: UObject | any): NiagaraDataInterfaceEmitterBinding;
}

declare class NiagaraDataInterfaceEmitterProperties extends NiagaraDataInterface { 
	EmitterBinding: NiagaraDataInterfaceEmitterBinding;
	static Load(ResourceName: string): NiagaraDataInterfaceEmitterProperties;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceEmitterProperties;
	static GetDefaultObject(): NiagaraDataInterfaceEmitterProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceEmitterProperties;
	static C(Other: UObject | any): NiagaraDataInterfaceEmitterProperties;
}

declare class BasicParticleData { 
	position: Vector;
	Size: number;
	Velocity: Vector;
	clone() : BasicParticleData;
	static C(Other: UObject | any): BasicParticleData;
}

declare class NiagaraParticleCallbackHandler extends Interface { 
	static Load(ResourceName: string): NiagaraParticleCallbackHandler;
	static Find(Outer: UObject, ResourceName: string): NiagaraParticleCallbackHandler;
	static GetDefaultObject(): NiagaraParticleCallbackHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraParticleCallbackHandler;
	ReceiveParticleData(Data: BasicParticleData[],NiagaraSystem: NiagaraSystem,SimulationPositionOffset: Vector): void;
	static C(Other: UObject | any): NiagaraParticleCallbackHandler;
}

declare type ENDIExport_GPUAllocationMode = 'FixedSize' | 'PerParticle' | 'ENDIExport_MAX';
declare var ENDIExport_GPUAllocationMode : { FixedSize:'FixedSize',PerParticle:'PerParticle',ENDIExport_MAX:'ENDIExport_MAX', };
declare class NiagaraDataInterfaceExport extends NiagaraDataInterface { 
	CallbackHandlerParameter: NiagaraUserParameterBinding;
	GPUAllocationMode: ENDIExport_GPUAllocationMode;
	GPUAllocationFixedSize: number;
	GPUAllocationPerParticleSize: number;
	static Load(ResourceName: string): NiagaraDataInterfaceExport;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceExport;
	static GetDefaultObject(): NiagaraDataInterfaceExport;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceExport;
	static C(Other: UObject | any): NiagaraDataInterfaceExport;
}

declare class NiagaraDataInterfaceGBuffer extends NiagaraDataInterface { 
	static Load(ResourceName: string): NiagaraDataInterfaceGBuffer;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceGBuffer;
	static GetDefaultObject(): NiagaraDataInterfaceGBuffer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceGBuffer;
	static C(Other: UObject | any): NiagaraDataInterfaceGBuffer;
}

declare class NiagaraDataInterfaceGrid2D extends NiagaraDataInterfaceRWBase { 
	NumCellsX: number;
	NumCellsY: number;
	NumCellsMaxAxis: number;
	NumAttributes: number;
	SetGridFromMaxAxis: boolean;
	WorldBBoxSize: Vector2D;
	static Load(ResourceName: string): NiagaraDataInterfaceGrid2D;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceGrid2D;
	static GetDefaultObject(): NiagaraDataInterfaceGrid2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceGrid2D;
	static C(Other: UObject | any): NiagaraDataInterfaceGrid2D;
}

declare type ENiagaraGpuBufferFormat = 'Float' | 'HalfFloat' | 'UnsignedNormalizedByte' | 'Max' | 'ENiagaraGpuBufferFormat_MAX';
declare var ENiagaraGpuBufferFormat : { Float:'Float',HalfFloat:'HalfFloat',UnsignedNormalizedByte:'UnsignedNormalizedByte',Max:'Max',ENiagaraGpuBufferFormat_MAX:'ENiagaraGpuBufferFormat_MAX', };
declare class NiagaraDataInterfaceGrid2DCollection extends NiagaraDataInterfaceGrid2D { 
	RenderTargetUserParameter: NiagaraUserParameterBinding;
	OverrideBufferFormat: ENiagaraGpuBufferFormat;
	bOverrideFormat: boolean;
	bPreviewGrid: boolean;
	PreviewAttribute: string;
	ManagedRenderTargets: any;
	static Load(ResourceName: string): NiagaraDataInterfaceGrid2DCollection;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceGrid2DCollection;
	static GetDefaultObject(): NiagaraDataInterfaceGrid2DCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceGrid2DCollection;
	GetTextureSize(Component: NiagaraComponent,SizeX?: number,SizeY?: number): {SizeX: number, SizeY: number};
	GetRawTextureSize(Component: NiagaraComponent,SizeX?: number,SizeY?: number): {SizeX: number, SizeY: number};
	FillTexture2D(Component: NiagaraComponent,Dest: TextureRenderTarget2D,AttributeIndex: number): boolean;
	FillRawTexture2D(Component: NiagaraComponent,Dest: TextureRenderTarget2D,TilesX?: number,TilesY?: number): {TilesX: number, TilesY: number, $: boolean};
	static C(Other: UObject | any): NiagaraDataInterfaceGrid2DCollection;
}

declare class NiagaraDataInterfaceGrid2DCollectionReader extends NiagaraDataInterfaceGrid2DCollection { 
	EmitterName: string;
	DIName: string;
	static Load(ResourceName: string): NiagaraDataInterfaceGrid2DCollectionReader;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceGrid2DCollectionReader;
	static GetDefaultObject(): NiagaraDataInterfaceGrid2DCollectionReader;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceGrid2DCollectionReader;
	static C(Other: UObject | any): NiagaraDataInterfaceGrid2DCollectionReader;
}

declare type ESetResolutionMethod = 'Independent' | 'MaxAxis' | 'CellSize' | 'ESetResolutionMethod_MAX';
declare var ESetResolutionMethod : { Independent:'Independent',MaxAxis:'MaxAxis',CellSize:'CellSize',ESetResolutionMethod_MAX:'ESetResolutionMethod_MAX', };
declare class NiagaraDataInterfaceGrid3D extends NiagaraDataInterfaceRWBase { 
	NumCells: IntVector;
	CellSize: number;
	NumCellsMaxAxis: number;
	SetResolutionMethod: ESetResolutionMethod;
	WorldBBoxSize: Vector;
	static Load(ResourceName: string): NiagaraDataInterfaceGrid3D;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceGrid3D;
	static GetDefaultObject(): NiagaraDataInterfaceGrid3D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceGrid3D;
	static C(Other: UObject | any): NiagaraDataInterfaceGrid3D;
}

declare class NiagaraDataInterfaceGrid3DCollection extends NiagaraDataInterfaceGrid3D { 
	NumAttributes: number;
	RenderTargetUserParameter: NiagaraUserParameterBinding;
	OverrideBufferFormat: ENiagaraGpuBufferFormat;
	bOverrideFormat: boolean;
	bPreviewGrid: boolean;
	PreviewAttribute: string;
	static Load(ResourceName: string): NiagaraDataInterfaceGrid3DCollection;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceGrid3DCollection;
	static GetDefaultObject(): NiagaraDataInterfaceGrid3DCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceGrid3DCollection;
	GetTextureSize(Component: NiagaraComponent,SizeX?: number,SizeY?: number,SizeZ?: number): {SizeX: number, SizeY: number, SizeZ: number};
	GetRawTextureSize(Component: NiagaraComponent,SizeX?: number,SizeY?: number,SizeZ?: number): {SizeX: number, SizeY: number, SizeZ: number};
	FillVolumeTexture(Component: NiagaraComponent,Dest: VolumeTexture,AttributeIndex: number): boolean;
	FillRawVolumeTexture(Component: NiagaraComponent,Dest: VolumeTexture,TilesX?: number,TilesY?: number,TileZ?: number): {TilesX: number, TilesY: number, TileZ: number, $: boolean};
	static C(Other: UObject | any): NiagaraDataInterfaceGrid3DCollection;
}

declare class NiagaraDataInterfaceGrid3DCollectionReader extends NiagaraDataInterfaceGrid3DCollection { 
	EmitterName: string;
	DIName: string;
	static Load(ResourceName: string): NiagaraDataInterfaceGrid3DCollectionReader;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceGrid3DCollectionReader;
	static GetDefaultObject(): NiagaraDataInterfaceGrid3DCollectionReader;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceGrid3DCollectionReader;
	static C(Other: UObject | any): NiagaraDataInterfaceGrid3DCollectionReader;
}

declare class NiagaraDataInterfaceIntRenderTarget2D extends NiagaraDataInterfaceRWBase { 
	Size: IntPoint;
	bPreviewRenderTarget: boolean;
	PreviewDisplayRange: Vector2D;
	RenderTargetUserParameter: NiagaraUserParameterBinding;
	ManagedRenderTargets: any;
	static Load(ResourceName: string): NiagaraDataInterfaceIntRenderTarget2D;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceIntRenderTarget2D;
	static GetDefaultObject(): NiagaraDataInterfaceIntRenderTarget2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceIntRenderTarget2D;
	static C(Other: UObject | any): NiagaraDataInterfaceIntRenderTarget2D;
}

declare type ENDILandscape_SourceMode = 'Default' | 'Source' | 'AttachParent' | 'ENDILandscape_MAX';
declare var ENDILandscape_SourceMode : { Default:'Default',Source:'Source',AttachParent:'AttachParent',ENDILandscape_MAX:'ENDILandscape_MAX', };
declare class NiagaraDataInterfaceLandscape extends NiagaraDataInterface { 
	SourceLandscape: Actor;
	SourceMode: ENDILandscape_SourceMode;
	PhysicalMaterials: PhysicalMaterial[];
	static Load(ResourceName: string): NiagaraDataInterfaceLandscape;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceLandscape;
	static GetDefaultObject(): NiagaraDataInterfaceLandscape;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceLandscape;
	static C(Other: UObject | any): NiagaraDataInterfaceLandscape;
}

declare type ENiagaraMeshPivotOffsetSpace = 'Mesh' | 'Simulation' | 'World' | 'Local' | 'ENiagaraMeshPivotOffsetSpace_MAX';
declare var ENiagaraMeshPivotOffsetSpace : { Mesh:'Mesh',Simulation:'Simulation',World:'World',Local:'Local',ENiagaraMeshPivotOffsetSpace_MAX:'ENiagaraMeshPivotOffsetSpace_MAX', };
declare class NiagaraMeshRendererMeshProperties { 
	Mesh: StaticMesh;
	UserParamBinding: NiagaraUserParameterBinding;
	Scale: Vector;
	Rotation: Rotator;
	PivotOffset: Vector;
	PivotOffsetSpace: ENiagaraMeshPivotOffsetSpace;
	clone() : NiagaraMeshRendererMeshProperties;
	static C(Other: UObject | any): NiagaraMeshRendererMeshProperties;
}

declare type ENiagaraRendererSourceDataMode = 'Particles' | 'Emitter' | 'ENiagaraRendererSourceDataMode_MAX';
declare var ENiagaraRendererSourceDataMode : { Particles:'Particles',Emitter:'Emitter',ENiagaraRendererSourceDataMode_MAX:'ENiagaraRendererSourceDataMode_MAX', };
declare type ENiagaraSortMode = 'None' | 'ViewDepth' | 'ViewDistance' | 'CustomAscending' | 'CustomDecending' | 'ENiagaraSortMode_MAX';
declare var ENiagaraSortMode : { None:'None',ViewDepth:'ViewDepth',ViewDistance:'ViewDistance',CustomAscending:'CustomAscending',CustomDecending:'CustomDecending',ENiagaraSortMode_MAX:'ENiagaraSortMode_MAX', };
declare class NiagaraMeshMaterialOverride { 
	ExplicitMat: MaterialInterface;
	UserParamBinding: NiagaraUserParameterBinding;
	clone() : NiagaraMeshMaterialOverride;
	static C(Other: UObject | any): NiagaraMeshMaterialOverride;
}

declare type ENiagaraMeshFacingMode = 'Default' | 'Velocity' | 'CameraPosition' | 'CameraPlane' | 'ENiagaraMeshFacingMode_MAX';
declare var ENiagaraMeshFacingMode : { Default:'Default',Velocity:'Velocity',CameraPosition:'CameraPosition',CameraPlane:'CameraPlane',ENiagaraMeshFacingMode_MAX:'ENiagaraMeshFacingMode_MAX', };
declare type ENiagaraMeshLockedAxisSpace = 'Simulation' | 'World' | 'Local' | 'ENiagaraMeshLockedAxisSpace_MAX';
declare var ENiagaraMeshLockedAxisSpace : { Simulation:'Simulation',World:'World',Local:'Local',ENiagaraMeshLockedAxisSpace_MAX:'ENiagaraMeshLockedAxisSpace_MAX', };
declare class NiagaraMaterialAttributeBinding { 
	MaterialParameterName: string;
	NiagaraVariable: NiagaraVariableBase;
	ResolvedNiagaraVariable: NiagaraVariableBase;
	NiagaraChildVariable: NiagaraVariableBase;
	clone() : NiagaraMaterialAttributeBinding;
	static C(Other: UObject | any): NiagaraMaterialAttributeBinding;
}

declare class NiagaraMeshRendererProperties extends NiagaraRendererProperties { 
	Meshes: NiagaraMeshRendererMeshProperties[];
	SourceMode: ENiagaraRendererSourceDataMode;
	SortMode: ENiagaraSortMode;
	bOverrideMaterials: boolean;
	bSortOnlyWhenTranslucent: boolean;
	bGpuLowLatencyTranslucency: boolean;
	bSubImageBlend: boolean;
	bEnableFrustumCulling: boolean;
	bEnableCameraDistanceCulling: boolean;
	bEnableMeshFlipbook: boolean;
	OverrideMaterials: NiagaraMeshMaterialOverride[];
	SubImageSize: Vector2D;
	FacingMode: ENiagaraMeshFacingMode;
	bLockedAxisEnable: boolean;
	LockedAxis: Vector;
	LockedAxisSpace: ENiagaraMeshLockedAxisSpace;
	MinCameraDistance: number;
	MaxCameraDistance: number;
	RendererVisibility: any;
	PositionBinding: NiagaraVariableAttributeBinding;
	ColorBinding: NiagaraVariableAttributeBinding;
	VelocityBinding: NiagaraVariableAttributeBinding;
	MeshOrientationBinding: NiagaraVariableAttributeBinding;
	ScaleBinding: NiagaraVariableAttributeBinding;
	SubImageIndexBinding: NiagaraVariableAttributeBinding;
	DynamicMaterialBinding: NiagaraVariableAttributeBinding;
	DynamicMaterial1Binding: NiagaraVariableAttributeBinding;
	DynamicMaterial2Binding: NiagaraVariableAttributeBinding;
	DynamicMaterial3Binding: NiagaraVariableAttributeBinding;
	MaterialRandomBinding: NiagaraVariableAttributeBinding;
	CustomSortingBinding: NiagaraVariableAttributeBinding;
	NormalizedAgeBinding: NiagaraVariableAttributeBinding;
	CameraOffsetBinding: NiagaraVariableAttributeBinding;
	RendererVisibilityTagBinding: NiagaraVariableAttributeBinding;
	MeshIndexBinding: NiagaraVariableAttributeBinding;
	MaterialParameterBindings: NiagaraMaterialAttributeBinding[];
	PrevPositionBinding: NiagaraVariableAttributeBinding;
	PrevScaleBinding: NiagaraVariableAttributeBinding;
	PrevMeshOrientationBinding: NiagaraVariableAttributeBinding;
	PrevCameraOffsetBinding: NiagaraVariableAttributeBinding;
	PrevVelocityBinding: NiagaraVariableAttributeBinding;
	FirstFlipbookFrame: StaticMesh;
	FlipbookSuffixFormat: string;
	FlipbookSuffixNumDigits: any;
	NumFlipbookFrames: any;
	ParticleMesh: StaticMesh;
	PivotOffset: Vector;
	PivotOffsetSpace: ENiagaraMeshPivotOffsetSpace;
	static Load(ResourceName: string): NiagaraMeshRendererProperties;
	static Find(Outer: UObject, ResourceName: string): NiagaraMeshRendererProperties;
	static GetDefaultObject(): NiagaraMeshRendererProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraMeshRendererProperties;
	static C(Other: UObject | any): NiagaraMeshRendererProperties;
}

declare class NiagaraDataInterfaceMeshRendererInfo extends NiagaraDataInterface { 
	MeshRenderer: NiagaraMeshRendererProperties;
	static Load(ResourceName: string): NiagaraDataInterfaceMeshRendererInfo;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceMeshRendererInfo;
	static GetDefaultObject(): NiagaraDataInterfaceMeshRendererInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceMeshRendererInfo;
	static C(Other: UObject | any): NiagaraDataInterfaceMeshRendererInfo;
}

declare class NiagaraDataInterfaceNeighborGrid3D extends NiagaraDataInterfaceGrid3D { 
	MaxNeighborsPerCell: any;
	static Load(ResourceName: string): NiagaraDataInterfaceNeighborGrid3D;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceNeighborGrid3D;
	static GetDefaultObject(): NiagaraDataInterfaceNeighborGrid3D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceNeighborGrid3D;
	static C(Other: UObject | any): NiagaraDataInterfaceNeighborGrid3D;
}

declare class NiagaraDataInterfaceOcclusion extends NiagaraDataInterface { 
	static Load(ResourceName: string): NiagaraDataInterfaceOcclusion;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceOcclusion;
	static GetDefaultObject(): NiagaraDataInterfaceOcclusion;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceOcclusion;
	static C(Other: UObject | any): NiagaraDataInterfaceOcclusion;
}

declare class NiagaraDataInterfaceParticleRead extends NiagaraDataInterfaceRWBase { 
	EmitterName: string;
	static Load(ResourceName: string): NiagaraDataInterfaceParticleRead;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceParticleRead;
	static GetDefaultObject(): NiagaraDataInterfaceParticleRead;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceParticleRead;
	static C(Other: UObject | any): NiagaraDataInterfaceParticleRead;
}

declare class NiagaraDataInterfacePlatformSet extends NiagaraDataInterface { 
	Platforms: NiagaraPlatformSet;
	static Load(ResourceName: string): NiagaraDataInterfacePlatformSet;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfacePlatformSet;
	static GetDefaultObject(): NiagaraDataInterfacePlatformSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfacePlatformSet;
	static C(Other: UObject | any): NiagaraDataInterfacePlatformSet;
}

declare class NiagaraDataInterfaceRasterizationGrid3D extends NiagaraDataInterfaceGrid3D { 
	NumAttributes: number;
	Precision: number;
	ResetValue: number;
	static Load(ResourceName: string): NiagaraDataInterfaceRasterizationGrid3D;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceRasterizationGrid3D;
	static GetDefaultObject(): NiagaraDataInterfaceRasterizationGrid3D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceRasterizationGrid3D;
	static C(Other: UObject | any): NiagaraDataInterfaceRasterizationGrid3D;
}

declare type ENiagaraMipMapGeneration = 'Disabled' | 'PostStage' | 'PostSimulate' | 'ENiagaraMipMapGeneration_MAX';
declare var ENiagaraMipMapGeneration : { Disabled:'Disabled',PostStage:'PostStage',PostSimulate:'PostSimulate',ENiagaraMipMapGeneration_MAX:'ENiagaraMipMapGeneration_MAX', };
declare type ENiagaraMipMapGenerationType = 'Unfiltered' | 'Linear' | 'Blur1' | 'Blur2' | 'Blur3' | 'Blur4' | 'ENiagaraMipMapGenerationType_MAX';
declare var ENiagaraMipMapGenerationType : { Unfiltered:'Unfiltered',Linear:'Linear',Blur1:'Blur1',Blur2:'Blur2',Blur3:'Blur3',Blur4:'Blur4',ENiagaraMipMapGenerationType_MAX:'ENiagaraMipMapGenerationType_MAX', };
declare class NiagaraDataInterfaceRenderTarget2D extends NiagaraDataInterfaceRWBase { 
	Size: IntPoint;
	MipMapGeneration: ENiagaraMipMapGeneration;
	MipMapGenerationType: ENiagaraMipMapGenerationType;
	OverrideRenderTargetFormat: ETextureRenderTargetFormat;
	bInheritUserParameterSettings: boolean;
	bOverrideFormat: boolean;
	bPreviewRenderTarget: boolean;
	RenderTargetUserParameter: NiagaraUserParameterBinding;
	ManagedRenderTargets: any;
	static Load(ResourceName: string): NiagaraDataInterfaceRenderTarget2D;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceRenderTarget2D;
	static GetDefaultObject(): NiagaraDataInterfaceRenderTarget2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceRenderTarget2D;
	static C(Other: UObject | any): NiagaraDataInterfaceRenderTarget2D;
}

declare class NiagaraDataInterfaceRenderTarget2DArray extends NiagaraDataInterfaceRWBase { 
	Size: IntVector;
	OverrideRenderTargetFormat: ETextureRenderTargetFormat;
	bInheritUserParameterSettings: boolean;
	bOverrideFormat: boolean;
	bPreviewRenderTarget: boolean;
	RenderTargetUserParameter: NiagaraUserParameterBinding;
	ManagedRenderTargets: any;
	static Load(ResourceName: string): NiagaraDataInterfaceRenderTarget2DArray;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceRenderTarget2DArray;
	static GetDefaultObject(): NiagaraDataInterfaceRenderTarget2DArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceRenderTarget2DArray;
	static C(Other: UObject | any): NiagaraDataInterfaceRenderTarget2DArray;
}

declare class NiagaraDataInterfaceRenderTargetCube extends NiagaraDataInterfaceRWBase { 
	Size: number;
	OverrideRenderTargetFormat: ETextureRenderTargetFormat;
	bInheritUserParameterSettings: boolean;
	bOverrideFormat: boolean;
	bPreviewRenderTarget: boolean;
	RenderTargetUserParameter: NiagaraUserParameterBinding;
	ManagedRenderTargets: any;
	static Load(ResourceName: string): NiagaraDataInterfaceRenderTargetCube;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceRenderTargetCube;
	static GetDefaultObject(): NiagaraDataInterfaceRenderTargetCube;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceRenderTargetCube;
	static C(Other: UObject | any): NiagaraDataInterfaceRenderTargetCube;
}

declare class NiagaraDataInterfaceRenderTargetVolume extends NiagaraDataInterfaceRWBase { 
	Size: IntVector;
	OverrideRenderTargetFormat: ETextureRenderTargetFormat;
	bInheritUserParameterSettings: boolean;
	bOverrideFormat: boolean;
	bPreviewRenderTarget: boolean;
	RenderTargetUserParameter: NiagaraUserParameterBinding;
	ManagedRenderTargets: any;
	static Load(ResourceName: string): NiagaraDataInterfaceRenderTargetVolume;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceRenderTargetVolume;
	static GetDefaultObject(): NiagaraDataInterfaceRenderTargetVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceRenderTargetVolume;
	static C(Other: UObject | any): NiagaraDataInterfaceRenderTargetVolume;
}

declare class NiagaraDataInterfaceRigidMeshCollisionQuery extends NiagaraDataInterface { 
	Tag: string;
	OnlyUseMoveable: boolean;
	MaxNumPrimitives: number;
	static Load(ResourceName: string): NiagaraDataInterfaceRigidMeshCollisionQuery;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceRigidMeshCollisionQuery;
	static GetDefaultObject(): NiagaraDataInterfaceRigidMeshCollisionQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceRigidMeshCollisionQuery;
	static C(Other: UObject | any): NiagaraDataInterfaceRigidMeshCollisionQuery;
}

declare class NiagaraDataInterfaceSimpleCounter extends NiagaraDataInterface { 
	GpuSyncMode: ENiagaraGpuSyncMode;
	InitialValue: number;
	static Load(ResourceName: string): NiagaraDataInterfaceSimpleCounter;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceSimpleCounter;
	static GetDefaultObject(): NiagaraDataInterfaceSimpleCounter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceSimpleCounter;
	static C(Other: UObject | any): NiagaraDataInterfaceSimpleCounter;
}

declare type ENDISkeletalMesh_SourceMode = 'Default' | 'Source' | 'AttachParent' | 'ENDISkeletalMesh_MAX';
declare var ENDISkeletalMesh_SourceMode : { Default:'Default',Source:'Source',AttachParent:'AttachParent',ENDISkeletalMesh_MAX:'ENDISkeletalMesh_MAX', };
declare type ENDISkeletalMesh_SkinningMode = 'Invalid' | 'None' | 'SkinOnTheFly' | 'PreSkin' | 'ENDISkeletalMesh_MAX';
declare var ENDISkeletalMesh_SkinningMode : { Invalid:'Invalid',None:'None',SkinOnTheFly:'SkinOnTheFly',PreSkin:'PreSkin',ENDISkeletalMesh_MAX:'ENDISkeletalMesh_MAX', };
declare class NiagaraDataInterfaceSkeletalMesh extends NiagaraDataInterface { 
	SourceMode: ENDISkeletalMesh_SourceMode;
	PreviewMesh: SkeletalMesh;
	Source: Actor;
	MeshUserParameter: NiagaraUserParameterBinding;
	SourceComponent: SkeletalMeshComponent;
	SkinningMode: ENDISkeletalMesh_SkinningMode;
	SamplingRegions: string[];
	WholeMeshLOD: number;
	FilteredBones: string[];
	FilteredSockets: string[];
	ExcludeBoneName: string;
	bExcludeBone: boolean;
	UvSetIndex: number;
	bRequireCurrentFrameData: boolean;
	static Load(ResourceName: string): NiagaraDataInterfaceSkeletalMesh;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceSkeletalMesh;
	static GetDefaultObject(): NiagaraDataInterfaceSkeletalMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceSkeletalMesh;
	static C(Other: UObject | any): NiagaraDataInterfaceSkeletalMesh;
}

declare class NiagaraDataInterfaceSpline extends NiagaraDataInterface { 
	Source: Actor;
	SplineUserParameter: NiagaraUserParameterBinding;
	bUseLUT: boolean;
	NumLUTSteps: number;
	static Load(ResourceName: string): NiagaraDataInterfaceSpline;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceSpline;
	static GetDefaultObject(): NiagaraDataInterfaceSpline;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceSpline;
	static C(Other: UObject | any): NiagaraDataInterfaceSpline;
}

declare type ENDIStaticMesh_SourceMode = 'Default' | 'Source' | 'AttachParent' | 'DefaultMeshOnly' | 'ENDIStaticMesh_MAX';
declare var ENDIStaticMesh_SourceMode : { Default:'Default',Source:'Source',AttachParent:'AttachParent',DefaultMeshOnly:'DefaultMeshOnly',ENDIStaticMesh_MAX:'ENDIStaticMesh_MAX', };
declare class NDIStaticMeshSectionFilter { 
	AllowedMaterialSlots: number[];
	clone() : NDIStaticMeshSectionFilter;
	static C(Other: UObject | any): NDIStaticMeshSectionFilter;
}

declare class NiagaraDataInterfaceStaticMesh extends NiagaraDataInterface { 
	SourceMode: ENDIStaticMesh_SourceMode;
	PreviewMesh: StaticMesh;
	DefaultMesh: StaticMesh;
	Source: Actor;
	SourceComponent: StaticMeshComponent;
	SectionFilter: NDIStaticMeshSectionFilter;
	bUsePhysicsBodyVelocity: boolean;
	FilteredSockets: string[];
	static Load(ResourceName: string): NiagaraDataInterfaceStaticMesh;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceStaticMesh;
	static GetDefaultObject(): NiagaraDataInterfaceStaticMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceStaticMesh;
	static C(Other: UObject | any): NiagaraDataInterfaceStaticMesh;
}

declare class NiagaraDataInterfaceTexture extends NiagaraDataInterface { 
	Texture: Texture;
	TextureUserParameter: NiagaraUserParameterBinding;
	static Load(ResourceName: string): NiagaraDataInterfaceTexture;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceTexture;
	static GetDefaultObject(): NiagaraDataInterfaceTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceTexture;
	static C(Other: UObject | any): NiagaraDataInterfaceTexture;
}

declare class NiagaraUObjectPropertyReaderRemap { 
	GraphName: string;
	RemapName: string;
	clone() : NiagaraUObjectPropertyReaderRemap;
	static C(Other: UObject | any): NiagaraUObjectPropertyReaderRemap;
}

declare class NiagaraDataInterfaceUObjectPropertyReader extends NiagaraDataInterface { 
	UObjectParameterBinding: NiagaraUserParameterBinding;
	PropertyRemap: NiagaraUObjectPropertyReaderRemap[];
	SourceActor: any;
	SourceActorComponentClass: UnrealEngineClass;
	static Load(ResourceName: string): NiagaraDataInterfaceUObjectPropertyReader;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceUObjectPropertyReader;
	static GetDefaultObject(): NiagaraDataInterfaceUObjectPropertyReader;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceUObjectPropertyReader;
	static SetUObjectReaderPropertyRemap(NiagaraComponent: NiagaraComponent,UserParameterName: string,GraphName: string,RemapName: string): void;
	static C(Other: UObject | any): NiagaraDataInterfaceUObjectPropertyReader;
}

declare class NiagaraDataInterfaceVector2DCurve extends NiagaraDataInterfaceCurveBase { 
	XCurve: RichCurve;
	YCurve: RichCurve;
	static Load(ResourceName: string): NiagaraDataInterfaceVector2DCurve;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceVector2DCurve;
	static GetDefaultObject(): NiagaraDataInterfaceVector2DCurve;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceVector2DCurve;
	static C(Other: UObject | any): NiagaraDataInterfaceVector2DCurve;
}

declare class NiagaraDataInterfaceVector4Curve extends NiagaraDataInterfaceCurveBase { 
	XCurve: RichCurve;
	YCurve: RichCurve;
	ZCurve: RichCurve;
	WCurve: RichCurve;
	static Load(ResourceName: string): NiagaraDataInterfaceVector4Curve;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceVector4Curve;
	static GetDefaultObject(): NiagaraDataInterfaceVector4Curve;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceVector4Curve;
	static C(Other: UObject | any): NiagaraDataInterfaceVector4Curve;
}

declare class NiagaraDataInterfaceVectorCurve extends NiagaraDataInterfaceCurveBase { 
	XCurve: RichCurve;
	YCurve: RichCurve;
	ZCurve: RichCurve;
	static Load(ResourceName: string): NiagaraDataInterfaceVectorCurve;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceVectorCurve;
	static GetDefaultObject(): NiagaraDataInterfaceVectorCurve;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceVectorCurve;
	static C(Other: UObject | any): NiagaraDataInterfaceVectorCurve;
}

declare class NiagaraDataInterfaceVectorField extends NiagaraDataInterface { 
	Field: VectorField;
	bTileX: boolean;
	bTileY: boolean;
	bTileZ: boolean;
	static Load(ResourceName: string): NiagaraDataInterfaceVectorField;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceVectorField;
	static GetDefaultObject(): NiagaraDataInterfaceVectorField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceVectorField;
	static C(Other: UObject | any): NiagaraDataInterfaceVectorField;
}

declare class NiagaraDataInterfaceVolumeTexture extends NiagaraDataInterface { 
	Texture: VolumeTexture;
	TextureUserParameter: NiagaraUserParameterBinding;
	static Load(ResourceName: string): NiagaraDataInterfaceVolumeTexture;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceVolumeTexture;
	static GetDefaultObject(): NiagaraDataInterfaceVolumeTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceVolumeTexture;
	static C(Other: UObject | any): NiagaraDataInterfaceVolumeTexture;
}

declare type ENiagaraDebugHUDOverviewMode = 'Overview' | 'Scalability' | 'Performance' | 'GpuComputePerformance' | 'ENiagaraDebugHUDOverviewMode_MAX';
declare var ENiagaraDebugHUDOverviewMode : { Overview:'Overview',Scalability:'Scalability',Performance:'Performance',GpuComputePerformance:'GpuComputePerformance',ENiagaraDebugHUDOverviewMode_MAX:'ENiagaraDebugHUDOverviewMode_MAX', };
declare type ENiagaraDebugHudFont = 'Small' | 'Normal' | 'ENiagaraDebugHudFont_MAX';
declare var ENiagaraDebugHudFont : { Small:'Small',Normal:'Normal',ENiagaraDebugHudFont_MAX:'ENiagaraDebugHudFont_MAX', };
declare type ENiagaraDebugHudVerbosity = 'None' | 'Basic' | 'Verbose' | 'ENiagaraDebugHudVerbosity_MAX';
declare var ENiagaraDebugHudVerbosity : { None:'None',Basic:'Basic',Verbose:'Verbose',ENiagaraDebugHudVerbosity_MAX:'ENiagaraDebugHudVerbosity_MAX', };
declare class NiagaraDebugHUDVariable { 
	bEnabled: boolean;
	Name: string;
	clone() : NiagaraDebugHUDVariable;
	static C(Other: UObject | any): NiagaraDebugHUDVariable;
}

declare type ENiagaraDebugHudHAlign = 'Left' | 'Center' | 'Right' | 'ENiagaraDebugHudHAlign_MAX';
declare var ENiagaraDebugHudHAlign : { Left:'Left',Center:'Center',Right:'Right',ENiagaraDebugHudHAlign_MAX:'ENiagaraDebugHudHAlign_MAX', };
declare type ENiagaraDebugHudVAlign = 'Top' | 'Center' | 'Bottom' | 'ENiagaraDebugHudVAlign_MAX';
declare var ENiagaraDebugHudVAlign : { Top:'Top',Center:'Center',Bottom:'Bottom',ENiagaraDebugHudVAlign_MAX:'ENiagaraDebugHudVAlign_MAX', };
declare class NiagaraDebugHudTextOptions { 
	Font: ENiagaraDebugHudFont;
	HorizontalAlignment: ENiagaraDebugHudHAlign;
	VerticalAlignment: ENiagaraDebugHudVAlign;
	ScreenOffset: Vector2D;
	clone() : NiagaraDebugHudTextOptions;
	static C(Other: UObject | any): NiagaraDebugHudTextOptions;
}

declare type ENiagaraDebugHUDPerfSampleMode = 'FrameTotal' | 'PerInstanceAverage' | 'ENiagaraDebugHUDPerfSampleMode_MAX';
declare var ENiagaraDebugHUDPerfSampleMode : { FrameTotal:'FrameTotal',PerInstanceAverage:'PerInstanceAverage',ENiagaraDebugHUDPerfSampleMode_MAX:'ENiagaraDebugHUDPerfSampleMode_MAX', };
declare type ENiagaraDebugHUDPerfGraphMode = 'None' | 'GameThread' | 'RenderThread' | 'GPU' | 'ENiagaraDebugHUDPerfGraphMode_MAX';
declare var ENiagaraDebugHUDPerfGraphMode : { None:'None',GameThread:'GameThread',RenderThread:'RenderThread',GPU:'GPU',ENiagaraDebugHUDPerfGraphMode_MAX:'ENiagaraDebugHUDPerfGraphMode_MAX', };
declare type ENiagaraDebugPlaybackMode = 'Play' | 'Loop' | 'Paused' | 'Step' | 'ENiagaraDebugPlaybackMode_MAX';
declare var ENiagaraDebugPlaybackMode : { Play:'Play',Loop:'Loop',Paused:'Paused',Step:'Step',ENiagaraDebugPlaybackMode_MAX:'ENiagaraDebugPlaybackMode_MAX', };
declare class NiagaraDebugHUDSettingsData { 
	bWidgetEnabled: boolean;
	bHudEnabled: boolean;
	bValidateSystemSimulationDataBuffers: boolean;
	bValidateParticleDataBuffers: boolean;
	bOverviewEnabled: boolean;
	OverviewMode: ENiagaraDebugHUDOverviewMode;
	OverviewFont: ENiagaraDebugHudFont;
	OverviewLocation: Vector2D;
	ActorFilter: string;
	bComponentFilterEnabled: boolean;
	ComponentFilter: string;
	bSystemFilterEnabled: boolean;
	SystemFilter: string;
	bEmitterFilterEnabled: boolean;
	EmitterFilter: string;
	bActorFilterEnabled: boolean;
	SystemDebugVerbosity: ENiagaraDebugHudVerbosity;
	SystemEmitterVerbosity: ENiagaraDebugHudVerbosity;
	bSystemShowBounds: boolean;
	bSystemShowActiveOnlyInWorld: boolean;
	bShowSystemVariables: boolean;
	SystemVariables: NiagaraDebugHUDVariable[];
	SystemTextOptions: NiagaraDebugHudTextOptions;
	bShowParticleVariables: boolean;
	bEnableGpuParticleReadback: boolean;
	bShowParticleIndex: boolean;
	ParticlesVariables: NiagaraDebugHUDVariable[];
	ParticleTextOptions: NiagaraDebugHudTextOptions;
	bShowParticlesVariablesWithSystem: boolean;
	bShowParticleVariablesVertical: boolean;
	bUseMaxParticlesToDisplay: boolean;
	bUseParticleDisplayClip: boolean;
	ParticleDisplayClip: Vector2D;
	bUseParticleDisplayCenterRadius: boolean;
	ParticleDisplayCenterRadius: number;
	MaxParticlesToDisplay: number;
	PerfReportFrames: number;
	PerfSampleMode: ENiagaraDebugHUDPerfSampleMode;
	PerfGraphMode: ENiagaraDebugHUDPerfGraphMode;
	PerfHistoryFrames: number;
	PerfGraphTimeRange: number;
	PerfGraphSize: Vector2D;
	PerfGraphAxisColor: LinearColor;
	bEnableSmoothing: boolean;
	SmoothingWidth: number;
	DefaultBackgroundColor: LinearColor;
	OverviewHeadingColor: LinearColor;
	OverviewDetailColor: LinearColor;
	OverviewDetailHighlightColor: LinearColor;
	InWorldErrorTextColor: LinearColor;
	InWorldTextColor: LinearColor;
	MessageInfoTextColor: LinearColor;
	MessageWarningTextColor: LinearColor;
	MessageErrorTextColor: LinearColor;
	SystemColorTableOpacity: number;
	SystemColorSeed: any;
	SystemColorHSVMin: Vector;
	SystemColorHSVMax: Vector;
	PlaybackMode: ENiagaraDebugPlaybackMode;
	bPlaybackRateEnabled: boolean;
	PlaybackRate: number;
	bLoopTimeEnabled: boolean;
	LoopTime: number;
	bShowGlobalBudgetInfo: boolean;
	clone() : NiagaraDebugHUDSettingsData;
	static C(Other: UObject | any): NiagaraDebugHUDSettingsData;
}

declare class NiagaraDebugHUDSettings extends UObject { 
	Data: NiagaraDebugHUDSettingsData;
	static Load(ResourceName: string): NiagaraDebugHUDSettings;
	static Find(Outer: UObject, ResourceName: string): NiagaraDebugHUDSettings;
	static GetDefaultObject(): NiagaraDebugHUDSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDebugHUDSettings;
	static C(Other: UObject | any): NiagaraDebugHUDSettings;
}

declare class NiagaraSignificanceHandlerDistance extends NiagaraSignificanceHandler { 
	static Load(ResourceName: string): NiagaraSignificanceHandlerDistance;
	static Find(Outer: UObject, ResourceName: string): NiagaraSignificanceHandlerDistance;
	static GetDefaultObject(): NiagaraSignificanceHandlerDistance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraSignificanceHandlerDistance;
	static C(Other: UObject | any): NiagaraSignificanceHandlerDistance;
}

declare class NiagaraSignificanceHandlerAge extends NiagaraSignificanceHandler { 
	static Load(ResourceName: string): NiagaraSignificanceHandlerAge;
	static Find(Outer: UObject, ResourceName: string): NiagaraSignificanceHandlerAge;
	static GetDefaultObject(): NiagaraSignificanceHandlerAge;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraSignificanceHandlerAge;
	static C(Other: UObject | any): NiagaraSignificanceHandlerAge;
}

declare class NiagaraEventReceiverEmitterAction extends UObject { 
	static Load(ResourceName: string): NiagaraEventReceiverEmitterAction;
	static Find(Outer: UObject, ResourceName: string): NiagaraEventReceiverEmitterAction;
	static GetDefaultObject(): NiagaraEventReceiverEmitterAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraEventReceiverEmitterAction;
	static C(Other: UObject | any): NiagaraEventReceiverEmitterAction;
}

declare class NiagaraEventReceiverEmitterAction_SpawnParticles extends NiagaraEventReceiverEmitterAction { 
	NumParticles: any;
	static Load(ResourceName: string): NiagaraEventReceiverEmitterAction_SpawnParticles;
	static Find(Outer: UObject, ResourceName: string): NiagaraEventReceiverEmitterAction_SpawnParticles;
	static GetDefaultObject(): NiagaraEventReceiverEmitterAction_SpawnParticles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraEventReceiverEmitterAction_SpawnParticles;
	static C(Other: UObject | any): NiagaraEventReceiverEmitterAction_SpawnParticles;
}

declare class FXSystemSpawnParameters { 
	clone() : FXSystemSpawnParameters;
	static C(Other: UObject | any): FXSystemSpawnParameters;
	SpawnSystemAtLocationWithParams(): {SpawnParams: FXSystemSpawnParameters, $: NiagaraComponent};
	SpawnSystemAttachedWithParams(): {SpawnParams: FXSystemSpawnParameters, $: NiagaraComponent};
	static SpawnSystemAtLocationWithParams(SpawnParams?: FXSystemSpawnParameters): {SpawnParams: FXSystemSpawnParameters, $: NiagaraComponent};
	static SpawnSystemAttachedWithParams(SpawnParams?: FXSystemSpawnParameters): {SpawnParams: FXSystemSpawnParameters, $: NiagaraComponent};
}

declare class NiagaraFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): NiagaraFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): NiagaraFunctionLibrary;
	static GetDefaultObject(): NiagaraFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraFunctionLibrary;
	static SpawnSystemAttachedWithParams(SpawnParams?: FXSystemSpawnParameters): {SpawnParams: FXSystemSpawnParameters, $: NiagaraComponent};
	static SpawnSystemAttached(SystemTemplate: NiagaraSystem,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bAutoDestroy: boolean,bAutoActivate: boolean,PoolingMethod: ENCPoolMethod,bPreCullCheck: boolean): NiagaraComponent;
	static SpawnSystemAtLocationWithParams(SpawnParams?: FXSystemSpawnParameters): {SpawnParams: FXSystemSpawnParameters, $: NiagaraComponent};
	static SpawnSystemAtLocation(WorldContextObject: UObject,SystemTemplate: NiagaraSystem,Location: Vector,Rotation: Rotator,Scale: Vector,bAutoDestroy: boolean,bAutoActivate: boolean,PoolingMethod: ENCPoolMethod,bPreCullCheck: boolean): NiagaraComponent;
	static SetVolumeTextureObject(NiagaraSystem: NiagaraComponent,OverrideName: string,Texture: VolumeTexture): void;
	static SetTextureObject(NiagaraSystem: NiagaraComponent,OverrideName: string,Texture: Texture): void;
	static SetTexture2DArrayObject(NiagaraSystem: NiagaraComponent,OverrideName: string,Texture: Texture2DArray): void;
	static SetSkeletalMeshDataInterfaceSamplingRegions(NiagaraSystem: NiagaraComponent,OverrideName: string,SamplingRegions: string[]): void;
	static SetComponentNiagaraGPURayTracedCollisionGroup(WorldContextObject: UObject,Primitive: PrimitiveComponent,CollisionGroup: number): void;
	static SetActorNiagaraGPURayTracedCollisionGroup(WorldContextObject: UObject,Actor: Actor,CollisionGroup: number): void;
	static ReleaseNiagaraGPURayTracedCollisionGroup(WorldContextObject: UObject,CollisionGroup: number): void;
	static OverrideSystemUserVariableStaticMeshComponent(NiagaraSystem: NiagaraComponent,OverrideName: string,StaticMeshComponent: StaticMeshComponent): void;
	static OverrideSystemUserVariableStaticMesh(NiagaraSystem: NiagaraComponent,OverrideName: string,StaticMesh: StaticMesh): void;
	static OverrideSystemUserVariableSkeletalMeshComponent(NiagaraSystem: NiagaraComponent,OverrideName: string,SkeletalMeshComponent: SkeletalMeshComponent): void;
	static GetNiagaraParameterCollection(WorldContextObject: UObject,Collection: NiagaraParameterCollection): NiagaraParameterCollectionInstance;
	static AcquireNiagaraGPURayTracedCollisionGroup(WorldContextObject: UObject): number;
	static C(Other: UObject | any): NiagaraFunctionLibrary;
}

declare class NiagaraLensEffectBase extends NiagaraActor { 
	DesiredRelativeTransform: Transform;
	BaseAuthoredFOV: number;
	bAllowMultipleInstances: boolean;
	bResetWhenRetriggered: boolean;
	EmittersToTreatAsSame: UnrealEngineClass[];
	OwningCameraManager: PlayerCameraManager;
	static GetDefaultObject(): NiagaraLensEffectBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraLensEffectBase;
	static C(Other: UObject | any): NiagaraLensEffectBase;
}

declare class NiagaraLightRendererProperties extends NiagaraRendererProperties { 
	bUseInverseSquaredFalloff: boolean;
	bAffectsTranslucency: boolean;
	bAlphaScalesBrightness: boolean;
	RadiusScale: number;
	DefaultExponent: number;
	ColorAdd: Vector;
	RendererVisibility: number;
	LightRenderingEnabledBinding: NiagaraVariableAttributeBinding;
	LightExponentBinding: NiagaraVariableAttributeBinding;
	PositionBinding: NiagaraVariableAttributeBinding;
	ColorBinding: NiagaraVariableAttributeBinding;
	RadiusBinding: NiagaraVariableAttributeBinding;
	VolumetricScatteringBinding: NiagaraVariableAttributeBinding;
	RendererVisibilityTagBinding: NiagaraVariableAttributeBinding;
	static Load(ResourceName: string): NiagaraLightRendererProperties;
	static Find(Outer: UObject, ResourceName: string): NiagaraLightRendererProperties;
	static GetDefaultObject(): NiagaraLightRendererProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraLightRendererProperties;
	static C(Other: UObject | any): NiagaraLightRendererProperties;
}

declare class NiagaraMessageDataBase extends UObject { 
	static Load(ResourceName: string): NiagaraMessageDataBase;
	static Find(Outer: UObject, ResourceName: string): NiagaraMessageDataBase;
	static GetDefaultObject(): NiagaraMessageDataBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraMessageDataBase;
	static C(Other: UObject | any): NiagaraMessageDataBase;
}

declare class NiagaraBaselineController_Basic extends NiagaraBaselineController { 
	NumInstances: number;
	SpawnedComponents: NiagaraComponent[];
	static Load(ResourceName: string): NiagaraBaselineController_Basic;
	static Find(Outer: UObject, ResourceName: string): NiagaraBaselineController_Basic;
	static GetDefaultObject(): NiagaraBaselineController_Basic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraBaselineController_Basic;
	static C(Other: UObject | any): NiagaraBaselineController_Basic;
}

declare class NiagaraPrecompileContainer extends UObject { 
	Scripts: NiagaraScript[];
	System: NiagaraSystem;
	static Load(ResourceName: string): NiagaraPrecompileContainer;
	static Find(Outer: UObject, ResourceName: string): NiagaraPrecompileContainer;
	static GetDefaultObject(): NiagaraPrecompileContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraPrecompileContainer;
	static C(Other: UObject | any): NiagaraPrecompileContainer;
}

declare class NiagaraPreviewBase extends Actor { 
	static GetDefaultObject(): NiagaraPreviewBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraPreviewBase;
	SetSystem(InSystem: NiagaraSystem): void;
	SetLabelText(InXAxisText: string,InYAxisText: string): void;
	static C(Other: UObject | any): NiagaraPreviewBase;
}

declare class NiagaraPreviewAxis extends UObject { 
	static Load(ResourceName: string): NiagaraPreviewAxis;
	static Find(Outer: UObject, ResourceName: string): NiagaraPreviewAxis;
	static GetDefaultObject(): NiagaraPreviewAxis;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraPreviewAxis;
	Num(): number;
	ApplyToPreview(PreviewComponent: NiagaraComponent,PreviewIndex: number,bIsXAxis: boolean,OutLabelText?: string): {OutLabelText: string};
	static C(Other: UObject | any): NiagaraPreviewAxis;
}

declare class NiagaraPreviewAxis_InterpParamBase extends NiagaraPreviewAxis { 
	Param: string;
	Count: number;
	static Load(ResourceName: string): NiagaraPreviewAxis_InterpParamBase;
	static Find(Outer: UObject, ResourceName: string): NiagaraPreviewAxis_InterpParamBase;
	static GetDefaultObject(): NiagaraPreviewAxis_InterpParamBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraPreviewAxis_InterpParamBase;
	static C(Other: UObject | any): NiagaraPreviewAxis_InterpParamBase;
}

declare class NiagaraPreviewAxis_InterpParamInt32 extends NiagaraPreviewAxis_InterpParamBase { 
	Min: number;
	Max: number;
	static Load(ResourceName: string): NiagaraPreviewAxis_InterpParamInt32;
	static Find(Outer: UObject, ResourceName: string): NiagaraPreviewAxis_InterpParamInt32;
	static GetDefaultObject(): NiagaraPreviewAxis_InterpParamInt32;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraPreviewAxis_InterpParamInt32;
	static C(Other: UObject | any): NiagaraPreviewAxis_InterpParamInt32;
}

declare class NiagaraPreviewAxis_InterpParamFloat extends NiagaraPreviewAxis_InterpParamBase { 
	Min: number;
	Max: number;
	static Load(ResourceName: string): NiagaraPreviewAxis_InterpParamFloat;
	static Find(Outer: UObject, ResourceName: string): NiagaraPreviewAxis_InterpParamFloat;
	static GetDefaultObject(): NiagaraPreviewAxis_InterpParamFloat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraPreviewAxis_InterpParamFloat;
	static C(Other: UObject | any): NiagaraPreviewAxis_InterpParamFloat;
}

declare class NiagaraPreviewAxis_InterpParamVector2D extends NiagaraPreviewAxis_InterpParamBase { 
	Min: Vector2D;
	Max: Vector2D;
	static Load(ResourceName: string): NiagaraPreviewAxis_InterpParamVector2D;
	static Find(Outer: UObject, ResourceName: string): NiagaraPreviewAxis_InterpParamVector2D;
	static GetDefaultObject(): NiagaraPreviewAxis_InterpParamVector2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraPreviewAxis_InterpParamVector2D;
	static C(Other: UObject | any): NiagaraPreviewAxis_InterpParamVector2D;
}

declare class NiagaraPreviewAxis_InterpParamVector extends NiagaraPreviewAxis_InterpParamBase { 
	Min: Vector;
	Max: Vector;
	static Load(ResourceName: string): NiagaraPreviewAxis_InterpParamVector;
	static Find(Outer: UObject, ResourceName: string): NiagaraPreviewAxis_InterpParamVector;
	static GetDefaultObject(): NiagaraPreviewAxis_InterpParamVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraPreviewAxis_InterpParamVector;
	static C(Other: UObject | any): NiagaraPreviewAxis_InterpParamVector;
}

declare class NiagaraPreviewAxis_InterpParamVector4 extends NiagaraPreviewAxis_InterpParamBase { 
	Min: Vector4;
	Max: Vector4;
	static Load(ResourceName: string): NiagaraPreviewAxis_InterpParamVector4;
	static Find(Outer: UObject, ResourceName: string): NiagaraPreviewAxis_InterpParamVector4;
	static GetDefaultObject(): NiagaraPreviewAxis_InterpParamVector4;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraPreviewAxis_InterpParamVector4;
	static C(Other: UObject | any): NiagaraPreviewAxis_InterpParamVector4;
}

declare class NiagaraPreviewAxis_InterpParamLinearColor extends NiagaraPreviewAxis_InterpParamBase { 
	Min: LinearColor;
	Max: LinearColor;
	static Load(ResourceName: string): NiagaraPreviewAxis_InterpParamLinearColor;
	static Find(Outer: UObject, ResourceName: string): NiagaraPreviewAxis_InterpParamLinearColor;
	static GetDefaultObject(): NiagaraPreviewAxis_InterpParamLinearColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraPreviewAxis_InterpParamLinearColor;
	static C(Other: UObject | any): NiagaraPreviewAxis_InterpParamLinearColor;
}

declare type ENiagaraPreviewGridResetMode = 'Never' | 'Individual' | 'All' | 'ENiagaraPreviewGridResetMode_MAX';
declare var ENiagaraPreviewGridResetMode : { Never:'Never',Individual:'Individual',All:'All',ENiagaraPreviewGridResetMode_MAX:'ENiagaraPreviewGridResetMode_MAX', };
declare class NiagaraPreviewGrid extends Actor { 
	System: NiagaraSystem;
	ResetMode: ENiagaraPreviewGridResetMode;
	PreviewAxisX: NiagaraPreviewAxis;
	PreviewAxisY: NiagaraPreviewAxis;
	PreviewClass: UnrealEngineClass;
	SpacingX: number;
	SpacingY: number;
	NumX: number;
	NumY: number;
	PreviewComponents: ChildActorComponent[];
	SpriteComponent: BillboardComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): NiagaraPreviewGrid;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraPreviewGrid;
	SetPaused(bPaused: boolean): void;
	GetPreviews(OutPreviews?: NiagaraComponent[]): {OutPreviews: NiagaraComponent[]};
	DeactivatePreviews(): void;
	ActivatePreviews(bReset: boolean): void;
	static C(Other: UObject | any): NiagaraPreviewGrid;
}

declare type ENiagaraRibbonFacingMode = 'Screen' | 'Custom' | 'CustomSideVector' | 'ENiagaraRibbonFacingMode_MAX';
declare var ENiagaraRibbonFacingMode : { Screen:'Screen',Custom:'Custom',CustomSideVector:'CustomSideVector',ENiagaraRibbonFacingMode_MAX:'ENiagaraRibbonFacingMode_MAX', };
declare type ENiagaraRibbonUVDistributionMode = 'ScaledUniformly' | 'ScaledUsingRibbonSegmentLength' | 'TiledOverRibbonLength' | 'TiledFromStartOverRibbonLength' | 'ENiagaraRibbonUVDistributionMode_MAX';
declare var ENiagaraRibbonUVDistributionMode : { ScaledUniformly:'ScaledUniformly',ScaledUsingRibbonSegmentLength:'ScaledUsingRibbonSegmentLength',TiledOverRibbonLength:'TiledOverRibbonLength',TiledFromStartOverRibbonLength:'TiledFromStartOverRibbonLength',ENiagaraRibbonUVDistributionMode_MAX:'ENiagaraRibbonUVDistributionMode_MAX', };
declare type ENiagaraRibbonUVEdgeMode = 'SmoothTransition' | 'Locked' | 'ENiagaraRibbonUVEdgeMode_MAX';
declare var ENiagaraRibbonUVEdgeMode : { SmoothTransition:'SmoothTransition',Locked:'Locked',ENiagaraRibbonUVEdgeMode_MAX:'ENiagaraRibbonUVEdgeMode_MAX', };
declare class NiagaraRibbonUVSettings { 
	DistributionMode: ENiagaraRibbonUVDistributionMode;
	LeadingEdgeMode: ENiagaraRibbonUVEdgeMode;
	TrailingEdgeMode: ENiagaraRibbonUVEdgeMode;
	TilingLength: number;
	Offset: Vector2D;
	Scale: Vector2D;
	bEnablePerParticleUOverride: boolean;
	bEnablePerParticleVRangeOverride: boolean;
	clone() : NiagaraRibbonUVSettings;
	static C(Other: UObject | any): NiagaraRibbonUVSettings;
}

declare type ENiagaraRibbonAgeOffsetMode = 'Scale' | 'Clip' | 'ENiagaraRibbonAgeOffsetMode_MAX';
declare var ENiagaraRibbonAgeOffsetMode : { Scale:'Scale',Clip:'Clip',ENiagaraRibbonAgeOffsetMode_MAX:'ENiagaraRibbonAgeOffsetMode_MAX', };
declare type ENiagaraRibbonDrawDirection = 'FrontToBack' | 'BackToFront' | 'ENiagaraRibbonDrawDirection_MAX';
declare var ENiagaraRibbonDrawDirection : { FrontToBack:'FrontToBack',BackToFront:'BackToFront',ENiagaraRibbonDrawDirection_MAX:'ENiagaraRibbonDrawDirection_MAX', };
declare type ENiagaraRibbonShapeMode = 'Plane' | 'MultiPlane' | 'Tube' | 'Custom' | 'ENiagaraRibbonShapeMode_MAX';
declare var ENiagaraRibbonShapeMode : { Plane:'Plane',MultiPlane:'MultiPlane',Tube:'Tube',Custom:'Custom',ENiagaraRibbonShapeMode_MAX:'ENiagaraRibbonShapeMode_MAX', };
declare class NiagaraRibbonShapeCustomVertex { 
	position: Vector2D;
	Normal: Vector2D;
	TextureV: number;
	clone() : NiagaraRibbonShapeCustomVertex;
	static C(Other: UObject | any): NiagaraRibbonShapeCustomVertex;
}

declare type ENiagaraRibbonTessellationMode = 'Automatic' | 'Custom' | 'Disabled' | 'ENiagaraRibbonTessellationMode_MAX';
declare var ENiagaraRibbonTessellationMode : { Automatic:'Automatic',Custom:'Custom',Disabled:'Disabled',ENiagaraRibbonTessellationMode_MAX:'ENiagaraRibbonTessellationMode_MAX', };
declare class NiagaraRibbonRendererProperties extends NiagaraRendererProperties { 
	Material: MaterialInterface;
	MaterialUserParamBinding: NiagaraUserParameterBinding;
	FacingMode: ENiagaraRibbonFacingMode;
	UV0Settings: NiagaraRibbonUVSettings;
	UV1Settings: NiagaraRibbonUVSettings;
	UV0TilingDistance: number;
	UV0Scale: Vector2D;
	UV0Offset: Vector2D;
	UV0AgeOffsetMode: ENiagaraRibbonAgeOffsetMode;
	UV1TilingDistance: number;
	UV1Scale: Vector2D;
	UV1Offset: Vector2D;
	UV1AgeOffsetMode: ENiagaraRibbonAgeOffsetMode;
	DrawDirection: ENiagaraRibbonDrawDirection;
	Shape: ENiagaraRibbonShapeMode;
	bEnableAccurateGeometry: boolean;
	WidthSegmentationCount: number;
	MultiPlaneCount: number;
	TubeSubdivisions: number;
	CustomVertices: NiagaraRibbonShapeCustomVertex[];
	CurveTension: number;
	TessellationMode: ENiagaraRibbonTessellationMode;
	TessellationFactor: number;
	bUseConstantFactor: boolean;
	TessellationAngle: number;
	bScreenSpaceTessellation: boolean;
	PositionBinding: NiagaraVariableAttributeBinding;
	ColorBinding: NiagaraVariableAttributeBinding;
	VelocityBinding: NiagaraVariableAttributeBinding;
	NormalizedAgeBinding: NiagaraVariableAttributeBinding;
	RibbonTwistBinding: NiagaraVariableAttributeBinding;
	RibbonWidthBinding: NiagaraVariableAttributeBinding;
	RibbonFacingBinding: NiagaraVariableAttributeBinding;
	RibbonIdBinding: NiagaraVariableAttributeBinding;
	RibbonLinkOrderBinding: NiagaraVariableAttributeBinding;
	MaterialRandomBinding: NiagaraVariableAttributeBinding;
	DynamicMaterialBinding: NiagaraVariableAttributeBinding;
	DynamicMaterial1Binding: NiagaraVariableAttributeBinding;
	DynamicMaterial2Binding: NiagaraVariableAttributeBinding;
	DynamicMaterial3Binding: NiagaraVariableAttributeBinding;
	RibbonUVDistance: NiagaraVariableAttributeBinding;
	U0OverrideBinding: NiagaraVariableAttributeBinding;
	V0RangeOverrideBinding: NiagaraVariableAttributeBinding;
	U1OverrideBinding: NiagaraVariableAttributeBinding;
	V1RangeOverrideBinding: NiagaraVariableAttributeBinding;
	MaterialParameterBindings: NiagaraMaterialAttributeBinding[];
	PrevPositionBinding: NiagaraVariableAttributeBinding;
	PrevRibbonWidthBinding: NiagaraVariableAttributeBinding;
	PrevRibbonFacingBinding: NiagaraVariableAttributeBinding;
	PrevRibbonTwistBinding: NiagaraVariableAttributeBinding;
	static Load(ResourceName: string): NiagaraRibbonRendererProperties;
	static Find(Outer: UObject, ResourceName: string): NiagaraRibbonRendererProperties;
	static GetDefaultObject(): NiagaraRibbonRendererProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraRibbonRendererProperties;
	static C(Other: UObject | any): NiagaraRibbonRendererProperties;
}

declare type ENiagaraDefaultRendererMotionVectorSetting = 'Precise' | 'Approximate' | 'ENiagaraDefaultRendererMotionVectorSetting_MAX';
declare var ENiagaraDefaultRendererMotionVectorSetting : { Precise:'Precise',Approximate:'Approximate',ENiagaraDefaultRendererMotionVectorSetting_MAX:'ENiagaraDefaultRendererMotionVectorSetting_MAX', };
declare type ENiagaraDefaultRendererPixelCoverageMode = 'Enabled' | 'Disabled' | 'ENiagaraDefaultRendererPixelCoverageMode_MAX';
declare var ENiagaraDefaultRendererPixelCoverageMode : { Enabled:'Enabled',Disabled:'Disabled',ENiagaraDefaultRendererPixelCoverageMode_MAX:'ENiagaraDefaultRendererPixelCoverageMode_MAX', };
declare type ENDISkelMesh_GpuMaxInfluences = 'AllowMax4' | 'AllowMax8' | 'Unlimited' | 'ENDISkelMesh_MAX';
declare var ENDISkelMesh_GpuMaxInfluences : { AllowMax4:'AllowMax4',AllowMax8:'AllowMax8',Unlimited:'Unlimited',ENDISkelMesh_MAX:'ENDISkelMesh_MAX', };
declare type ENDISkelMesh_GpuUniformSamplingFormat = 'Full' | 'Limited_24_8' | 'Limited_23_9' | 'ENDISkelMesh_MAX';
declare var ENDISkelMesh_GpuUniformSamplingFormat : { Full:'Full',Limited_24_8:'Limited_24_8',Limited_23_9:'Limited_23_9',ENDISkelMesh_MAX:'ENDISkelMesh_MAX', };
declare type ENDISkelMesh_AdjacencyTriangleIndexFormat = 'Full' | 'Half' | 'ENDISkelMesh_MAX';
declare var ENDISkelMesh_AdjacencyTriangleIndexFormat : { Full:'Full',Half:'Half',ENDISkelMesh_MAX:'ENDISkelMesh_MAX', };
declare class NiagaraSettings extends DeveloperSettings { 
	AdditionalParameterTypes: SoftObjectPath[];
	AdditionalPayloadTypes: SoftObjectPath[];
	AdditionalParameterEnums: SoftObjectPath[];
	bSystemViewportInOrbitMode: boolean;
	bShowConvertibleInputsInStack: boolean;
	bSystemsSupportLargeWorldCoordinates: boolean;
	bEnforceStrictStackTypes: boolean;
	DefaultEffectType: SoftObjectPath;
	PositionPinTypeColor: LinearColor;
	QualityLevels: string[];
	ComponentRendererWarningsPerClass: any;
	DefaultRenderTargetFormat: ETextureRenderTargetFormat;
	DefaultGridFormat: ENiagaraGpuBufferFormat;
	DefaultRendererMotionVectorSetting: ENiagaraDefaultRendererMotionVectorSetting;
	DefaultPixelCoverageMode: ENiagaraDefaultRendererPixelCoverageMode;
	NDISkelMesh_GpuMaxInfluences: ENDISkelMesh_GpuMaxInfluences;
	NDISkelMesh_GpuUniformSamplingFormat: ENDISkelMesh_GpuUniformSamplingFormat;
	NDISkelMesh_AdjacencyTriangleIndexFormat: ENDISkelMesh_AdjacencyTriangleIndexFormat;
	NDIStaticMesh_AllowDistanceFields: boolean;
	NDICollisionQuery_AsyncGpuTraceProviderOrder: ENDICollisionQuery_AsyncGpuTraceProvider[];
	static Load(ResourceName: string): NiagaraSettings;
	static Find(Outer: UObject, ResourceName: string): NiagaraSettings;
	static GetDefaultObject(): NiagaraSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraSettings;
	static C(Other: UObject | any): NiagaraSettings;
}

declare type ENiagaraIterationSource = 'Particles' | 'DataInterface' | 'ENiagaraIterationSource_MAX';
declare var ENiagaraIterationSource : { Particles:'Particles',DataInterface:'DataInterface',ENiagaraIterationSource_MAX:'ENiagaraIterationSource_MAX', };
declare class NiagaraVariableDataInterfaceBinding { 
	BoundVariable: NiagaraVariable;
	clone() : NiagaraVariableDataInterfaceBinding;
	static C(Other: UObject | any): NiagaraVariableDataInterfaceBinding;
}

declare class NiagaraSimulationStageGeneric extends NiagaraSimulationStageBase { 
	EnabledBinding: NiagaraVariableAttributeBinding;
	IterationSource: ENiagaraIterationSource;
	Iterations: number;
	NumIterationsBinding: NiagaraVariableAttributeBinding;
	bSpawnOnly: boolean;
	ExecuteBehavior: ENiagaraSimStageExecuteBehavior;
	bDisablePartialParticleUpdate: boolean;
	DataInterface: NiagaraVariableDataInterfaceBinding;
	bParticleIterationStateEnabled: boolean;
	ParticleIterationStateBinding: NiagaraVariableAttributeBinding;
	ParticleIterationStateRange: IntPoint;
	bGpuDispatchForceLinear: boolean;
	bOverrideGpuDispatchNumThreads: boolean;
	OverrideGpuDispatchNumThreads: IntVector;
	static Load(ResourceName: string): NiagaraSimulationStageGeneric;
	static Find(Outer: UObject, ResourceName: string): NiagaraSimulationStageGeneric;
	static GetDefaultObject(): NiagaraSimulationStageGeneric;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraSimulationStageGeneric;
	static C(Other: UObject | any): NiagaraSimulationStageGeneric;
}

declare type ENiagaraSpriteAlignment = 'Unaligned' | 'VelocityAligned' | 'CustomAlignment' | 'ENiagaraSpriteAlignment_MAX';
declare var ENiagaraSpriteAlignment : { Unaligned:'Unaligned',VelocityAligned:'VelocityAligned',CustomAlignment:'CustomAlignment',ENiagaraSpriteAlignment_MAX:'ENiagaraSpriteAlignment_MAX', };
declare type ENiagaraSpriteFacingMode = 'FaceCamera' | 'FaceCameraPlane' | 'CustomFacingVector' | 'FaceCameraPosition' | 'FaceCameraDistanceBlend' | 'ENiagaraSpriteFacingMode_MAX';
declare var ENiagaraSpriteFacingMode : { FaceCamera:'FaceCamera',FaceCameraPlane:'FaceCameraPlane',CustomFacingVector:'CustomFacingVector',FaceCameraPosition:'FaceCameraPosition',FaceCameraDistanceBlend:'FaceCameraDistanceBlend',ENiagaraSpriteFacingMode_MAX:'ENiagaraSpriteFacingMode_MAX', };
declare type ENiagaraRendererPixelCoverageMode = 'Automatic' | 'Disabled' | 'Enabled' | 'Enabled_RGBA' | 'Enabled_RGB' | 'Enabled_A' | 'ENiagaraRendererPixelCoverageMode_MAX';
declare var ENiagaraRendererPixelCoverageMode : { Automatic:'Automatic',Disabled:'Disabled',Enabled:'Enabled',Enabled_RGBA:'Enabled_RGBA',Enabled_RGB:'Enabled_RGB',Enabled_A:'Enabled_A',ENiagaraRendererPixelCoverageMode_MAX:'ENiagaraRendererPixelCoverageMode_MAX', };
declare class NiagaraSpriteRendererProperties extends NiagaraRendererProperties { 
	Material: MaterialInterface;
	SourceMode: ENiagaraRendererSourceDataMode;
	MaterialUserParamBinding: NiagaraUserParameterBinding;
	Alignment: ENiagaraSpriteAlignment;
	FacingMode: ENiagaraSpriteFacingMode;
	PivotInUVSpace: Vector2D;
	MacroUVRadius: number;
	SortMode: ENiagaraSortMode;
	SubImageSize: Vector2D;
	bSubImageBlend: boolean;
	bRemoveHMDRollInVR: boolean;
	bSortOnlyWhenTranslucent: boolean;
	bGpuLowLatencyTranslucency: boolean;
	PixelCoverageMode: ENiagaraRendererPixelCoverageMode;
	PixelCoverageBlend: number;
	MinFacingCameraBlendDistance: number;
	MaxFacingCameraBlendDistance: number;
	bEnableCameraDistanceCulling: boolean;
	MinCameraDistance: number;
	MaxCameraDistance: number;
	RendererVisibility: any;
	PositionBinding: NiagaraVariableAttributeBinding;
	ColorBinding: NiagaraVariableAttributeBinding;
	VelocityBinding: NiagaraVariableAttributeBinding;
	SpriteRotationBinding: NiagaraVariableAttributeBinding;
	SpriteSizeBinding: NiagaraVariableAttributeBinding;
	SpriteFacingBinding: NiagaraVariableAttributeBinding;
	SpriteAlignmentBinding: NiagaraVariableAttributeBinding;
	SubImageIndexBinding: NiagaraVariableAttributeBinding;
	DynamicMaterialBinding: NiagaraVariableAttributeBinding;
	DynamicMaterial1Binding: NiagaraVariableAttributeBinding;
	DynamicMaterial2Binding: NiagaraVariableAttributeBinding;
	DynamicMaterial3Binding: NiagaraVariableAttributeBinding;
	CameraOffsetBinding: NiagaraVariableAttributeBinding;
	UVScaleBinding: NiagaraVariableAttributeBinding;
	PivotOffsetBinding: NiagaraVariableAttributeBinding;
	MaterialRandomBinding: NiagaraVariableAttributeBinding;
	CustomSortingBinding: NiagaraVariableAttributeBinding;
	NormalizedAgeBinding: NiagaraVariableAttributeBinding;
	RendererVisibilityTagBinding: NiagaraVariableAttributeBinding;
	MaterialParameterBindings: NiagaraMaterialAttributeBinding[];
	PrevPositionBinding: NiagaraVariableAttributeBinding;
	PrevVelocityBinding: NiagaraVariableAttributeBinding;
	PrevSpriteRotationBinding: NiagaraVariableAttributeBinding;
	PrevSpriteSizeBinding: NiagaraVariableAttributeBinding;
	PrevSpriteFacingBinding: NiagaraVariableAttributeBinding;
	PrevSpriteAlignmentBinding: NiagaraVariableAttributeBinding;
	PrevCameraOffsetBinding: NiagaraVariableAttributeBinding;
	PrevPivotOffsetBinding: NiagaraVariableAttributeBinding;
	bUseMaterialCutoutTexture: boolean;
	CutoutTexture: Texture2D;
	BoundingMode: ESubUVBoundingVertexCount;
	OpacitySourceMode: EOpacitySourceMode;
	AlphaThreshold: number;
	static Load(ResourceName: string): NiagaraSpriteRendererProperties;
	static Find(Outer: UObject, ResourceName: string): NiagaraSpriteRendererProperties;
	static GetDefaultObject(): NiagaraSpriteRendererProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraSpriteRendererProperties;
	static C(Other: UObject | any): NiagaraSpriteRendererProperties;
}

declare class SphericalPontoon { 
	CenterSocket: string;
	RelativeLocation: Vector;
	Radius: number;
	LocalForce: Vector;
	CenterLocation: Vector;
	SocketRotation: Quat;
	Offset: Vector;
	WaterHeight: number;
	WaterDepth: number;
	ImmersionDepth: number;
	WaterPlaneLocation: Vector;
	WaterPlaneNormal: Vector;
	WaterSurfacePosition: Vector;
	WaterVelocity: Vector;
	WaterBodyIndex: number;
	CurrentWaterBodyComponent: WaterBodyComponent;
	clone() : SphericalPontoon;
	static C(Other: UObject | any): SphericalPontoon;
}

declare class BuoyancyData { 
	Pontoons: SphericalPontoon[];
	BuoyancyCoefficient: number;
	BuoyancyDamp: number;
	BuoyancyDamp2: number;
	BuoyancyRampMinVelocity: number;
	BuoyancyRampMaxVelocity: number;
	BuoyancyRampMax: number;
	MaxBuoyantForce: number;
	bApplyDragForcesInWater: boolean;
	DragCoefficient: number;
	DragCoefficient2: number;
	AngularDragCoefficient: number;
	MaxDragSpeed: number;
	bApplyRiverForces: boolean;
	RiverPontoonIndex: number;
	WaterShorePushFactor: number;
	RiverTraversalPathWidth: number;
	MaxShorePushForce: number;
	WaterVelocityStrength: number;
	MaxWaterForce: number;
	bAlwaysAllowLateralPush: boolean;
	bAllowCurrentWhenMovingFastUpstream: boolean;
	bApplyDownstreamAngularRotation: boolean;
	DownstreamAxisOfRotation: Vector;
	DownstreamRotationStrength: number;
	DownstreamRotationStiffness: number;
	DownstreamRotationAngularDamping: number;
	DownstreamMaxAcceleration: number;
	clone() : BuoyancyData;
	static C(Other: UObject | any): BuoyancyData;
}

declare class BuoyancyComponent extends ActorComponent { 
	Pontoons: SphericalPontoon[];
	OnEnteredWaterDelegate: UnrealEngineMulticastDelegate<(Pontoon: SphericalPontoon) => void>;
	OnExitedWaterDelegate: UnrealEngineMulticastDelegate<(Pontoon: SphericalPontoon) => void>;
	BuoyancyData: BuoyancyData;
	CurrentWaterBodyComponents: WaterBodyComponent[];
	SimulatingComponent: PrimitiveComponent;
	static Load(ResourceName: string): BuoyancyComponent;
	static Find(Outer: UObject, ResourceName: string): BuoyancyComponent;
	static GetDefaultObject(): BuoyancyComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BuoyancyComponent;
	OnPontoonExitedWater(Pontoon: SphericalPontoon): void;
	OnPontoonEnteredWater(Pontoon: SphericalPontoon): void;
	IsOverlappingWaterBody(): boolean;
	IsInWaterBody(): boolean;
	GetLastWaterSurfaceInfo(OutWaterPlaneLocation?: Vector,OutWaterPlaneNormal?: Vector,OutWaterSurfacePosition?: Vector,OutWaterDepth?: number,OutWaterBodyIdx?: number,OutWaterVelocity?: Vector): {OutWaterPlaneLocation: Vector, OutWaterPlaneNormal: Vector, OutWaterSurfacePosition: Vector, OutWaterDepth: number, OutWaterBodyIdx: number, OutWaterVelocity: Vector};
	GetCurrentWaterBodyComponents(): WaterBodyComponent[];
	static C(Other: UObject | any): BuoyancyComponent;
}

declare class BuoyancyManager extends Actor { 
	BuoyancyComponents: BuoyancyComponent[];
	static GetDefaultObject(): BuoyancyManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BuoyancyManager;
	static GetBuoyancyComponentManager(WorldContextObject: UObject,Manager?: BuoyancyManager): {Manager: BuoyancyManager, $: boolean};
	static C(Other: UObject | any): BuoyancyManager;
}

declare class EnvQueryTest_InsideWaterBody extends EnvQueryTest { 
	bIncludeWaves: boolean;
	bSimpleWaves: boolean;
	bIgnoreExclusionVolumes: boolean;
	static Load(ResourceName: string): EnvQueryTest_InsideWaterBody;
	static Find(Outer: UObject, ResourceName: string): EnvQueryTest_InsideWaterBody;
	static GetDefaultObject(): EnvQueryTest_InsideWaterBody;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvQueryTest_InsideWaterBody;
	static C(Other: UObject | any): EnvQueryTest_InsideWaterBody;
}

declare class GerstnerWave { 
	WaveLength: number;
	Amplitude: number;
	Steepness: number;
	Direction: Vector;
	WaveVector: Vector2D;
	WaveSpeed: number;
	WKA: number;
	Q: number;
	PhaseOffset: number;
	clone() : GerstnerWave;
	static C(Other: UObject | any): GerstnerWave;
}

declare class GerstnerWaterWaveGeneratorBase extends UObject { 
	static Load(ResourceName: string): GerstnerWaterWaveGeneratorBase;
	static Find(Outer: UObject, ResourceName: string): GerstnerWaterWaveGeneratorBase;
	static GetDefaultObject(): GerstnerWaterWaveGeneratorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GerstnerWaterWaveGeneratorBase;
	GenerateGerstnerWaves(OutWaves?: GerstnerWave[]): {OutWaves: GerstnerWave[]};
	static C(Other: UObject | any): GerstnerWaterWaveGeneratorBase;
}

declare class GerstnerWaterWaveGeneratorSimple extends GerstnerWaterWaveGeneratorBase { 
	NumWaves: number;
	Seed: number;
	Randomness: number;
	MinWavelength: number;
	MaxWavelength: number;
	WavelengthFalloff: number;
	MinAmplitude: number;
	MaxAmplitude: number;
	AmplitudeFalloff: number;
	WindAngleDeg: number;
	DirectionAngularSpreadDeg: number;
	SmallWaveSteepness: number;
	LargeWaveSteepness: number;
	SteepnessFalloff: number;
	static Load(ResourceName: string): GerstnerWaterWaveGeneratorSimple;
	static Find(Outer: UObject, ResourceName: string): GerstnerWaterWaveGeneratorSimple;
	static GetDefaultObject(): GerstnerWaterWaveGeneratorSimple;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GerstnerWaterWaveGeneratorSimple;
	static C(Other: UObject | any): GerstnerWaterWaveGeneratorSimple;
}

declare type EWaveSpectrumType = 'Phillips' | 'PiersonMoskowitz' | 'JONSWAP' | 'EWaveSpectrumType_MAX';
declare var EWaveSpectrumType : { Phillips:'Phillips',PiersonMoskowitz:'PiersonMoskowitz',JONSWAP:'JONSWAP',EWaveSpectrumType_MAX:'EWaveSpectrumType_MAX', };
declare class GerstnerWaveOctave { 
	NumWaves: number;
	AmplitudeScale: number;
	MainDirection: number;
	SpreadAngle: number;
	bUniformSpread: boolean;
	clone() : GerstnerWaveOctave;
	static C(Other: UObject | any): GerstnerWaveOctave;
}

declare class GerstnerWaterWaveGeneratorSpectrum extends GerstnerWaterWaveGeneratorBase { 
	SpectrumType: EWaveSpectrumType;
	Octaves: GerstnerWaveOctave[];
	static Load(ResourceName: string): GerstnerWaterWaveGeneratorSpectrum;
	static Find(Outer: UObject, ResourceName: string): GerstnerWaterWaveGeneratorSpectrum;
	static GetDefaultObject(): GerstnerWaterWaveGeneratorSpectrum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GerstnerWaterWaveGeneratorSpectrum;
	static C(Other: UObject | any): GerstnerWaterWaveGeneratorSpectrum;
}

declare class WaterWaves extends WaterWavesBase { 
	static Load(ResourceName: string): WaterWaves;
	static Find(Outer: UObject, ResourceName: string): WaterWaves;
	static GetDefaultObject(): WaterWaves;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterWaves;
	static C(Other: UObject | any): WaterWaves;
}

declare class GerstnerWaterWaves extends WaterWaves { 
	GerstnerWaveGenerator: GerstnerWaterWaveGeneratorBase;
	GerstnerWaves: GerstnerWave[];
	MaxWaveHeight: number;
	static Load(ResourceName: string): GerstnerWaterWaves;
	static Find(Outer: UObject, ResourceName: string): GerstnerWaterWaves;
	static GetDefaultObject(): GerstnerWaterWaves;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GerstnerWaterWaves;
	static C(Other: UObject | any): GerstnerWaterWaves;
}

declare class GerstnerWaterWaveSubsystem extends EngineSubsystem { 
	static Load(ResourceName: string): GerstnerWaterWaveSubsystem;
	static Find(Outer: UObject, ResourceName: string): GerstnerWaterWaveSubsystem;
	static GetDefaultObject(): GerstnerWaterWaveSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GerstnerWaterWaveSubsystem;
	static C(Other: UObject | any): GerstnerWaterWaveSubsystem;
}

declare class LakeCollisionComponent extends PrimitiveComponent { 
	CachedBodySetup: BodySetup;
	BoxExtent: Vector;
	static Load(ResourceName: string): LakeCollisionComponent;
	static Find(Outer: UObject, ResourceName: string): LakeCollisionComponent;
	static GetDefaultObject(): LakeCollisionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LakeCollisionComponent;
	static C(Other: UObject | any): LakeCollisionComponent;
}

declare class NiagaraDataInterfaceWater extends NiagaraDataInterface { 
	SourceBodyComponent: WaterBodyComponent;
	static Load(ResourceName: string): NiagaraDataInterfaceWater;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceWater;
	static GetDefaultObject(): NiagaraDataInterfaceWater;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceWater;
	static C(Other: UObject | any): NiagaraDataInterfaceWater;
}

declare class NiagaraWaterFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): NiagaraWaterFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): NiagaraWaterFunctionLibrary;
	static GetDefaultObject(): NiagaraWaterFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraWaterFunctionLibrary;
	static SetWaterBodyComponent(NiagaraSystem: NiagaraComponent,OverrideName: string,WaterBodyComponent: WaterBodyComponent): void;
	static SetWaterBody(NiagaraSystem: NiagaraComponent,OverrideName: string,WaterBody: WaterBody): void;
	static C(Other: UObject | any): NiagaraWaterFunctionLibrary;
}

declare class OceanCollisionComponent extends PrimitiveComponent { 
	CachedBodySetup: BodySetup;
	static Load(ResourceName: string): OceanCollisionComponent;
	static Find(Outer: UObject, ResourceName: string): OceanCollisionComponent;
	static GetDefaultObject(): OceanCollisionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OceanCollisionComponent;
	static C(Other: UObject | any): OceanCollisionComponent;
}

declare class OceanBoxCollisionComponent extends BoxComponent { 
	static Load(ResourceName: string): OceanBoxCollisionComponent;
	static Find(Outer: UObject, ResourceName: string): OceanBoxCollisionComponent;
	static GetDefaultObject(): OceanBoxCollisionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OceanBoxCollisionComponent;
	static C(Other: UObject | any): OceanBoxCollisionComponent;
}

declare class WaterBodyGenerator extends UObject { 
	static Load(ResourceName: string): WaterBodyGenerator;
	static Find(Outer: UObject, ResourceName: string): WaterBodyGenerator;
	static GetDefaultObject(): WaterBodyGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBodyGenerator;
	static C(Other: UObject | any): WaterBodyGenerator;
}

declare class CustomMeshGenerator extends WaterBodyGenerator { 
	MeshComp: StaticMeshComponent;
	static Load(ResourceName: string): CustomMeshGenerator;
	static Find(Outer: UObject, ResourceName: string): CustomMeshGenerator;
	static GetDefaultObject(): CustomMeshGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CustomMeshGenerator;
	static C(Other: UObject | any): CustomMeshGenerator;
}

declare class WaterBodyCustom extends WaterBody { 
	CustomGenerator: CustomMeshGenerator;
	static GetDefaultObject(): WaterBodyCustom;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBodyCustom;
	static C(Other: UObject | any): WaterBodyCustom;
}

declare class WaterBodyCustomComponent extends WaterBodyComponent { 
	MeshComp: StaticMeshComponent;
	static Load(ResourceName: string): WaterBodyCustomComponent;
	static Find(Outer: UObject, ResourceName: string): WaterBodyCustomComponent;
	static GetDefaultObject(): WaterBodyCustomComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBodyCustomComponent;
	static C(Other: UObject | any): WaterBodyCustomComponent;
}

declare class LakeGenerator extends WaterBodyGenerator { 
	LakeMeshComp: StaticMeshComponent;
	LakeCollisionComp: BoxComponent;
	LakeCollision: LakeCollisionComponent;
	static Load(ResourceName: string): LakeGenerator;
	static Find(Outer: UObject, ResourceName: string): LakeGenerator;
	static GetDefaultObject(): LakeGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LakeGenerator;
	static C(Other: UObject | any): LakeGenerator;
}

declare class WaterBodyLake extends WaterBody { 
	LakeGenerator: LakeGenerator;
	static GetDefaultObject(): WaterBodyLake;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBodyLake;
	static C(Other: UObject | any): WaterBodyLake;
}

declare class WaterBodyLakeComponent extends WaterBodyComponent { 
	LakeMeshComp: StaticMeshComponent;
	LakeCollision: LakeCollisionComponent;
	static Load(ResourceName: string): WaterBodyLakeComponent;
	static Find(Outer: UObject, ResourceName: string): WaterBodyLakeComponent;
	static GetDefaultObject(): WaterBodyLakeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBodyLakeComponent;
	static C(Other: UObject | any): WaterBodyLakeComponent;
}

declare class OceanGenerator extends WaterBodyGenerator { 
	CollisionBoxes: OceanBoxCollisionComponent[];
	CollisionHullSets: OceanCollisionComponent[];
	static Load(ResourceName: string): OceanGenerator;
	static Find(Outer: UObject, ResourceName: string): OceanGenerator;
	static GetDefaultObject(): OceanGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OceanGenerator;
	static C(Other: UObject | any): OceanGenerator;
}

declare class WaterBodyOcean extends WaterBody { 
	OceanGenerator: OceanGenerator;
	CollisionExtents: Vector;
	static GetDefaultObject(): WaterBodyOcean;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBodyOcean;
	static C(Other: UObject | any): WaterBodyOcean;
}

declare class WaterBodyOceanComponent extends WaterBodyComponent { 
	CollisionBoxes: OceanBoxCollisionComponent[];
	CollisionHullSets: OceanCollisionComponent[];
	CollisionExtents: Vector;
	HeightOffset: number;
	static Load(ResourceName: string): WaterBodyOceanComponent;
	static Find(Outer: UObject, ResourceName: string): WaterBodyOceanComponent;
	static GetDefaultObject(): WaterBodyOceanComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBodyOceanComponent;
	static C(Other: UObject | any): WaterBodyOceanComponent;
}

declare class RiverGenerator extends WaterBodyGenerator { 
	SplineMeshComponents: SplineMeshComponent[];
	static Load(ResourceName: string): RiverGenerator;
	static Find(Outer: UObject, ResourceName: string): RiverGenerator;
	static GetDefaultObject(): RiverGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RiverGenerator;
	static C(Other: UObject | any): RiverGenerator;
}

declare class WaterBodyRiver extends WaterBody { 
	RiverGenerator: RiverGenerator;
	LakeTransitionMaterial: MaterialInterface;
	LakeTransitionMID: MaterialInstanceDynamic;
	OceanTransitionMaterial: MaterialInterface;
	OceanTransitionMID: MaterialInstanceDynamic;
	static GetDefaultObject(): WaterBodyRiver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBodyRiver;
	static C(Other: UObject | any): WaterBodyRiver;
}

declare class WaterBodyRiverComponent extends WaterBodyComponent { 
	SplineMeshComponents: SplineMeshComponent[];
	LakeTransitionMaterial: MaterialInterface;
	LakeTransitionMID: MaterialInstanceDynamic;
	OceanTransitionMaterial: MaterialInterface;
	OceanTransitionMID: MaterialInstanceDynamic;
	static Load(ResourceName: string): WaterBodyRiverComponent;
	static Find(Outer: UObject, ResourceName: string): WaterBodyRiverComponent;
	static GetDefaultObject(): WaterBodyRiverComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBodyRiverComponent;
	static C(Other: UObject | any): WaterBodyRiverComponent;
}

declare class WaterBrushActorInterface extends Interface { 
	static Load(ResourceName: string): WaterBrushActorInterface;
	static Find(Outer: UObject, ResourceName: string): WaterBrushActorInterface;
	static GetDefaultObject(): WaterBrushActorInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBrushActorInterface;
	static C(Other: UObject | any): WaterBrushActorInterface;
}

declare class WaterMeshComponent extends MeshComponent { 
	ForceCollapseDensityLevel: number;
	FarDistanceMaterial: MaterialInterface;
	FarDistanceMeshExtent: number;
	RTWorldLocation: Vector;
	RTWorldSizeVector: Vector;
	TileSize: number;
	ExtentInTiles: IntPoint;
	UsedMaterials: any;
	TessellationFactor: number;
	LODScale: number;
	static Load(ResourceName: string): WaterMeshComponent;
	static Find(Outer: UObject, ResourceName: string): WaterMeshComponent;
	static GetDefaultObject(): WaterMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterMeshComponent;
	IsEnabled(): boolean;
	static C(Other: UObject | any): WaterMeshComponent;
}

declare class WaterRuntimeSettings extends DeveloperSettings { 
	CollisionChannelForWaterTraces: ECollisionChannel;
	MaterialParameterCollection: MaterialParameterCollection;
	WaterBodyIconWorldSize: number;
	WaterBodyIconWorldZOffset: number;
	DefaultWaterCollisionProfileName: string;
	WaterBodyRiverComponentClass: UnrealEngineClass;
	WaterBodyLakeComponentClass: UnrealEngineClass;
	WaterBodyOceanComponentClass: UnrealEngineClass;
	WaterBodyCustomComponentClass: UnrealEngineClass;
	static Load(ResourceName: string): WaterRuntimeSettings;
	static Find(Outer: UObject, ResourceName: string): WaterRuntimeSettings;
	static GetDefaultObject(): WaterRuntimeSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterRuntimeSettings;
	static C(Other: UObject | any): WaterRuntimeSettings;
}

declare class WaterZone extends Actor { 
	WaterVelocityTexture: Texture2D;
	BoundsComponent: BoxComponent;
	SelectedWaterBodies: any[];
	ActorIcon: BillboardComponent;
	WaterMesh: WaterMeshComponent;
	static GetDefaultObject(): WaterZone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterZone;
	static C(Other: UObject | any): WaterZone;
}

declare class WaterSubsystem extends TickableWorldSubsystem { 
	BuoyancyManager: BuoyancyManager;
	OnCameraUnderwaterStateChanged: UnrealEngineMulticastDelegate<(bIsUnderWater: boolean, DepthUnderwater: number) => void>;
	OnWaterScalabilityChanged: UnrealEngineMulticastDelegate<() => void>;
	DefaultRiverMesh: StaticMesh;
	DefaultLakeMesh: StaticMesh;
	WaterZoneActor: WaterZone;
	MaterialParameterCollection: MaterialParameterCollection;
	static Load(ResourceName: string): WaterSubsystem;
	static Find(Outer: UObject, ResourceName: string): WaterSubsystem;
	static GetDefaultObject(): WaterSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterSubsystem;
	SetOceanFloodHeight(InFloodHeight: number): void;
	PrintToWaterLog(Message: string,bWarning: boolean): void;
	IsWaterRenderingEnabled(): boolean;
	IsUnderwaterPostProcessEnabled(): boolean;
	IsShallowWaterSimulationEnabled(): boolean;
	GetWaterTimeSeconds(): number;
	GetSmoothedWorldTimeSeconds(): number;
	static GetShallowWaterSimulationRenderTargetSize(): number;
	static GetShallowWaterMaxImpulseForces(): number;
	static GetShallowWaterMaxDynamicForces(): number;
	GetOceanTotalHeight(): number;
	GetOceanFloodHeight(): number;
	GetOceanBaseHeight(): number;
	GetCameraUnderwaterDepth(): number;
	static C(Other: UObject | any): WaterSubsystem;
}

declare class WaterWavesAsset extends UObject { 
	WaterWaves: WaterWaves;
	static Load(ResourceName: string): WaterWavesAsset;
	static Find(Outer: UObject, ResourceName: string): WaterWavesAsset;
	static GetDefaultObject(): WaterWavesAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterWavesAsset;
	static C(Other: UObject | any): WaterWavesAsset;
}

declare class WaterWavesAssetReference extends WaterWavesBase { 
	WaterWavesAsset: WaterWavesAsset;
	static Load(ResourceName: string): WaterWavesAssetReference;
	static Find(Outer: UObject, ResourceName: string): WaterWavesAssetReference;
	static GetDefaultObject(): WaterWavesAssetReference;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterWavesAssetReference;
	static C(Other: UObject | any): WaterWavesAssetReference;
}

declare class JsonLibraryBlueprintHelpers extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): JsonLibraryBlueprintHelpers;
	static Find(Outer: UObject, ResourceName: string): JsonLibraryBlueprintHelpers;
	static GetDefaultObject(): JsonLibraryBlueprintHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JsonLibraryBlueprintHelpers;
	static StructToJson(StructType: ScriptStruct,struct: StructBase): JsonLibraryObject;
	static StructFromJson(StructType: ScriptStruct,UObject: JsonLibraryObject,OutStruct?: StructBase): {OutStruct: StructBase, $: boolean};
	static IsValidObject(UObject: JsonLibraryObject): boolean;
	static ConstructInvalidObject(): JsonLibraryObject;
	static C(Other: UObject | any): JsonLibraryBlueprintHelpers;
}

declare class JsonLibraryHelpers extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): JsonLibraryHelpers;
	static Find(Outer: UObject, ResourceName: string): JsonLibraryHelpers;
	static GetDefaultObject(): JsonLibraryHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JsonLibraryHelpers;
	static ToVectorMap(Target: JsonLibraryValue): any;
	static ToVectorArray(Target: JsonLibraryValue): Vector[];
	static ToVector(Value: JsonLibraryValue): Vector;
	static ToTransformMap(Target: JsonLibraryValue): any;
	static ToTransformArray(Target: JsonLibraryValue): Transform[];
	static ToTransform(Value: JsonLibraryValue): Transform;
	static ToStringMap(Target: JsonLibraryValue): any;
	static ToStringArray(Target: JsonLibraryValue): string[];
	static ToString(Value: JsonLibraryValue): string;
	static ToRotatorMap(Target: JsonLibraryValue): any;
	static ToRotatorArray(Target: JsonLibraryValue): Rotator[];
	static ToRotator(Value: JsonLibraryValue): Rotator;
	static ToObjectArray(Target: JsonLibraryValue): JsonLibraryObject[];
	static ToObject(Value: JsonLibraryValue): JsonLibraryObject;
	static ToMap(Target: JsonLibraryValue): any;
	static ToList(Value: JsonLibraryValue): JsonLibraryList;
	static ToLinearColorMap(Target: JsonLibraryValue): any;
	static ToLinearColorArray(Target: JsonLibraryValue): LinearColor[];
	static ToLinearColor(Value: JsonLibraryValue): LinearColor;
	static ToIntegerMap(Target: JsonLibraryValue): any;
	static ToIntegerArray(Target: JsonLibraryValue): number[];
	static ToInteger(Value: JsonLibraryValue): number;
	static ToGuidMap(Target: JsonLibraryValue): any;
	static ToGuidArray(Target: JsonLibraryValue): Guid[];
	static ToGuid(Value: JsonLibraryValue): Guid;
	static ToFloatMap(Target: JsonLibraryValue): any;
	static ToFloatArray(Target: JsonLibraryValue): number[];
	static ToFloat(Value: JsonLibraryValue): number;
	static ToDateTimeMap(Target: JsonLibraryValue): any;
	static ToDateTimeArray(Target: JsonLibraryValue): DateTime[];
	static ToDateTime(Value: JsonLibraryValue): DateTime;
	static ToColorMap(Target: JsonLibraryValue): any;
	static ToColorArray(Target: JsonLibraryValue): Color[];
	static ToColor(Value: JsonLibraryValue): Color;
	static ToBooleanMap(Target: JsonLibraryValue): any;
	static ToBooleanArray(Target: JsonLibraryValue): boolean[];
	static ToBoolean(Value: JsonLibraryValue): boolean;
	static ToArray(Target: JsonLibraryValue): JsonLibraryValue[];
	static StripCommentsOrCommas(text: string,bComments: boolean,bTrailingCommas: boolean): string;
	static Parse(text: string,bComments: boolean,bTrailingCommas: boolean): JsonLibraryValue;
	static JsonValue_Stringify(Target: JsonLibraryValue,bCondensed: boolean): string;
	static JsonValue_IsVector(Target: JsonLibraryValue): boolean;
	static JsonValue_IsValid(Target: JsonLibraryValue): boolean;
	static JsonValue_IsTransform(Target: JsonLibraryValue): boolean;
	static JsonValue_IsRotator(Target: JsonLibraryValue): boolean;
	static JsonValue_IsGuid(Target: JsonLibraryValue): boolean;
	static JsonValue_GetType(Target: JsonLibraryValue): EJsonLibraryType;
	static JsonValue_Equals(Target: JsonLibraryValue,Value: JsonLibraryValue): boolean;
	static JsonObject_Stringify(Target: JsonLibraryObject,bCondensed: boolean): string;
	static JsonObject_SetVector(Target?: JsonLibraryObject,Key?: string,Value?: Vector): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetValue(Target?: JsonLibraryObject,Key?: string,Value?: JsonLibraryValue): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetTransform(Target?: JsonLibraryObject,Key?: string,Value?: Transform): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetString(Target?: JsonLibraryObject,Key?: string,Value?: string): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetRotator(Target?: JsonLibraryObject,Key?: string,Value?: Rotator): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetObject(Target?: JsonLibraryObject,Key?: string,Value?: JsonLibraryObject): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetMap(Target?: JsonLibraryObject,Key?: string,Value?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetList(Target?: JsonLibraryObject,Key?: string,Value?: JsonLibraryList): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetLinearColor(Target?: JsonLibraryObject,Key?: string,Value?: LinearColor): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetInteger(Target?: JsonLibraryObject,Key?: string,Value?: number): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetGuid(Target?: JsonLibraryObject,Key?: string,Value?: Guid): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetFloat(Target?: JsonLibraryObject,Key?: string,Value?: number): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetDateTime(Target?: JsonLibraryObject,Key?: string,Value?: DateTime): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetColor(Target?: JsonLibraryObject,Key?: string,Value?: Color): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetBoolean(Target?: JsonLibraryObject,Key?: string,Value?: boolean): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetArray(Target?: JsonLibraryObject,Key?: string,Value?: JsonLibraryValue[]): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_RemoveKey(Target?: JsonLibraryObject,Key?: string): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_IsVector(Target: JsonLibraryObject): boolean;
	static JsonObject_IsValid(Target: JsonLibraryObject): boolean;
	static JsonObject_IsTransform(Target: JsonLibraryObject): boolean;
	static JsonObject_IsRotator(Target: JsonLibraryObject): boolean;
	static JsonObject_IsEmpty(Target: JsonLibraryObject): boolean;
	static JsonObject_HasKey(Target: JsonLibraryObject,Key: string): boolean;
	static JsonObject_GetVector(Target: JsonLibraryObject,Key: string): Vector;
	static JsonObject_GetValues(Target: JsonLibraryObject): JsonLibraryValue[];
	static JsonObject_GetValue(Target: JsonLibraryObject,Key: string): JsonLibraryValue;
	static JsonObject_GetTransform(Target: JsonLibraryObject,Key: string): Transform;
	static JsonObject_GetString(Target: JsonLibraryObject,Key: string): string;
	static JsonObject_GetRotator(Target: JsonLibraryObject,Key: string): Rotator;
	static JsonObject_GetObject(Target: JsonLibraryObject,Key: string): JsonLibraryObject;
	static JsonObject_GetMap(Target: JsonLibraryObject,Key: string): any;
	static JsonObject_GetList(Target: JsonLibraryObject,Key: string): JsonLibraryList;
	static JsonObject_GetLinearColor(Target: JsonLibraryObject,Key: string): LinearColor;
	static JsonObject_GetKeys(Target: JsonLibraryObject): string[];
	static JsonObject_GetInteger(Target: JsonLibraryObject,Key: string): number;
	static JsonObject_GetGuid(Target: JsonLibraryObject,Key: string): Guid;
	static JsonObject_GetFloat(Target: JsonLibraryObject,Key: string): number;
	static JsonObject_GetDateTime(Target: JsonLibraryObject,Key: string): DateTime;
	static JsonObject_GetColor(Target: JsonLibraryObject,Key: string): Color;
	static JsonObject_GetBoolean(Target: JsonLibraryObject,Key: string): boolean;
	static JsonObject_GetArray(Target: JsonLibraryObject,Key: string): JsonLibraryValue[];
	static JsonObject_Equals(Target: JsonLibraryObject,UObject: JsonLibraryObject): boolean;
	static JsonObject_Count(Target: JsonLibraryObject): number;
	static JsonObject_Clear(Target?: JsonLibraryObject): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddVectorMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddTransformMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddStringMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddRotatorMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddLinearColorMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddIntegerMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddGuidMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddFloatMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddDateTimeMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddColorMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddBooleanMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_Add(Target?: JsonLibraryObject,UObject?: JsonLibraryObject): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonList_Swap(Target?: JsonLibraryList,IndexA?: number,IndexB?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_Stringify(Target: JsonLibraryList,bCondensed: boolean): string;
	static JsonList_SetVector(Target?: JsonLibraryList,index?: number,Value?: Vector): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetValue(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryValue): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetTransform(Target?: JsonLibraryList,index?: number,Value?: Transform): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetString(Target?: JsonLibraryList,index?: number,Value?: string): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetRotator(Target?: JsonLibraryList,index?: number,Value?: Rotator): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetObject(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryObject): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetMap(Target?: JsonLibraryList,index?: number,Value?: any): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetList(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetLinearColor(Target?: JsonLibraryList,index?: number,Value?: LinearColor): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetInteger(Target?: JsonLibraryList,index?: number,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetGuid(Target?: JsonLibraryList,index?: number,Value?: Guid): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetFloat(Target?: JsonLibraryList,index?: number,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetDateTime(Target?: JsonLibraryList,index?: number,Value?: DateTime): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetColor(Target?: JsonLibraryList,index?: number,Value?: Color): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetBoolean(Target?: JsonLibraryList,index?: number,Value?: boolean): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetArray(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryValue[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveVector(Target?: JsonLibraryList,Value?: Vector): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveValue(Target?: JsonLibraryList,Value?: JsonLibraryValue): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveTransform(Target?: JsonLibraryList,Value?: Transform): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveString(Target?: JsonLibraryList,Value?: string): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveRotator(Target?: JsonLibraryList,Value?: Rotator): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveObject(Target?: JsonLibraryList,Value?: JsonLibraryObject): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveList(Target?: JsonLibraryList,Value?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveLinearColor(Target?: JsonLibraryList,Value?: LinearColor): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveInteger(Target?: JsonLibraryList,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveGuid(Target?: JsonLibraryList,Value?: Guid): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveFloat(Target?: JsonLibraryList,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveDateTime(Target?: JsonLibraryList,Value?: DateTime): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveColor(Target?: JsonLibraryList,Value?: Color): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveBoolean(Target?: JsonLibraryList,Value?: boolean): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_Remove(Target?: JsonLibraryList,index?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_IsValid(Target: JsonLibraryList): boolean;
	static JsonList_IsEmpty(Target: JsonLibraryList): boolean;
	static JsonList_InsertVector(Target?: JsonLibraryList,index?: number,Value?: Vector): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertValue(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryValue): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertTransform(Target?: JsonLibraryList,index?: number,Value?: Transform): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertString(Target?: JsonLibraryList,index?: number,Value?: string): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertRotator(Target?: JsonLibraryList,index?: number,Value?: Rotator): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertObject(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryObject): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertMap(Target?: JsonLibraryList,index?: number,Value?: any): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertList(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertLinearColor(Target?: JsonLibraryList,index?: number,Value?: LinearColor): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertInteger(Target?: JsonLibraryList,index?: number,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertGuid(Target?: JsonLibraryList,index?: number,Value?: Guid): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertFloat(Target?: JsonLibraryList,index?: number,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertDateTime(Target?: JsonLibraryList,index?: number,Value?: DateTime): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertColor(Target?: JsonLibraryList,index?: number,Value?: Color): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertBoolean(Target?: JsonLibraryList,index?: number,Value?: boolean): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertArray(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryValue[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectVectorArray(Target?: JsonLibraryList,index?: number,Array?: Vector[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectTransformArray(Target?: JsonLibraryList,index?: number,Array?: Transform[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectStringArray(Target?: JsonLibraryList,index?: number,Array?: string[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectRotatorArray(Target?: JsonLibraryList,index?: number,Array?: Rotator[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectObjectArray(Target?: JsonLibraryList,index?: number,Array?: JsonLibraryObject[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectLinearColorArray(Target?: JsonLibraryList,index?: number,Array?: LinearColor[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectIntegerArray(Target?: JsonLibraryList,index?: number,Array?: number[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectGuidArray(Target?: JsonLibraryList,index?: number,Array?: Guid[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectFloatArray(Target?: JsonLibraryList,index?: number,Array?: number[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectDateTimeArray(Target?: JsonLibraryList,index?: number,Array?: DateTime[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectColorArray(Target?: JsonLibraryList,index?: number,Array?: Color[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectBooleanArray(Target?: JsonLibraryList,index?: number,Array?: boolean[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_Inject(Target?: JsonLibraryList,index?: number,List?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_GetVector(Target: JsonLibraryList,index: number): Vector;
	static JsonList_GetValue(Target: JsonLibraryList,index: number): JsonLibraryValue;
	static JsonList_GetTransform(Target: JsonLibraryList,index: number): Transform;
	static JsonList_GetString(Target: JsonLibraryList,index: number): string;
	static JsonList_GetRotator(Target: JsonLibraryList,index: number): Rotator;
	static JsonList_GetObject(Target: JsonLibraryList,index: number): JsonLibraryObject;
	static JsonList_GetMap(Target: JsonLibraryList,index: number): any;
	static JsonList_GetList(Target: JsonLibraryList,index: number): JsonLibraryList;
	static JsonList_GetLinearColor(Target: JsonLibraryList,index: number): LinearColor;
	static JsonList_GetInteger(Target: JsonLibraryList,index: number): number;
	static JsonList_GetGuid(Target: JsonLibraryList,index: number): Guid;
	static JsonList_GetFloat(Target: JsonLibraryList,index: number): number;
	static JsonList_GetDateTime(Target: JsonLibraryList,index: number): DateTime;
	static JsonList_GetColor(Target: JsonLibraryList,index: number): Color;
	static JsonList_GetBoolean(Target: JsonLibraryList,index: number): boolean;
	static JsonList_GetArray(Target: JsonLibraryList,index: number): JsonLibraryValue[];
	static JsonList_FindVector(Target: JsonLibraryList,Value: Vector,index: number): number;
	static JsonList_FindValue(Target: JsonLibraryList,Value: JsonLibraryValue,index: number): number;
	static JsonList_FindTransform(Target: JsonLibraryList,Value: Transform,index: number): number;
	static JsonList_FindString(Target: JsonLibraryList,Value: string,index: number): number;
	static JsonList_FindRotator(Target: JsonLibraryList,Value: Rotator,index: number): number;
	static JsonList_FindObject(Target: JsonLibraryList,Value: JsonLibraryObject,index: number): number;
	static JsonList_FindList(Target: JsonLibraryList,Value: JsonLibraryList,index: number): number;
	static JsonList_FindLinearColor(Target: JsonLibraryList,Value: LinearColor,index: number): number;
	static JsonList_FindInteger(Target: JsonLibraryList,Value: number,index: number): number;
	static JsonList_FindGuid(Target: JsonLibraryList,Value: Guid,index: number): number;
	static JsonList_FindFloat(Target: JsonLibraryList,Value: number,index: number): number;
	static JsonList_FindDateTime(Target: JsonLibraryList,Value: DateTime,index: number): number;
	static JsonList_FindColor(Target: JsonLibraryList,Value: Color,index: number): number;
	static JsonList_FindBoolean(Target: JsonLibraryList,Value: boolean,index: number): number;
	static JsonList_Equals(Target: JsonLibraryList,List: JsonLibraryList): boolean;
	static JsonList_Count(Target: JsonLibraryList): number;
	static JsonList_Clear(Target?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendVectorArray(Target?: JsonLibraryList,Array?: Vector[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendTransformArray(Target?: JsonLibraryList,Array?: Transform[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendStringArray(Target?: JsonLibraryList,Array?: string[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendRotatorArray(Target?: JsonLibraryList,Array?: Rotator[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendObjectArray(Target?: JsonLibraryList,Array?: JsonLibraryObject[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendLinearColorArray(Target?: JsonLibraryList,Array?: LinearColor[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendIntegerArray(Target?: JsonLibraryList,Array?: number[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendGuidArray(Target?: JsonLibraryList,Array?: Guid[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendFloatArray(Target?: JsonLibraryList,Array?: number[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendDateTimeArray(Target?: JsonLibraryList,Array?: DateTime[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendColorArray(Target?: JsonLibraryList,Array?: Color[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendBooleanArray(Target?: JsonLibraryList,Array?: boolean[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_Append(Target?: JsonLibraryList,List?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddVector(Target?: JsonLibraryList,Value?: Vector): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddValue(Target?: JsonLibraryList,Value?: JsonLibraryValue): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddTransform(Target?: JsonLibraryList,Value?: Transform): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddString(Target?: JsonLibraryList,Value?: string): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddRotator(Target?: JsonLibraryList,Value?: Rotator): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddObject(Target?: JsonLibraryList,Value?: JsonLibraryObject): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddMap(Target?: JsonLibraryList,Value?: any): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddList(Target?: JsonLibraryList,Value?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddLinearColor(Target?: JsonLibraryList,Value?: LinearColor): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddInteger(Target?: JsonLibraryList,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddGuid(Target?: JsonLibraryList,Value?: Guid): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddFloat(Target?: JsonLibraryList,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddDateTime(Target?: JsonLibraryList,Value?: DateTime): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddColor(Target?: JsonLibraryList,Value?: Color): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddBoolean(Target?: JsonLibraryList,Value?: boolean): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddArray(Target?: JsonLibraryList,Value?: JsonLibraryValue[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static FromVectorMap(Value: any): JsonLibraryValue;
	static FromVectorArray(Value: Vector[]): JsonLibraryValue;
	static FromVector(Value: Vector): JsonLibraryValue;
	static FromTransformMap(Value: any): JsonLibraryValue;
	static FromTransformArray(Value: Transform[]): JsonLibraryValue;
	static FromTransform(Value: Transform): JsonLibraryValue;
	static FromStringMap(Value: any): JsonLibraryValue;
	static FromStringArray(Value: string[]): JsonLibraryValue;
	static FromString(Value: string): JsonLibraryValue;
	static FromRotatorMap(Value: any): JsonLibraryValue;
	static FromRotatorArray(Value: Rotator[]): JsonLibraryValue;
	static FromRotator(Value: Rotator): JsonLibraryValue;
	static FromObjectArray(Value: JsonLibraryObject[]): JsonLibraryValue;
	static FromObject(Value: JsonLibraryObject): JsonLibraryValue;
	static FromMap(Value: any): JsonLibraryValue;
	static FromList(Value: JsonLibraryList): JsonLibraryValue;
	static FromLinearColorMap(Value: any): JsonLibraryValue;
	static FromLinearColorArray(Value: LinearColor[]): JsonLibraryValue;
	static FromLinearColor(Value: LinearColor): JsonLibraryValue;
	static FromIntegerMap(Value: any): JsonLibraryValue;
	static FromIntegerArray(Value: number[]): JsonLibraryValue;
	static FromInteger(Value: number): JsonLibraryValue;
	static FromGuidMap(Value: any): JsonLibraryValue;
	static FromGuidArray(Value: Guid[]): JsonLibraryValue;
	static FromGuid(Value: Guid): JsonLibraryValue;
	static FromFloatMap(Value: any): JsonLibraryValue;
	static FromFloatArray(Value: number[]): JsonLibraryValue;
	static FromFloat(Value: number): JsonLibraryValue;
	static FromDateTimeMap(Value: any): JsonLibraryValue;
	static FromDateTimeArray(Value: DateTime[]): JsonLibraryValue;
	static FromDateTime(Value: DateTime): JsonLibraryValue;
	static FromColorMap(Value: any): JsonLibraryValue;
	static FromColorArray(Value: Color[]): JsonLibraryValue;
	static FromColor(Value: Color): JsonLibraryValue;
	static FromBooleanMap(Value: any): JsonLibraryValue;
	static FromBooleanArray(Value: boolean[]): JsonLibraryValue;
	static FromBoolean(Value: boolean): JsonLibraryValue;
	static FromArray(Value: JsonLibraryValue[]): JsonLibraryValue;
	static ConvertVectorToObject(Value: Vector): JsonLibraryObject;
	static ConvertVectorMapToObject(Value: any): JsonLibraryObject;
	static ConvertVectorArrayToList(Value: Vector[]): JsonLibraryList;
	static ConvertTransformToObject(Value: Transform): JsonLibraryObject;
	static ConvertTransformMapToObject(Value: any): JsonLibraryObject;
	static ConvertTransformArrayToList(Value: Transform[]): JsonLibraryList;
	static ConvertStringMapToObject(Value: any): JsonLibraryObject;
	static ConvertStringArrayToList(Value: string[]): JsonLibraryList;
	static ConvertRotatorToObject(Value: Rotator): JsonLibraryObject;
	static ConvertRotatorMapToObject(Value: any): JsonLibraryObject;
	static ConvertRotatorArrayToList(Value: Rotator[]): JsonLibraryList;
	static ConvertObjectToVector(UObject: JsonLibraryObject): Vector;
	static ConvertObjectToTransform(UObject: JsonLibraryObject): Transform;
	static ConvertObjectToRotator(UObject: JsonLibraryObject): Rotator;
	static ConvertObjectToMap(UObject: JsonLibraryObject): any;
	static ConvertObjectToLinearColor(UObject: JsonLibraryObject): LinearColor;
	static ConvertObjectArrayToList(Value: JsonLibraryObject[]): JsonLibraryList;
	static ConvertMapToObject(Value: any): JsonLibraryObject;
	static ConvertListToArray(List: JsonLibraryList): JsonLibraryValue[];
	static ConvertLinearColorToObject(Value: LinearColor): JsonLibraryObject;
	static ConvertLinearColorMapToObject(Value: any): JsonLibraryObject;
	static ConvertLinearColorArrayToList(Value: LinearColor[]): JsonLibraryList;
	static ConvertIntegerMapToObject(Value: any): JsonLibraryObject;
	static ConvertIntegerArrayToList(Value: number[]): JsonLibraryList;
	static ConvertGuidMapToObject(Value: any): JsonLibraryObject;
	static ConvertGuidArrayToList(Value: Guid[]): JsonLibraryList;
	static ConvertFloatMapToObject(Value: any): JsonLibraryObject;
	static ConvertFloatArrayToList(Value: number[]): JsonLibraryList;
	static ConvertDateTimeMapToObject(Value: any): JsonLibraryObject;
	static ConvertDateTimeArrayToList(Value: DateTime[]): JsonLibraryList;
	static ConvertColorMapToObject(Value: any): JsonLibraryObject;
	static ConvertColorArrayToList(Value: Color[]): JsonLibraryList;
	static ConvertBooleanMapToObject(Value: any): JsonLibraryObject;
	static ConvertBooleanArrayToList(Value: boolean[]): JsonLibraryList;
	static ConvertArrayToList(Value: JsonLibraryValue[]): JsonLibraryList;
	static ConstructNull(): JsonLibraryValue;
	static ConstructMap(): any;
	static ConstructArray(): JsonLibraryValue[];
	static C(Other: UObject | any): JsonLibraryHelpers;
}

declare type EHttpLibraryContentType = 'Default' | 'TXT' | 'HTML' | 'CSS' | 'CSV' | 'JSON' | 'JS' | 'RTF' | 'XML' | 'XHTML' | 'BIN' | 'FORM' | 'DATA' | 'EHttpLibraryContentType_MAX';
declare var EHttpLibraryContentType : { Default:'Default',TXT:'TXT',HTML:'HTML',CSS:'CSS',CSV:'CSV',JSON:'JSON',JS:'JS',RTF:'RTF',XML:'XML',XHTML:'XHTML',BIN:'BIN',FORM:'FORM',DATA:'DATA',EHttpLibraryContentType_MAX:'EHttpLibraryContentType_MAX', };
declare type EHttpLibraryRequestMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'HEAD' | 'CONNECT' | 'OPTIONS' | 'TRACE' | 'EHttpLibraryRequestMethod_MAX';
declare var EHttpLibraryRequestMethod : { GET:'GET',POST:'POST',PUT:'PUT',PATCH:'PATCH',DELETE:'DELETE',HEAD:'HEAD',CONNECT:'CONNECT',OPTIONS:'OPTIONS',TRACE:'TRACE',EHttpLibraryRequestMethod_MAX:'EHttpLibraryRequestMethod_MAX', };
declare class HttpLibraryBinaryRequest extends UObject { 
	static Load(ResourceName: string): HttpLibraryBinaryRequest;
	static Find(Outer: UObject, ResourceName: string): HttpLibraryBinaryRequest;
	static GetDefaultObject(): HttpLibraryBinaryRequest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HttpLibraryBinaryRequest;
	SendString(URL: string,QueryString: any,Headers: any,Content: string,ContentType: EHttpLibraryContentType,Method: EHttpLibraryRequestMethod): boolean;
	SendJSON(URL: string,QueryString: any,Headers: any,Content: JsonLibraryValue,Method: EHttpLibraryRequestMethod): boolean;
	SendBinary(URL: string,QueryString: any,Headers: any,Content: number[],ContentType: EHttpLibraryContentType,Method: EHttpLibraryRequestMethod): boolean;
	Send(URL: string,QueryString: any,Headers: any,Method: EHttpLibraryRequestMethod): boolean;
	IsRunning(): boolean;
	IsComplete(): boolean;
	Cancel(): boolean;
	static C(Other: UObject | any): HttpLibraryBinaryRequest;
}

declare class HttpLibraryGetRequestCallbackProxy extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(Response: JsonLibraryValue, StatusCode: number) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(Response: JsonLibraryValue, StatusCode: number) => void>;
	static Load(ResourceName: string): HttpLibraryGetRequestCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): HttpLibraryGetRequestCallbackProxy;
	static GetDefaultObject(): HttpLibraryGetRequestCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HttpLibraryGetRequestCallbackProxy;
	static CreateProxyObjectForGet(URL: string,QueryString: any,Headers: any): HttpLibraryGetRequestCallbackProxy;
	static C(Other: UObject | any): HttpLibraryGetRequestCallbackProxy;
}

declare class HttpLibraryHelpers extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): HttpLibraryHelpers;
	static Find(Outer: UObject, ResourceName: string): HttpLibraryHelpers;
	static GetDefaultObject(): HttpLibraryHelpers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HttpLibraryHelpers;
	static SetHttpTimeout(Timeout: number): void;
	static IsHttpEnabled(): boolean;
	static GetHttpTimeout(): number;
	static GetContentType(ContentType: EHttpLibraryContentType): string;
	static FindContentType(ContentType: string): EHttpLibraryContentType;
	static ConvertStringToBytes(Data: string): number[];
	static ConvertJsonToBytes(Data: JsonLibraryValue): number[];
	static ConvertBytesToString(Data: number[]): string;
	static ConvertBytesToJson(Data: number[]): JsonLibraryValue;
	static AppendQueryString(URL: string,QueryString: any): string;
	static C(Other: UObject | any): HttpLibraryHelpers;
}

declare class HttpLibraryJsonRequest extends UObject { 
	static Load(ResourceName: string): HttpLibraryJsonRequest;
	static Find(Outer: UObject, ResourceName: string): HttpLibraryJsonRequest;
	static GetDefaultObject(): HttpLibraryJsonRequest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HttpLibraryJsonRequest;
	SendString(URL: string,QueryString: any,Headers: any,Content: string,ContentType: EHttpLibraryContentType,Method: EHttpLibraryRequestMethod): boolean;
	SendJSON(URL: string,QueryString: any,Headers: any,Content: JsonLibraryValue,Method: EHttpLibraryRequestMethod): boolean;
	SendBinary(URL: string,QueryString: any,Headers: any,Content: number[],ContentType: EHttpLibraryContentType,Method: EHttpLibraryRequestMethod): boolean;
	Send(URL: string,QueryString: any,Headers: any,Method: EHttpLibraryRequestMethod): boolean;
	IsRunning(): boolean;
	IsComplete(): boolean;
	Cancel(): boolean;
	static C(Other: UObject | any): HttpLibraryJsonRequest;
}

declare class HttpLibraryPostRequestCallbackProxy extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(Response: JsonLibraryValue, StatusCode: number) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(Response: JsonLibraryValue, StatusCode: number) => void>;
	static Load(ResourceName: string): HttpLibraryPostRequestCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): HttpLibraryPostRequestCallbackProxy;
	static GetDefaultObject(): HttpLibraryPostRequestCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HttpLibraryPostRequestCallbackProxy;
	static CreateProxyObjectForPost(URL: string,QueryString: any,Headers: any,Content: JsonLibraryValue): HttpLibraryPostRequestCallbackProxy;
	static C(Other: UObject | any): HttpLibraryPostRequestCallbackProxy;
}

declare class HttpLibraryRequest extends UObject { 
	static Load(ResourceName: string): HttpLibraryRequest;
	static Find(Outer: UObject, ResourceName: string): HttpLibraryRequest;
	static GetDefaultObject(): HttpLibraryRequest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HttpLibraryRequest;
	SendString(URL: string,QueryString: any,Headers: any,Content: string,ContentType: EHttpLibraryContentType,Method: EHttpLibraryRequestMethod): boolean;
	SendJSON(URL: string,QueryString: any,Headers: any,Content: JsonLibraryValue,Method: EHttpLibraryRequestMethod): boolean;
	SendBinary(URL: string,QueryString: any,Headers: any,Content: number[],ContentType: EHttpLibraryContentType,Method: EHttpLibraryRequestMethod): boolean;
	Send(URL: string,QueryString: any,Headers: any,Method: EHttpLibraryRequestMethod): boolean;
	IsRunning(): boolean;
	IsComplete(): boolean;
	Cancel(): boolean;
	static C(Other: UObject | any): HttpLibraryRequest;
}

declare class HttpLibraryRequestCallbackProxy extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(Response: number[], ContentType: EHttpLibraryContentType, StatusCode: number, BytesSent: number, BytesReceived: number) => void>;
	OnProgress: UnrealEngineMulticastDelegate<(Response: number[], ContentType: EHttpLibraryContentType, StatusCode: number, BytesSent: number, BytesReceived: number) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(Response: number[], ContentType: EHttpLibraryContentType, StatusCode: number, BytesSent: number, BytesReceived: number) => void>;
	static Load(ResourceName: string): HttpLibraryRequestCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): HttpLibraryRequestCallbackProxy;
	static GetDefaultObject(): HttpLibraryRequestCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HttpLibraryRequestCallbackProxy;
	static CreateProxyObjectForRequest(Method: EHttpLibraryRequestMethod,URL: string,QueryString: any,Headers: any,Content: number[],ContentType: EHttpLibraryContentType): HttpLibraryRequestCallbackProxy;
	static C(Other: UObject | any): HttpLibraryRequestCallbackProxy;
}

declare class K2Node_HttpLibraryGetRequest extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_HttpLibraryGetRequest;
	static Find(Outer: UObject, ResourceName: string): K2Node_HttpLibraryGetRequest;
	static GetDefaultObject(): K2Node_HttpLibraryGetRequest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_HttpLibraryGetRequest;
	static C(Other: UObject | any): K2Node_HttpLibraryGetRequest;
}

declare class K2Node_HttpLibraryPostRequest extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_HttpLibraryPostRequest;
	static Find(Outer: UObject, ResourceName: string): K2Node_HttpLibraryPostRequest;
	static GetDefaultObject(): K2Node_HttpLibraryPostRequest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_HttpLibraryPostRequest;
	static C(Other: UObject | any): K2Node_HttpLibraryPostRequest;
}

declare class K2Node_HttpLibraryRequest extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_HttpLibraryRequest;
	static Find(Outer: UObject, ResourceName: string): K2Node_HttpLibraryRequest;
	static GetDefaultObject(): K2Node_HttpLibraryRequest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_HttpLibraryRequest;
	static C(Other: UObject | any): K2Node_HttpLibraryRequest;
}

declare class K2Node_JsonLibraryFromStruct extends K2Node { 
	static Load(ResourceName: string): K2Node_JsonLibraryFromStruct;
	static Find(Outer: UObject, ResourceName: string): K2Node_JsonLibraryFromStruct;
	static GetDefaultObject(): K2Node_JsonLibraryFromStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_JsonLibraryFromStruct;
	static C(Other: UObject | any): K2Node_JsonLibraryFromStruct;
}

declare class K2Node_JsonLibraryToStruct extends K2Node { 
	static Load(ResourceName: string): K2Node_JsonLibraryToStruct;
	static Find(Outer: UObject, ResourceName: string): K2Node_JsonLibraryToStruct;
	static GetDefaultObject(): K2Node_JsonLibraryToStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_JsonLibraryToStruct;
	static C(Other: UObject | any): K2Node_JsonLibraryToStruct;
}

declare class NamedInterface { 
	InterfaceName: string;
	InterfaceObject: UObject;
	clone() : NamedInterface;
	static C(Other: UObject | any): NamedInterface;
}

declare class NamedInterfaceDef { 
	InterfaceName: string;
	InterfaceClassName: string;
	clone() : NamedInterfaceDef;
	static C(Other: UObject | any): NamedInterfaceDef;
}

declare class NamedInterfaces extends UObject { 
	NamedInterfaces: NamedInterface[];
	NamedInterfaceDefs: NamedInterfaceDef[];
	static Load(ResourceName: string): NamedInterfaces;
	static Find(Outer: UObject, ResourceName: string): NamedInterfaces;
	static GetDefaultObject(): NamedInterfaces;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedInterfaces;
	static C(Other: UObject | any): NamedInterfaces;
}

declare class TurnBasedMatchInterface extends Interface { 
	static Load(ResourceName: string): TurnBasedMatchInterface;
	static Find(Outer: UObject, ResourceName: string): TurnBasedMatchInterface;
	static GetDefaultObject(): TurnBasedMatchInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TurnBasedMatchInterface;
	OnMatchReceivedTurn(Match: string,bDidBecomeActive: boolean): void;
	OnMatchEnded(Match: string): void;
	static C(Other: UObject | any): TurnBasedMatchInterface;
}

declare class AchievementBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AchievementBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): AchievementBlueprintLibrary;
	static GetDefaultObject(): AchievementBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AchievementBlueprintLibrary;
	static GetCachedAchievementProgress(WorldContextObject: UObject,PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Progress?: number): {bFoundID: boolean, Progress: number};
	static GetCachedAchievementDescription(WorldContextObject: UObject,PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Title?: string,LockedDescription?: string,UnlockedDescription?: string,bHidden?: boolean): {bFoundID: boolean, Title: string, LockedDescription: string, UnlockedDescription: string, bHidden: boolean};
	static C(Other: UObject | any): AchievementBlueprintLibrary;
}

declare class AchievementQueryCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AchievementQueryCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): AchievementQueryCallbackProxy;
	static GetDefaultObject(): AchievementQueryCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AchievementQueryCallbackProxy;
	static CacheAchievements(WorldContextObject: UObject,PlayerController: PlayerController): AchievementQueryCallbackProxy;
	static CacheAchievementDescriptions(WorldContextObject: UObject,PlayerController: PlayerController): AchievementQueryCallbackProxy;
	static C(Other: UObject | any): AchievementQueryCallbackProxy;
}

declare class AchievementWriteCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(WrittenAchievementName: string, WrittenProgress: number, WrittenUserTag: number) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(WrittenAchievementName: string, WrittenProgress: number, WrittenUserTag: number) => void>;
	static Load(ResourceName: string): AchievementWriteCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): AchievementWriteCallbackProxy;
	static GetDefaultObject(): AchievementWriteCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AchievementWriteCallbackProxy;
	static WriteAchievementProgress(WorldContextObject: UObject,PlayerController: PlayerController,AchievementName: string,Progress: number,UserTag: number): AchievementWriteCallbackProxy;
	static C(Other: UObject | any): AchievementWriteCallbackProxy;
}

declare class ConnectionCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(ErrorCode: number) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(ErrorCode: number) => void>;
	static Load(ResourceName: string): ConnectionCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): ConnectionCallbackProxy;
	static GetDefaultObject(): ConnectionCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConnectionCallbackProxy;
	static ConnectToService(WorldContextObject: UObject,PlayerController: PlayerController): ConnectionCallbackProxy;
	static C(Other: UObject | any): ConnectionCallbackProxy;
}

declare class CreateSessionCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): CreateSessionCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): CreateSessionCallbackProxy;
	static GetDefaultObject(): CreateSessionCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CreateSessionCallbackProxy;
	static CreateSession(WorldContextObject: UObject,PlayerController: PlayerController,PublicConnections: number,bUseLAN: boolean): CreateSessionCallbackProxy;
	static C(Other: UObject | any): CreateSessionCallbackProxy;
}

declare class DestroySessionCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): DestroySessionCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): DestroySessionCallbackProxy;
	static GetDefaultObject(): DestroySessionCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DestroySessionCallbackProxy;
	static DestroySession(WorldContextObject: UObject,PlayerController: PlayerController): DestroySessionCallbackProxy;
	static C(Other: UObject | any): DestroySessionCallbackProxy;
}

declare class EndMatchCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): EndMatchCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): EndMatchCallbackProxy;
	static GetDefaultObject(): EndMatchCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EndMatchCallbackProxy;
	static C(Other: UObject | any): EndMatchCallbackProxy;
}

declare class EndTurnCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): EndTurnCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): EndTurnCallbackProxy;
	static GetDefaultObject(): EndTurnCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EndTurnCallbackProxy;
	static C(Other: UObject | any): EndTurnCallbackProxy;
}

declare class BlueprintSessionResult { 
	clone() : BlueprintSessionResult;
	static C(Other: UObject | any): BlueprintSessionResult;
}

declare class FindSessionsCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(Results: BlueprintSessionResult[]) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(Results: BlueprintSessionResult[]) => void>;
	static Load(ResourceName: string): FindSessionsCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): FindSessionsCallbackProxy;
	static GetDefaultObject(): FindSessionsCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FindSessionsCallbackProxy;
	static GetServerName(Result: BlueprintSessionResult): string;
	static GetPingInMs(Result: BlueprintSessionResult): number;
	static GetMaxPlayers(Result: BlueprintSessionResult): number;
	static GetCurrentPlayers(Result: BlueprintSessionResult): number;
	static FindSessions(WorldContextObject: UObject,PlayerController: PlayerController,MaxResults: number,bUseLAN: boolean): FindSessionsCallbackProxy;
	static C(Other: UObject | any): FindSessionsCallbackProxy;
}

declare class FindTurnBasedMatchCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(MatchID: string) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(MatchID: string) => void>;
	static Load(ResourceName: string): FindTurnBasedMatchCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): FindTurnBasedMatchCallbackProxy;
	static GetDefaultObject(): FindTurnBasedMatchCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FindTurnBasedMatchCallbackProxy;
	static C(Other: UObject | any): FindTurnBasedMatchCallbackProxy;
}

declare type EInAppPurchaseState = 'Unknown' | 'Success' | 'Failed' | 'Cancelled' | 'Invalid' | 'NotAllowed' | 'Restored' | 'AlreadyOwned' | 'EInAppPurchaseState_MAX';
declare var EInAppPurchaseState : { Unknown:'Unknown',Success:'Success',Failed:'Failed',Cancelled:'Cancelled',Invalid:'Invalid',NotAllowed:'NotAllowed',Restored:'Restored',AlreadyOwned:'AlreadyOwned',EInAppPurchaseState_MAX:'EInAppPurchaseState_MAX', };
declare class InAppPurchaseProductInfo { 
	Identifier: string;
	TransactionIdentifier: string;
	DisplayName: string;
	DisplayDescription: string;
	DisplayPrice: string;
	RawPrice: number;
	CurrencyCode: string;
	CurrencySymbol: string;
	DecimalSeparator: string;
	GroupingSeparator: string;
	ReceiptData: string;
	clone() : InAppPurchaseProductInfo;
	static C(Other: UObject | any): InAppPurchaseProductInfo;
}

declare class InAppPurchaseProductRequest { 
	ProductIdentifier: string;
	bIsConsumable: boolean;
	clone() : InAppPurchaseProductRequest;
	static C(Other: UObject | any): InAppPurchaseProductRequest;
}

declare class InAppPurchaseCallbackProxy extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(PurchaseStatus: EInAppPurchaseState, InAppPurchaseReceipts: InAppPurchaseProductInfo) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(PurchaseStatus: EInAppPurchaseState, InAppPurchaseReceipts: InAppPurchaseProductInfo) => void>;
	static Load(ResourceName: string): InAppPurchaseCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): InAppPurchaseCallbackProxy;
	static GetDefaultObject(): InAppPurchaseCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InAppPurchaseCallbackProxy;
	static CreateProxyObjectForInAppPurchase(PlayerController: PlayerController,ProductRequest: InAppPurchaseProductRequest): InAppPurchaseCallbackProxy;
	static C(Other: UObject | any): InAppPurchaseCallbackProxy;
}

declare type EInAppPurchaseStatus = 'Invalid' | 'Failed' | 'Deferred' | 'Canceled' | 'Purchased' | 'Restored' | 'EInAppPurchaseStatus_MAX';
declare var EInAppPurchaseStatus : { Invalid:'Invalid',Failed:'Failed',Deferred:'Deferred',Canceled:'Canceled',Purchased:'Purchased',Restored:'Restored',EInAppPurchaseStatus_MAX:'EInAppPurchaseStatus_MAX', };
declare class InAppPurchaseReceiptInfo2 { 
	ItemName: string;
	ItemId: string;
	ValidationInfo: string;
	clone() : InAppPurchaseReceiptInfo2;
	static C(Other: UObject | any): InAppPurchaseReceiptInfo2;
}

declare class InAppPurchaseProductRequest2 { 
	ProductIdentifier: string;
	bIsConsumable: boolean;
	clone() : InAppPurchaseProductRequest2;
	static C(Other: UObject | any): InAppPurchaseProductRequest2;
}

declare class InAppPurchaseCallbackProxy2 extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(PurchaseStatus: EInAppPurchaseStatus, InAppPurchaseReceipts: InAppPurchaseReceiptInfo2[]) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(PurchaseStatus: EInAppPurchaseStatus, InAppPurchaseReceipts: InAppPurchaseReceiptInfo2[]) => void>;
	static Load(ResourceName: string): InAppPurchaseCallbackProxy2;
	static Find(Outer: UObject, ResourceName: string): InAppPurchaseCallbackProxy2;
	static GetDefaultObject(): InAppPurchaseCallbackProxy2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InAppPurchaseCallbackProxy2;
	static CreateProxyObjectForInAppPurchaseUnprocessedPurchases(PlayerController: PlayerController): InAppPurchaseCallbackProxy2;
	static CreateProxyObjectForInAppPurchaseQueryOwned(PlayerController: PlayerController): InAppPurchaseCallbackProxy2;
	static CreateProxyObjectForInAppPurchase(PlayerController: PlayerController,ProductRequest: InAppPurchaseProductRequest2): InAppPurchaseCallbackProxy2;
	static C(Other: UObject | any): InAppPurchaseCallbackProxy2;
}

declare class InAppPurchaseQueryCallbackProxy extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(InAppPurchaseInformation: InAppPurchaseProductInfo[]) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(InAppPurchaseInformation: InAppPurchaseProductInfo[]) => void>;
	static Load(ResourceName: string): InAppPurchaseQueryCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): InAppPurchaseQueryCallbackProxy;
	static GetDefaultObject(): InAppPurchaseQueryCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InAppPurchaseQueryCallbackProxy;
	static CreateProxyObjectForInAppPurchaseQuery(PlayerController: PlayerController,ProductIdentifiers: string[]): InAppPurchaseQueryCallbackProxy;
	static C(Other: UObject | any): InAppPurchaseQueryCallbackProxy;
}

declare type EOnlineProxyStoreOfferDiscountType = 'NotOnSale' | 'Percentage' | 'DiscountAmount' | 'PayAmount' | 'EOnlineProxyStoreOfferDiscountType_MAX';
declare var EOnlineProxyStoreOfferDiscountType : { NotOnSale:'NotOnSale',Percentage:'Percentage',DiscountAmount:'DiscountAmount',PayAmount:'PayAmount',EOnlineProxyStoreOfferDiscountType_MAX:'EOnlineProxyStoreOfferDiscountType_MAX', };
declare class OnlineProxyStoreOffer { 
	OfferId: string;
	Title: string;
	Description: string;
	LongDescription: string;
	RegularPriceText: string;
	RegularPrice: number;
	PriceText: string;
	NumericPrice: number;
	CurrencyCode: string;
	ReleaseDate: DateTime;
	ExpirationDate: DateTime;
	DiscountType: EOnlineProxyStoreOfferDiscountType;
	DynamicFields: any;
	clone() : OnlineProxyStoreOffer;
	static C(Other: UObject | any): OnlineProxyStoreOffer;
}

declare class InAppPurchaseQueryCallbackProxy2 extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(InAppOfferInformation: OnlineProxyStoreOffer[]) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(InAppOfferInformation: OnlineProxyStoreOffer[]) => void>;
	static Load(ResourceName: string): InAppPurchaseQueryCallbackProxy2;
	static Find(Outer: UObject, ResourceName: string): InAppPurchaseQueryCallbackProxy2;
	static GetDefaultObject(): InAppPurchaseQueryCallbackProxy2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InAppPurchaseQueryCallbackProxy2;
	static CreateProxyObjectForInAppPurchaseQuery(PlayerController: PlayerController,ProductIdentifiers: string[]): InAppPurchaseQueryCallbackProxy2;
	static C(Other: UObject | any): InAppPurchaseQueryCallbackProxy2;
}

declare class InAppPurchaseRestoreInfo { 
	Identifier: string;
	ReceiptData: string;
	TransactionIdentifier: string;
	clone() : InAppPurchaseRestoreInfo;
	static C(Other: UObject | any): InAppPurchaseRestoreInfo;
}

declare class InAppPurchaseRestoreCallbackProxy extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(CompletionStatus: EInAppPurchaseState, InAppRestorePurchaseInformation: InAppPurchaseRestoreInfo[]) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(CompletionStatus: EInAppPurchaseState, InAppRestorePurchaseInformation: InAppPurchaseRestoreInfo[]) => void>;
	static Load(ResourceName: string): InAppPurchaseRestoreCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): InAppPurchaseRestoreCallbackProxy;
	static GetDefaultObject(): InAppPurchaseRestoreCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InAppPurchaseRestoreCallbackProxy;
	static CreateProxyObjectForInAppPurchaseRestore(ConsumableProductFlags: InAppPurchaseProductRequest[],PlayerController: PlayerController): InAppPurchaseRestoreCallbackProxy;
	static C(Other: UObject | any): InAppPurchaseRestoreCallbackProxy;
}

declare class InAppPurchaseRestoreInfo2 { 
	ItemName: string;
	ItemId: string;
	ValidationInfo: string;
	clone() : InAppPurchaseRestoreInfo2;
	static C(Other: UObject | any): InAppPurchaseRestoreInfo2;
}

declare class InAppPurchaseRestoreCallbackProxy2 extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(PurchaseStatus: EInAppPurchaseStatus, InAppPurchaseRestoreInfo: InAppPurchaseRestoreInfo2[]) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(PurchaseStatus: EInAppPurchaseStatus, InAppPurchaseRestoreInfo: InAppPurchaseRestoreInfo2[]) => void>;
	static Load(ResourceName: string): InAppPurchaseRestoreCallbackProxy2;
	static Find(Outer: UObject, ResourceName: string): InAppPurchaseRestoreCallbackProxy2;
	static GetDefaultObject(): InAppPurchaseRestoreCallbackProxy2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InAppPurchaseRestoreCallbackProxy2;
	static CreateProxyObjectForInAppPurchaseRestore(ConsumableProductFlags: InAppPurchaseProductRequest2[],PlayerController: PlayerController): InAppPurchaseRestoreCallbackProxy2;
	static C(Other: UObject | any): InAppPurchaseRestoreCallbackProxy2;
}

declare class IpConnection extends NetConnection { 
	SocketErrorDisconnectDelay: number;
	static Load(ResourceName: string): IpConnection;
	static Find(Outer: UObject, ResourceName: string): IpConnection;
	static GetDefaultObject(): IpConnection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IpConnection;
	static C(Other: UObject | any): IpConnection;
}

declare class IpNetDriver extends NetDriver { 
	LogPortUnreach: boolean;
	AllowPlayerPortUnreach: boolean;
	MaxPortCountToTry: any;
	ServerDesiredSocketReceiveBufferBytes: any;
	ServerDesiredSocketSendBufferBytes: any;
	ClientDesiredSocketReceiveBufferBytes: any;
	ClientDesiredSocketSendBufferBytes: any;
	MaxSecondsInReceive: any;
	NbPacketsBetweenReceiveTimeTest: number;
	ResolutionConnectionTimeout: number;
	static Load(ResourceName: string): IpNetDriver;
	static Find(Outer: UObject, ResourceName: string): IpNetDriver;
	static GetDefaultObject(): IpNetDriver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IpNetDriver;
	static C(Other: UObject | any): IpNetDriver;
}

declare class JoinSessionCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): JoinSessionCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): JoinSessionCallbackProxy;
	static GetDefaultObject(): JoinSessionCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JoinSessionCallbackProxy;
	static JoinSession(WorldContextObject: UObject,PlayerController: PlayerController,SearchResult: BlueprintSessionResult): JoinSessionCallbackProxy;
	static C(Other: UObject | any): JoinSessionCallbackProxy;
}

declare class LeaderboardBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): LeaderboardBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): LeaderboardBlueprintLibrary;
	static GetDefaultObject(): LeaderboardBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LeaderboardBlueprintLibrary;
	static WriteLeaderboardInteger(PlayerController: PlayerController,StatName: string,StatValue: number): boolean;
	static C(Other: UObject | any): LeaderboardBlueprintLibrary;
}

declare class LeaderboardFlushCallbackProxy extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(SessionName: string) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(SessionName: string) => void>;
	static Load(ResourceName: string): LeaderboardFlushCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): LeaderboardFlushCallbackProxy;
	static GetDefaultObject(): LeaderboardFlushCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LeaderboardFlushCallbackProxy;
	static CreateProxyObjectForFlush(PlayerController: PlayerController,SessionName: string): LeaderboardFlushCallbackProxy;
	static C(Other: UObject | any): LeaderboardFlushCallbackProxy;
}

declare class LeaderboardQueryCallbackProxy extends UObject { 
	OnSuccess: UnrealEngineMulticastDelegate<(LeaderboardValue: number) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(LeaderboardValue: number) => void>;
	static Load(ResourceName: string): LeaderboardQueryCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): LeaderboardQueryCallbackProxy;
	static GetDefaultObject(): LeaderboardQueryCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LeaderboardQueryCallbackProxy;
	static CreateProxyObjectForIntQuery(PlayerController: PlayerController,StatName: string): LeaderboardQueryCallbackProxy;
	static C(Other: UObject | any): LeaderboardQueryCallbackProxy;
}

declare class LogoutCallbackProxy extends BlueprintAsyncActionBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(PlayerController: PlayerController) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(PlayerController: PlayerController) => void>;
	static Load(ResourceName: string): LogoutCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): LogoutCallbackProxy;
	static GetDefaultObject(): LogoutCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LogoutCallbackProxy;
	static Logout(WorldContextObject: UObject,PlayerController: PlayerController): LogoutCallbackProxy;
	static C(Other: UObject | any): LogoutCallbackProxy;
}

declare class OnlineBeacon extends Actor { 
	BeaconConnectionInitialTimeout: number;
	BeaconConnectionTimeout: number;
	NetDriver: NetDriver;
	static GetDefaultObject(): OnlineBeacon;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBeacon;
	static C(Other: UObject | any): OnlineBeacon;
}

declare class OnlineBeaconHostObject extends Actor { 
	BeaconTypeName: string;
	ClientBeaconActorClass: UnrealEngineClass;
	ClientActors: OnlineBeaconClient[];
	static GetDefaultObject(): OnlineBeaconHostObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBeaconHostObject;
	static C(Other: UObject | any): OnlineBeaconHostObject;
}

declare type EBeaconConnectionState = 'Invalid' | 'Closed' | 'Pending' | 'Open' | 'EBeaconConnectionState_MAX';
declare var EBeaconConnectionState : { Invalid:'Invalid',Closed:'Closed',Pending:'Pending',Open:'Open',EBeaconConnectionState_MAX:'EBeaconConnectionState_MAX', };
declare class OnlineBeaconClient extends OnlineBeacon { 
	BeaconOwner: OnlineBeaconHostObject;
	BeaconConnection: NetConnection;
	ConnectionState: EBeaconConnectionState;
	static GetDefaultObject(): OnlineBeaconClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBeaconClient;
	ClientOnConnected(): void;
	static C(Other: UObject | any): OnlineBeaconClient;
}

declare class OnlineBeaconHost extends OnlineBeacon { 
	ListenPort: number;
	bAuthRequired: boolean;
	MaxAuthTokenSize: any;
	ClientActors: OnlineBeaconClient[];
	static GetDefaultObject(): OnlineBeaconHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBeaconHost;
	static C(Other: UObject | any): OnlineBeaconHost;
}

declare class OnlineEngineInterfaceImpl extends OnlineEngineInterface { 
	MappedUniqueNetIdTypes: any;
	CompatibleUniqueNetIdTypes: string[];
	VoiceSubsystemNameOverride: string;
	static Load(ResourceName: string): OnlineEngineInterfaceImpl;
	static Find(Outer: UObject, ResourceName: string): OnlineEngineInterfaceImpl;
	static GetDefaultObject(): OnlineEngineInterfaceImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineEngineInterfaceImpl;
	static C(Other: UObject | any): OnlineEngineInterfaceImpl;
}

declare class PIELoginSettingsInternal { 
	ID: string;
	Token: string;
	Type: string;
	TokenBytes: number[];
	clone() : PIELoginSettingsInternal;
	static C(Other: UObject | any): PIELoginSettingsInternal;
}

declare class OnlinePIESettings extends DeveloperSettings { 
	bOnlinePIEEnabled: boolean;
	Logins: PIELoginSettingsInternal[];
	static Load(ResourceName: string): OnlinePIESettings;
	static Find(Outer: UObject, ResourceName: string): OnlinePIESettings;
	static GetDefaultObject(): OnlinePIESettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlinePIESettings;
	static C(Other: UObject | any): OnlinePIESettings;
}

declare class OnlineServicesEngineInterfaceImpl extends OnlineEngineInterface { 
	static Load(ResourceName: string): OnlineServicesEngineInterfaceImpl;
	static Find(Outer: UObject, ResourceName: string): OnlineServicesEngineInterfaceImpl;
	static GetDefaultObject(): OnlineServicesEngineInterfaceImpl;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineServicesEngineInterfaceImpl;
	static C(Other: UObject | any): OnlineServicesEngineInterfaceImpl;
}

declare class OnlineSessionClient extends OnlineSession { 
	bIsFromInvite: boolean;
	bHandlingDisconnect: boolean;
	static Load(ResourceName: string): OnlineSessionClient;
	static Find(Outer: UObject, ResourceName: string): OnlineSessionClient;
	static GetDefaultObject(): OnlineSessionClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineSessionClient;
	static C(Other: UObject | any): OnlineSessionClient;
}

declare class PlayerReservation { 
	UniqueId: UniqueNetIdRepl;
	ValidationStr: string;
	Platform: string;
	bAllowCrossplay: boolean;
	ElapsedTime: number;
	clone() : PlayerReservation;
	static C(Other: UObject | any): PlayerReservation;
}

declare class PartyReservation { 
	TeamNum: number;
	PartyLeader: UniqueNetIdRepl;
	PartyMembers: PlayerReservation[];
	RemovedPartyMembers: PlayerReservation[];
	clone() : PartyReservation;
	static C(Other: UObject | any): PartyReservation;
}

declare type EClientRequestType = 'NonePending' | 'ExistingSessionReservation' | 'ReservationUpdate' | 'EmptyServerReservation' | 'Reconnect' | 'Abandon' | 'ReservationRemoveMembers' | 'AddOrUpdateReservation' | 'EClientRequestType_MAX';
declare var EClientRequestType : { NonePending:'NonePending',ExistingSessionReservation:'ExistingSessionReservation',ReservationUpdate:'ReservationUpdate',EmptyServerReservation:'EmptyServerReservation',Reconnect:'Reconnect',Abandon:'Abandon',ReservationRemoveMembers:'ReservationRemoveMembers',AddOrUpdateReservation:'AddOrUpdateReservation',EClientRequestType_MAX:'EClientRequestType_MAX', };
declare type EPartyReservationResult = 'NoResult' | 'RequestPending' | 'GeneralError' | 'PartyLimitReached' | 'IncorrectPlayerCount' | 'RequestTimedOut' | 'ReservationDuplicate' | 'ReservationNotFound' | 'ReservationAccepted' | 'ReservationDenied' | 'ReservationDenied_CrossPlayRestriction' | 'ReservationDenied_Banned' | 'ReservationRequestCanceled' | 'ReservationInvalid' | 'BadSessionId' | 'ReservationDenied_ContainsExistingPlayers' | 'EPartyReservationResult_MAX';
declare var EPartyReservationResult : { NoResult:'NoResult',RequestPending:'RequestPending',GeneralError:'GeneralError',PartyLimitReached:'PartyLimitReached',IncorrectPlayerCount:'IncorrectPlayerCount',RequestTimedOut:'RequestTimedOut',ReservationDuplicate:'ReservationDuplicate',ReservationNotFound:'ReservationNotFound',ReservationAccepted:'ReservationAccepted',ReservationDenied:'ReservationDenied',ReservationDenied_CrossPlayRestriction:'ReservationDenied_CrossPlayRestriction',ReservationDenied_Banned:'ReservationDenied_Banned',ReservationRequestCanceled:'ReservationRequestCanceled',ReservationInvalid:'ReservationInvalid',BadSessionId:'BadSessionId',ReservationDenied_ContainsExistingPlayers:'ReservationDenied_ContainsExistingPlayers',EPartyReservationResult_MAX:'EPartyReservationResult_MAX', };
declare class PartyBeaconClient extends OnlineBeaconClient { 
	DestSessionId: string;
	PendingReservation: PartyReservation;
	RequestType: EClientRequestType;
	bPendingReservationSent: boolean;
	bCancelReservation: boolean;
	static GetDefaultObject(): PartyBeaconClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PartyBeaconClient;
	ServerUpdateReservationRequest(SessionId: string,ReservationUpdate: PartyReservation): void;
	ServerReservationRequest(SessionId: string,Reservation: PartyReservation): void;
	ServerRemoveMemberFromReservationRequest(SessionId: string,ReservationUpdate: PartyReservation): void;
	ServerCancelReservationRequest(PartyLeader: UniqueNetIdRepl): void;
	ServerAddOrUpdateReservationRequest(SessionId: string,Reservation: PartyReservation): void;
	ClientSendReservationUpdates(NumRemainingReservations: number): void;
	ClientSendReservationFull(): void;
	ClientReservationResponse(ReservationResponse: EPartyReservationResult): void;
	ClientCancelReservationResponse(ReservationResponse: EPartyReservationResult): void;
	static C(Other: UObject | any): PartyBeaconClient;
}

declare class PartyBeaconCrossplayPlatformMapping { 
	PlatformName: string;
	PlatformType: string;
	clone() : PartyBeaconCrossplayPlatformMapping;
	static C(Other: UObject | any): PartyBeaconCrossplayPlatformMapping;
}

declare class PartyBeaconState extends UObject { 
	SessionName: string;
	NumConsumedReservations: number;
	MaxReservations: number;
	NumTeams: number;
	NumPlayersPerTeam: number;
	TeamAssignmentMethod: string;
	ReservedHostTeamNum: number;
	ForceTeamNum: number;
	bRestrictCrossConsole: boolean;
	PlatformCrossplayRestrictions: string[];
	PlatformTypeMapping: PartyBeaconCrossplayPlatformMapping[];
	bEnableRemovalRequests: boolean;
	Reservations: PartyReservation[];
	static Load(ResourceName: string): PartyBeaconState;
	static Find(Outer: UObject, ResourceName: string): PartyBeaconState;
	static GetDefaultObject(): PartyBeaconState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PartyBeaconState;
	static C(Other: UObject | any): PartyBeaconState;
}

declare class PartyBeaconHost extends OnlineBeaconHostObject { 
	State: PartyBeaconState;
	bLogoutOnSessionTimeout: boolean;
	SessionTimeoutSecs: number;
	TravelSessionTimeoutSecs: number;
	static GetDefaultObject(): PartyBeaconHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PartyBeaconHost;
	static C(Other: UObject | any): PartyBeaconHost;
}

declare type EMPMatchOutcome = 'None' | 'Quit' | 'Won' | 'Lost' | 'Tied' | 'TimeExpired' | 'First' | 'Second' | 'Third' | 'Fourth' | 'EMPMatchOutcome_MAX';
declare var EMPMatchOutcome : { None:'None',Quit:'Quit',Won:'Won',Lost:'Lost',Tied:'Tied',TimeExpired:'TimeExpired',First:'First',Second:'Second',Third:'Third',Fourth:'Fourth',EMPMatchOutcome_MAX:'EMPMatchOutcome_MAX', };
declare class QuitMatchCallbackProxy extends OnlineBlueprintCallProxyBase { 
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): QuitMatchCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): QuitMatchCallbackProxy;
	static GetDefaultObject(): QuitMatchCallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): QuitMatchCallbackProxy;
	static QuitMatch(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,Outcome: EMPMatchOutcome,TurnTimeoutInSeconds: number): QuitMatchCallbackProxy;
	static C(Other: UObject | any): QuitMatchCallbackProxy;
}

declare class ShowLoginUICallbackProxy extends BlueprintAsyncActionBase { 
	OnSuccess: UnrealEngineMulticastDelegate<(PlayerController: PlayerController) => void>;
	OnFailure: UnrealEngineMulticastDelegate<(PlayerController: PlayerController) => void>;
	static Load(ResourceName: string): ShowLoginUICallbackProxy;
	static Find(Outer: UObject, ResourceName: string): ShowLoginUICallbackProxy;
	static GetDefaultObject(): ShowLoginUICallbackProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShowLoginUICallbackProxy;
	static ShowExternalLoginUI(WorldContextObject: UObject,InPlayerController: PlayerController): ShowLoginUICallbackProxy;
	static C(Other: UObject | any): ShowLoginUICallbackProxy;
}

declare class SpectatorReservation { 
	SpectatorId: UniqueNetIdRepl;
	Spectator: PlayerReservation;
	clone() : SpectatorReservation;
	static C(Other: UObject | any): SpectatorReservation;
}

declare type ESpectatorClientRequestType = 'NonePending' | 'ExistingSessionReservation' | 'ReservationUpdate' | 'EmptyServerReservation' | 'Reconnect' | 'Abandon' | 'ESpectatorClientRequestType_MAX';
declare var ESpectatorClientRequestType : { NonePending:'NonePending',ExistingSessionReservation:'ExistingSessionReservation',ReservationUpdate:'ReservationUpdate',EmptyServerReservation:'EmptyServerReservation',Reconnect:'Reconnect',Abandon:'Abandon',ESpectatorClientRequestType_MAX:'ESpectatorClientRequestType_MAX', };
declare type ESpectatorReservationResult = 'NoResult' | 'RequestPending' | 'GeneralError' | 'SpectatorLimitReached' | 'IncorrectPlayerCount' | 'RequestTimedOut' | 'ReservationDuplicate' | 'ReservationNotFound' | 'ReservationAccepted' | 'ReservationDenied' | 'ReservationDenied_CrossPlayRestriction' | 'ReservationDenied_Banned' | 'ReservationRequestCanceled' | 'ReservationInvalid' | 'BadSessionId' | 'ReservationDenied_ContainsExistingPlayers' | 'ESpectatorReservationResult_MAX';
declare var ESpectatorReservationResult : { NoResult:'NoResult',RequestPending:'RequestPending',GeneralError:'GeneralError',SpectatorLimitReached:'SpectatorLimitReached',IncorrectPlayerCount:'IncorrectPlayerCount',RequestTimedOut:'RequestTimedOut',ReservationDuplicate:'ReservationDuplicate',ReservationNotFound:'ReservationNotFound',ReservationAccepted:'ReservationAccepted',ReservationDenied:'ReservationDenied',ReservationDenied_CrossPlayRestriction:'ReservationDenied_CrossPlayRestriction',ReservationDenied_Banned:'ReservationDenied_Banned',ReservationRequestCanceled:'ReservationRequestCanceled',ReservationInvalid:'ReservationInvalid',BadSessionId:'BadSessionId',ReservationDenied_ContainsExistingPlayers:'ReservationDenied_ContainsExistingPlayers',ESpectatorReservationResult_MAX:'ESpectatorReservationResult_MAX', };
declare class SpectatorBeaconClient extends OnlineBeaconClient { 
	DestSessionId: string;
	PendingReservation: SpectatorReservation;
	RequestType: ESpectatorClientRequestType;
	bPendingReservationSent: boolean;
	bCancelReservation: boolean;
	static GetDefaultObject(): SpectatorBeaconClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpectatorBeaconClient;
	ServerReservationRequest(SessionId: string,Reservation: SpectatorReservation): void;
	ServerCancelReservationRequest(Spectator: UniqueNetIdRepl): void;
	ClientSendReservationUpdates(NumRemainingReservations: number): void;
	ClientSendReservationFull(): void;
	ClientReservationResponse(ReservationResponse: ESpectatorReservationResult): void;
	ClientCancelReservationResponse(ReservationResponse: ESpectatorReservationResult): void;
	static C(Other: UObject | any): SpectatorBeaconClient;
}

declare class SpectatorBeaconState extends UObject { 
	SessionName: string;
	NumConsumedReservations: number;
	MaxReservations: number;
	bRestrictCrossConsole: boolean;
	Reservations: SpectatorReservation[];
	static Load(ResourceName: string): SpectatorBeaconState;
	static Find(Outer: UObject, ResourceName: string): SpectatorBeaconState;
	static GetDefaultObject(): SpectatorBeaconState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpectatorBeaconState;
	static C(Other: UObject | any): SpectatorBeaconState;
}

declare class SpectatorBeaconHost extends OnlineBeaconHostObject { 
	State: SpectatorBeaconState;
	bLogoutOnSessionTimeout: boolean;
	SessionTimeoutSecs: number;
	TravelSessionTimeoutSecs: number;
	static GetDefaultObject(): SpectatorBeaconHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpectatorBeaconHost;
	static C(Other: UObject | any): SpectatorBeaconHost;
}

declare class TestBeaconClient extends OnlineBeaconClient { 
	static GetDefaultObject(): TestBeaconClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestBeaconClient;
	ServerPong(): void;
	ClientPing(): void;
	static C(Other: UObject | any): TestBeaconClient;
}

declare class TestBeaconHost extends OnlineBeaconHostObject { 
	static GetDefaultObject(): TestBeaconHost;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestBeaconHost;
	static C(Other: UObject | any): TestBeaconHost;
}

declare class TurnBasedBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): TurnBasedBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): TurnBasedBlueprintLibrary;
	static GetDefaultObject(): TurnBasedBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TurnBasedBlueprintLibrary;
	static RegisterTurnBasedMatchInterfaceObject(WorldContextObject: UObject,PlayerController: PlayerController,UObject: UObject): void;
	static GetPlayerDisplayName(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,PlayerIndex: number,PlayerDisplayName?: string): {PlayerDisplayName: string};
	static GetMyPlayerIndex(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,PlayerIndex?: number): {PlayerIndex: number};
	static GetIsMyTurn(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,bIsMyTurn?: boolean): {bIsMyTurn: boolean};
	static C(Other: UObject | any): TurnBasedBlueprintLibrary;
}

declare class VoipListenerSynthComponent extends SynthComponent { 
	static Load(ResourceName: string): VoipListenerSynthComponent;
	static Find(Outer: UObject, ResourceName: string): VoipListenerSynthComponent;
	static GetDefaultObject(): VoipListenerSynthComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VoipListenerSynthComponent;
	IsIdling(): boolean;
	static C(Other: UObject | any): VoipListenerSynthComponent;
}

declare class K2Node_InAppPurchase extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchase;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchase;
	static GetDefaultObject(): K2Node_InAppPurchase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchase;
	static C(Other: UObject | any): K2Node_InAppPurchase;
}

declare class K2Node_InAppPurchase2 extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchase2;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchase2;
	static GetDefaultObject(): K2Node_InAppPurchase2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchase2;
	static C(Other: UObject | any): K2Node_InAppPurchase2;
}

declare class K2Node_InAppPurchaseQuery extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchaseQuery;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchaseQuery;
	static GetDefaultObject(): K2Node_InAppPurchaseQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchaseQuery;
	static C(Other: UObject | any): K2Node_InAppPurchaseQuery;
}

declare class K2Node_InAppPurchaseQuery2 extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchaseQuery2;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchaseQuery2;
	static GetDefaultObject(): K2Node_InAppPurchaseQuery2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchaseQuery2;
	static C(Other: UObject | any): K2Node_InAppPurchaseQuery2;
}

declare class K2Node_InAppPurchaseQueryOwned2 extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchaseQueryOwned2;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchaseQueryOwned2;
	static GetDefaultObject(): K2Node_InAppPurchaseQueryOwned2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchaseQueryOwned2;
	static C(Other: UObject | any): K2Node_InAppPurchaseQueryOwned2;
}

declare class K2Node_InAppPurchaseRestore extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchaseRestore;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchaseRestore;
	static GetDefaultObject(): K2Node_InAppPurchaseRestore;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchaseRestore;
	static C(Other: UObject | any): K2Node_InAppPurchaseRestore;
}

declare class K2Node_InAppPurchaseRestore2 extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchaseRestore2;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchaseRestore2;
	static GetDefaultObject(): K2Node_InAppPurchaseRestore2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchaseRestore2;
	static C(Other: UObject | any): K2Node_InAppPurchaseRestore2;
}

declare class K2Node_InAppPurchaseUnprocessed2 extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_InAppPurchaseUnprocessed2;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchaseUnprocessed2;
	static GetDefaultObject(): K2Node_InAppPurchaseUnprocessed2;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchaseUnprocessed2;
	static C(Other: UObject | any): K2Node_InAppPurchaseUnprocessed2;
}

declare class K2Node_LeaderboardFlush extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_LeaderboardFlush;
	static Find(Outer: UObject, ResourceName: string): K2Node_LeaderboardFlush;
	static GetDefaultObject(): K2Node_LeaderboardFlush;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LeaderboardFlush;
	static C(Other: UObject | any): K2Node_LeaderboardFlush;
}

declare class K2Node_LeaderboardQuery extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_LeaderboardQuery;
	static Find(Outer: UObject, ResourceName: string): K2Node_LeaderboardQuery;
	static GetDefaultObject(): K2Node_LeaderboardQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LeaderboardQuery;
	static C(Other: UObject | any): K2Node_LeaderboardQuery;
}

declare class GeometryCacheTrack extends UObject { 
	Duration: number;
	static Load(ResourceName: string): GeometryCacheTrack;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheTrack;
	static GetDefaultObject(): GeometryCacheTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheTrack;
	static C(Other: UObject | any): GeometryCacheTrack;
}

declare class GeometryCache extends UObject { 
	AssetImportData: AssetImportData;
	ThumbnailInfo: ThumbnailInfo;
	Materials: MaterialInterface[];
	Tracks: GeometryCacheTrack[];
	StartFrame: number;
	EndFrame: number;
	Hash: any;
	static Load(ResourceName: string): GeometryCache;
	static Find(Outer: UObject, ResourceName: string): GeometryCache;
	static GetDefaultObject(): GeometryCache;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCache;
	static C(Other: UObject | any): GeometryCache;
}

declare class GeometryCacheComponent extends MeshComponent { 
	GeometryCache: GeometryCache;
	bRunning: boolean;
	bLooping: boolean;
	bExtrapolateFrames: boolean;
	StartTimeOffset: number;
	PlaybackSpeed: number;
	MotionVectorScale: number;
	NumTracks: number;
	ElapsedTime: number;
	Duration: number;
	bManualTick: boolean;
	bOverrideWireframeColor: boolean;
	WireframeOverrideColor: LinearColor;
	static Load(ResourceName: string): GeometryCacheComponent;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheComponent;
	static GetDefaultObject(): GeometryCacheComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheComponent;
	TickAtThisTime(Time: number,bInIsRunning: boolean,bInBackwards: boolean,bInIsLooping: boolean): void;
	Stop(): void;
	SetWireframeOverrideColor(Color: LinearColor): void;
	SetStartTimeOffset(NewStartTimeOffset: number): void;
	SetPlaybackSpeed(NewPlaybackSpeed: number): void;
	SetOverrideWireframeColor(bOverride: boolean): void;
	SetMotionVectorScale(NewMotionVectorScale: number): void;
	SetLooping(bNewLooping: boolean): void;
	SetGeometryCache(NewGeomCache: GeometryCache): boolean;
	SetExtrapolateFrames(bNewExtrapolating: boolean): void;
	PlayReversedFromEnd(): void;
	PlayReversed(): void;
	PlayFromStart(): void;
	Play(): void;
	Pause(): void;
	IsPlayingReversed(): boolean;
	IsPlaying(): boolean;
	IsLooping(): boolean;
	IsExtrapolatingFrames(): boolean;
	GetWireframeOverrideColor(): LinearColor;
	GetStartTimeOffset(): number;
	GetPlaybackSpeed(): number;
	GetPlaybackDirection(): number;
	GetOverrideWireframeColor(): boolean;
	GetNumberOfFrames(): number;
	GetMotionVectorScale(): number;
	GetDuration(): number;
	GetAnimationTime(): number;
	static C(Other: UObject | any): GeometryCacheComponent;
}

declare class GeometryCacheActor extends Actor { 
	GeometryCacheComponent: GeometryCacheComponent;
	static GetDefaultObject(): GeometryCacheActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheActor;
	GetGeometryCacheComponent(): GeometryCacheComponent;
	static C(Other: UObject | any): GeometryCacheActor;
}

declare class GeometryCacheCodecBase extends UObject { 
	TopologyRanges: number[];
	static Load(ResourceName: string): GeometryCacheCodecBase;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheCodecBase;
	static GetDefaultObject(): GeometryCacheCodecBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheCodecBase;
	static C(Other: UObject | any): GeometryCacheCodecBase;
}

declare class GeometryCacheCodecRaw extends GeometryCacheCodecBase { 
	DummyProperty: number;
	static Load(ResourceName: string): GeometryCacheCodecRaw;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheCodecRaw;
	static GetDefaultObject(): GeometryCacheCodecRaw;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheCodecRaw;
	static C(Other: UObject | any): GeometryCacheCodecRaw;
}

declare class GeometryCacheCodecV1 extends GeometryCacheCodecBase { 
	static Load(ResourceName: string): GeometryCacheCodecV1;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheCodecV1;
	static GetDefaultObject(): GeometryCacheCodecV1;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheCodecV1;
	static C(Other: UObject | any): GeometryCacheCodecV1;
}

declare class GeometryCacheMeshData { 
	clone() : GeometryCacheMeshData;
	static C(Other: UObject | any): GeometryCacheMeshData;
}

declare class GeometryCacheTrack_FlipbookAnimation extends GeometryCacheTrack { 
	NumMeshSamples: any;
	static Load(ResourceName: string): GeometryCacheTrack_FlipbookAnimation;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheTrack_FlipbookAnimation;
	static GetDefaultObject(): GeometryCacheTrack_FlipbookAnimation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheTrack_FlipbookAnimation;
	AddMeshSample(MeshData: GeometryCacheMeshData,SampleTime: number): void;
	static C(Other: UObject | any): GeometryCacheTrack_FlipbookAnimation;
}

declare class GeometryCacheTrackStreamable extends GeometryCacheTrack { 
	Codec: GeometryCacheCodecBase;
	StartSampleTime: number;
	static Load(ResourceName: string): GeometryCacheTrackStreamable;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheTrackStreamable;
	static GetDefaultObject(): GeometryCacheTrackStreamable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheTrackStreamable;
	static C(Other: UObject | any): GeometryCacheTrackStreamable;
}

declare class GeometryCacheTrack_TransformAnimation extends GeometryCacheTrack { 
	static Load(ResourceName: string): GeometryCacheTrack_TransformAnimation;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheTrack_TransformAnimation;
	static GetDefaultObject(): GeometryCacheTrack_TransformAnimation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheTrack_TransformAnimation;
	SetMesh(NewMeshData: GeometryCacheMeshData): void;
	static C(Other: UObject | any): GeometryCacheTrack_TransformAnimation;
}

declare class GeometryCacheTrack_TransformGroupAnimation extends GeometryCacheTrack { 
	static Load(ResourceName: string): GeometryCacheTrack_TransformGroupAnimation;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheTrack_TransformGroupAnimation;
	static GetDefaultObject(): GeometryCacheTrack_TransformGroupAnimation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheTrack_TransformGroupAnimation;
	SetMesh(NewMeshData: GeometryCacheMeshData): void;
	static C(Other: UObject | any): GeometryCacheTrack_TransformGroupAnimation;
}

declare class NiagaraGeometryCacheReference { 
	GeometryCache: GeometryCache;
	GeometryCacheUserParamBinding: NiagaraUserParameterBinding;
	OverrideMaterials: MaterialInterface[];
	clone() : NiagaraGeometryCacheReference;
	static C(Other: UObject | any): NiagaraGeometryCacheReference;
}

declare class NiagaraGeometryCacheRendererProperties extends NiagaraRendererProperties { 
	GeometryCaches: NiagaraGeometryCacheReference[];
	bIsLooping: boolean;
	ComponentCountLimit: any;
	PositionBinding: NiagaraVariableAttributeBinding;
	RotationBinding: NiagaraVariableAttributeBinding;
	ScaleBinding: NiagaraVariableAttributeBinding;
	ElapsedTimeBinding: NiagaraVariableAttributeBinding;
	EnabledBinding: NiagaraVariableAttributeBinding;
	ArrayIndexBinding: NiagaraVariableAttributeBinding;
	RendererVisibilityTagBinding: NiagaraVariableAttributeBinding;
	RendererVisibility: number;
	bAssignComponentsOnParticleID: boolean;
	static Load(ResourceName: string): NiagaraGeometryCacheRendererProperties;
	static Find(Outer: UObject, ResourceName: string): NiagaraGeometryCacheRendererProperties;
	static GetDefaultObject(): NiagaraGeometryCacheRendererProperties;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraGeometryCacheRendererProperties;
	static C(Other: UObject | any): NiagaraGeometryCacheRendererProperties;
}

declare class HairGroupInfo { 
	GroupID: number;
	GroupName: string;
	NumCurves: number;
	NumGuides: number;
	NumCurveVertices: number;
	NumGuideVertices: number;
	MaxCurveLength: number;
	MaxImportedWidth: number;
	clone() : HairGroupInfo;
	static C(Other: UObject | any): HairGroupInfo;
}

declare class HairGroupInfoWithVisibility extends HairGroupInfo { 
	bIsVisible: boolean;
	clone() : HairGroupInfoWithVisibility;
	static C(Other: UObject | any): HairGroupInfoWithVisibility;
}

declare class HairGeometrySettings { 
	HairWidth: number;
	HairRootScale: number;
	HairTipScale: number;
	clone() : HairGeometrySettings;
	static C(Other: UObject | any): HairGeometrySettings;
}

declare class HairShadowSettings { 
	HairShadowDensity: number;
	HairRaytracingRadiusScale: number;
	bUseHairRaytracingGeometry: boolean;
	bVoxelize: boolean;
	clone() : HairShadowSettings;
	static C(Other: UObject | any): HairShadowSettings;
}

declare class HairAdvancedRenderingSettings { 
	bUseStableRasterization: boolean;
	bScatterSceneLighting: boolean;
	clone() : HairAdvancedRenderingSettings;
	static C(Other: UObject | any): HairAdvancedRenderingSettings;
}

declare class HairGroupsRendering { 
	MaterialSlotName: string;
	Material: MaterialInterface;
	GeometrySettings: HairGeometrySettings;
	ShadowSettings: HairShadowSettings;
	AdvancedSettings: HairAdvancedRenderingSettings;
	clone() : HairGroupsRendering;
	static C(Other: UObject | any): HairGroupsRendering;
}

declare type EGroomNiagaraSolvers = 'None' | 'CosseratRods' | 'AngularSprings' | 'CustomSolver' | 'EGroomNiagaraSolvers_MAX';
declare var EGroomNiagaraSolvers : { None:'None',CosseratRods:'CosseratRods',AngularSprings:'AngularSprings',CustomSolver:'CustomSolver',EGroomNiagaraSolvers_MAX:'EGroomNiagaraSolvers_MAX', };
declare class HairSolverSettings { 
	EnableSimulation: boolean;
	NiagaraSolver: EGroomNiagaraSolvers;
	CustomSystem: NiagaraSystem;
	SubSteps: number;
	IterationCount: number;
	clone() : HairSolverSettings;
	static C(Other: UObject | any): HairSolverSettings;
}

declare class HairExternalForces { 
	GravityVector: Vector;
	AirDrag: number;
	AirVelocity: Vector;
	clone() : HairExternalForces;
	static C(Other: UObject | any): HairExternalForces;
}

declare class HairBendConstraint { 
	SolveBend: boolean;
	ProjectBend: boolean;
	BendDamping: number;
	BendStiffness: number;
	BendScale: RuntimeFloatCurve;
	clone() : HairBendConstraint;
	static C(Other: UObject | any): HairBendConstraint;
}

declare class HairStretchConstraint { 
	SolveStretch: boolean;
	ProjectStretch: boolean;
	StretchDamping: number;
	StretchStiffness: number;
	StretchScale: RuntimeFloatCurve;
	clone() : HairStretchConstraint;
	static C(Other: UObject | any): HairStretchConstraint;
}

declare class HairCollisionConstraint { 
	SolveCollision: boolean;
	ProjectCollision: boolean;
	StaticFriction: number;
	KineticFriction: number;
	StrandsViscosity: number;
	GridDimension: IntVector;
	CollisionRadius: number;
	RadiusScale: RuntimeFloatCurve;
	clone() : HairCollisionConstraint;
	static C(Other: UObject | any): HairCollisionConstraint;
}

declare class HairMaterialConstraints { 
	BendConstraint: HairBendConstraint;
	StretchConstraint: HairStretchConstraint;
	CollisionConstraint: HairCollisionConstraint;
	clone() : HairMaterialConstraints;
	static C(Other: UObject | any): HairMaterialConstraints;
}

declare type EGroomStrandsSize = 'None' | 'Size2' | 'Size4' | 'Size8' | 'Size16' | 'Size32' | 'EGroomStrandsSize_MAX';
declare var EGroomStrandsSize : { None:'None',Size2:'Size2',Size4:'Size4',Size8:'Size8',Size16:'Size16',Size32:'Size32',EGroomStrandsSize_MAX:'EGroomStrandsSize_MAX', };
declare class HairStrandsParameters { 
	StrandsSize: EGroomStrandsSize;
	StrandsDensity: number;
	StrandsSmoothing: number;
	StrandsThickness: number;
	ThicknessScale: RuntimeFloatCurve;
	clone() : HairStrandsParameters;
	static C(Other: UObject | any): HairStrandsParameters;
}

declare class HairGroupsPhysics { 
	SolverSettings: HairSolverSettings;
	ExternalForces: HairExternalForces;
	MaterialConstraints: HairMaterialConstraints;
	StrandsParameters: HairStrandsParameters;
	clone() : HairGroupsPhysics;
	static C(Other: UObject | any): HairGroupsPhysics;
}

declare class HairDecimationSettings { 
	CurveDecimation: number;
	VertexDecimation: number;
	clone() : HairDecimationSettings;
	static C(Other: UObject | any): HairDecimationSettings;
}

declare type EHairInterpolationQuality = 'Low' | 'Medium' | 'High' | 'Unknown' | 'EHairInterpolationQuality_MAX';
declare var EHairInterpolationQuality : { Low:'Low',Medium:'Medium',High:'High',Unknown:'Unknown',EHairInterpolationQuality_MAX:'EHairInterpolationQuality_MAX', };
declare type EHairInterpolationWeight = 'Parametric' | 'Root' | 'Index' | 'Unknown' | 'EHairInterpolationWeight_MAX';
declare var EHairInterpolationWeight : { Parametric:'Parametric',Root:'Root',Index:'Index',Unknown:'Unknown',EHairInterpolationWeight_MAX:'EHairInterpolationWeight_MAX', };
declare class HairInterpolationSettings { 
	bOverrideGuides: boolean;
	HairToGuideDensity: number;
	InterpolationQuality: EHairInterpolationQuality;
	InterpolationDistance: EHairInterpolationWeight;
	bRandomizeGuide: boolean;
	bUseUniqueGuide: boolean;
	clone() : HairInterpolationSettings;
	static C(Other: UObject | any): HairInterpolationSettings;
}

declare class HairGroupsInterpolation { 
	DecimationSettings: HairDecimationSettings;
	InterpolationSettings: HairInterpolationSettings;
	clone() : HairGroupsInterpolation;
	static C(Other: UObject | any): HairGroupsInterpolation;
}

declare type EGroomGeometryType = 'Strands' | 'Cards' | 'Meshes' | 'EGroomGeometryType_MAX';
declare var EGroomGeometryType : { Strands:'Strands',Cards:'Cards',Meshes:'Meshes',EGroomGeometryType_MAX:'EGroomGeometryType_MAX', };
declare type EGroomBindingType = 'NoneBinding' | 'Rigid' | 'Skinning' | 'EGroomBindingType_MAX';
declare var EGroomBindingType : { NoneBinding:'NoneBinding',Rigid:'Rigid',Skinning:'Skinning',EGroomBindingType_MAX:'EGroomBindingType_MAX', };
declare type EGroomOverrideType = 'Auto' | 'Enable' | 'Disable' | 'EGroomOverrideType_MAX';
declare var EGroomOverrideType : { Auto:'Auto',Enable:'Enable',Disable:'Disable',EGroomOverrideType_MAX:'EGroomOverrideType_MAX', };
declare class HairLODSettings { 
	CurveDecimation: number;
	VertexDecimation: number;
	AngularThreshold: number;
	ScreenSize: number;
	ThicknessScale: number;
	bVisible: boolean;
	GeometryType: EGroomGeometryType;
	BindingType: EGroomBindingType;
	Simulation: EGroomOverrideType;
	GlobalInterpolation: EGroomOverrideType;
	clone() : HairLODSettings;
	static C(Other: UObject | any): HairLODSettings;
}

declare class HairGroupsLOD { 
	LODs: HairLODSettings[];
	ClusterWorldSize: number;
	ClusterScreenSizeScale: number;
	clone() : HairGroupsLOD;
	static C(Other: UObject | any): HairGroupsLOD;
}

declare type EHairCardsSourceType = 'Procedural' | 'Imported' | 'EHairCardsSourceType_MAX';
declare var EHairCardsSourceType : { Procedural:'Procedural',Imported:'Imported',EHairCardsSourceType_MAX:'EHairCardsSourceType_MAX', };
declare type EHairCardsClusterType = 'Low' | 'High' | 'EHairCardsClusterType_MAX';
declare var EHairCardsClusterType : { Low:'Low',High:'High',EHairCardsClusterType_MAX:'EHairCardsClusterType_MAX', };
declare class HairCardsClusterSettings { 
	ClusterDecimation: number;
	Type: EHairCardsClusterType;
	bUseGuide: boolean;
	clone() : HairCardsClusterSettings;
	static C(Other: UObject | any): HairCardsClusterSettings;
}

declare type EHairCardsGenerationType = 'CardsCount' | 'UseGuides' | 'EHairCardsGenerationType_MAX';
declare var EHairCardsGenerationType : { CardsCount:'CardsCount',UseGuides:'UseGuides',EHairCardsGenerationType_MAX:'EHairCardsGenerationType_MAX', };
declare class HairCardsGeometrySettings { 
	GenerationType: EHairCardsGenerationType;
	CardsCount: number;
	ClusterType: EHairCardsClusterType;
	MinSegmentLength: number;
	AngularThreshold: number;
	MinCardsLength: number;
	MaxCardsLength: number;
	clone() : HairCardsGeometrySettings;
	static C(Other: UObject | any): HairCardsGeometrySettings;
}

declare class HairCardsTextureSettings { 
	AtlasMaxResolution: number;
	PixelPerCentimeters: number;
	LengthTextureCount: number;
	DensityTextureCount: number;
	clone() : HairCardsTextureSettings;
	static C(Other: UObject | any): HairCardsTextureSettings;
}

declare class HairGroupsProceduralCards { 
	ClusterSettings: HairCardsClusterSettings;
	GeometrySettings: HairCardsGeometrySettings;
	TextureSettings: HairCardsTextureSettings;
	Version: number;
	clone() : HairGroupsProceduralCards;
	static C(Other: UObject | any): HairGroupsProceduralCards;
}

declare class HairGroupCardsTextures { 
	DepthTexture: Texture2D;
	CoverageTexture: Texture2D;
	TangentTexture: Texture2D;
	AttributeTexture: Texture2D;
	AuxilaryDataTexture: Texture2D;
	MaterialTexture: Texture2D;
	clone() : HairGroupCardsTextures;
	static C(Other: UObject | any): HairGroupCardsTextures;
}

declare class HairGroupCardsInfo { 
	NumCards: number;
	NumCardVertices: number;
	clone() : HairGroupCardsInfo;
	static C(Other: UObject | any): HairGroupCardsInfo;
}

declare class HairGroupsCardsSourceDescription { 
	Material: MaterialInterface;
	MaterialSlotName: string;
	SourceType: EHairCardsSourceType;
	ProceduralMesh: StaticMesh;
	ProceduralMeshKey: string;
	ImportedMesh: StaticMesh;
	ProceduralSettings: HairGroupsProceduralCards;
	Textures: HairGroupCardsTextures;
	GroupIndex: number;
	LODIndex: number;
	CardsInfo: HairGroupCardsInfo;
	ImportedMeshKey: string;
	clone() : HairGroupsCardsSourceDescription;
	static C(Other: UObject | any): HairGroupsCardsSourceDescription;
}

declare class HairGroupsMeshesSourceDescription { 
	Material: MaterialInterface;
	MaterialSlotName: string;
	ImportedMesh: StaticMesh;
	Textures: HairGroupCardsTextures;
	GroupIndex: number;
	LODIndex: number;
	ImportedMeshKey: string;
	clone() : HairGroupsMeshesSourceDescription;
	static C(Other: UObject | any): HairGroupsMeshesSourceDescription;
}

declare class HairGroupsMaterial { 
	Material: MaterialInterface;
	SlotName: string;
	clone() : HairGroupsMaterial;
	static C(Other: UObject | any): HairGroupsMaterial;
}

declare type EGroomInterpolationType = 'None' | 'RigidTransform' | 'OffsetTransform' | 'SmoothTransform' | 'EGroomInterpolationType_MAX';
declare var EGroomInterpolationType : { None:'None',RigidTransform:'RigidTransform',OffsetTransform:'OffsetTransform',SmoothTransform:'SmoothTransform',EGroomInterpolationType_MAX:'EGroomInterpolationType_MAX', };
declare type EGroomBindingMeshType = 'SkeletalMesh' | 'GeometryCache' | 'EGroomBindingMeshType_MAX';
declare var EGroomBindingMeshType : { SkeletalMesh:'SkeletalMesh',GeometryCache:'GeometryCache',EGroomBindingMeshType_MAX:'EGroomBindingMeshType_MAX', };
declare class GoomBindingGroupInfo { 
	RenRootCount: number;
	RenLODCount: number;
	SimRootCount: number;
	SimLODCount: number;
	clone() : GoomBindingGroupInfo;
	static C(Other: UObject | any): GoomBindingGroupInfo;
}

declare class GroomBindingAsset extends UObject { 
	GroomBindingType: EGroomBindingMeshType;
	Groom: GroomAsset;
	SourceSkeletalMesh: SkeletalMesh;
	TargetSkeletalMesh: SkeletalMesh;
	SourceGeometryCache: GeometryCache;
	TargetGeometryCache: GeometryCache;
	NumInterpolationPoints: number;
	MatchingSection: number;
	GroupInfos: GoomBindingGroupInfo[];
	static Load(ResourceName: string): GroomBindingAsset;
	static Find(Outer: UObject, ResourceName: string): GroomBindingAsset;
	static GetDefaultObject(): GroomBindingAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomBindingAsset;
	static C(Other: UObject | any): GroomBindingAsset;
}

declare class GroomAsset extends UObject { 
	HairGroupsInfo: HairGroupInfoWithVisibility[];
	HairGroupsRendering: HairGroupsRendering[];
	HairGroupsPhysics: HairGroupsPhysics[];
	HairGroupsInterpolation: HairGroupsInterpolation[];
	HairGroupsLOD: HairGroupsLOD[];
	HairGroupsCards: HairGroupsCardsSourceDescription[];
	HairGroupsMeshes: HairGroupsMeshesSourceDescription[];
	HairGroupsMaterials: HairGroupsMaterial[];
	EnableGlobalInterpolation: boolean;
	HairInterpolationType: EGroomInterpolationType;
	MinLOD: PerPlatformInt;
	DisableBelowMinLodStripping: PerPlatformBool;
	EffectiveLODBias: number[];
	AssetImportData: AssetImportData;
	AssetUserData: AssetUserData[];
	static Load(ResourceName: string): GroomAsset;
	static Find(Outer: UObject, ResourceName: string): GroomAsset;
	static GetDefaultObject(): GroomAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomAsset;
	static C(Other: UObject | any): GroomAsset;
	CreateNewGeometryCacheGroomBindingAsset(GeometryCache: GeometryCache,NumInterpolationPoints: number,SourceGeometryCacheForTransfer: GeometryCache,MatchingSection: number): GroomBindingAsset;
	CreateNewGroomBindingAsset(InSkeletalMesh: SkeletalMesh,InNumInterpolationPoints: number,InSourceSkeletalMeshForTransfer: SkeletalMesh,InMatchingSection: number): GroomBindingAsset;
	static CreateNewGeometryCacheGroomBindingAsset(GroomAsset: GroomAsset,GeometryCache: GeometryCache,NumInterpolationPoints: number,SourceGeometryCacheForTransfer: GeometryCache,MatchingSection: number): GroomBindingAsset;
	static CreateNewGroomBindingAsset(InGroomAsset: GroomAsset,InSkeletalMesh: SkeletalMesh,InNumInterpolationPoints: number,InSourceSkeletalMeshForTransfer: SkeletalMesh,InMatchingSection: number): GroomBindingAsset;
}

declare type EGroomCacheType = 'None' | 'Strands' | 'Guides' | 'EGroomCacheType_MAX';
declare var EGroomCacheType : { None:'None',Strands:'Strands',Guides:'Guides',EGroomCacheType_MAX:'EGroomCacheType_MAX', };
declare type EGroomCacheAttributes = 'None' | 'Position' | 'Width' | 'Color' | 'PositionWidth' | 'PositionColor' | 'WidthColor' | 'PositionWidthColor' | 'EGroomCacheAttributes_MAX';
declare var EGroomCacheAttributes : { None:'None',Position:'Position',Width:'Width',Color:'Color',PositionWidth:'PositionWidth',PositionColor:'PositionColor',WidthColor:'WidthColor',PositionWidthColor:'PositionWidthColor',EGroomCacheAttributes_MAX:'EGroomCacheAttributes_MAX', };
declare class GroomAnimationInfo { 
	NumFrames: any;
	SecondsPerFrame: number;
	Duration: number;
	StartTime: number;
	EndTime: number;
	StartFrame: number;
	EndFrame: number;
	Attributes: EGroomCacheAttributes;
	clone() : GroomAnimationInfo;
	static C(Other: UObject | any): GroomAnimationInfo;
}

declare class GroomCacheInfo { 
	Version: number;
	Type: EGroomCacheType;
	AnimationInfo: GroomAnimationInfo;
	clone() : GroomCacheInfo;
	static C(Other: UObject | any): GroomCacheInfo;
}

declare class GroomCache extends UObject { 
	AssetImportData: AssetImportData;
	GroomCacheInfo: GroomCacheInfo;
	static Load(ResourceName: string): GroomCache;
	static Find(Outer: UObject, ResourceName: string): GroomCache;
	static GetDefaultObject(): GroomCache;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomCache;
	static C(Other: UObject | any): GroomCache;
}

declare class HairSimulationSetup { 
	bResetSimulation: boolean;
	bDebugSimulation: boolean;
	bLocalSimulation: boolean;
	LinearVelocityScale: number;
	AngularVelocityScale: number;
	LocalBone: string;
	TeleportDistance: number;
	clone() : HairSimulationSetup;
	static C(Other: UObject | any): HairSimulationSetup;
}

declare class HairSimulationSolver { 
	bEnableSimulation: boolean;
	clone() : HairSimulationSolver;
	static C(Other: UObject | any): HairSimulationSolver;
}

declare class HairSimulationForces { 
	GravityVector: Vector;
	AirDrag: number;
	AirVelocity: Vector;
	clone() : HairSimulationForces;
	static C(Other: UObject | any): HairSimulationForces;
}

declare class HairSimulationConstraints { 
	BendDamping: number;
	BendStiffness: number;
	StretchDamping: number;
	StretchStiffness: number;
	StaticFriction: number;
	KineticFriction: number;
	StrandsViscosity: number;
	CollisionRadius: number;
	clone() : HairSimulationConstraints;
	static C(Other: UObject | any): HairSimulationConstraints;
}

declare class HairSimulationSettings { 
	bOverrideSettings: boolean;
	SimulationSetup: HairSimulationSetup;
	SolverSettings: HairSimulationSolver;
	ExternalForces: HairSimulationForces;
	MaterialConstraints: HairSimulationConstraints;
	clone() : HairSimulationSettings;
	static C(Other: UObject | any): HairSimulationSettings;
}

declare class HairGroupDesc { 
	HairLength: number;
	HairWidth: number;
	HairWidth_Override: boolean;
	HairRootScale: number;
	HairRootScale_Override: boolean;
	HairTipScale: number;
	HairTipScale_Override: boolean;
	HairShadowDensity: number;
	HairShadowDensity_Override: boolean;
	HairRaytracingRadiusScale: number;
	HairRaytracingRadiusScale_Override: boolean;
	bUseHairRaytracingGeometry: boolean;
	bUseHairRaytracingGeometry_Override: boolean;
	LODBias: number;
	bUseStableRasterization: boolean;
	bUseStableRasterization_Override: boolean;
	bScatterSceneLighting: boolean;
	bScatterSceneLighting_Override: boolean;
	bSupportVoxelization: boolean;
	bSupportVoxelization_Override: boolean;
	HairLengthScale: number;
	HairLengthScale_Override: boolean;
	clone() : HairGroupDesc;
	static C(Other: UObject | any): HairGroupDesc;
}

declare class GroomComponent extends MeshComponent { 
	GroomAsset: GroomAsset;
	GroomCache: GroomCache;
	NiagaraComponents: NiagaraComponent[];
	SourceSkeletalMesh: SkeletalMesh;
	BindingAsset: GroomBindingAsset;
	PhysicsAsset: PhysicsAsset;
	SimulationSettings: HairSimulationSettings;
	Strands_DebugMaterial: MaterialInterface;
	Strands_DefaultMaterial: MaterialInterface;
	Cards_DefaultMaterial: MaterialInterface;
	Meshes_DefaultMaterial: MaterialInterface;
	AngularSpringsSystem: NiagaraSystem;
	CosseratRodsSystem: NiagaraSystem;
	AttachmentName: string;
	GroomGroupsDesc: HairGroupDesc[];
	bUseCards: boolean;
	bRunning: boolean;
	bLooping: boolean;
	bManualTick: boolean;
	ElapsedTime: number;
	GroomAssetBeingLoaded: GroomAsset;
	BindingAssetBeingLoaded: GroomBindingAsset;
	static Load(ResourceName: string): GroomComponent;
	static Find(Outer: UObject, ResourceName: string): GroomComponent;
	static GetDefaultObject(): GroomComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomComponent;
	SetPhysicsAsset(InPhysicsAsset: PhysicsAsset): void;
	SetHairLengthScaleEnable(bEnable: boolean): void;
	SetHairLengthScale(Scale: number): void;
	SetGroomAsset(Asset: GroomAsset): void;
	SetEnableSimulation(bInEnableSimulation: boolean): void;
	SetBindingAsset(InBinding: GroomBindingAsset): void;
	ResetSimulation(): void;
	ResetCollisionComponents(): void;
	GetIsHairLengthScaleEnabled(): boolean;
	AddCollisionComponent(SkeletalMeshComponent: SkeletalMeshComponent): void;
	static C(Other: UObject | any): GroomComponent;
}

declare class GroomActor extends Actor { 
	GroomComponent: GroomComponent;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): GroomActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomActor;
	static C(Other: UObject | any): GroomActor;
}

declare class GroomConversionSettings { 
	Rotation: Vector;
	Scale: Vector;
	clone() : GroomConversionSettings;
	static C(Other: UObject | any): GroomConversionSettings;
}

declare class GroomImportOptions extends UObject { 
	ConversionSettings: GroomConversionSettings;
	InterpolationSettings: HairGroupsInterpolation[];
	static Load(ResourceName: string): GroomImportOptions;
	static Find(Outer: UObject, ResourceName: string): GroomImportOptions;
	static GetDefaultObject(): GroomImportOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomImportOptions;
	static C(Other: UObject | any): GroomImportOptions;
}

declare class GroomAssetImportData extends AssetImportData { 
	ImportOptions: GroomImportOptions;
	static Load(ResourceName: string): GroomAssetImportData;
	static Find(Outer: UObject, ResourceName: string): GroomAssetImportData;
	static GetDefaultObject(): GroomAssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomAssetImportData;
	static C(Other: UObject | any): GroomAssetImportData;
}

declare class GroomBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): GroomBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): GroomBlueprintLibrary;
	static GetDefaultObject(): GroomBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomBlueprintLibrary;
	static CreateNewGroomBindingAssetWithPath(InDesiredPackagePath: string,InGroomAsset: GroomAsset,InSkeletalMesh: SkeletalMesh,InNumInterpolationPoints: number,InSourceSkeletalMeshForTransfer: SkeletalMesh,InMatchingSection: number): GroomBindingAsset;
	static CreateNewGroomBindingAsset(InGroomAsset: GroomAsset,InSkeletalMesh: SkeletalMesh,InNumInterpolationPoints: number,InSourceSkeletalMeshForTransfer: SkeletalMesh,InMatchingSection: number): GroomBindingAsset;
	static CreateNewGeometryCacheGroomBindingAssetWithPath(DesiredPackagePath: string,GroomAsset: GroomAsset,GeometryCache: GeometryCache,NumInterpolationPoints: number,SourceGeometryCacheForTransfer: GeometryCache,MatchingSection: number): GroomBindingAsset;
	static CreateNewGeometryCacheGroomBindingAsset(GroomAsset: GroomAsset,GeometryCache: GeometryCache,NumInterpolationPoints: number,SourceGeometryCacheForTransfer: GeometryCache,MatchingSection: number): GroomBindingAsset;
	static C(Other: UObject | any): GroomBlueprintLibrary;
}

declare class GroomCacheImportSettings { 
	bImportGroomCache: boolean;
	FrameStart: number;
	FrameEnd: number;
	bSkipEmptyFrames: boolean;
	bImportGroomAsset: boolean;
	GroomAsset: SoftObjectPath;
	clone() : GroomCacheImportSettings;
	static C(Other: UObject | any): GroomCacheImportSettings;
}

declare class GroomCacheImportOptions extends UObject { 
	ImportSettings: GroomCacheImportSettings;
	static Load(ResourceName: string): GroomCacheImportOptions;
	static Find(Outer: UObject, ResourceName: string): GroomCacheImportOptions;
	static GetDefaultObject(): GroomCacheImportOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomCacheImportOptions;
	static C(Other: UObject | any): GroomCacheImportOptions;
}

declare class GroomCacheImportData extends AssetImportData { 
	Settings: GroomCacheImportSettings;
	static Load(ResourceName: string): GroomCacheImportData;
	static Find(Outer: UObject, ResourceName: string): GroomCacheImportData;
	static GetDefaultObject(): GroomCacheImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomCacheImportData;
	static C(Other: UObject | any): GroomCacheImportData;
}

declare class GroomCreateBindingOptions extends UObject { 
	GroomBindingType: EGroomBindingMeshType;
	SourceSkeletalMesh: SkeletalMesh;
	TargetSkeletalMesh: SkeletalMesh;
	SourceGeometryCache: GeometryCache;
	TargetGeometryCache: GeometryCache;
	NumInterpolationPoints: number;
	MatchingSection: number;
	static Load(ResourceName: string): GroomCreateBindingOptions;
	static Find(Outer: UObject, ResourceName: string): GroomCreateBindingOptions;
	static GetDefaultObject(): GroomCreateBindingOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomCreateBindingOptions;
	static C(Other: UObject | any): GroomCreateBindingOptions;
}

declare type EFollicleMaskChannel = 'R' | 'G' | 'B' | 'A' | 'EFollicleMaskChannel_MAX';
declare var EFollicleMaskChannel : { R:'R',G:'G',B:'B',A:'A',EFollicleMaskChannel_MAX:'EFollicleMaskChannel_MAX', };
declare class FollicleMaskOptions { 
	Groom: GroomAsset;
	Channel: EFollicleMaskChannel;
	clone() : FollicleMaskOptions;
	static C(Other: UObject | any): FollicleMaskOptions;
}

declare class GroomCreateFollicleMaskOptions extends UObject { 
	Resolution: number;
	RootRadius: number;
	Grooms: FollicleMaskOptions[];
	static Load(ResourceName: string): GroomCreateFollicleMaskOptions;
	static Find(Outer: UObject, ResourceName: string): GroomCreateFollicleMaskOptions;
	static GetDefaultObject(): GroomCreateFollicleMaskOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomCreateFollicleMaskOptions;
	static C(Other: UObject | any): GroomCreateFollicleMaskOptions;
}

declare type EStrandsTexturesTraceType = 'TraceInside' | 'TraceOuside' | 'TraceBidirectional' | 'EStrandsTexturesTraceType_MAX';
declare var EStrandsTexturesTraceType : { TraceInside:'TraceInside',TraceOuside:'TraceOuside',TraceBidirectional:'TraceBidirectional',EStrandsTexturesTraceType_MAX:'EStrandsTexturesTraceType_MAX', };
declare type EStrandsTexturesMeshType = 'Static' | 'Skeletal' | 'EStrandsTexturesMeshType_MAX';
declare var EStrandsTexturesMeshType : { Static:'Static',Skeletal:'Skeletal',EStrandsTexturesMeshType_MAX:'EStrandsTexturesMeshType_MAX', };
declare class GroomCreateStrandsTexturesOptions extends UObject { 
	Resolution: number;
	TraceType: EStrandsTexturesTraceType;
	TraceDistance: number;
	MeshType: EStrandsTexturesMeshType;
	StaticMesh: StaticMesh;
	SkeletalMesh: SkeletalMesh;
	LODIndex: number;
	SectionIndex: number;
	UVChannelIndex: number;
	GroupIndex: number[];
	static Load(ResourceName: string): GroomCreateStrandsTexturesOptions;
	static Find(Outer: UObject, ResourceName: string): GroomCreateStrandsTexturesOptions;
	static GetDefaultObject(): GroomCreateStrandsTexturesOptions;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomCreateStrandsTexturesOptions;
	static C(Other: UObject | any): GroomCreateStrandsTexturesOptions;
}

declare class GroomHairGroupPreview { 
	GroupName: string;
	GroupID: number;
	CurveCount: number;
	GuideCount: number;
	bHasPrecomputedWeights: boolean;
	InterpolationSettings: HairGroupsInterpolation;
	clone() : GroomHairGroupPreview;
	static C(Other: UObject | any): GroomHairGroupPreview;
}

declare class GroomHairGroupsPreview extends UObject { 
	Groups: GroomHairGroupPreview[];
	static Load(ResourceName: string): GroomHairGroupsPreview;
	static Find(Outer: UObject, ResourceName: string): GroomHairGroupsPreview;
	static GetDefaultObject(): GroomHairGroupsPreview;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomHairGroupsPreview;
	static C(Other: UObject | any): GroomHairGroupsPreview;
}

declare class GroomPluginSettings extends UObject { 
	GroomCacheLookAheadBuffer: number;
	static Load(ResourceName: string): GroomPluginSettings;
	static Find(Outer: UObject, ResourceName: string): GroomPluginSettings;
	static GetDefaultObject(): GroomPluginSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroomPluginSettings;
	static C(Other: UObject | any): GroomPluginSettings;
}

declare class MovieSceneGroomCacheParams { 
	GroomCache: GroomCache;
	FirstLoopStartFrameOffset: FrameNumber;
	StartFrameOffset: FrameNumber;
	EndFrameOffset: FrameNumber;
	PlayRate: number;
	bReverse: boolean;
	clone() : MovieSceneGroomCacheParams;
	static C(Other: UObject | any): MovieSceneGroomCacheParams;
}

declare class MovieSceneGroomCacheSection extends MovieSceneSection { 
	Params: MovieSceneGroomCacheParams;
	static Load(ResourceName: string): MovieSceneGroomCacheSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneGroomCacheSection;
	static GetDefaultObject(): MovieSceneGroomCacheSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneGroomCacheSection;
	static C(Other: UObject | any): MovieSceneGroomCacheSection;
}

declare class MovieSceneGroomCacheTrack extends MovieSceneNameableTrack { 
	AnimationSections: MovieSceneSection[];
	static Load(ResourceName: string): MovieSceneGroomCacheTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneGroomCacheTrack;
	static GetDefaultObject(): MovieSceneGroomCacheTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneGroomCacheTrack;
	static C(Other: UObject | any): MovieSceneGroomCacheTrack;
}

declare class NiagaraDataInterfaceHairStrands extends NiagaraDataInterface { 
	DefaultSource: GroomAsset;
	SourceActor: Actor;
	static Load(ResourceName: string): NiagaraDataInterfaceHairStrands;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceHairStrands;
	static GetDefaultObject(): NiagaraDataInterfaceHairStrands;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceHairStrands;
	static C(Other: UObject | any): NiagaraDataInterfaceHairStrands;
}

declare class NiagaraDataInterfacePhysicsAsset extends NiagaraDataInterface { 
	DefaultSource: PhysicsAsset;
	SourceActor: Actor;
	MeshUserParameter: NiagaraUserParameterBinding;
	static Load(ResourceName: string): NiagaraDataInterfacePhysicsAsset;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfacePhysicsAsset;
	static GetDefaultObject(): NiagaraDataInterfacePhysicsAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfacePhysicsAsset;
	static C(Other: UObject | any): NiagaraDataInterfacePhysicsAsset;
}

declare class NiagaraDataInterfaceVelocityGrid extends NiagaraDataInterfaceRWBase { 
	GridSize: IntVector;
	static Load(ResourceName: string): NiagaraDataInterfaceVelocityGrid;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceVelocityGrid;
	static GetDefaultObject(): NiagaraDataInterfaceVelocityGrid;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceVelocityGrid;
	static C(Other: UObject | any): NiagaraDataInterfaceVelocityGrid;
}

declare class NiagaraDataInterfacePressureGrid extends NiagaraDataInterfaceVelocityGrid { 
	static Load(ResourceName: string): NiagaraDataInterfacePressureGrid;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfacePressureGrid;
	static GetDefaultObject(): NiagaraDataInterfacePressureGrid;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfacePressureGrid;
	static C(Other: UObject | any): NiagaraDataInterfacePressureGrid;
}

declare class ChaosDebugDrawComponent extends ActorComponent { 
	static Load(ResourceName: string): ChaosDebugDrawComponent;
	static Find(Outer: UObject, ResourceName: string): ChaosDebugDrawComponent;
	static GetDefaultObject(): ChaosDebugDrawComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosDebugDrawComponent;
	static C(Other: UObject | any): ChaosDebugDrawComponent;
}

declare class ChaosNotifyHandlerInterface extends Interface { 
	static Load(ResourceName: string): ChaosNotifyHandlerInterface;
	static Find(Outer: UObject, ResourceName: string): ChaosNotifyHandlerInterface;
	static GetDefaultObject(): ChaosNotifyHandlerInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosNotifyHandlerInterface;
	static C(Other: UObject | any): ChaosNotifyHandlerInterface;
}

declare class ChaosPhysicsCollisionInfo { 
	Component: PrimitiveComponent;
	OtherComponent: PrimitiveComponent;
	Location: Vector;
	Normal: Vector;
	AccumulatedImpulse: Vector;
	Velocity: Vector;
	OtherVelocity: Vector;
	AngularVelocity: Vector;
	OtherAngularVelocity: Vector;
	Mass: number;
	OtherMass: number;
	clone() : ChaosPhysicsCollisionInfo;
	static C(Other: UObject | any): ChaosPhysicsCollisionInfo;
	ConvertPhysicsCollisionToHitResult(): HitResult;
	static ConvertPhysicsCollisionToHitResult(PhysicsCollision: ChaosPhysicsCollisionInfo): HitResult;
}

declare class ChaosSolverEngineBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): ChaosSolverEngineBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): ChaosSolverEngineBlueprintLibrary;
	static GetDefaultObject(): ChaosSolverEngineBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolverEngineBlueprintLibrary;
	static ConvertPhysicsCollisionToHitResult(PhysicsCollision: ChaosPhysicsCollisionInfo): HitResult;
	static C(Other: UObject | any): ChaosSolverEngineBlueprintLibrary;
}

declare class ChaosSolver extends UObject { 
	static Load(ResourceName: string): ChaosSolver;
	static Find(Outer: UObject, ResourceName: string): ChaosSolver;
	static GetDefaultObject(): ChaosSolver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolver;
	static C(Other: UObject | any): ChaosSolver;
}

declare class ChaosSolverSettings extends DeveloperSettings { 
	DefaultChaosSolverActorClass: SoftClassPath;
	static Load(ResourceName: string): ChaosSolverSettings;
	static Find(Outer: UObject, ResourceName: string): ChaosSolverSettings;
	static GetDefaultObject(): ChaosSolverSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosSolverSettings;
	static C(Other: UObject | any): ChaosSolverSettings;
}

declare class FieldSystem extends UObject { 
	static Load(ResourceName: string): FieldSystem;
	static Find(Outer: UObject, ResourceName: string): FieldSystem;
	static GetDefaultObject(): FieldSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystem;
	static C(Other: UObject | any): FieldSystem;
}

declare class FieldNodeBase extends ActorComponent { 
	static Load(ResourceName: string): FieldNodeBase;
	static Find(Outer: UObject, ResourceName: string): FieldNodeBase;
	static GetDefaultObject(): FieldNodeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeBase;
	static C(Other: UObject | any): FieldNodeBase;
}

declare class FieldSystemMetaData extends ActorComponent { 
	static Load(ResourceName: string): FieldSystemMetaData;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaData;
	static GetDefaultObject(): FieldSystemMetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaData;
	static C(Other: UObject | any): FieldSystemMetaData;
}

declare class FieldObjectCommands { 
	TargetNames: string[];
	RootNodes: FieldNodeBase[];
	MetaDatas: FieldSystemMetaData[];
	clone() : FieldObjectCommands;
	static C(Other: UObject | any): FieldObjectCommands;
}

declare type EFieldPhysicsType = 'Field_None' | 'Field_DynamicState' | 'Field_LinearForce' | 'Field_ExternalClusterStrain' | 'Field_Kill' | 'Field_LinearVelocity' | 'Field_AngularVelociy' | 'Field_AngularTorque' | 'Field_InternalClusterStrain' | 'Field_DisableThreshold' | 'Field_SleepingThreshold' | 'Field_PositionStatic' | 'Field_PositionAnimated' | 'Field_PositionTarget' | 'Field_DynamicConstraint' | 'Field_CollisionGroup' | 'Field_ActivateDisabled' | 'Field_InitialLinearVelocity' | 'Field_InitialAngularVelocity' | 'Field_PhysicsType_Max';
declare var EFieldPhysicsType : { Field_None:'Field_None',Field_DynamicState:'Field_DynamicState',Field_LinearForce:'Field_LinearForce',Field_ExternalClusterStrain:'Field_ExternalClusterStrain',Field_Kill:'Field_Kill',Field_LinearVelocity:'Field_LinearVelocity',Field_AngularVelociy:'Field_AngularVelociy',Field_AngularTorque:'Field_AngularTorque',Field_InternalClusterStrain:'Field_InternalClusterStrain',Field_DisableThreshold:'Field_DisableThreshold',Field_SleepingThreshold:'Field_SleepingThreshold',Field_PositionStatic:'Field_PositionStatic',Field_PositionAnimated:'Field_PositionAnimated',Field_PositionTarget:'Field_PositionTarget',Field_DynamicConstraint:'Field_DynamicConstraint',Field_CollisionGroup:'Field_CollisionGroup',Field_ActivateDisabled:'Field_ActivateDisabled',Field_InitialLinearVelocity:'Field_InitialLinearVelocity',Field_InitialAngularVelocity:'Field_InitialAngularVelocity',Field_PhysicsType_Max:'Field_PhysicsType_Max', };
declare class FieldSystemComponent extends PrimitiveComponent { 
	FieldSystem: FieldSystem;
	bIsWorldField: boolean;
	bIsChaosField: boolean;
	SupportedSolvers: ChaosSolverActor[];
	ConstructionCommands: FieldObjectCommands;
	BufferCommands: FieldObjectCommands;
	static Load(ResourceName: string): FieldSystemComponent;
	static Find(Outer: UObject, ResourceName: string): FieldSystemComponent;
	static GetDefaultObject(): FieldSystemComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemComponent;
	ResetFieldSystem(): void;
	RemovePersistentFields(): void;
	ApplyUniformVectorFalloffForce(Enabled: boolean,position: Vector,Direction: Vector,Radius: number,Magnitude: number): void;
	ApplyStrainField(Enabled: boolean,position: Vector,Radius: number,Magnitude: number,Iterations: number): void;
	ApplyStayDynamicField(Enabled: boolean,position: Vector,Radius: number): void;
	ApplyRadialVectorFalloffForce(Enabled: boolean,position: Vector,Radius: number,Magnitude: number): void;
	ApplyRadialForce(Enabled: boolean,position: Vector,Magnitude: number): void;
	ApplyPhysicsField(Enabled: boolean,Target: EFieldPhysicsType,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	ApplyLinearForce(Enabled: boolean,Direction: Vector,Magnitude: number): void;
	AddPersistentField(Enabled: boolean,Target: EFieldPhysicsType,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	AddFieldCommand(Enabled: boolean,Target: EFieldPhysicsType,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	static C(Other: UObject | any): FieldSystemComponent;
}

declare class FieldSystemActor extends Actor { 
	FieldSystemComponent: FieldSystemComponent;
	static GetDefaultObject(): FieldSystemActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemActor;
	static C(Other: UObject | any): FieldSystemActor;
}

declare class FieldSystemMetaDataIteration extends FieldSystemMetaData { 
	Iterations: number;
	static Load(ResourceName: string): FieldSystemMetaDataIteration;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaDataIteration;
	static GetDefaultObject(): FieldSystemMetaDataIteration;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaDataIteration;
	SetMetaDataIteration(Iterations: number): FieldSystemMetaDataIteration;
	static C(Other: UObject | any): FieldSystemMetaDataIteration;
}

declare type EFieldResolutionType = 'Field_Resolution_Minimal' | 'Field_Resolution_DisabledParents' | 'Field_Resolution_Maximum' | 'Field_Resolution_Max';
declare var EFieldResolutionType : { Field_Resolution_Minimal:'Field_Resolution_Minimal',Field_Resolution_DisabledParents:'Field_Resolution_DisabledParents',Field_Resolution_Maximum:'Field_Resolution_Maximum',Field_Resolution_Max:'Field_Resolution_Max', };
declare class FieldSystemMetaDataProcessingResolution extends FieldSystemMetaData { 
	ResolutionType: EFieldResolutionType;
	static Load(ResourceName: string): FieldSystemMetaDataProcessingResolution;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaDataProcessingResolution;
	static GetDefaultObject(): FieldSystemMetaDataProcessingResolution;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaDataProcessingResolution;
	SetMetaDataaProcessingResolutionType(ResolutionType: EFieldResolutionType): FieldSystemMetaDataProcessingResolution;
	static C(Other: UObject | any): FieldSystemMetaDataProcessingResolution;
}

declare type EFieldFilterType = 'Field_Filter_Dynamic' | 'Field_Filter_Kinematic' | 'Field_Filter_Static' | 'Field_Filter_All' | 'Field_Filter_Sleeping' | 'Field_Filter_Disabled' | 'Field_Filter_Max';
declare var EFieldFilterType : { Field_Filter_Dynamic:'Field_Filter_Dynamic',Field_Filter_Kinematic:'Field_Filter_Kinematic',Field_Filter_Static:'Field_Filter_Static',Field_Filter_All:'Field_Filter_All',Field_Filter_Sleeping:'Field_Filter_Sleeping',Field_Filter_Disabled:'Field_Filter_Disabled',Field_Filter_Max:'Field_Filter_Max', };
declare type EFieldObjectType = 'Field_Object_Rigid' | 'Field_Object_Cloth' | 'Field_Object_Destruction' | 'Field_Object_Character' | 'Field_Object_All' | 'Field_Object_Max';
declare var EFieldObjectType : { Field_Object_Rigid:'Field_Object_Rigid',Field_Object_Cloth:'Field_Object_Cloth',Field_Object_Destruction:'Field_Object_Destruction',Field_Object_Character:'Field_Object_Character',Field_Object_All:'Field_Object_All',Field_Object_Max:'Field_Object_Max', };
declare type EFieldPositionType = 'Field_Position_CenterOfMass' | 'Field_Position_PivotPoint' | 'Field_Position_Max';
declare var EFieldPositionType : { Field_Position_CenterOfMass:'Field_Position_CenterOfMass',Field_Position_PivotPoint:'Field_Position_PivotPoint',Field_Position_Max:'Field_Position_Max', };
declare class FieldSystemMetaDataFilter extends FieldSystemMetaData { 
	FilterType: EFieldFilterType;
	ObjectType: EFieldObjectType;
	PositionType: EFieldPositionType;
	static Load(ResourceName: string): FieldSystemMetaDataFilter;
	static Find(Outer: UObject, ResourceName: string): FieldSystemMetaDataFilter;
	static GetDefaultObject(): FieldSystemMetaDataFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldSystemMetaDataFilter;
	SetMetaDataFilterType(FilterType: EFieldFilterType,ObjectType: EFieldObjectType,PositionType: EFieldPositionType): FieldSystemMetaDataFilter;
	static C(Other: UObject | any): FieldSystemMetaDataFilter;
}

declare class FieldNodeInt extends FieldNodeBase { 
	static Load(ResourceName: string): FieldNodeInt;
	static Find(Outer: UObject, ResourceName: string): FieldNodeInt;
	static GetDefaultObject(): FieldNodeInt;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeInt;
	static C(Other: UObject | any): FieldNodeInt;
}

declare class FieldNodeFloat extends FieldNodeBase { 
	static Load(ResourceName: string): FieldNodeFloat;
	static Find(Outer: UObject, ResourceName: string): FieldNodeFloat;
	static GetDefaultObject(): FieldNodeFloat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeFloat;
	static C(Other: UObject | any): FieldNodeFloat;
}

declare class FieldNodeVector extends FieldNodeBase { 
	static Load(ResourceName: string): FieldNodeVector;
	static Find(Outer: UObject, ResourceName: string): FieldNodeVector;
	static GetDefaultObject(): FieldNodeVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FieldNodeVector;
	static C(Other: UObject | any): FieldNodeVector;
}

declare class UniformInteger extends FieldNodeInt { 
	Magnitude: number;
	static Load(ResourceName: string): UniformInteger;
	static Find(Outer: UObject, ResourceName: string): UniformInteger;
	static GetDefaultObject(): UniformInteger;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformInteger;
	SetUniformInteger(Magnitude: number): UniformInteger;
	static C(Other: UObject | any): UniformInteger;
}

declare type ESetMaskConditionType = 'Field_Set_Always' | 'Field_Set_IFF_NOT_Interior' | 'Field_Set_IFF_NOT_Exterior' | 'Field_MaskCondition_Max' | 'Field_MAX';
declare var ESetMaskConditionType : { Field_Set_Always:'Field_Set_Always',Field_Set_IFF_NOT_Interior:'Field_Set_IFF_NOT_Interior',Field_Set_IFF_NOT_Exterior:'Field_Set_IFF_NOT_Exterior',Field_MaskCondition_Max:'Field_MaskCondition_Max',Field_MAX:'Field_MAX', };
declare class RadialIntMask extends FieldNodeInt { 
	Radius: number;
	position: Vector;
	InteriorValue: number;
	ExteriorValue: number;
	SetMaskCondition: ESetMaskConditionType;
	static Load(ResourceName: string): RadialIntMask;
	static Find(Outer: UObject, ResourceName: string): RadialIntMask;
	static GetDefaultObject(): RadialIntMask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialIntMask;
	SetRadialIntMask(Radius: number,position: Vector,InteriorValue: number,ExteriorValue: number,SetMaskConditionIn: ESetMaskConditionType): RadialIntMask;
	static C(Other: UObject | any): RadialIntMask;
}

declare class UniformScalar extends FieldNodeFloat { 
	Magnitude: number;
	static Load(ResourceName: string): UniformScalar;
	static Find(Outer: UObject, ResourceName: string): UniformScalar;
	static GetDefaultObject(): UniformScalar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScalar;
	SetUniformScalar(Magnitude: number): UniformScalar;
	static C(Other: UObject | any): UniformScalar;
}

declare type EWaveFunctionType = 'Field_Wave_Cosine' | 'Field_Wave_Gaussian' | 'Field_Wave_Falloff' | 'Field_Wave_Decay' | 'Field_Wave_Max';
declare var EWaveFunctionType : { Field_Wave_Cosine:'Field_Wave_Cosine',Field_Wave_Gaussian:'Field_Wave_Gaussian',Field_Wave_Falloff:'Field_Wave_Falloff',Field_Wave_Decay:'Field_Wave_Decay',Field_Wave_Max:'Field_Wave_Max', };
declare type EFieldFalloffType = 'Field_FallOff_None' | 'Field_Falloff_Linear' | 'Field_Falloff_Inverse' | 'Field_Falloff_Squared' | 'Field_Falloff_Logarithmic' | 'Field_Falloff_Max';
declare var EFieldFalloffType : { Field_FallOff_None:'Field_FallOff_None',Field_Falloff_Linear:'Field_Falloff_Linear',Field_Falloff_Inverse:'Field_Falloff_Inverse',Field_Falloff_Squared:'Field_Falloff_Squared',Field_Falloff_Logarithmic:'Field_Falloff_Logarithmic',Field_Falloff_Max:'Field_Falloff_Max', };
declare class WaveScalar extends FieldNodeFloat { 
	Magnitude: number;
	position: Vector;
	WaveLength: number;
	Period: number;
	UFunction: EWaveFunctionType;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): WaveScalar;
	static Find(Outer: UObject, ResourceName: string): WaveScalar;
	static GetDefaultObject(): WaveScalar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaveScalar;
	SetWaveScalar(Magnitude: number,position: Vector,WaveLength: number,Period: number,Time: number,UFunction: EWaveFunctionType,Falloff: EFieldFalloffType): WaveScalar;
	static C(Other: UObject | any): WaveScalar;
}

declare class RadialFalloff extends FieldNodeFloat { 
	Magnitude: number;
	MinRange: number;
	MaxRange: number;
	Default: number;
	Radius: number;
	position: Vector;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): RadialFalloff;
	static Find(Outer: UObject, ResourceName: string): RadialFalloff;
	static GetDefaultObject(): RadialFalloff;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialFalloff;
	SetRadialFalloff(Magnitude: number,MinRange: number,MaxRange: number,Default: number,Radius: number,position: Vector,Falloff: EFieldFalloffType): RadialFalloff;
	static C(Other: UObject | any): RadialFalloff;
}

declare class PlaneFalloff extends FieldNodeFloat { 
	Magnitude: number;
	MinRange: number;
	MaxRange: number;
	Default: number;
	Distance: number;
	position: Vector;
	Normal: Vector;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): PlaneFalloff;
	static Find(Outer: UObject, ResourceName: string): PlaneFalloff;
	static GetDefaultObject(): PlaneFalloff;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlaneFalloff;
	SetPlaneFalloff(Magnitude: number,MinRange: number,MaxRange: number,Default: number,Distance: number,position: Vector,Normal: Vector,Falloff: EFieldFalloffType): PlaneFalloff;
	static C(Other: UObject | any): PlaneFalloff;
}

declare class BoxFalloff extends FieldNodeFloat { 
	Magnitude: number;
	MinRange: number;
	MaxRange: number;
	Default: number;
	Transform: Transform;
	Falloff: EFieldFalloffType;
	static Load(ResourceName: string): BoxFalloff;
	static Find(Outer: UObject, ResourceName: string): BoxFalloff;
	static GetDefaultObject(): BoxFalloff;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoxFalloff;
	SetBoxFalloff(Magnitude: number,MinRange: number,MaxRange: number,Default: number,Transform: Transform,Falloff: EFieldFalloffType): BoxFalloff;
	static C(Other: UObject | any): BoxFalloff;
}

declare class NoiseField extends FieldNodeFloat { 
	MinRange: number;
	MaxRange: number;
	Transform: Transform;
	static Load(ResourceName: string): NoiseField;
	static Find(Outer: UObject, ResourceName: string): NoiseField;
	static GetDefaultObject(): NoiseField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NoiseField;
	SetNoiseField(MinRange: number,MaxRange: number,Transform: Transform): NoiseField;
	static C(Other: UObject | any): NoiseField;
}

declare class UniformVector extends FieldNodeVector { 
	Magnitude: number;
	Direction: Vector;
	static Load(ResourceName: string): UniformVector;
	static Find(Outer: UObject, ResourceName: string): UniformVector;
	static GetDefaultObject(): UniformVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformVector;
	SetUniformVector(Magnitude: number,Direction: Vector): UniformVector;
	static C(Other: UObject | any): UniformVector;
}

declare class RadialVector extends FieldNodeVector { 
	Magnitude: number;
	position: Vector;
	static Load(ResourceName: string): RadialVector;
	static Find(Outer: UObject, ResourceName: string): RadialVector;
	static GetDefaultObject(): RadialVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RadialVector;
	SetRadialVector(Magnitude: number,position: Vector): RadialVector;
	static C(Other: UObject | any): RadialVector;
}

declare class RandomVector extends FieldNodeVector { 
	Magnitude: number;
	static Load(ResourceName: string): RandomVector;
	static Find(Outer: UObject, ResourceName: string): RandomVector;
	static GetDefaultObject(): RandomVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RandomVector;
	SetRandomVector(Magnitude: number): RandomVector;
	static C(Other: UObject | any): RandomVector;
}

declare type EFieldOperationType = 'Field_Multiply' | 'Field_Divide' | 'Field_Add' | 'Field_Substract' | 'Field_Operation_Max';
declare var EFieldOperationType : { Field_Multiply:'Field_Multiply',Field_Divide:'Field_Divide',Field_Add:'Field_Add',Field_Substract:'Field_Substract',Field_Operation_Max:'Field_Operation_Max', };
declare class OperatorField extends FieldNodeBase { 
	Magnitude: number;
	RightField: FieldNodeBase;
	LeftField: FieldNodeBase;
	Operation: EFieldOperationType;
	static Load(ResourceName: string): OperatorField;
	static Find(Outer: UObject, ResourceName: string): OperatorField;
	static GetDefaultObject(): OperatorField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OperatorField;
	SetOperatorField(Magnitude: number,LeftField: FieldNodeBase,RightField: FieldNodeBase,Operation: EFieldOperationType): OperatorField;
	static C(Other: UObject | any): OperatorField;
}

declare class ToIntegerField extends FieldNodeInt { 
	FloatField: FieldNodeFloat;
	static Load(ResourceName: string): ToIntegerField;
	static Find(Outer: UObject, ResourceName: string): ToIntegerField;
	static GetDefaultObject(): ToIntegerField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToIntegerField;
	SetToIntegerField(FloatField: FieldNodeFloat): ToIntegerField;
	static C(Other: UObject | any): ToIntegerField;
}

declare class ToFloatField extends FieldNodeFloat { 
	IntField: FieldNodeInt;
	static Load(ResourceName: string): ToFloatField;
	static Find(Outer: UObject, ResourceName: string): ToFloatField;
	static GetDefaultObject(): ToFloatField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ToFloatField;
	SetToFloatField(IntegerField: FieldNodeInt): ToFloatField;
	static C(Other: UObject | any): ToFloatField;
}

declare type EFieldCullingOperationType = 'Field_Culling_Inside' | 'Field_Culling_Outside' | 'Field_Culling_Operation_Max' | 'Field_Culling_MAX';
declare var EFieldCullingOperationType : { Field_Culling_Inside:'Field_Culling_Inside',Field_Culling_Outside:'Field_Culling_Outside',Field_Culling_Operation_Max:'Field_Culling_Operation_Max',Field_Culling_MAX:'Field_Culling_MAX', };
declare class CullingField extends FieldNodeBase { 
	Culling: FieldNodeBase;
	Field: FieldNodeBase;
	Operation: EFieldCullingOperationType;
	static Load(ResourceName: string): CullingField;
	static Find(Outer: UObject, ResourceName: string): CullingField;
	static GetDefaultObject(): CullingField;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CullingField;
	SetCullingField(Culling: FieldNodeBase,Field: FieldNodeBase,Operation: EFieldCullingOperationType): CullingField;
	static C(Other: UObject | any): CullingField;
}

declare class ReturnResultsTerminal extends FieldNodeBase { 
	static Load(ResourceName: string): ReturnResultsTerminal;
	static Find(Outer: UObject, ResourceName: string): ReturnResultsTerminal;
	static GetDefaultObject(): ReturnResultsTerminal;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReturnResultsTerminal;
	SetReturnResultsTerminal(): ReturnResultsTerminal;
	static C(Other: UObject | any): ReturnResultsTerminal;
}

declare type ECompilerVersion = 'Default' | 'VisualStudio2015' | 'VisualStudio2017' | 'VisualStudio2019' | 'VisualStudio2022' | 'ECompilerVersion_MAX';
declare var ECompilerVersion : { Default:'Default',VisualStudio2015:'VisualStudio2015',VisualStudio2017:'VisualStudio2017',VisualStudio2019:'VisualStudio2019',VisualStudio2022:'VisualStudio2022',ECompilerVersion_MAX:'ECompilerVersion_MAX', };
declare type EDefaultGraphicsRHI = 'DefaultGraphicsRHI_Default' | 'DefaultGraphicsRHI_DX11' | 'DefaultGraphicsRHI_DX12' | 'DefaultGraphicsRHI_Vulkan' | 'DefaultGraphicsRHI_MAX';
declare var EDefaultGraphicsRHI : { DefaultGraphicsRHI_Default:'DefaultGraphicsRHI_Default',DefaultGraphicsRHI_DX11:'DefaultGraphicsRHI_DX11',DefaultGraphicsRHI_DX12:'DefaultGraphicsRHI_DX12',DefaultGraphicsRHI_Vulkan:'DefaultGraphicsRHI_Vulkan',DefaultGraphicsRHI_MAX:'DefaultGraphicsRHI_MAX', };
declare class PlatformRuntimeAudioCompressionOverrides { 
	bOverrideCompressionTimes: boolean;
	DurationThreshold: number;
	MaxNumRandomBranches: number;
	SoundCueQualityIndex: number;
	clone() : PlatformRuntimeAudioCompressionOverrides;
	static C(Other: UObject | any): PlatformRuntimeAudioCompressionOverrides;
}

declare class WindowsTargetSettings extends UObject { 
	Compiler: ECompilerVersion;
	TargetedRHIs: string[];
	DefaultGraphicsRHI: EDefaultGraphicsRHI;
	AudioSampleRate: number;
	AudioCallbackBufferFrameSize: number;
	AudioNumBuffersToEnqueue: number;
	AudioMaxChannels: number;
	AudioNumSourceWorkers: number;
	SpatializationPlugin: string;
	SourceDataOverridePlugin: string;
	ReverbPlugin: string;
	OcclusionPlugin: string;
	CompressionOverrides: PlatformRuntimeAudioCompressionOverrides;
	CacheSizeKB: number;
	MaxChunkSizeOverrideKB: number;
	bResampleForDevice: boolean;
	MaxSampleRate: number;
	HighSampleRate: number;
	MedSampleRate: number;
	LowSampleRate: number;
	MinSampleRate: number;
	CompressionQualityModifier: number;
	AutoStreamingThreshold: number;
	SoundCueCookQualityIndex: number;
	static Load(ResourceName: string): WindowsTargetSettings;
	static Find(Outer: UObject, ResourceName: string): WindowsTargetSettings;
	static GetDefaultObject(): WindowsTargetSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindowsTargetSettings;
	static C(Other: UObject | any): WindowsTargetSettings;
}

declare class SourceCodeAccessSettings extends UObject { 
	PreferredAccessor: string;
	static Load(ResourceName: string): SourceCodeAccessSettings;
	static Find(Outer: UObject, ResourceName: string): SourceCodeAccessSettings;
	static GetDefaultObject(): SourceCodeAccessSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceCodeAccessSettings;
	static C(Other: UObject | any): SourceCodeAccessSettings;
}

declare class LandscapeBlueprintBrush extends LandscapeBlueprintBrushBase { 
	static GetDefaultObject(): LandscapeBlueprintBrush;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LandscapeBlueprintBrush;
	static C(Other: UObject | any): LandscapeBlueprintBrush;
}

declare class PropertyViewBase extends Widget { 
	UObject: UObject;
	SoftObjectPath: SoftObjectPath;
	bAutoLoadAsset: boolean;
	OnPropertyChanged: UnrealEngineMulticastDelegate<(PropertyName: string) => void>;
	static Load(ResourceName: string): PropertyViewBase;
	static Find(Outer: UObject, ResourceName: string): PropertyViewBase;
	static GetDefaultObject(): PropertyViewBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyViewBase;
	SetObject(NewObject: UObject): void;
	GetObject(): UObject;
	static C(Other: UObject | any): PropertyViewBase;
}

declare class DetailsView extends PropertyViewBase { 
	bAllowFiltering: boolean;
	bAllowFavoriteSystem: boolean;
	bShowModifiedPropertiesOption: boolean;
	bShowKeyablePropertiesOption: boolean;
	bShowAnimatedPropertiesOption: boolean;
	ColumnWidth: number;
	bShowScrollBar: boolean;
	bForceHiddenPropertyVisibility: boolean;
	ViewIdentifier: string;
	CategoriesToShow: string[];
	PropertiesToShow: string[];
	bShowOnlyAllowed: boolean;
	static Load(ResourceName: string): DetailsView;
	static Find(Outer: UObject, ResourceName: string): DetailsView;
	static GetDefaultObject(): DetailsView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DetailsView;
	static C(Other: UObject | any): DetailsView;
}

declare class K2Node_CreateDragDropOperation extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_CreateDragDropOperation;
	static Find(Outer: UObject, ResourceName: string): K2Node_CreateDragDropOperation;
	static GetDefaultObject(): K2Node_CreateDragDropOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CreateDragDropOperation;
	static C(Other: UObject | any): K2Node_CreateDragDropOperation;
}

declare class K2Node_CreateWidget extends K2Node_ConstructObjectFromClass { 
	static Load(ResourceName: string): K2Node_CreateWidget;
	static Find(Outer: UObject, ResourceName: string): K2Node_CreateWidget;
	static GetDefaultObject(): K2Node_CreateWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CreateWidget;
	static C(Other: UObject | any): K2Node_CreateWidget;
}

declare class K2Node_PlayAnimation extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_PlayAnimation;
	static Find(Outer: UObject, ResourceName: string): K2Node_PlayAnimation;
	static GetDefaultObject(): K2Node_PlayAnimation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_PlayAnimation;
	static C(Other: UObject | any): K2Node_PlayAnimation;
}

declare class K2Node_PlayAnimationTimeRange extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_PlayAnimationTimeRange;
	static Find(Outer: UObject, ResourceName: string): K2Node_PlayAnimationTimeRange;
	static GetDefaultObject(): K2Node_PlayAnimationTimeRange;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_PlayAnimationTimeRange;
	static C(Other: UObject | any): K2Node_PlayAnimationTimeRange;
}

declare class EditorPropertyPathSegment { 
	struct: Struct;
	MemberName: string;
	MemberGuid: Guid;
	IsProperty: boolean;
	clone() : EditorPropertyPathSegment;
	static C(Other: UObject | any): EditorPropertyPathSegment;
}

declare class EditorPropertyPath { 
	Segments: EditorPropertyPathSegment[];
	clone() : EditorPropertyPath;
	static C(Other: UObject | any): EditorPropertyPath;
}

declare class DelegateEditorBinding { 
	ObjectName: string;
	PropertyName: string;
	FunctionName: string;
	SourceProperty: string;
	SourcePath: EditorPropertyPath;
	MemberGuid: Guid;
	Kind: EBindingKind;
	clone() : DelegateEditorBinding;
	static C(Other: UObject | any): DelegateEditorBinding;
}

declare class WidgetAnimation_DEPRECATED { 
	MovieScene: MovieScene;
	AnimationBindings: WidgetAnimationBinding[];
	clone() : WidgetAnimation_DEPRECATED;
	static C(Other: UObject | any): WidgetAnimation_DEPRECATED;
}

declare type EWidgetCompileTimeTickPrediction = 'WontTick' | 'OnDemand' | 'WillTick' | 'EWidgetCompileTimeTickPrediction_MAX';
declare var EWidgetCompileTimeTickPrediction : { WontTick:'WontTick',OnDemand:'OnDemand',WillTick:'WillTick',EWidgetCompileTimeTickPrediction_MAX:'EWidgetCompileTimeTickPrediction_MAX', };
declare type EThumbnailPreviewSizeMode = 'MatchDesignerMode' | 'FillScreen' | 'Custom' | 'Desired' | 'EThumbnailPreviewSizeMode_MAX';
declare var EThumbnailPreviewSizeMode : { MatchDesignerMode:'MatchDesignerMode',FillScreen:'FillScreen',Custom:'Custom',Desired:'Desired',EThumbnailPreviewSizeMode_MAX:'EThumbnailPreviewSizeMode_MAX', };
declare class WidgetBlueprint extends BaseWidgetBlueprint { 
	Bindings: DelegateEditorBinding[];
	AnimationData: WidgetAnimation_DEPRECATED[];
	Animations: WidgetAnimation[];
	PaletteCategory: string;
	TickFrequency: EWidgetTickFrequency;
	TickPrediction: EWidgetCompileTimeTickPrediction;
	TickPredictionReason: string;
	PropertyBindings: number;
	ThumbnailSizeMode: EThumbnailPreviewSizeMode;
	ThumbnailCustomSize: Vector2D;
	ThumbnailImage: Texture2D;
	static Load(ResourceName: string): WidgetBlueprint;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprint;
	static GetDefaultObject(): WidgetBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprint;
	static C(Other: UObject | any): WidgetBlueprint;
}

declare class K2Node_WidgetAnimationEvent extends K2Node_Event { 
	Action: EWidgetAnimationEvent;
	AnimationPropertyName: string;
	UserTag: string;
	SourceWidgetBlueprint: WidgetBlueprint;
	static Load(ResourceName: string): K2Node_WidgetAnimationEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_WidgetAnimationEvent;
	static GetDefaultObject(): K2Node_WidgetAnimationEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_WidgetAnimationEvent;
	static C(Other: UObject | any): K2Node_WidgetAnimationEvent;
}

declare class SinglePropertyView extends PropertyViewBase { 
	PropertyName: string;
	NameOverride: string;
	static Load(ResourceName: string): SinglePropertyView;
	static Find(Outer: UObject, ResourceName: string): SinglePropertyView;
	static GetDefaultObject(): SinglePropertyView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SinglePropertyView;
	SetPropertyName(NewPropertyName: string): void;
	SetNameOverride(NewPropertyName: string): void;
	GetPropertyName(): string;
	GetNameOverride(): string;
	static C(Other: UObject | any): SinglePropertyView;
}

declare class SlateVectorArtDataFactory extends Factory { 
	static Load(ResourceName: string): SlateVectorArtDataFactory;
	static Find(Outer: UObject, ResourceName: string): SlateVectorArtDataFactory;
	static GetDefaultObject(): SlateVectorArtDataFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateVectorArtDataFactory;
	static C(Other: UObject | any): SlateVectorArtDataFactory;
}

declare type EPropertyBindingPermissionLevel = 'Allow' | 'Prevent' | 'PreventAndWarn' | 'PreventAndError' | 'EPropertyBindingPermissionLevel_MAX';
declare var EPropertyBindingPermissionLevel : { Allow:'Allow',Prevent:'Prevent',PreventAndWarn:'PreventAndWarn',PreventAndError:'PreventAndError',EPropertyBindingPermissionLevel_MAX:'EPropertyBindingPermissionLevel_MAX', };
declare class WidgetCompilerOptions { 
	bAllowBlueprintTick: boolean;
	bAllowBlueprintPaint: boolean;
	PropertyBindingRule: EPropertyBindingPermissionLevel;
	Rules: Class[];
	clone() : WidgetCompilerOptions;
	static C(Other: UObject | any): WidgetCompilerOptions;
}

declare class DirectoryWidgetCompilerOptions { 
	Directory: DirectoryPath;
	IgnoredWidgets: WidgetBlueprint[];
	Options: WidgetCompilerOptions;
	clone() : DirectoryWidgetCompilerOptions;
	static C(Other: UObject | any): DirectoryWidgetCompilerOptions;
}

declare class DebugResolution { 
	Width: number;
	Height: number;
	Description: string;
	Color: LinearColor;
	clone() : DebugResolution;
	static C(Other: UObject | any): DebugResolution;
}

declare class UMGEditorProjectSettings extends DeveloperSettings { 
	DefaultCompilerOptions: WidgetCompilerOptions;
	DirectoryCompilerOptions: DirectoryWidgetCompilerOptions[];
	bShowWidgetsFromEngineContent: boolean;
	bShowWidgetsFromDeveloperContent: boolean;
	CategoriesToHide: string[];
	WidgetClassesToHide: SoftClassPath[];
	bUseWidgetTemplateSelector: boolean;
	DefaultRootWidget: UnrealEngineClass;
	DefaultWidgetParentClass: Class;
	DebugResolutions: DebugResolution[];
	Version: number;
	static Load(ResourceName: string): UMGEditorProjectSettings;
	static Find(Outer: UObject, ResourceName: string): UMGEditorProjectSettings;
	static GetDefaultObject(): UMGEditorProjectSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UMGEditorProjectSettings;
	static C(Other: UObject | any): UMGEditorProjectSettings;
}

declare class WidgetBlueprintFactory extends Factory { 
	BlueprintType: EBlueprintType;
	ParentClass: UnrealEngineClass;
	RootWidgetClass: UnrealEngineClass;
	static Load(ResourceName: string): WidgetBlueprintFactory;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintFactory;
	static GetDefaultObject(): WidgetBlueprintFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintFactory;
	static C(Other: UObject | any): WidgetBlueprintFactory;
}

declare class WidgetBlueprintThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	static Load(ResourceName: string): WidgetBlueprintThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintThumbnailRenderer;
	static GetDefaultObject(): WidgetBlueprintThumbnailRenderer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintThumbnailRenderer;
	static C(Other: UObject | any): WidgetBlueprintThumbnailRenderer;
}

declare class WidgetCompilerRule extends UObject { 
	static Load(ResourceName: string): WidgetCompilerRule;
	static Find(Outer: UObject, ResourceName: string): WidgetCompilerRule;
	static GetDefaultObject(): WidgetCompilerRule;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetCompilerRule;
	static C(Other: UObject | any): WidgetCompilerRule;
}

declare type EDisplayOnCompile = 'DoC_ErrorsOrWarnings' | 'DoC_ErrorsOnly' | 'DoC_WarningsOnly' | 'DoC_Never' | 'DoC_MAX';
declare var EDisplayOnCompile : { DoC_ErrorsOrWarnings:'DoC_ErrorsOrWarnings',DoC_ErrorsOnly:'DoC_ErrorsOnly',DoC_WarningsOnly:'DoC_WarningsOnly',DoC_Never:'DoC_Never',DoC_MAX:'DoC_MAX', };
declare class WidgetPaletteFavorites extends UObject { 
	Favorites: string[];
	static Load(ResourceName: string): WidgetPaletteFavorites;
	static Find(Outer: UObject, ResourceName: string): WidgetPaletteFavorites;
	static GetDefaultObject(): WidgetPaletteFavorites;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetPaletteFavorites;
	static C(Other: UObject | any): WidgetPaletteFavorites;
}

declare class WidgetDesignerSettings extends DeveloperSettings { 
	GridSnapEnabled: boolean;
	GridSnapSize: number;
	bLockToPanelOnDragByDefault: boolean;
	bShowOutlines: boolean;
	bExecutePreConstructEvent: boolean;
	bRespectLocks: boolean;
	CreateOnCompile: EDisplayOnCompile;
	DismissOnCompile: EDisplayOnCompile;
	Favorites: WidgetPaletteFavorites;
	static Load(ResourceName: string): WidgetDesignerSettings;
	static Find(Outer: UObject, ResourceName: string): WidgetDesignerSettings;
	static GetDefaultObject(): WidgetDesignerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetDesignerSettings;
	static C(Other: UObject | any): WidgetDesignerSettings;
}

declare class WidgetGraphSchema extends EdGraphSchema_K2 { 
	static Load(ResourceName: string): WidgetGraphSchema;
	static Find(Outer: UObject, ResourceName: string): WidgetGraphSchema;
	static GetDefaultObject(): WidgetGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetGraphSchema;
	static C(Other: UObject | any): WidgetGraphSchema;
}

declare class WidgetSlotPair extends UObject { 
	WidgetName: string;
	SlotPropertyNames: string[];
	SlotPropertyValues: string[];
	static Load(ResourceName: string): WidgetSlotPair;
	static Find(Outer: UObject, ResourceName: string): WidgetSlotPair;
	static GetDefaultObject(): WidgetSlotPair;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetSlotPair;
	static C(Other: UObject | any): WidgetSlotPair;
}

declare class AutomationTestExcludelistEntry { 
	Map: string;
	Test: string;
	Reason: string;
	RHIs: any;
	Warn: boolean;
	clone() : AutomationTestExcludelistEntry;
	static C(Other: UObject | any): AutomationTestExcludelistEntry;
}

declare class AutomationTestExcludelist extends UObject { 
	ExcludeTest: AutomationTestExcludelistEntry[];
	static Load(ResourceName: string): AutomationTestExcludelist;
	static Find(Outer: UObject, ResourceName: string): AutomationTestExcludelist;
	static GetDefaultObject(): AutomationTestExcludelist;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationTestExcludelist;
	static C(Other: UObject | any): AutomationTestExcludelist;
}

declare class AutomatedTestFilter { 
	Contains: string;
	MatchFromStart: boolean;
	MatchFromEnd: boolean;
	clone() : AutomatedTestFilter;
	static C(Other: UObject | any): AutomatedTestFilter;
}

declare class AutomatedTestGroup { 
	Name: string;
	Filters: AutomatedTestFilter[];
	clone() : AutomatedTestGroup;
	static C(Other: UObject | any): AutomatedTestGroup;
}

declare class AutomationControllerSettings extends UObject { 
	Groups: AutomatedTestGroup[];
	bSuppressLogErrors: boolean;
	bSuppressLogWarnings: boolean;
	bElevateLogWarningsToErrors: boolean;
	bTreatLogWarningsAsTestErrors: boolean;
	CheckTestIntervalSeconds: number;
	GameInstanceLostTimerSeconds: number;
	TelemetryDirectory: string;
	bResetTelemetryStorageOnNewSession: boolean;
	static Load(ResourceName: string): AutomationControllerSettings;
	static Find(Outer: UObject, ResourceName: string): AutomationControllerSettings;
	static GetDefaultObject(): AutomationControllerSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationControllerSettings;
	static C(Other: UObject | any): AutomationControllerSettings;
}

declare class AutomationEditorTask extends UObject { 
	static Load(ResourceName: string): AutomationEditorTask;
	static Find(Outer: UObject, ResourceName: string): AutomationEditorTask;
	static GetDefaultObject(): AutomationEditorTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationEditorTask;
	IsValidTask(): boolean;
	IsTaskDone(): boolean;
	static C(Other: UObject | any): AutomationEditorTask;
}

declare class AutomationBlueprintFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AutomationBlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): AutomationBlueprintFunctionLibrary;
	static GetDefaultObject(): AutomationBlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationBlueprintFunctionLibrary;
	static TakeHighResScreenshot(ResX: number,ResY: number,Filename: string,Camera: CameraActor,bMaskEnabled: boolean,bCaptureHDR: boolean,ComparisonTolerance: EComparisonTolerance,ComparisonNotes: string,Delay: number): AutomationEditorTask;
	static TakeAutomationScreenshotOfUI(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Name: string,Options: AutomationScreenshotOptions): void;
	static TakeAutomationScreenshotAtCamera(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Camera: CameraActor,NameOverride: string,Notes: string,Options: AutomationScreenshotOptions): void;
	static TakeAutomationScreenshot(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Name: string,Notes: string,Options: AutomationScreenshotOptions): void;
	static SetTestTelemetryStorage(StorageName: string): void;
	static SetScalabilityQualityToLow(WorldContextObject: UObject): void;
	static SetScalabilityQualityToEpic(WorldContextObject: UObject): void;
	static SetScalabilityQualityLevelRelativeToMax(WorldContextObject: UObject,Value: number): void;
	static GetStatIncMax(StatName: string): number;
	static GetStatIncAverage(StatName: string): number;
	static GetStatExcMax(StatName: string): number;
	static GetStatExcAverage(StatName: string): number;
	static GetStatCallCount(StatName: string): number;
	static GetDefaultScreenshotOptionsForRendering(Tolerance: EComparisonTolerance,Delay: number): AutomationScreenshotOptions;
	static GetDefaultScreenshotOptionsForGameplay(Tolerance: EComparisonTolerance,Delay: number): AutomationScreenshotOptions;
	static FinishLoadingBeforeScreenshot(): void;
	static EnableStatGroup(WorldContextObject: UObject,GroupName: string): void;
	static DisableStatGroup(WorldContextObject: UObject,GroupName: string): void;
	static CompareImageAgainstReference(ImageFilePath: string,ComparisonName: string,ComparisonTolerance: EComparisonTolerance,ComparisonNotes: string,WorldContextObject: UObject): boolean;
	static AutomationWaitForLoading(WorldContextObject: UObject,LatentInfo: LatentActionInfo,Options: AutomationWaitForLoadingOptions): void;
	static AreAutomatedTestsRunning(): boolean;
	static AddTestTelemetryData(DataPoint: string,Measurement: number,Context: string): void;
	static AddExpectedLogError(ExpectedPatternString: string,Occurrences: number,ExactMatch: boolean): void;
	static C(Other: UObject | any): AutomationBlueprintFunctionLibrary;
}

declare class FuncTestRenderingComponent extends PrimitiveComponent { 
	static Load(ResourceName: string): FuncTestRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): FuncTestRenderingComponent;
	static GetDefaultObject(): FuncTestRenderingComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FuncTestRenderingComponent;
	static C(Other: UObject | any): FuncTestRenderingComponent;
}

declare type EFunctionalTestLogHandling = 'ProjectDefault' | 'OutputIsError' | 'OutputIgnored' | 'EFunctionalTestLogHandling_MAX';
declare var EFunctionalTestLogHandling : { ProjectDefault:'ProjectDefault',OutputIsError:'OutputIsError',OutputIgnored:'OutputIgnored',EFunctionalTestLogHandling_MAX:'EFunctionalTestLogHandling_MAX', };
declare type EFunctionalTestResult = 'Default' | 'Invalid' | 'Error' | 'Running' | 'Failed' | 'Succeeded' | 'EFunctionalTestResult_MAX';
declare var EFunctionalTestResult : { Default:'Default',Invalid:'Invalid',Error:'Error',Running:'Running',Failed:'Failed',Succeeded:'Succeeded',EFunctionalTestResult_MAX:'EFunctionalTestResult_MAX', };
declare type EComparisonMethod = 'Equal_To' | 'Not_Equal_To' | 'Greater_Than_Or_Equal_To' | 'Less_Than_Or_Equal_To' | 'Greater_Than' | 'Less_Than' | 'EComparisonMethod_MAX';
declare var EComparisonMethod : { Equal_To:'Equal_To',Not_Equal_To:'Not_Equal_To',Greater_Than_Or_Equal_To:'Greater_Than_Or_Equal_To',Less_Than_Or_Equal_To:'Less_Than_Or_Equal_To',Greater_Than:'Greater_Than',Less_Than:'Less_Than',EComparisonMethod_MAX:'EComparisonMethod_MAX', };
declare class FunctionalTest extends Actor { 
	TestLabel: string;
	SpriteComponent: BillboardComponent;
	bIsEnabled: boolean;
	LogErrorHandling: EFunctionalTestLogHandling;
	LogWarningHandling: EFunctionalTestLogHandling;
	Author: string;
	Description: string;
	ObservationPoint: Actor;
	RandomNumbersStream: RandomStream;
	Result: EFunctionalTestResult;
	PreparationTimeLimit: number;
	TimeLimit: number;
	TimesUpMessage: string;
	TimesUpResult: EFunctionalTestResult;
	OnTestPrepare: UnrealEngineMulticastDelegate<() => void>;
	OnTestStart: UnrealEngineMulticastDelegate<() => void>;
	OnTestFinished: UnrealEngineMulticastDelegate<() => void>;
	AutoDestroyActors: Actor[];
	RenderComp: FuncTestRenderingComponent;
	TestName: TextRenderComponent;
	bIsRunning: boolean;
	TotalTime: number;
	static GetDefaultObject(): FunctionalTest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalTest;
	SetTimeLimit(NewTimeLimit: number,ResultWhenTimeRunsOut: EFunctionalTestResult): void;
	RegisterAutoDestroyActor(ActorToAutoDestroy: Actor): void;
	ReceiveStartTest(): void;
	ReceivePrepareTest(): void;
	OnWantsReRunCheck(): boolean;
	OnAdditionalTestFinishedMessageRequest(TestResult: EFunctionalTestResult): string;
	LogMessage(Message: string): void;
	IsRunning(): boolean;
	IsReady(): boolean;
	IsEnabled(): boolean;
	GetCurrentRerunReason(): string;
	FinishTest(TestResult: EFunctionalTestResult,Message: string): void;
	DebugGatherRelevantActors(): Actor[];
	AssertValue_Int(Actual: number,ShouldBe: EComparisonMethod,Expected: number,What: string,ContextObject: UObject): boolean;
	AssertValue_Float(Actual: number,ShouldBe: EComparisonMethod,Expected: number,What: string,ContextObject: UObject): boolean;
	AssertValue_Double(Actual: any,ShouldBe: EComparisonMethod,Expected: any,What: string,ContextObject: UObject): boolean;
	AssertValue_DateTime(Actual: DateTime,ShouldBe: EComparisonMethod,Expected: DateTime,What: string,ContextObject: UObject): boolean;
	AssertTrue(Condition: boolean,Message: string,ContextObject: UObject): boolean;
	AssertNotEqual_Vector(Actual: Vector,NotExpected: Vector,What: string,ContextObject: UObject): boolean;
	AssertNotEqual_Transform(Actual: Transform,NotExpected: Transform,What: string,ContextObject: UObject): boolean;
	AssertNotEqual_String(Actual: string,NotExpected: string,What: string,ContextObject: UObject): boolean;
	AssertNotEqual_Rotator(Actual: Rotator,NotExpected: Rotator,What: string,ContextObject: UObject): boolean;
	AssertIsValid(UObject: UObject,Message: string,ContextObject: UObject): boolean;
	AssertFalse(Condition: boolean,Message: string,ContextObject: UObject): boolean;
	AssertEqual_Vector(Actual: Vector,Expected: Vector,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Transform(Actual: Transform,Expected: Transform,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_TraceQueryResults(Actual: TraceQueryTestResults,Expected: TraceQueryTestResults,What: string,ContextObject: UObject): boolean;
	AssertEqual_String(Actual: string,Expected: string,What: string,ContextObject: UObject): boolean;
	AssertEqual_Rotator(Actual: Rotator,Expected: Rotator,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Object(Actual: UObject,Expected: UObject,What: string,ContextObject: UObject): boolean;
	AssertEqual_Name(Actual: string,Expected: string,What: string,ContextObject: UObject): boolean;
	AssertEqual_Int(Actual: number,Expected: number,What: string,ContextObject: UObject): boolean;
	AssertEqual_Float(Actual: number,Expected: number,What: string,Tolerance: number,ContextObject: UObject): boolean;
	AssertEqual_Double(Actual: any,Expected: any,What: string,Tolerance: any,ContextObject: UObject): boolean;
	AssertEqual_Bool(Actual: boolean,Expected: boolean,What: string,ContextObject: UObject): boolean;
	AddWarning(Message: string): void;
	AddRerun(Reason: string): void;
	AddError(Message: string): void;
	static C(Other: UObject | any): FunctionalTest;
}

declare class PendingDelayedSpawn { 
	clone() : PendingDelayedSpawn;
	static C(Other: UObject | any): PendingDelayedSpawn;
}

declare class FunctionalAITestBase extends FunctionalTest { 
	SpawnLocationRandomizationRange: number;
	SpawnedPawns: Pawn[];
	PendingDelayedSpawns: PendingDelayedSpawn[];
	CurrentSpawnSetIndex: number;
	CurrentSpawnSetName: string;
	OnAISpawned: UnrealEngineMulticastDelegate<(Controller: AIController, Pawn: Pawn) => void>;
	OnAllAISPawned: UnrealEngineMulticastDelegate<() => void>;
	NavMeshDebugOrigin: Vector;
	NavMeshDebugExtent: Vector;
	bWaitForNavMesh: boolean;
	bDebugNavMeshOnTimeout: boolean;
	static GetDefaultObject(): FunctionalAITestBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalAITestBase;
	IsOneOfSpawnedPawns(Actor: Actor): boolean;
	static C(Other: UObject | any): FunctionalAITestBase;
}

declare class AITestSpawnSetBase { 
	Name: string;
	bEnabled: boolean;
	FallbackSpawnLocation: Actor;
	clone() : AITestSpawnSetBase;
	static C(Other: UObject | any): AITestSpawnSetBase;
}

declare class AITestSpawnInfoBase { 
	SpawnLocation: Actor;
	NumberToSpawn: number;
	SpawnDelay: number;
	PreSpawnDelay: number;
	clone() : AITestSpawnInfoBase;
	static C(Other: UObject | any): AITestSpawnInfoBase;
}

declare class GenericTeamId { 
	TeamID: number;
	clone() : GenericTeamId;
	static C(Other: UObject | any): GenericTeamId;
}

declare class AITestSpawnInfo extends AITestSpawnInfoBase { 
	PawnClass: UnrealEngineClass;
	ControllerClass: UnrealEngineClass;
	TeamID: GenericTeamId;
	BehaviorTree: BehaviorTree;
	clone() : AITestSpawnInfo;
	static C(Other: UObject | any): AITestSpawnInfo;
}

declare class AITestSpawnSet extends AITestSpawnSetBase { 
	SpawnInfoContainer: AITestSpawnInfo[];
	clone() : AITestSpawnSet;
	static C(Other: UObject | any): AITestSpawnSet;
}

declare class FunctionalAITest extends FunctionalAITestBase { 
	SpawnSets: AITestSpawnSet[];
	static GetDefaultObject(): FunctionalAITest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalAITest;
	static C(Other: UObject | any): FunctionalAITest;
}

declare class AutomationPerformaceHelper extends UObject { 
	static Load(ResourceName: string): AutomationPerformaceHelper;
	static Find(Outer: UObject, ResourceName: string): AutomationPerformaceHelper;
	static GetDefaultObject(): AutomationPerformaceHelper;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationPerformaceHelper;
	WriteLogFile(CaptureDir: string,CaptureExtension: string): void;
	TriggerGPUTraceIfRecordFallsBelowBudget(): void;
	Tick(DeltaSeconds: number): void;
	StopCPUProfiling(): void;
	StartCPUProfiling(): void;
	Sample(DeltaSeconds: number): void;
	OnBeginTests(): void;
	OnAllTestsComplete(): void;
	IsRecording(): boolean;
	IsCurrentRecordWithinRenderThreadBudget(): boolean;
	IsCurrentRecordWithinGPUBudget(): boolean;
	IsCurrentRecordWithinGameThreadBudget(): boolean;
	EndStatsFile(): void;
	EndRecordingBaseline(): void;
	EndRecording(): void;
	BeginStatsFile(RecordName: string): void;
	BeginRecordingBaseline(RecordName: string): void;
	BeginRecording(RecordName: string,InGPUBudget: number,InRenderThreadBudget: number,InGameThreadBudget: number): void;
	static C(Other: UObject | any): AutomationPerformaceHelper;
}

declare class FunctionalTestGameMode extends GameModeBase { 
	static GetDefaultObject(): FunctionalTestGameMode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalTestGameMode;
	static C(Other: UObject | any): FunctionalTestGameMode;
}

declare class FunctionalTestingManager extends BlueprintFunctionLibrary { 
	TestsLeft: FunctionalTest[];
	AllTests: FunctionalTest[];
	OnSetupTests: UnrealEngineMulticastDelegate<() => void>;
	OnTestsComplete: UnrealEngineMulticastDelegate<() => void>;
	OnTestsBegin: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): FunctionalTestingManager;
	static Find(Outer: UObject, ResourceName: string): FunctionalTestingManager;
	static GetDefaultObject(): FunctionalTestingManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalTestingManager;
	static RunAllFunctionalTests(WorldContextObject: UObject,bNewLog: boolean,bRunLooped: boolean,FailedTestsReproString: string): boolean;
	static C(Other: UObject | any): FunctionalTestingManager;
}

declare class PhasedAutomationActorBase extends Actor { 
	static GetDefaultObject(): PhasedAutomationActorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhasedAutomationActorBase;
	OnFunctionalTestingComplete(): void;
	OnFunctionalTestingBegin(): void;
	static C(Other: UObject | any): PhasedAutomationActorBase;
}

declare class FunctionalTestLevelScript extends LevelScriptActor { 
	static GetDefaultObject(): FunctionalTestLevelScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalTestLevelScript;
	static C(Other: UObject | any): FunctionalTestLevelScript;
}

declare class FunctionalTestUtilityLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): FunctionalTestUtilityLibrary;
	static Find(Outer: UObject, ResourceName: string): FunctionalTestUtilityLibrary;
	static GetDefaultObject(): FunctionalTestUtilityLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalTestUtilityLibrary;
	static TraceChannelTestUtil(WorldContextObject: UObject,BatchOptions: TraceChannelTestBatchOptions,Start: Vector,End: Vector,SphereCapsuleRadius: number,CapsuleHalfHeight: number,BoxHalfSize: Vector,Orientation: Rotator,TraceChannel: ETraceTypeQuery,ObjectTypes: EObjectTypeQuery[],ProfileName: string,bTraceComplex: boolean,ActorsToIgnore: Actor[],bIgnoreSelf: boolean,DrawDebugType: EDrawDebugTrace,TraceColor: LinearColor,TraceHitColor: LinearColor,DrawTime: number): TraceQueryTestResults;
	static C(Other: UObject | any): FunctionalTestUtilityLibrary;
}

declare class ScreenshotFunctionalTestBase extends FunctionalTest { 
	Notes: string;
	ScreenshotCamera: CameraComponent;
	ScreenshotOptions: AutomationScreenshotOptions;
	static GetDefaultObject(): ScreenshotFunctionalTestBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScreenshotFunctionalTestBase;
	static C(Other: UObject | any): ScreenshotFunctionalTestBase;
}

declare type EWidgetTestAppearLocation = 'Viewport' | 'PlayerScreen' | 'EWidgetTestAppearLocation_MAX';
declare var EWidgetTestAppearLocation : { Viewport:'Viewport',PlayerScreen:'PlayerScreen',EWidgetTestAppearLocation_MAX:'EWidgetTestAppearLocation_MAX', };
declare class FunctionalUIScreenshotTest extends ScreenshotFunctionalTestBase { 
	WidgetClass: UnrealEngineClass;
	SpawnedWidget: UserWidget;
	WidgetLocation: EWidgetTestAppearLocation;
	ScreenshotRT: TextureRenderTarget2D;
	bHideDebugCanvas: boolean;
	static GetDefaultObject(): FunctionalUIScreenshotTest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalUIScreenshotTest;
	static C(Other: UObject | any): FunctionalUIScreenshotTest;
}

declare class GroundTruthData extends UObject { 
	bResetGroundTruth: boolean;
	ObjectData: UObject;
	static Load(ResourceName: string): GroundTruthData;
	static Find(Outer: UObject, ResourceName: string): GroundTruthData;
	static GetDefaultObject(): GroundTruthData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GroundTruthData;
	SaveObject(GroundTruth: UObject): void;
	LoadObject(): UObject;
	CanModify(): boolean;
	static C(Other: UObject | any): GroundTruthData;
}

declare class ScreenshotFunctionalTest extends ScreenshotFunctionalTestBase { 
	bCameraCutOnScreenshotPrep: boolean;
	static GetDefaultObject(): ScreenshotFunctionalTest;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScreenshotFunctionalTest;
	static C(Other: UObject | any): ScreenshotFunctionalTest;
}

declare class TestPhaseComponent extends SceneComponent { 
	static Load(ResourceName: string): TestPhaseComponent;
	static Find(Outer: UObject, ResourceName: string): TestPhaseComponent;
	static GetDefaultObject(): TestPhaseComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestPhaseComponent;
	static C(Other: UObject | any): TestPhaseComponent;
}

declare class AIGraph extends EdGraph { 
	GraphVersion: number;
	static Load(ResourceName: string): AIGraph;
	static Find(Outer: UObject, ResourceName: string): AIGraph;
	static GetDefaultObject(): AIGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIGraph;
	static C(Other: UObject | any): AIGraph;
}

declare class GraphNodeClassData { 
	AssetName: string;
	GeneratedClassPackage: string;
	ClassName: string;
	Category: string;
	clone() : GraphNodeClassData;
	static C(Other: UObject | any): GraphNodeClassData;
}

declare class AIGraphNode extends EdGraphNode { 
	ClassData: GraphNodeClassData;
	NodeInstance: UObject;
	ParentNode: AIGraphNode;
	SubNodes: AIGraphNode[];
	CopySubNodeIndex: number;
	bIsReadOnly: boolean;
	bIsSubNode: boolean;
	ErrorMessage: string;
	static Load(ResourceName: string): AIGraphNode;
	static Find(Outer: UObject, ResourceName: string): AIGraphNode;
	static GetDefaultObject(): AIGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIGraphNode;
	static C(Other: UObject | any): AIGraphNode;
}

declare class AIGraphSchema extends EdGraphSchema { 
	static Load(ResourceName: string): AIGraphSchema;
	static Find(Outer: UObject, ResourceName: string): AIGraphSchema;
	static GetDefaultObject(): AIGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIGraphSchema;
	static C(Other: UObject | any): AIGraphSchema;
}

declare class K2Node_AIMoveTo extends K2Node_BaseAsyncTask { 
	static Load(ResourceName: string): K2Node_AIMoveTo;
	static Find(Outer: UObject, ResourceName: string): K2Node_AIMoveTo;
	static GetDefaultObject(): K2Node_AIMoveTo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_AIMoveTo;
	static C(Other: UObject | any): K2Node_AIMoveTo;
}

declare class BehaviorTreeDecoratorGraph extends EdGraph { 
	static Load(ResourceName: string): BehaviorTreeDecoratorGraph;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeDecoratorGraph;
	static GetDefaultObject(): BehaviorTreeDecoratorGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeDecoratorGraph;
	static C(Other: UObject | any): BehaviorTreeDecoratorGraph;
}

declare class BehaviorTreeDecoratorGraphNode extends EdGraphNode { 
	static Load(ResourceName: string): BehaviorTreeDecoratorGraphNode;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeDecoratorGraphNode;
	static GetDefaultObject(): BehaviorTreeDecoratorGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeDecoratorGraphNode;
	static C(Other: UObject | any): BehaviorTreeDecoratorGraphNode;
}

declare class BehaviorTreeDecoratorGraphNode_Decorator extends BehaviorTreeDecoratorGraphNode { 
	NodeInstance: UObject;
	ClassData: GraphNodeClassData;
	static Load(ResourceName: string): BehaviorTreeDecoratorGraphNode_Decorator;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeDecoratorGraphNode_Decorator;
	static GetDefaultObject(): BehaviorTreeDecoratorGraphNode_Decorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeDecoratorGraphNode_Decorator;
	static C(Other: UObject | any): BehaviorTreeDecoratorGraphNode_Decorator;
}

declare type EDecoratorLogicMode = 'Sink' | 'And' | 'Or' | 'Not' | 'EDecoratorLogicMode_MAX';
declare var EDecoratorLogicMode : { Sink:'Sink',And:'And',Or:'Or',Not:'Not',EDecoratorLogicMode_MAX:'EDecoratorLogicMode_MAX', };
declare class BehaviorTreeDecoratorGraphNode_Logic extends BehaviorTreeDecoratorGraphNode { 
	LogicMode: EDecoratorLogicMode;
	static Load(ResourceName: string): BehaviorTreeDecoratorGraphNode_Logic;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeDecoratorGraphNode_Logic;
	static GetDefaultObject(): BehaviorTreeDecoratorGraphNode_Logic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeDecoratorGraphNode_Logic;
	static C(Other: UObject | any): BehaviorTreeDecoratorGraphNode_Logic;
}

declare class BehaviorTreeEditorTypes extends UObject { 
	static Load(ResourceName: string): BehaviorTreeEditorTypes;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeEditorTypes;
	static GetDefaultObject(): BehaviorTreeEditorTypes;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeEditorTypes;
	static C(Other: UObject | any): BehaviorTreeEditorTypes;
}

declare class BehaviorTreeFactory extends Factory { 
	static Load(ResourceName: string): BehaviorTreeFactory;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeFactory;
	static GetDefaultObject(): BehaviorTreeFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeFactory;
	static C(Other: UObject | any): BehaviorTreeFactory;
}

declare class BehaviorTreeGraph extends AIGraph { 
	ModCounter: number;
	bIsUsingModCounter: boolean;
	static Load(ResourceName: string): BehaviorTreeGraph;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraph;
	static GetDefaultObject(): BehaviorTreeGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraph;
	static C(Other: UObject | any): BehaviorTreeGraph;
}

declare class BehaviorTreeGraphNode extends AIGraphNode { 
	Decorators: BehaviorTreeGraphNode[];
	Services: BehaviorTreeGraphNode[];
	bInjectedNode: boolean;
	static Load(ResourceName: string): BehaviorTreeGraphNode;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode;
	static GetDefaultObject(): BehaviorTreeGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode;
	static C(Other: UObject | any): BehaviorTreeGraphNode;
}

declare class BehaviorTreeGraphNode_Composite extends BehaviorTreeGraphNode { 
	static Load(ResourceName: string): BehaviorTreeGraphNode_Composite;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Composite;
	static GetDefaultObject(): BehaviorTreeGraphNode_Composite;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Composite;
	static C(Other: UObject | any): BehaviorTreeGraphNode_Composite;
}

declare class BehaviorTreeGraphNode_CompositeDecorator extends BehaviorTreeGraphNode { 
	BoundGraph: EdGraph;
	CompositeName: string;
	bShowOperations: boolean;
	bCanAbortFlow: boolean;
	ParentNodeInstance: BTCompositeNode;
	CachedDescription: string;
	static Load(ResourceName: string): BehaviorTreeGraphNode_CompositeDecorator;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_CompositeDecorator;
	static GetDefaultObject(): BehaviorTreeGraphNode_CompositeDecorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_CompositeDecorator;
	static C(Other: UObject | any): BehaviorTreeGraphNode_CompositeDecorator;
}

declare class BehaviorTreeGraphNode_Decorator extends BehaviorTreeGraphNode { 
	static Load(ResourceName: string): BehaviorTreeGraphNode_Decorator;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Decorator;
	static GetDefaultObject(): BehaviorTreeGraphNode_Decorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Decorator;
	static C(Other: UObject | any): BehaviorTreeGraphNode_Decorator;
}

declare class BehaviorTreeGraphNode_Root extends BehaviorTreeGraphNode { 
	BlackboardAsset: BlackboardData;
	static Load(ResourceName: string): BehaviorTreeGraphNode_Root;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Root;
	static GetDefaultObject(): BehaviorTreeGraphNode_Root;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Root;
	static C(Other: UObject | any): BehaviorTreeGraphNode_Root;
}

declare class BehaviorTreeGraphNode_Service extends BehaviorTreeGraphNode { 
	static Load(ResourceName: string): BehaviorTreeGraphNode_Service;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Service;
	static GetDefaultObject(): BehaviorTreeGraphNode_Service;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Service;
	static C(Other: UObject | any): BehaviorTreeGraphNode_Service;
}

declare class BehaviorTreeGraphNode_SimpleParallel extends BehaviorTreeGraphNode_Composite { 
	static Load(ResourceName: string): BehaviorTreeGraphNode_SimpleParallel;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_SimpleParallel;
	static GetDefaultObject(): BehaviorTreeGraphNode_SimpleParallel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_SimpleParallel;
	static C(Other: UObject | any): BehaviorTreeGraphNode_SimpleParallel;
}

declare class BehaviorTreeGraphNode_Task extends BehaviorTreeGraphNode { 
	static Load(ResourceName: string): BehaviorTreeGraphNode_Task;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Task;
	static GetDefaultObject(): BehaviorTreeGraphNode_Task;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Task;
	static C(Other: UObject | any): BehaviorTreeGraphNode_Task;
}

declare class BehaviorTreeGraphNode_SubtreeTask extends BehaviorTreeGraphNode_Task { 
	static Load(ResourceName: string): BehaviorTreeGraphNode_SubtreeTask;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_SubtreeTask;
	static GetDefaultObject(): BehaviorTreeGraphNode_SubtreeTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_SubtreeTask;
	static C(Other: UObject | any): BehaviorTreeGraphNode_SubtreeTask;
}

declare class BlackboardDataFactory extends Factory { 
	static Load(ResourceName: string): BlackboardDataFactory;
	static Find(Outer: UObject, ResourceName: string): BlackboardDataFactory;
	static GetDefaultObject(): BlackboardDataFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardDataFactory;
	static C(Other: UObject | any): BlackboardDataFactory;
}

declare class EdGraphSchema_BehaviorTree extends AIGraphSchema { 
	static Load(ResourceName: string): EdGraphSchema_BehaviorTree;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema_BehaviorTree;
	static GetDefaultObject(): EdGraphSchema_BehaviorTree;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_BehaviorTree;
	static C(Other: UObject | any): EdGraphSchema_BehaviorTree;
}

declare class EdGraphSchema_BehaviorTreeDecorator extends EdGraphSchema { 
	PC_Boolean: string;
	static Load(ResourceName: string): EdGraphSchema_BehaviorTreeDecorator;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema_BehaviorTreeDecorator;
	static GetDefaultObject(): EdGraphSchema_BehaviorTreeDecorator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_BehaviorTreeDecorator;
	static C(Other: UObject | any): EdGraphSchema_BehaviorTreeDecorator;
}

declare class K2Node_LatentGameplayTaskCall extends K2Node_BaseAsyncTask { 
	SpawnParamPins: string[];
	static Load(ResourceName: string): K2Node_LatentGameplayTaskCall;
	static Find(Outer: UObject, ResourceName: string): K2Node_LatentGameplayTaskCall;
	static GetDefaultObject(): K2Node_LatentGameplayTaskCall;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LatentGameplayTaskCall;
	static C(Other: UObject | any): K2Node_LatentGameplayTaskCall;
}

declare class Overlays extends UObject { 
	static Load(ResourceName: string): Overlays;
	static Find(Outer: UObject, ResourceName: string): Overlays;
	static GetDefaultObject(): Overlays;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Overlays;
	static C(Other: UObject | any): Overlays;
}

declare class OverlayItem { 
	StartTime: Timespan;
	EndTime: Timespan;
	text: string;
	position: Vector2D;
	clone() : OverlayItem;
	static C(Other: UObject | any): OverlayItem;
}

declare class BasicOverlays extends Overlays { 
	Overlays: OverlayItem[];
	AssetImportData: AssetImportData;
	static Load(ResourceName: string): BasicOverlays;
	static Find(Outer: UObject, ResourceName: string): BasicOverlays;
	static GetDefaultObject(): BasicOverlays;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BasicOverlays;
	static C(Other: UObject | any): BasicOverlays;
}

declare class LocalizedOverlays extends Overlays { 
	DefaultOverlays: BasicOverlays;
	LocaleToOverlaysMap: any;
	AssetImportData: AssetImportData;
	static Load(ResourceName: string): LocalizedOverlays;
	static Find(Outer: UObject, ResourceName: string): LocalizedOverlays;
	static GetDefaultObject(): LocalizedOverlays;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizedOverlays;
	static C(Other: UObject | any): LocalizedOverlays;
}

declare class BasicOverlaysFactory extends Factory { 
	static Load(ResourceName: string): BasicOverlaysFactory;
	static Find(Outer: UObject, ResourceName: string): BasicOverlaysFactory;
	static GetDefaultObject(): BasicOverlaysFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BasicOverlaysFactory;
	static C(Other: UObject | any): BasicOverlaysFactory;
}

declare class BasicOverlaysFactoryNew extends Factory { 
	static Load(ResourceName: string): BasicOverlaysFactoryNew;
	static Find(Outer: UObject, ResourceName: string): BasicOverlaysFactoryNew;
	static GetDefaultObject(): BasicOverlaysFactoryNew;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BasicOverlaysFactoryNew;
	static C(Other: UObject | any): BasicOverlaysFactoryNew;
}

declare class LocalizedOverlaysFactoryNew extends Factory { 
	static Load(ResourceName: string): LocalizedOverlaysFactoryNew;
	static Find(Outer: UObject, ResourceName: string): LocalizedOverlaysFactoryNew;
	static GetDefaultObject(): LocalizedOverlaysFactoryNew;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizedOverlaysFactoryNew;
	static C(Other: UObject | any): LocalizedOverlaysFactoryNew;
}

declare class ReimportBasicOverlaysFactory extends BasicOverlaysFactory { 
	static Load(ResourceName: string): ReimportBasicOverlaysFactory;
	static Find(Outer: UObject, ResourceName: string): ReimportBasicOverlaysFactory;
	static GetDefaultObject(): ReimportBasicOverlaysFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportBasicOverlaysFactory;
	static C(Other: UObject | any): ReimportBasicOverlaysFactory;
}

declare type EClothingWindMethodNv = 'Legacy' | 'Accurate' | 'EClothingWindMethodNv_MAX';
declare var EClothingWindMethodNv : { Legacy:'Legacy',Accurate:'Accurate',EClothingWindMethodNv_MAX:'EClothingWindMethodNv_MAX', };
declare class ClothConstraintSetupNv { 
	Stiffness: number;
	StiffnessMultiplier: number;
	StretchLimit: number;
	CompressionLimit: number;
	clone() : ClothConstraintSetupNv;
	static C(Other: UObject | any): ClothConstraintSetupNv;
}

declare class ClothConfigNv extends ClothConfigCommon { 
	ClothingWindMethod: EClothingWindMethodNv;
	VerticalConstraint: ClothConstraintSetupNv;
	HorizontalConstraint: ClothConstraintSetupNv;
	BendConstraint: ClothConstraintSetupNv;
	ShearConstraint: ClothConstraintSetupNv;
	SelfCollisionRadius: number;
	SelfCollisionStiffness: number;
	SelfCollisionCullScale: number;
	Damping: Vector;
	Friction: number;
	WindDragCoefficient: number;
	WindLiftCoefficient: number;
	LinearDrag: Vector;
	AngularDrag: Vector;
	LinearInertiaScale: Vector;
	AngularInertiaScale: Vector;
	CentrifugalInertiaScale: Vector;
	SolverFrequency: number;
	StiffnessFrequency: number;
	GravityScale: number;
	GravityOverride: Vector;
	bUseGravityOverride: boolean;
	TetherStiffness: number;
	TetherLimit: number;
	CollisionThickness: number;
	AnimDriveSpringStiffness: number;
	AnimDriveDamperStiffness: number;
	WindMethod: EClothingWindMethod_Legacy;
	VerticalConstraintConfig: ClothConstraintSetup_Legacy;
	HorizontalConstraintConfig: ClothConstraintSetup_Legacy;
	BendConstraintConfig: ClothConstraintSetup_Legacy;
	ShearConstraintConfig: ClothConstraintSetup_Legacy;
	static Load(ResourceName: string): ClothConfigNv;
	static Find(Outer: UObject, ResourceName: string): ClothConfigNv;
	static GetDefaultObject(): ClothConfigNv;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothConfigNv;
	static C(Other: UObject | any): ClothConfigNv;
}

declare class ClothingSimulationFactoryNv extends ClothingSimulationFactory { 
	static Load(ResourceName: string): ClothingSimulationFactoryNv;
	static Find(Outer: UObject, ResourceName: string): ClothingSimulationFactoryNv;
	static GetDefaultObject(): ClothingSimulationFactoryNv;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingSimulationFactoryNv;
	static C(Other: UObject | any): ClothingSimulationFactoryNv;
}

declare class ClothingSimulationInteractorNv extends ClothingSimulationInteractor { 
	static Load(ResourceName: string): ClothingSimulationInteractorNv;
	static Find(Outer: UObject, ResourceName: string): ClothingSimulationInteractorNv;
	static GetDefaultObject(): ClothingSimulationInteractorNv;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingSimulationInteractorNv;
	SetAnimDriveDamperStiffness(InStiffness: number): void;
	static C(Other: UObject | any): ClothingSimulationInteractorNv;
}

declare class ClothPhysicalMeshDataNv_Legacy extends ClothPhysicalMeshDataBase_Legacy { 
	MaxDistances: number[];
	BackstopDistances: number[];
	BackstopRadiuses: number[];
	AnimDriveMultipliers: number[];
	static Load(ResourceName: string): ClothPhysicalMeshDataNv_Legacy;
	static Find(Outer: UObject, ResourceName: string): ClothPhysicalMeshDataNv_Legacy;
	static GetDefaultObject(): ClothPhysicalMeshDataNv_Legacy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothPhysicalMeshDataNv_Legacy;
	static C(Other: UObject | any): ClothPhysicalMeshDataNv_Legacy;
}

declare class ClothingAssetFactory extends ClothingAssetFactoryBase { 
	static Load(ResourceName: string): ClothingAssetFactory;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetFactory;
	static GetDefaultObject(): ClothingAssetFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetFactory;
	static C(Other: UObject | any): ClothingAssetFactory;
}

declare class AnimDataController extends UObject { 
	Model: AnimDataModel;
	static Load(ResourceName: string): AnimDataController;
	static Find(Outer: UObject, ResourceName: string): AnimDataController;
	static GetDefaultObject(): AnimDataController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimDataController;
	static C(Other: UObject | any): AnimDataController;
}

declare class BlueprintMaterialTextureNodesBPLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): BlueprintMaterialTextureNodesBPLibrary;
	static Find(Outer: UObject, ResourceName: string): BlueprintMaterialTextureNodesBPLibrary;
	static GetDefaultObject(): BlueprintMaterialTextureNodesBPLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintMaterialTextureNodesBPLibrary;
	static UpdateMIC(MIC: MaterialInstanceConstant): void;
	static Texture2D_SampleUV_EditorOnly(Texture: Texture2D,UV: Vector2D): LinearColor;
	static SetMICVectorParam_EditorOnly(Material: MaterialInstanceConstant,ParamName: string,Value: LinearColor): boolean;
	static SetMICTwoSided_EditorOnly(Material: MaterialInstanceConstant,TwoSided: boolean): boolean;
	static SetMICTextureParam_EditorOnly(Material: MaterialInstanceConstant,ParamName: string,Texture: Texture2D): boolean;
	static SetMICShadingModel_EditorOnly(Material: MaterialInstanceConstant,ShadingModel: EMaterialShadingModel): boolean;
	static SetMICScalarParam_EditorOnly(Material: MaterialInstanceConstant,ParamName: string,Value: number): boolean;
	static SetMICDitheredLODTransition_EditorOnly(Material: MaterialInstanceConstant,DitheredLODTransition: boolean): boolean;
	static SetMICBlendMode_EditorOnly(Material: MaterialInstanceConstant,BlendMode: EBlendMode): boolean;
	static RenderTarget_SampleUV_EditorOnly(InRenderTarget: TextureRenderTarget2D,UV: Vector2D): LinearColor;
	static RenderTarget_SampleRectangle_EditorOnly(InRenderTarget: TextureRenderTarget2D,InRect: LinearColor): LinearColor[];
	static CreateMIC_EditorOnly(Material: MaterialInterface,Name: string): MaterialInstanceConstant;
	static C(Other: UObject | any): BlueprintMaterialTextureNodesBPLibrary;
}

declare class MassModuleSettings extends UObject { 
	static Load(ResourceName: string): MassModuleSettings;
	static Find(Outer: UObject, ResourceName: string): MassModuleSettings;
	static GetDefaultObject(): MassModuleSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MassModuleSettings;
	static C(Other: UObject | any): MassModuleSettings;
}

declare type EMassProcessingPhase = 'PrePhysics' | 'StartPhysics' | 'DuringPhysics' | 'EndPhysics' | 'PostPhysics' | 'FrameEnd' | 'MAX';
declare var EMassProcessingPhase : { PrePhysics:'PrePhysics',StartPhysics:'StartPhysics',DuringPhysics:'DuringPhysics',EndPhysics:'EndPhysics',PostPhysics:'PostPhysics',FrameEnd:'FrameEnd',MAX:'MAX', };
declare class MassProcessorExecutionOrder { 
	ExecuteInGroup: string;
	ExecuteBefore: string[];
	ExecuteAfter: string[];
	clone() : MassProcessorExecutionOrder;
	static C(Other: UObject | any): MassProcessorExecutionOrder;
}

declare class MassProcessor extends UObject { 
	ExecutionFlags: number;
	ProcessingPhase: EMassProcessingPhase;
	ExecutionOrder: MassProcessorExecutionOrder;
	bAutoRegisterWithProcessingPhases: boolean;
	bRequiresGameThreadExecution: boolean;
	bCanShowUpInSettings: boolean;
	static Load(ResourceName: string): MassProcessor;
	static Find(Outer: UObject, ResourceName: string): MassProcessor;
	static GetDefaultObject(): MassProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MassProcessor;
	static C(Other: UObject | any): MassProcessor;
}

declare class MassRuntimePipeline { 
	Processors: MassProcessor[];
	clone() : MassRuntimePipeline;
	static C(Other: UObject | any): MassRuntimePipeline;
}

declare class MassCompositeProcessor extends MassProcessor { 
	ChildPipeline: MassRuntimePipeline;
	GroupName: string;
	static Load(ResourceName: string): MassCompositeProcessor;
	static Find(Outer: UObject, ResourceName: string): MassCompositeProcessor;
	static GetDefaultObject(): MassCompositeProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MassCompositeProcessor;
	static C(Other: UObject | any): MassCompositeProcessor;
}

declare class MassProcessingPhaseConfig { 
	PhaseName: string;
	PhaseGroupClass: UnrealEngineClass;
	OffGameThreadGroupNames: string[];
	ProcessorCDOs: MassProcessor[];
	PhaseProcessor: MassCompositeProcessor;
	Description: string;
	clone() : MassProcessingPhaseConfig;
	static C(Other: UObject | any): MassProcessingPhaseConfig;
}

declare class MassEntitySettings extends MassModuleSettings { 
	DumpDependencyGraphFileName: string;
	ProcessingPhasesConfig: MassProcessingPhaseConfig;
	ProcessorCDOs: MassProcessor[];
	static Load(ResourceName: string): MassEntitySettings;
	static Find(Outer: UObject, ResourceName: string): MassEntitySettings;
	static GetDefaultObject(): MassEntitySettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MassEntitySettings;
	static C(Other: UObject | any): MassEntitySettings;
}

declare class ConstSharedStruct { 
	clone() : ConstSharedStruct;
	static C(Other: UObject | any): ConstSharedStruct;
}

declare class SharedStruct extends ConstSharedStruct { 
	clone() : SharedStruct;
	static C(Other: UObject | any): SharedStruct;
}

declare class MassObserversMap { 
	Container: any;
	clone() : MassObserversMap;
	static C(Other: UObject | any): MassObserversMap;
}

declare class MassObserverManager { 
	FragmentObservers: MassObserversMap;
	TagObservers: MassObserversMap;
	clone() : MassObserverManager;
	static C(Other: UObject | any): MassObserverManager;
}

declare class MassEntitySubsystem extends WorldSubsystem { 
	ConstSharedFragments: ConstSharedStruct[];
	SharedFragments: SharedStruct[];
	ObserverManager: MassObserverManager;
	static Load(ResourceName: string): MassEntitySubsystem;
	static Find(Outer: UObject, ResourceName: string): MassEntitySubsystem;
	static GetDefaultObject(): MassEntitySubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MassEntitySubsystem;
	static C(Other: UObject | any): MassEntitySubsystem;
}

declare class MassObserverProcessor extends MassProcessor { 
	ObservedType: ScriptStruct;
	static Load(ResourceName: string): MassObserverProcessor;
	static Find(Outer: UObject, ResourceName: string): MassObserverProcessor;
	static GetDefaultObject(): MassObserverProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MassObserverProcessor;
	static C(Other: UObject | any): MassObserverProcessor;
}

declare class MassEntityObserverClassesMap { 
	Container: any;
	clone() : MassEntityObserverClassesMap;
	static C(Other: UObject | any): MassEntityObserverClassesMap;
}

declare class MassObserverRegistry extends UObject { 
	FragmentObservers: MassEntityObserverClassesMap;
	TagObservers: MassEntityObserverClassesMap;
	static Load(ResourceName: string): MassObserverRegistry;
	static Find(Outer: UObject, ResourceName: string): MassObserverRegistry;
	static GetDefaultObject(): MassObserverRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MassObserverRegistry;
	static C(Other: UObject | any): MassObserverRegistry;
}

declare class MassProcessingPhase extends TickFunction { 
	PhaseProcessor: MassCompositeProcessor;
	Manager: MassProcessingPhaseManager;
	clone() : MassProcessingPhase;
	static C(Other: UObject | any): MassProcessingPhase;
}

declare class MassProcessingPhaseManager extends UObject { 
	ProcessingPhases: MassProcessingPhase;
	EntitySubsystem: MassEntitySubsystem;
	static Load(ResourceName: string): MassProcessingPhaseManager;
	static Find(Outer: UObject, ResourceName: string): MassProcessingPhaseManager;
	static GetDefaultObject(): MassProcessingPhaseManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MassProcessingPhaseManager;
	static C(Other: UObject | any): MassProcessingPhaseManager;
}

declare class MassSchematic extends DataAsset { 
	Processors: MassProcessor[];
	static Load(ResourceName: string): MassSchematic;
	static Find(Outer: UObject, ResourceName: string): MassSchematic;
	static GetDefaultObject(): MassSchematic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MassSchematic;
	static C(Other: UObject | any): MassSchematic;
}

declare class MassSettings extends DeveloperSettings { 
	ModuleSettings: any;
	static Load(ResourceName: string): MassSettings;
	static Find(Outer: UObject, ResourceName: string): MassSettings;
	static GetDefaultObject(): MassSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MassSettings;
	static C(Other: UObject | any): MassSettings;
}

declare class EdGraphSchema_EnvironmentQuery extends AIGraphSchema { 
	static Load(ResourceName: string): EdGraphSchema_EnvironmentQuery;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema_EnvironmentQuery;
	static GetDefaultObject(): EdGraphSchema_EnvironmentQuery;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_EnvironmentQuery;
	static C(Other: UObject | any): EdGraphSchema_EnvironmentQuery;
}

declare class EnvironmentQueryFactory extends Factory { 
	static Load(ResourceName: string): EnvironmentQueryFactory;
	static Find(Outer: UObject, ResourceName: string): EnvironmentQueryFactory;
	static GetDefaultObject(): EnvironmentQueryFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvironmentQueryFactory;
	static C(Other: UObject | any): EnvironmentQueryFactory;
}

declare class EnvironmentQueryGraph extends AIGraph { 
	static Load(ResourceName: string): EnvironmentQueryGraph;
	static Find(Outer: UObject, ResourceName: string): EnvironmentQueryGraph;
	static GetDefaultObject(): EnvironmentQueryGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvironmentQueryGraph;
	static C(Other: UObject | any): EnvironmentQueryGraph;
}

declare class EnvironmentQueryGraphNode extends AIGraphNode { 
	static Load(ResourceName: string): EnvironmentQueryGraphNode;
	static Find(Outer: UObject, ResourceName: string): EnvironmentQueryGraphNode;
	static GetDefaultObject(): EnvironmentQueryGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvironmentQueryGraphNode;
	static C(Other: UObject | any): EnvironmentQueryGraphNode;
}

declare class EnvironmentQueryGraphNode_Option extends EnvironmentQueryGraphNode { 
	static Load(ResourceName: string): EnvironmentQueryGraphNode_Option;
	static Find(Outer: UObject, ResourceName: string): EnvironmentQueryGraphNode_Option;
	static GetDefaultObject(): EnvironmentQueryGraphNode_Option;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvironmentQueryGraphNode_Option;
	static C(Other: UObject | any): EnvironmentQueryGraphNode_Option;
}

declare class EnvironmentQueryGraphNode_Root extends EnvironmentQueryGraphNode { 
	DebugMessages: string[];
	bHasDebugError: boolean;
	static Load(ResourceName: string): EnvironmentQueryGraphNode_Root;
	static Find(Outer: UObject, ResourceName: string): EnvironmentQueryGraphNode_Root;
	static GetDefaultObject(): EnvironmentQueryGraphNode_Root;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvironmentQueryGraphNode_Root;
	static C(Other: UObject | any): EnvironmentQueryGraphNode_Root;
}

declare class EnvironmentQueryGraphNode_Test extends EnvironmentQueryGraphNode { 
	TestWeightPct: number;
	bHasNamedWeight: boolean;
	bTestEnabled: boolean;
	static Load(ResourceName: string): EnvironmentQueryGraphNode_Test;
	static Find(Outer: UObject, ResourceName: string): EnvironmentQueryGraphNode_Test;
	static GetDefaultObject(): EnvironmentQueryGraphNode_Test;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnvironmentQueryGraphNode_Test;
	static C(Other: UObject | any): EnvironmentQueryGraphNode_Test;
}

declare class CameraAnimationSequenceSubsystem extends WorldSubsystem { 
	Linker: MovieSceneEntitySystemLinker;
	static Load(ResourceName: string): CameraAnimationSequenceSubsystem;
	static Find(Outer: UObject, ResourceName: string): CameraAnimationSequenceSubsystem;
	static GetDefaultObject(): CameraAnimationSequenceSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnimationSequenceSubsystem;
	static C(Other: UObject | any): CameraAnimationSequenceSubsystem;
}

declare class SequenceCameraShakeTestUtil extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): SequenceCameraShakeTestUtil;
	static Find(Outer: UObject, ResourceName: string): SequenceCameraShakeTestUtil;
	static GetDefaultObject(): SequenceCameraShakeTestUtil;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceCameraShakeTestUtil;
	static GetPostProcessBlendCache(PlayerController: PlayerController,PPIndex: number,OutPPSettings?: PostProcessSettings,OutPPBlendWeight?: number): {OutPPSettings: PostProcessSettings, OutPPBlendWeight: number, $: boolean};
	static GetLastFrameCameraCachePOV(PlayerController: PlayerController): MinimalViewInfo;
	static GetCameraCachePOV(PlayerController: PlayerController): MinimalViewInfo;
	static C(Other: UObject | any): SequenceCameraShakeTestUtil;
}

declare class TemplateSequencePlayer extends MovieSceneSequencePlayer { 
	static Load(ResourceName: string): TemplateSequencePlayer;
	static Find(Outer: UObject, ResourceName: string): TemplateSequencePlayer;
	static GetDefaultObject(): TemplateSequencePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateSequencePlayer;
	static CreateTemplateSequencePlayer(WorldContextObject: UObject,TemplateSequence: TemplateSequence,Settings: MovieSceneSequencePlaybackSettings,OutActor?: TemplateSequenceActor): {OutActor: TemplateSequenceActor, $: TemplateSequencePlayer};
	static C(Other: UObject | any): TemplateSequencePlayer;
}

declare class TemplateSequenceBindingOverrideData { 
	UObject: any;
	bOverridesDefault: boolean;
	clone() : TemplateSequenceBindingOverrideData;
	static C(Other: UObject | any): TemplateSequenceBindingOverrideData;
}

declare class TemplateSequenceActor extends Actor { 
	PlaybackSettings: MovieSceneSequencePlaybackSettings;
	SequencePlayer: TemplateSequencePlayer;
	TemplateSequence: SoftObjectPath;
	BindingOverride: TemplateSequenceBindingOverrideData;
	static GetDefaultObject(): TemplateSequenceActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateSequenceActor;
	SetSequence(InSequence: TemplateSequence): void;
	SetBinding(Actor: Actor,bOverridesDefault: boolean): void;
	LoadSequence(): TemplateSequence;
	GetSequencePlayer(): TemplateSequencePlayer;
	GetSequence(): TemplateSequence;
	static C(Other: UObject | any): TemplateSequenceActor;
}

declare type ETemplateSectionPropertyScaleType = 'FloatProperty' | 'TransformPropertyLocationOnly' | 'TransformPropertyRotationOnly' | 'ETemplateSectionPropertyScaleType_MAX';
declare var ETemplateSectionPropertyScaleType : { FloatProperty:'FloatProperty',TransformPropertyLocationOnly:'TransformPropertyLocationOnly',TransformPropertyRotationOnly:'TransformPropertyRotationOnly',ETemplateSectionPropertyScaleType_MAX:'ETemplateSectionPropertyScaleType_MAX', };
declare class TemplateSectionPropertyScale { 
	ObjectBinding: Guid;
	PropertyBinding: MovieScenePropertyBinding;
	PropertyScaleType: ETemplateSectionPropertyScaleType;
	FloatChannel: MovieSceneFloatChannel;
	clone() : TemplateSectionPropertyScale;
	static C(Other: UObject | any): TemplateSectionPropertyScale;
}

declare class TemplateSequenceSection extends MovieSceneSubSection { 
	PropertyScales: TemplateSectionPropertyScale[];
	static Load(ResourceName: string): TemplateSequenceSection;
	static Find(Outer: UObject, ResourceName: string): TemplateSequenceSection;
	static GetDefaultObject(): TemplateSequenceSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateSequenceSection;
	static C(Other: UObject | any): TemplateSequenceSection;
}

declare class TemplateSequenceSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): TemplateSequenceSystem;
	static Find(Outer: UObject, ResourceName: string): TemplateSequenceSystem;
	static GetDefaultObject(): TemplateSequenceSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateSequenceSystem;
	static C(Other: UObject | any): TemplateSequenceSystem;
}

declare class TemplateSequencePropertyScalingInstantiatorSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): TemplateSequencePropertyScalingInstantiatorSystem;
	static Find(Outer: UObject, ResourceName: string): TemplateSequencePropertyScalingInstantiatorSystem;
	static GetDefaultObject(): TemplateSequencePropertyScalingInstantiatorSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateSequencePropertyScalingInstantiatorSystem;
	static C(Other: UObject | any): TemplateSequencePropertyScalingInstantiatorSystem;
}

declare class TemplateSequencePropertyScalingEvaluatorSystem extends MovieSceneEntitySystem { 
	static Load(ResourceName: string): TemplateSequencePropertyScalingEvaluatorSystem;
	static Find(Outer: UObject, ResourceName: string): TemplateSequencePropertyScalingEvaluatorSystem;
	static GetDefaultObject(): TemplateSequencePropertyScalingEvaluatorSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateSequencePropertyScalingEvaluatorSystem;
	static C(Other: UObject | any): TemplateSequencePropertyScalingEvaluatorSystem;
}

declare class TemplateSequenceTrack extends MovieSceneSubTrack { 
	static Load(ResourceName: string): TemplateSequenceTrack;
	static Find(Outer: UObject, ResourceName: string): TemplateSequenceTrack;
	static GetDefaultObject(): TemplateSequenceTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateSequenceTrack;
	static C(Other: UObject | any): TemplateSequenceTrack;
}

declare type ECameraAnimationEasingType = 'Linear' | 'Sinusoidal' | 'Quadratic' | 'Cubic' | 'Quartic' | 'Quintic' | 'Exponential' | 'Circular' | 'ECameraAnimationEasingType_MAX';
declare var ECameraAnimationEasingType : { Linear:'Linear',Sinusoidal:'Sinusoidal',Quadratic:'Quadratic',Cubic:'Cubic',Quartic:'Quartic',Quintic:'Quintic',Exponential:'Exponential',Circular:'Circular',ECameraAnimationEasingType_MAX:'ECameraAnimationEasingType_MAX', };
declare type ECameraAnimationPlaySpace = 'CameraLocal' | 'World' | 'UserDefined' | 'ECameraAnimationPlaySpace_MAX';
declare var ECameraAnimationPlaySpace : { CameraLocal:'CameraLocal',World:'World',UserDefined:'UserDefined',ECameraAnimationPlaySpace_MAX:'ECameraAnimationPlaySpace_MAX', };
declare class CameraAnimationParams { 
	PlayRate: number;
	Scale: number;
	EaseInType: ECameraAnimationEasingType;
	EaseInDuration: number;
	EaseOutType: ECameraAnimationEasingType;
	EaseOutDuration: number;
	bLoop: boolean;
	bRandomStartTime: boolean;
	DurationOverride: number;
	PlaySpace: ECameraAnimationPlaySpace;
	UserPlaySpaceRot: Rotator;
	clone() : CameraAnimationParams;
	static C(Other: UObject | any): CameraAnimationParams;
}

declare class CameraAnimationHandle { 
	clone() : CameraAnimationHandle;
	static C(Other: UObject | any): CameraAnimationHandle;
}

declare class ActiveCameraAnimationInfo { 
	Sequence: CameraAnimationSequence;
	Params: CameraAnimationParams;
	Handle: CameraAnimationHandle;
	Player: CameraAnimationSequencePlayer;
	CameraStandIn: CameraAnimationSequenceCameraStandIn;
	EaseInCurrentTime: number;
	EaseOutCurrentTime: number;
	bIsEasingIn: boolean;
	bIsEasingOut: boolean;
	clone() : ActiveCameraAnimationInfo;
	static C(Other: UObject | any): ActiveCameraAnimationInfo;
}

declare class CameraAnimationCameraModifier extends CameraModifier { 
	ActiveAnimations: ActiveCameraAnimationInfo[];
	InstanceSerialNumber: any;
	static Load(ResourceName: string): CameraAnimationCameraModifier;
	static Find(Outer: UObject, ResourceName: string): CameraAnimationCameraModifier;
	static GetDefaultObject(): CameraAnimationCameraModifier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnimationCameraModifier;
	StopCameraAnimation(Handle: CameraAnimationHandle,bImmediate: boolean): void;
	StopAllCameraAnimationsOf(Sequence: CameraAnimationSequence,bImmediate: boolean): void;
	StopAllCameraAnimations(bImmediate: boolean): void;
	PlayCameraAnimation(Sequence: CameraAnimationSequence,Params: CameraAnimationParams): CameraAnimationHandle;
	IsCameraAnimationActive(Handle: CameraAnimationHandle): boolean;
	static GetCameraAnimationCameraModifierFromPlayerController(PlayerController: PlayerController): CameraAnimationCameraModifier;
	static GetCameraAnimationCameraModifierFromID(WorldContextObject: UObject,ControllerId: number): CameraAnimationCameraModifier;
	static GetCameraAnimationCameraModifier(WorldContextObject: UObject,PlayerIndex: number): CameraAnimationCameraModifier;
	static C(Other: UObject | any): CameraAnimationCameraModifier;
}

declare class TestCameraShake extends CameraShakeBase { 
	static Load(ResourceName: string): TestCameraShake;
	static Find(Outer: UObject, ResourceName: string): TestCameraShake;
	static GetDefaultObject(): TestCameraShake;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestCameraShake;
	static C(Other: UObject | any): TestCameraShake;
}

declare class SimpleCameraShakePattern extends CameraShakePattern { 
	Duration: number;
	BlendInTime: number;
	BlendOutTime: number;
	static Load(ResourceName: string): SimpleCameraShakePattern;
	static Find(Outer: UObject, ResourceName: string): SimpleCameraShakePattern;
	static GetDefaultObject(): SimpleCameraShakePattern;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SimpleCameraShakePattern;
	static C(Other: UObject | any): SimpleCameraShakePattern;
}

declare class ConstantCameraShakePattern extends SimpleCameraShakePattern { 
	LocationOffset: Vector;
	RotationOffset: Rotator;
	static Load(ResourceName: string): ConstantCameraShakePattern;
	static Find(Outer: UObject, ResourceName: string): ConstantCameraShakePattern;
	static GetDefaultObject(): ConstantCameraShakePattern;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConstantCameraShakePattern;
	static C(Other: UObject | any): ConstantCameraShakePattern;
}

declare class CompositeCameraShakePattern extends CameraShakePattern { 
	ChildPatterns: CameraShakePattern[];
	static Load(ResourceName: string): CompositeCameraShakePattern;
	static Find(Outer: UObject, ResourceName: string): CompositeCameraShakePattern;
	static GetDefaultObject(): CompositeCameraShakePattern;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompositeCameraShakePattern;
	static C(Other: UObject | any): CompositeCameraShakePattern;
}

declare class DefaultCameraShakeBase extends CameraShakeBase { 
	static Load(ResourceName: string): DefaultCameraShakeBase;
	static Find(Outer: UObject, ResourceName: string): DefaultCameraShakeBase;
	static GetDefaultObject(): DefaultCameraShakeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultCameraShakeBase;
	static C(Other: UObject | any): DefaultCameraShakeBase;
}

declare class MatineeCameraShakePattern extends CameraShakePattern { 
	static Load(ResourceName: string): MatineeCameraShakePattern;
	static Find(Outer: UObject, ResourceName: string): MatineeCameraShakePattern;
	static GetDefaultObject(): MatineeCameraShakePattern;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeCameraShakePattern;
	static C(Other: UObject | any): MatineeCameraShakePattern;
}

declare class MovieSceneMatineeCameraShakeEvaluator extends MovieSceneCameraShakeEvaluator { 
	static Load(ResourceName: string): MovieSceneMatineeCameraShakeEvaluator;
	static Find(Outer: UObject, ResourceName: string): MovieSceneMatineeCameraShakeEvaluator;
	static GetDefaultObject(): MovieSceneMatineeCameraShakeEvaluator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneMatineeCameraShakeEvaluator;
	static C(Other: UObject | any): MovieSceneMatineeCameraShakeEvaluator;
}

declare class MatineeCameraShakeFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): MatineeCameraShakeFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): MatineeCameraShakeFunctionLibrary;
	static GetDefaultObject(): MatineeCameraShakeFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeCameraShakeFunctionLibrary;
	static Conv_MatineeCameraShake(CameraShake: CameraShakeBase): MatineeCameraShake;
	static C(Other: UObject | any): MatineeCameraShakeFunctionLibrary;
}

declare class PerlinNoiseShaker { 
	Amplitude: number;
	Frequency: number;
	clone() : PerlinNoiseShaker;
	static C(Other: UObject | any): PerlinNoiseShaker;
}

declare class PerlinNoiseCameraShakePattern extends SimpleCameraShakePattern { 
	LocationAmplitudeMultiplier: number;
	LocationFrequencyMultiplier: number;
	X: PerlinNoiseShaker;
	Y: PerlinNoiseShaker;
	Z: PerlinNoiseShaker;
	RotationAmplitudeMultiplier: number;
	RotationFrequencyMultiplier: number;
	Pitch: PerlinNoiseShaker;
	Yaw: PerlinNoiseShaker;
	Roll: PerlinNoiseShaker;
	FOV: PerlinNoiseShaker;
	static Load(ResourceName: string): PerlinNoiseCameraShakePattern;
	static Find(Outer: UObject, ResourceName: string): PerlinNoiseCameraShakePattern;
	static GetDefaultObject(): PerlinNoiseCameraShakePattern;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PerlinNoiseCameraShakePattern;
	static C(Other: UObject | any): PerlinNoiseCameraShakePattern;
}

declare type EInitialWaveOscillatorOffsetType = 'Random' | 'Zero' | 'EInitialWaveOscillatorOffsetType_MAX';
declare var EInitialWaveOscillatorOffsetType : { Random:'Random',Zero:'Zero',EInitialWaveOscillatorOffsetType_MAX:'EInitialWaveOscillatorOffsetType_MAX', };
declare class WaveOscillator { 
	Amplitude: number;
	Frequency: number;
	InitialOffsetType: EInitialWaveOscillatorOffsetType;
	clone() : WaveOscillator;
	static C(Other: UObject | any): WaveOscillator;
}

declare class WaveOscillatorCameraShakePattern extends SimpleCameraShakePattern { 
	LocationAmplitudeMultiplier: number;
	LocationFrequencyMultiplier: number;
	X: WaveOscillator;
	Y: WaveOscillator;
	Z: WaveOscillator;
	RotationAmplitudeMultiplier: number;
	RotationFrequencyMultiplier: number;
	Pitch: WaveOscillator;
	Yaw: WaveOscillator;
	Roll: WaveOscillator;
	FOV: WaveOscillator;
	static Load(ResourceName: string): WaveOscillatorCameraShakePattern;
	static Find(Outer: UObject, ResourceName: string): WaveOscillatorCameraShakePattern;
	static GetDefaultObject(): WaveOscillatorCameraShakePattern;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaveOscillatorCameraShakePattern;
	static C(Other: UObject | any): WaveOscillatorCameraShakePattern;
}

declare class SignificanceManager extends UObject { 
	SignificanceManagerClassName: SoftClassPath;
	static Load(ResourceName: string): SignificanceManager;
	static Find(Outer: UObject, ResourceName: string): SignificanceManager;
	static GetDefaultObject(): SignificanceManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SignificanceManager;
	static C(Other: UObject | any): SignificanceManager;
}

declare class AnimationSharingStateProcessor extends UObject { 
	AnimationStateEnum: Enum;
	static Load(ResourceName: string): AnimationSharingStateProcessor;
	static Find(Outer: UObject, ResourceName: string): AnimationSharingStateProcessor;
	static GetDefaultObject(): AnimationSharingStateProcessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationSharingStateProcessor;
	ProcessActorState(OutState?: number,InActor?: Actor,CurrentState?: number,OnDemandState?: number,bShouldProcess?: boolean): {OutState: number, bShouldProcess: boolean};
	GetAnimationStateEnum(): Enum;
	static C(Other: UObject | any): AnimationSharingStateProcessor;
}

declare class AnimSharingInstance extends UObject { 
	RegisteredActors: Actor[];
	StateProcessor: AnimationSharingStateProcessor;
	UsedAnimationSequences: AnimSequence[];
	StateEnum: Enum;
	SharingActor: Actor;
	static Load(ResourceName: string): AnimSharingInstance;
	static Find(Outer: UObject, ResourceName: string): AnimSharingInstance;
	static GetDefaultObject(): AnimSharingInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSharingInstance;
	static C(Other: UObject | any): AnimSharingInstance;
}

declare class AnimSharingStateInstance extends AnimInstance { 
	AnimationToPlay: AnimSequence;
	PermutationTimeOffset: number;
	PlayRate: number;
	bStateBool: boolean;
	Instance: AnimSharingInstance;
	static Load(ResourceName: string): AnimSharingStateInstance;
	static Find(Outer: UObject, ResourceName: string): AnimSharingStateInstance;
	static GetDefaultObject(): AnimSharingStateInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSharingStateInstance;
	GetInstancedActors(Actors?: Actor[]): {Actors: Actor[]};
	static C(Other: UObject | any): AnimSharingStateInstance;
}

declare class AnimSharingTransitionInstance extends AnimInstance { 
	FromComponent: any;
	ToComponent: any;
	BlendTime: number;
	bBlendBool: boolean;
	static Load(ResourceName: string): AnimSharingTransitionInstance;
	static Find(Outer: UObject, ResourceName: string): AnimSharingTransitionInstance;
	static GetDefaultObject(): AnimSharingTransitionInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSharingTransitionInstance;
	static C(Other: UObject | any): AnimSharingTransitionInstance;
}

declare class AnimSharingAdditiveInstance extends AnimInstance { 
	BaseComponent: any;
	AdditiveAnimation: any;
	Alpha: number;
	bStateBool: boolean;
	static Load(ResourceName: string): AnimSharingAdditiveInstance;
	static Find(Outer: UObject, ResourceName: string): AnimSharingAdditiveInstance;
	static GetDefaultObject(): AnimSharingAdditiveInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSharingAdditiveInstance;
	static C(Other: UObject | any): AnimSharingAdditiveInstance;
}

declare class AnimationSetup { 
	AnimSequence: AnimSequence;
	AnimBlueprint: UnrealEngineClass;
	NumRandomizedInstances: PerPlatformInt;
	Enabled: PerPlatformBool;
	clone() : AnimationSetup;
	static C(Other: UObject | any): AnimationSetup;
}

declare class AnimationStateEntry { 
	State: number;
	AnimationSetups: AnimationSetup[];
	bOnDemand: boolean;
	bAdditive: boolean;
	BlendTime: number;
	bReturnToPreviousState: boolean;
	bSetNextState: boolean;
	NextState: number;
	MaximumNumberOfConcurrentInstances: PerPlatformInt;
	WiggleTimePercentage: number;
	bRequiresCurves: boolean;
	clone() : AnimationStateEntry;
	static C(Other: UObject | any): AnimationStateEntry;
}

declare class PerSkeletonAnimationSharingSetup { 
	Skeleton: Skeleton;
	SkeletalMesh: SkeletalMesh;
	BlendAnimBlueprint: UnrealEngineClass;
	AdditiveAnimBlueprint: UnrealEngineClass;
	StateProcessorClass: UnrealEngineClass;
	AnimationStates: AnimationStateEntry[];
	clone() : PerSkeletonAnimationSharingSetup;
	static C(Other: UObject | any): PerSkeletonAnimationSharingSetup;
}

declare class AnimationSharingScalability { 
	UseBlendTransitions: PerPlatformBool;
	BlendSignificanceValue: PerPlatformFloat;
	MaximumNumberConcurrentBlends: PerPlatformInt;
	TickSignificanceValue: PerPlatformFloat;
	clone() : AnimationSharingScalability;
	static C(Other: UObject | any): AnimationSharingScalability;
}

declare class AnimationSharingSetup extends UObject { 
	SkeletonSetups: PerSkeletonAnimationSharingSetup[];
	ScalabilitySettings: AnimationSharingScalability;
	static Load(ResourceName: string): AnimationSharingSetup;
	static Find(Outer: UObject, ResourceName: string): AnimationSharingSetup;
	static GetDefaultObject(): AnimationSharingSetup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationSharingSetup;
	static C(Other: UObject | any): AnimationSharingSetup;
}

declare class AnimationSharingManager extends UObject { 
	Skeletons: Skeleton[];
	PerSkeletonData: AnimSharingInstance[];
	static Load(ResourceName: string): AnimationSharingManager;
	static Find(Outer: UObject, ResourceName: string): AnimationSharingManager;
	static GetDefaultObject(): AnimationSharingManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationSharingManager;
	RegisterActorWithSkeletonBP(InActor: Actor,SharingSkeleton: Skeleton): void;
	static GetAnimationSharingManager(WorldContextObject: UObject): AnimationSharingManager;
	static CreateAnimationSharingManager(WorldContextObject: UObject,Setup: AnimationSharingSetup): boolean;
	static AnimationSharingEnabled(): boolean;
	static C(Other: UObject | any): AnimationSharingManager;
}

declare class K2Node_PropertyAccess extends K2Node { 
	Path: string[];
	TextPath: string;
	ResolvedPinType: EdGraphPinType;
	GeneratedPropertyName: string;
	ContextId: string;
	static Load(ResourceName: string): K2Node_PropertyAccess;
	static Find(Outer: UObject, ResourceName: string): K2Node_PropertyAccess;
	static GetDefaultObject(): K2Node_PropertyAccess;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_PropertyAccess;
	static C(Other: UObject | any): K2Node_PropertyAccess;
}

declare class FilterData { 
	Name: string;
	AllowlistedNames: string[];
	clone() : FilterData;
	static C(Other: UObject | any): FilterData;
}

declare class LocalFilterPresetContainer extends UObject { 
	UserPresets: FilterData[];
	static Load(ResourceName: string): LocalFilterPresetContainer;
	static Find(Outer: UObject, ResourceName: string): LocalFilterPresetContainer;
	static GetDefaultObject(): LocalFilterPresetContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalFilterPresetContainer;
	static C(Other: UObject | any): LocalFilterPresetContainer;
}

declare class SharedFilterPresetContainer extends UObject { 
	SharedPresets: FilterData[];
	static Load(ResourceName: string): SharedFilterPresetContainer;
	static Find(Outer: UObject, ResourceName: string): SharedFilterPresetContainer;
	static GetDefaultObject(): SharedFilterPresetContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SharedFilterPresetContainer;
	static C(Other: UObject | any): SharedFilterPresetContainer;
}

declare class EngineFilterPresetContainer extends UObject { 
	EnginePresets: FilterData[];
	static Load(ResourceName: string): EngineFilterPresetContainer;
	static Find(Outer: UObject, ResourceName: string): EngineFilterPresetContainer;
	static GetDefaultObject(): EngineFilterPresetContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EngineFilterPresetContainer;
	static C(Other: UObject | any): EngineFilterPresetContainer;
}

declare class EdGraphNode_Reference extends EdGraphNode { 
	static Load(ResourceName: string): EdGraphNode_Reference;
	static Find(Outer: UObject, ResourceName: string): EdGraphNode_Reference;
	static GetDefaultObject(): EdGraphNode_Reference;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphNode_Reference;
	static C(Other: UObject | any): EdGraphNode_Reference;
}

declare class EdGraph_ReferenceViewer extends EdGraph { 
	static Load(ResourceName: string): EdGraph_ReferenceViewer;
	static Find(Outer: UObject, ResourceName: string): EdGraph_ReferenceViewer;
	static GetDefaultObject(): EdGraph_ReferenceViewer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraph_ReferenceViewer;
	static C(Other: UObject | any): EdGraph_ReferenceViewer;
}

declare class ReferenceViewerSchema extends EdGraphSchema { 
	static Load(ResourceName: string): ReferenceViewerSchema;
	static Find(Outer: UObject, ResourceName: string): ReferenceViewerSchema;
	static GetDefaultObject(): ReferenceViewerSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReferenceViewerSchema;
	static C(Other: UObject | any): ReferenceViewerSchema;
}

declare class UndoHistorySettings extends UObject { 
	bShowTransactionDetails: boolean;
	static Load(ResourceName: string): UndoHistorySettings;
	static Find(Outer: UObject, ResourceName: string): UndoHistorySettings;
	static GetDefaultObject(): UndoHistorySettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UndoHistorySettings;
	static C(Other: UObject | any): UndoHistorySettings;
}

declare class LevelAssetEditor extends AssetEditor { 
	static Load(ResourceName: string): LevelAssetEditor;
	static Find(Outer: UObject, ResourceName: string): LevelAssetEditor;
	static GetDefaultObject(): LevelAssetEditor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelAssetEditor;
	static C(Other: UObject | any): LevelAssetEditor;
}

declare class PixelInspectorView extends UObject { 
	FinalColor: LinearColor;
	SceneColor: LinearColor;
	PreExposure: number;
	Luminance: number;
	HdrColor: LinearColor;
	Normal: Vector;
	PerObjectGBufferData: number;
	Metallic: number;
	Specular: number;
	Roughness: number;
	MaterialShadingModel: EMaterialShadingModel;
	SelectiveOutputMask: number;
	BaseColor: LinearColor;
	IndirectIrradiance: number;
	AmbientOcclusion: number;
	SubsurfaceColor: LinearColor;
	SubsurfaceProfile: Vector;
	Opacity: number;
	ClearCoat: number;
	ClearCoatRoughness: number;
	WorldNormal: Vector;
	Backlit: number;
	Cloth: number;
	EyeTangent: Vector;
	IrisMask: number;
	IrisDistance: number;
	static Load(ResourceName: string): PixelInspectorView;
	static Find(Outer: UObject, ResourceName: string): PixelInspectorView;
	static GetDefaultObject(): PixelInspectorView;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PixelInspectorView;
	static C(Other: UObject | any): PixelInspectorView;
}

declare class EditorUtilityObject extends UObject { 
	static Load(ResourceName: string): EditorUtilityObject;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityObject;
	static GetDefaultObject(): EditorUtilityObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityObject;
	Run(): void;
	static C(Other: UObject | any): EditorUtilityObject;
}

declare class ActorActionUtility extends EditorUtilityObject { 
	static Load(ResourceName: string): ActorActionUtility;
	static Find(Outer: UObject, ResourceName: string): ActorActionUtility;
	static GetDefaultObject(): ActorActionUtility;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorActionUtility;
	GetSupportedClass(): UnrealEngineClass;
	static C(Other: UObject | any): ActorActionUtility;
}

declare class AssetActionUtility extends EditorUtilityObject { 
	static Load(ResourceName: string): AssetActionUtility;
	static Find(Outer: UObject, ResourceName: string): AssetActionUtility;
	static GetDefaultObject(): AssetActionUtility;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetActionUtility;
	IsActionForBlueprints(): boolean;
	GetSupportedClass(): UnrealEngineClass;
	static C(Other: UObject | any): AssetActionUtility;
}

declare class AsyncCaptureScene extends BlueprintAsyncActionBase { 
	Complete: UnrealEngineMulticastDelegate<(Texture: TextureRenderTarget2D) => void>;
	SceneCapture: SceneCapture2D;
	SceneCaptureRT: TextureRenderTarget2D;
	static Load(ResourceName: string): AsyncCaptureScene;
	static Find(Outer: UObject, ResourceName: string): AsyncCaptureScene;
	static GetDefaultObject(): AsyncCaptureScene;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncCaptureScene;
	static CaptureSceneAsync(ViewCamera: CameraComponent,SceneCaptureClass: UnrealEngineClass,ResX: number,ResY: number): AsyncCaptureScene;
	static C(Other: UObject | any): AsyncCaptureScene;
}

declare class AsyncImageExport extends BlueprintAsyncActionBase { 
	Complete: UnrealEngineMulticastDelegate<(bSuccess: boolean) => void>;
	TextureToExport: Texture;
	Quality: number;
	TargetFile: string;
	static Load(ResourceName: string): AsyncImageExport;
	static Find(Outer: UObject, ResourceName: string): AsyncImageExport;
	static GetDefaultObject(): AsyncImageExport;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncImageExport;
	static ExportImageAsync(Texture: Texture,OutputFile: string,Quality: number): AsyncImageExport;
	static C(Other: UObject | any): AsyncImageExport;
}

declare class EditorUtilityWidget extends UserWidget { 
	HelpText: string;
	bAlwaysReregisterWithWindowsMenu: boolean;
	bAutoRunDefaultAction: boolean;
	static Load(ResourceName: string): EditorUtilityWidget;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityWidget;
	static GetDefaultObject(): EditorUtilityWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityWidget;
	Run(): void;
	static C(Other: UObject | any): EditorUtilityWidget;
}

declare class EditorUtilityWidgetBlueprint extends WidgetBlueprint { 
	CreatedUMGWidget: EditorUtilityWidget;
	static Load(ResourceName: string): EditorUtilityWidgetBlueprint;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityWidgetBlueprint;
	static GetDefaultObject(): EditorUtilityWidgetBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityWidgetBlueprint;
	static C(Other: UObject | any): EditorUtilityWidgetBlueprint;
}

declare class EditorUtilitySubsystem extends EditorSubsystem { 
	LoadedUIs: SoftObjectPath[];
	StartupObjects: SoftObjectPath[];
	OnBeginPIE: UnrealEngineMulticastDelegate<(bIsSimulating: boolean) => void>;
	OnEndPIE: UnrealEngineMulticastDelegate<(bIsSimulating: boolean) => void>;
	ObjectInstances: any;
	ActiveTaskStack: EditorUtilityTask[];
	ReferencedObjects: any;
	static Load(ResourceName: string): EditorUtilitySubsystem;
	static Find(Outer: UObject, ResourceName: string): EditorUtilitySubsystem;
	static GetDefaultObject(): EditorUtilitySubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilitySubsystem;
	TryRun(Asset: UObject): boolean;
	SpawnRegisteredTabByID(NewTabID: string): boolean;
	SpawnAndRegisterTabAndGetID(InBlueprint: EditorUtilityWidgetBlueprint,NewTabID?: string): {NewTabID: string, $: EditorUtilityWidget};
	SpawnAndRegisterTab(InBlueprint: EditorUtilityWidgetBlueprint): EditorUtilityWidget;
	ReleaseInstanceOfAsset(Asset: UObject): void;
	RegisterTabAndGetID(InBlueprint: EditorUtilityWidgetBlueprint,NewTabID?: string): {NewTabID: string};
	RegisterAndExecuteTask(NewTask: EditorUtilityTask,OptionalParentTask: EditorUtilityTask): void;
	FindUtilityWidgetFromBlueprint(InBlueprint: EditorUtilityWidgetBlueprint): EditorUtilityWidget;
	DoesTabExist(NewTabID: string): boolean;
	CloseTabByID(NewTabID: string): boolean;
	CanRun(Asset: UObject): boolean;
	static C(Other: UObject | any): EditorUtilitySubsystem;
}

declare class EditorUtilityTask extends UObject { 
	MyTaskManager: EditorUtilitySubsystem;
	MyParentTask: EditorUtilityTask;
	bCancelRequested: boolean;
	static Load(ResourceName: string): EditorUtilityTask;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityTask;
	static GetDefaultObject(): EditorUtilityTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityTask;
	WasCancelRequested(): boolean;
	SetTaskNotificationText(text: string): void;
	Run(): void;
	ReceiveCancelRequested(): void;
	ReceiveBeginExecution(): void;
	FinishExecutingTask(): void;
	static C(Other: UObject | any): EditorUtilityTask;
}

declare class AsyncRegisterAndExecuteTask extends BlueprintAsyncActionBase { 
	OnFinished: UnrealEngineMulticastDelegate<(Task: EditorUtilityTask) => void>;
	static Load(ResourceName: string): AsyncRegisterAndExecuteTask;
	static Find(Outer: UObject, ResourceName: string): AsyncRegisterAndExecuteTask;
	static GetDefaultObject(): AsyncRegisterAndExecuteTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncRegisterAndExecuteTask;
	static RegisterAndExecuteTask(Task: EditorUtilityTask,OptionalParentTask: EditorUtilityTask): AsyncRegisterAndExecuteTask;
	static C(Other: UObject | any): AsyncRegisterAndExecuteTask;
}

declare class EditorUtilityExtension extends Interface { 
	static Load(ResourceName: string): EditorUtilityExtension;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityExtension;
	static GetDefaultObject(): EditorUtilityExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityExtension;
	static C(Other: UObject | any): EditorUtilityExtension;
}

declare class EditorUtilityActor extends Actor { 
	static GetDefaultObject(): EditorUtilityActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityActor;
	Run(): void;
	static C(Other: UObject | any): EditorUtilityActor;
}

declare class EditorUtilityActorComponent extends ActorComponent { 
	static Load(ResourceName: string): EditorUtilityActorComponent;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityActorComponent;
	static GetDefaultObject(): EditorUtilityActorComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityActorComponent;
	static C(Other: UObject | any): EditorUtilityActorComponent;
}

declare class EditorUtilityBlueprint extends Blueprint { 
	static Load(ResourceName: string): EditorUtilityBlueprint;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityBlueprint;
	static GetDefaultObject(): EditorUtilityBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityBlueprint;
	static C(Other: UObject | any): EditorUtilityBlueprint;
}

declare class EditorUtilityBlueprintFactory extends Factory { 
	ParentClass: UnrealEngineClass;
	static Load(ResourceName: string): EditorUtilityBlueprintFactory;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityBlueprintFactory;
	static GetDefaultObject(): EditorUtilityBlueprintFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityBlueprintFactory;
	static C(Other: UObject | any): EditorUtilityBlueprintFactory;
}

declare class EditorUtilityCamera extends CameraActor { 
	static GetDefaultObject(): EditorUtilityCamera;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityCamera;
	static C(Other: UObject | any): EditorUtilityCamera;
}

declare class EditorUtilityBlueprintAsyncActionBase extends BlueprintAsyncActionBase { 
	static Load(ResourceName: string): EditorUtilityBlueprintAsyncActionBase;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityBlueprintAsyncActionBase;
	static GetDefaultObject(): EditorUtilityBlueprintAsyncActionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityBlueprintAsyncActionBase;
	static C(Other: UObject | any): EditorUtilityBlueprintAsyncActionBase;
}

declare class AsyncEditorDelay extends EditorUtilityBlueprintAsyncActionBase { 
	Complete: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AsyncEditorDelay;
	static Find(Outer: UObject, ResourceName: string): AsyncEditorDelay;
	static GetDefaultObject(): AsyncEditorDelay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncEditorDelay;
	static AsyncEditorDelay(Seconds: number,MinimumFrames: number): AsyncEditorDelay;
	static C(Other: UObject | any): AsyncEditorDelay;
}

declare class AsyncEditorWaitForGameWorld extends EditorUtilityBlueprintAsyncActionBase { 
	Complete: UnrealEngineMulticastDelegate<(World: World) => void>;
	static Load(ResourceName: string): AsyncEditorWaitForGameWorld;
	static Find(Outer: UObject, ResourceName: string): AsyncEditorWaitForGameWorld;
	static GetDefaultObject(): AsyncEditorWaitForGameWorld;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncEditorWaitForGameWorld;
	static AsyncWaitForGameWorld(index: number,Server: boolean): AsyncEditorWaitForGameWorld;
	static C(Other: UObject | any): AsyncEditorWaitForGameWorld;
}

declare class AsyncEditorOpenMapAndFocusActor extends EditorUtilityBlueprintAsyncActionBase { 
	Complete: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AsyncEditorOpenMapAndFocusActor;
	static Find(Outer: UObject, ResourceName: string): AsyncEditorOpenMapAndFocusActor;
	static GetDefaultObject(): AsyncEditorOpenMapAndFocusActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AsyncEditorOpenMapAndFocusActor;
	static AsyncEditorOpenMapAndFocusActor(Map: SoftObjectPath,FocusActorName: string): AsyncEditorOpenMapAndFocusActor;
	static C(Other: UObject | any): AsyncEditorOpenMapAndFocusActor;
}

declare class EditorUtilityLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): EditorUtilityLibrary;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityLibrary;
	static GetDefaultObject(): EditorUtilityLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityLibrary;
	static RenameAsset(Asset: UObject,NewName: string): void;
	static GetSelectionSet(): Actor[];
	static GetSelectionBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static GetSelectedBlueprintClasses(): UnrealEngineClass[];
	static GetSelectedAssets(): UObject[];
	static GetSelectedAssetData(): AssetData[];
	static GetCurrentContentBrowserPath(OutPath?: string): {OutPath: string, $: boolean};
	GetActorReference(PathToActor: string): Actor;
	static C(Other: UObject | any): EditorUtilityLibrary;
}

declare class EditorUtilityToolMenuEntry extends ToolMenuEntryScript { 
	static Load(ResourceName: string): EditorUtilityToolMenuEntry;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityToolMenuEntry;
	static GetDefaultObject(): EditorUtilityToolMenuEntry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityToolMenuEntry;
	static C(Other: UObject | any): EditorUtilityToolMenuEntry;
}

declare class EditorUtilityToolMenuSection extends ToolMenuSectionDynamic { 
	static Load(ResourceName: string): EditorUtilityToolMenuSection;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityToolMenuSection;
	static GetDefaultObject(): EditorUtilityToolMenuSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityToolMenuSection;
	static C(Other: UObject | any): EditorUtilityToolMenuSection;
}

declare class EditorUtilityWidgetBlueprintFactory extends Factory { 
	BlueprintType: EBlueprintType;
	ParentClass: UnrealEngineClass;
	static Load(ResourceName: string): EditorUtilityWidgetBlueprintFactory;
	static Find(Outer: UObject, ResourceName: string): EditorUtilityWidgetBlueprintFactory;
	static GetDefaultObject(): EditorUtilityWidgetBlueprintFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorUtilityWidgetBlueprintFactory;
	static C(Other: UObject | any): EditorUtilityWidgetBlueprintFactory;
}

declare class GlobalEditorUtilityBase extends UObject { 
	HelpText: string;
	bDirtiedSelectionSet: boolean;
	bAutoRunDefaultAction: boolean;
	OnEachSelectedActor: UnrealEngineMulticastDelegate<(Actor: Actor, index: number) => void>;
	OnEachSelectedAsset: UnrealEngineMulticastDelegate<(Asset: UObject, index: number) => void>;
	static Load(ResourceName: string): GlobalEditorUtilityBase;
	static Find(Outer: UObject, ResourceName: string): GlobalEditorUtilityBase;
	static GetDefaultObject(): GlobalEditorUtilityBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GlobalEditorUtilityBase;
	SetActorSelectionState(Actor: Actor,bShouldBeSelected: boolean): void;
	SelectNothing(): void;
	RenameAsset(Asset: UObject,NewName: string): void;
	OnDefaultActionClicked(): void;
	GetSelectionSet(): Actor[];
	GetSelectionBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	GetSelectedAssets(): UObject[];
	GetEditorUserSettings(): EditorPerProjectUserSettings;
	GetActorReference(PathToActor: string): Actor;
	ForEachSelectedAsset(): void;
	ForEachSelectedActor(): void;
	ClearActorSelectionSet(): void;
	static C(Other: UObject | any): GlobalEditorUtilityBase;
}

declare class PlacedEditorUtilityBase extends Actor { 
	HelpText: string;
	static GetDefaultObject(): PlacedEditorUtilityBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlacedEditorUtilityBase;
	SetLevelViewportCameraInfo(CameraLocation: Vector,CameraRotation: Rotator): void;
	SetActorSelectionState(Actor: Actor,bShouldBeSelected: boolean): void;
	SelectNothing(): void;
	GetSelectionSet(): Actor[];
	GetLevelViewportCameraInfo(CameraLocation?: Vector,CameraRotation?: Rotator): {CameraLocation: Vector, CameraRotation: Rotator, $: boolean};
	GetActorReference(PathToActor: string): Actor;
	ClearActorSelectionSet(): void;
	static C(Other: UObject | any): PlacedEditorUtilityBase;
}

declare class DataValidationChangelist extends UObject { 
	static Load(ResourceName: string): DataValidationChangelist;
	static Find(Outer: UObject, ResourceName: string): DataValidationChangelist;
	static GetDefaultObject(): DataValidationChangelist;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataValidationChangelist;
	static C(Other: UObject | any): DataValidationChangelist;
}

declare class DataValidationCommandlet extends Commandlet { 
	static Load(ResourceName: string): DataValidationCommandlet;
	static Find(Outer: UObject, ResourceName: string): DataValidationCommandlet;
	static GetDefaultObject(): DataValidationCommandlet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataValidationCommandlet;
	static C(Other: UObject | any): DataValidationCommandlet;
}

declare class DataValidationManager extends UObject { 
	ExcludedDirectories: DirectoryPath[];
	bValidateOnSave: boolean;
	DataValidationManagerClassName: SoftClassPath;
	static Load(ResourceName: string): DataValidationManager;
	static Find(Outer: UObject, ResourceName: string): DataValidationManager;
	static GetDefaultObject(): DataValidationManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataValidationManager;
	static C(Other: UObject | any): DataValidationManager;
}

declare type EDataValidationResult = 'Invalid' | 'Valid' | 'NotValidated' | 'EDataValidationResult_MAX';
declare var EDataValidationResult : { Invalid:'Invalid',Valid:'Valid',NotValidated:'NotValidated',EDataValidationResult_MAX:'EDataValidationResult_MAX', };
declare type EDataValidationUsecase = 'None' | 'Manual' | 'Commandlet' | 'Save' | 'PreSubmit' | 'Script' | 'EDataValidationUsecase_MAX';
declare var EDataValidationUsecase : { None:'None',Manual:'Manual',Commandlet:'Commandlet',Save:'Save',PreSubmit:'PreSubmit',Script:'Script',EDataValidationUsecase_MAX:'EDataValidationUsecase_MAX', };
declare class EditorValidatorBase extends UObject { 
	bIsEnabled: boolean;
	static Load(ResourceName: string): EditorValidatorBase;
	static Find(Outer: UObject, ResourceName: string): EditorValidatorBase;
	static GetDefaultObject(): EditorValidatorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorValidatorBase;
	ValidateLoadedAsset(InAsset: UObject,ValidationErrors?: string[]): {ValidationErrors: string[], $: EDataValidationResult};
	GetValidationResult(): EDataValidationResult;
	CanValidateAsset(InAsset: UObject): boolean;
	CanValidate(InUsecase: EDataValidationUsecase): boolean;
	AssetWarning(InAsset: UObject,InMessage: string): void;
	AssetPasses(InAsset: UObject): void;
	AssetFails(InAsset: UObject,InMessage: string,ValidationErrors?: string[]): {ValidationErrors: string[]};
	static C(Other: UObject | any): EditorValidatorBase;
}

declare class DirtyFilesChangelistValidator extends EditorValidatorBase { 
	static Load(ResourceName: string): DirtyFilesChangelistValidator;
	static Find(Outer: UObject, ResourceName: string): DirtyFilesChangelistValidator;
	static GetDefaultObject(): DirtyFilesChangelistValidator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DirtyFilesChangelistValidator;
	static C(Other: UObject | any): DirtyFilesChangelistValidator;
}

declare class DataValidationSettings extends UObject { 
	bValidateOnSave: boolean;
	static Load(ResourceName: string): DataValidationSettings;
	static Find(Outer: UObject, ResourceName: string): DataValidationSettings;
	static GetDefaultObject(): DataValidationSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataValidationSettings;
	static C(Other: UObject | any): DataValidationSettings;
}

declare class ValidateAssetsSettings { 
	bSkipExcludedDirectories: boolean;
	bShowIfNoFailures: boolean;
	ValidationUsecase: EDataValidationUsecase;
	clone() : ValidateAssetsSettings;
	static C(Other: UObject | any): ValidateAssetsSettings;
}

declare class ValidateAssetsResults { 
	NumChecked: number;
	NumValid: number;
	NumInvalid: number;
	NumSkipped: number;
	NumWarnings: number;
	NumUnableToValidate: number;
	clone() : ValidateAssetsResults;
	static C(Other: UObject | any): ValidateAssetsResults;
}

declare class EditorValidatorSubsystem extends EditorSubsystem { 
	ExcludedDirectories: DirectoryPath[];
	bValidateOnSave: boolean;
	Validators: any;
	bValidateAssetsWhileSavingForCook: boolean;
	bAllowBlueprintValidators: boolean;
	static Load(ResourceName: string): EditorValidatorSubsystem;
	static Find(Outer: UObject, ResourceName: string): EditorValidatorSubsystem;
	static GetDefaultObject(): EditorValidatorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorValidatorSubsystem;
	ValidateAssetsWithSettings(AssetDataList: AssetData[],InSettings: ValidateAssetsSettings,OutResults?: ValidateAssetsResults): {OutResults: ValidateAssetsResults, $: number};
	ValidateAssets(AssetDataList: AssetData[],bSkipExcludedDirectories: boolean,bShowIfNoFailures: boolean): number;
	IsObjectValid(InObject: UObject,ValidationErrors?: string[],ValidationWarnings?: string[],InValidationUsecase?: EDataValidationUsecase): {ValidationErrors: string[], ValidationWarnings: string[], $: EDataValidationResult};
	IsAssetValid(AssetData: AssetData,ValidationErrors?: string[],ValidationWarnings?: string[],InValidationUsecase?: EDataValidationUsecase): {ValidationErrors: string[], ValidationWarnings: string[], $: EDataValidationResult};
	AddValidator(InValidator: EditorValidatorBase): void;
	static C(Other: UObject | any): EditorValidatorSubsystem;
}

declare class EditorValidator_Localization extends EditorValidatorBase { 
	static Load(ResourceName: string): EditorValidator_Localization;
	static Find(Outer: UObject, ResourceName: string): EditorValidator_Localization;
	static GetDefaultObject(): EditorValidator_Localization;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorValidator_Localization;
	static C(Other: UObject | any): EditorValidator_Localization;
}

declare class UncontrolledChangelistValidator extends EditorValidatorBase { 
	static Load(ResourceName: string): UncontrolledChangelistValidator;
	static Find(Outer: UObject, ResourceName: string): UncontrolledChangelistValidator;
	static GetDefaultObject(): UncontrolledChangelistValidator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UncontrolledChangelistValidator;
	static C(Other: UObject | any): UncontrolledChangelistValidator;
}

declare class WorldPartitionChangelistValidator extends EditorValidatorBase { 
	static Load(ResourceName: string): WorldPartitionChangelistValidator;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionChangelistValidator;
	static GetDefaultObject(): WorldPartitionChangelistValidator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionChangelistValidator;
	static C(Other: UObject | any): WorldPartitionChangelistValidator;
}

declare class AudioCurveSourceComponent extends AudioComponent { 
	CurveSourceBindingName: string;
	CurveSyncOffset: number;
	static Load(ResourceName: string): AudioCurveSourceComponent;
	static Find(Outer: UObject, ResourceName: string): AudioCurveSourceComponent;
	static GetDefaultObject(): AudioCurveSourceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioCurveSourceComponent;
	static C(Other: UObject | any): AudioCurveSourceComponent;
}

declare class FacialAnimationBulkImporterSettings extends UObject { 
	SourceImportPath: DirectoryPath;
	TargetImportPath: DirectoryPath;
	CurveNodeName: string;
	static Load(ResourceName: string): FacialAnimationBulkImporterSettings;
	static Find(Outer: UObject, ResourceName: string): FacialAnimationBulkImporterSettings;
	static GetDefaultObject(): FacialAnimationBulkImporterSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FacialAnimationBulkImporterSettings;
	static C(Other: UObject | any): FacialAnimationBulkImporterSettings;
}

declare class GameplayTagSearchFilter extends ContentBrowserFrontEndFilterExtension { 
	static Load(ResourceName: string): GameplayTagSearchFilter;
	static Find(Outer: UObject, ResourceName: string): GameplayTagSearchFilter;
	static GetDefaultObject(): GameplayTagSearchFilter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagSearchFilter;
	static C(Other: UObject | any): GameplayTagSearchFilter;
}

declare class GameplayTagsK2Node_LiteralGameplayTag extends K2Node { 
	static Load(ResourceName: string): GameplayTagsK2Node_LiteralGameplayTag;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_LiteralGameplayTag;
	static GetDefaultObject(): GameplayTagsK2Node_LiteralGameplayTag;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_LiteralGameplayTag;
	static C(Other: UObject | any): GameplayTagsK2Node_LiteralGameplayTag;
}

declare class GameplayTagsK2Node_MultiCompareBase extends K2Node { 
	NumberOfPins: number;
	PinNames: string[];
	static Load(ResourceName: string): GameplayTagsK2Node_MultiCompareBase;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_MultiCompareBase;
	static GetDefaultObject(): GameplayTagsK2Node_MultiCompareBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_MultiCompareBase;
	static C(Other: UObject | any): GameplayTagsK2Node_MultiCompareBase;
}

declare class GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface extends GameplayTagsK2Node_MultiCompareBase { 
	static Load(ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
	static GetDefaultObject(): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
	static C(Other: UObject | any): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
}

declare class GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags extends GameplayTagsK2Node_MultiCompareBase { 
	static Load(ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
	static GetDefaultObject(): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
	static C(Other: UObject | any): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
}

declare class GameplayTagsK2Node_MultiCompareGameplayTagContainer extends GameplayTagsK2Node_MultiCompareBase { 
	static Load(ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
	static GetDefaultObject(): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
	static C(Other: UObject | any): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
}

declare class GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags extends GameplayTagsK2Node_MultiCompareBase { 
	static Load(ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
	static GetDefaultObject(): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
	static C(Other: UObject | any): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
}

declare class GameplayTagsK2Node_SwitchGameplayTag extends K2Node_Switch { 
	PinTags: GameplayTag[];
	PinNames: string[];
	static Load(ResourceName: string): GameplayTagsK2Node_SwitchGameplayTag;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_SwitchGameplayTag;
	static GetDefaultObject(): GameplayTagsK2Node_SwitchGameplayTag;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_SwitchGameplayTag;
	static C(Other: UObject | any): GameplayTagsK2Node_SwitchGameplayTag;
}

declare class GameplayTagsK2Node_SwitchGameplayTagContainer extends K2Node_Switch { 
	PinContainers: GameplayTagContainer[];
	PinNames: string[];
	static Load(ResourceName: string): GameplayTagsK2Node_SwitchGameplayTagContainer;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_SwitchGameplayTagContainer;
	static GetDefaultObject(): GameplayTagsK2Node_SwitchGameplayTagContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_SwitchGameplayTagContainer;
	static C(Other: UObject | any): GameplayTagsK2Node_SwitchGameplayTagContainer;
}

declare type EChaosCollisionSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByHighestSpeed' | 'SortByHighestImpulse' | 'SortByNearestFirst' | 'Count' | 'EChaosCollisionSortMethod_MAX';
declare var EChaosCollisionSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByHighestSpeed:'SortByHighestSpeed',SortByHighestImpulse:'SortByHighestImpulse',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosCollisionSortMethod_MAX:'EChaosCollisionSortMethod_MAX', };
declare class ChaosCollisionEventRequestSettings { 
	MaxNumberResults: number;
	MinMass: number;
	MinSpeed: number;
	MinImpulse: number;
	MaxDistance: number;
	SortMethod: EChaosCollisionSortMethod;
	clone() : ChaosCollisionEventRequestSettings;
	static C(Other: UObject | any): ChaosCollisionEventRequestSettings;
}

declare type EChaosBreakingSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByHighestSpeed' | 'SortByNearestFirst' | 'Count' | 'EChaosBreakingSortMethod_MAX';
declare var EChaosBreakingSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByHighestSpeed:'SortByHighestSpeed',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosBreakingSortMethod_MAX:'EChaosBreakingSortMethod_MAX', };
declare class ChaosBreakingEventRequestSettings { 
	MaxNumberOfResults: number;
	MinRadius: number;
	MinSpeed: number;
	MinMass: number;
	MaxDistance: number;
	SortMethod: EChaosBreakingSortMethod;
	clone() : ChaosBreakingEventRequestSettings;
	static C(Other: UObject | any): ChaosBreakingEventRequestSettings;
}

declare type EChaosTrailingSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByHighestSpeed' | 'SortByNearestFirst' | 'Count' | 'EChaosTrailingSortMethod_MAX';
declare var EChaosTrailingSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByHighestSpeed:'SortByHighestSpeed',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosTrailingSortMethod_MAX:'EChaosTrailingSortMethod_MAX', };
declare class ChaosTrailingEventRequestSettings { 
	MaxNumberOfResults: number;
	MinMass: number;
	MinSpeed: number;
	MinAngularSpeed: number;
	MaxDistance: number;
	SortMethod: EChaosTrailingSortMethod;
	clone() : ChaosTrailingEventRequestSettings;
	static C(Other: UObject | any): ChaosTrailingEventRequestSettings;
}

declare type EChaosRemovalSortMethod = 'SortNone' | 'SortByHighestMass' | 'SortByNearestFirst' | 'Count' | 'EChaosRemovalSortMethod_MAX';
declare var EChaosRemovalSortMethod : { SortNone:'SortNone',SortByHighestMass:'SortByHighestMass',SortByNearestFirst:'SortByNearestFirst',Count:'Count',EChaosRemovalSortMethod_MAX:'EChaosRemovalSortMethod_MAX', };
declare class ChaosRemovalEventRequestSettings { 
	MaxNumberOfResults: number;
	MinMass: number;
	MaxDistance: number;
	SortMethod: EChaosRemovalSortMethod;
	clone() : ChaosRemovalEventRequestSettings;
	static C(Other: UObject | any): ChaosRemovalEventRequestSettings;
}

declare class ChaosCollisionEventData { 
	Location: Vector;
	Normal: Vector;
	Velocity1: Vector;
	Velocity2: Vector;
	Mass1: number;
	Mass2: number;
	Impulse: Vector;
	clone() : ChaosCollisionEventData;
	static C(Other: UObject | any): ChaosCollisionEventData;
}

declare class ChaosBreakingEventData { 
	Location: Vector;
	Velocity: Vector;
	Mass: number;
	clone() : ChaosBreakingEventData;
	static C(Other: UObject | any): ChaosBreakingEventData;
}

declare class ChaosTrailingEventData { 
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	ParticleIndex: number;
	clone() : ChaosTrailingEventData;
	static C(Other: UObject | any): ChaosTrailingEventData;
}

declare class ChaosRemovalEventData { 
	Location: Vector;
	Mass: number;
	ParticleIndex: number;
	clone() : ChaosRemovalEventData;
	static C(Other: UObject | any): ChaosRemovalEventData;
}

declare class GeometryCollectionSource { 
	SourceGeometryObject: SoftObjectPath;
	LocalTransform: Transform;
	SourceMaterial: MaterialInterface[];
	clone() : GeometryCollectionSource;
	static C(Other: UObject | any): GeometryCollectionSource;
}

declare class GeometryCollectionEmbeddedExemplar { 
	StaticMeshExemplar: SoftObjectPath;
	StartCullDistance: number;
	EndCullDistance: number;
	InstanceCount: number;
	clone() : GeometryCollectionEmbeddedExemplar;
	static C(Other: UObject | any): GeometryCollectionEmbeddedExemplar;
}

declare type ECollisionTypeEnum = 'Chaos_Volumetric' | 'Chaos_Surface_Volumetric' | 'Chaos_Max';
declare var ECollisionTypeEnum : { Chaos_Volumetric:'Chaos_Volumetric',Chaos_Surface_Volumetric:'Chaos_Surface_Volumetric',Chaos_Max:'Chaos_Max', };
declare type EImplicitTypeEnum = 'Chaos_Implicit_Box' | 'Chaos_Implicit_Sphere' | 'Chaos_Implicit_Capsule' | 'Chaos_Implicit_LevelSet' | 'Chaos_Implicit_None' | 'Chaos_Implicit_Convex' | 'Chaos_Max';
declare var EImplicitTypeEnum : { Chaos_Implicit_Box:'Chaos_Implicit_Box',Chaos_Implicit_Sphere:'Chaos_Implicit_Sphere',Chaos_Implicit_Capsule:'Chaos_Implicit_Capsule',Chaos_Implicit_LevelSet:'Chaos_Implicit_LevelSet',Chaos_Implicit_None:'Chaos_Implicit_None',Chaos_Implicit_Convex:'Chaos_Implicit_Convex',Chaos_Max:'Chaos_Max', };
declare class GeometryCollectionLevelSetData { 
	MinLevelSetResolution: number;
	MaxLevelSetResolution: number;
	MinClusterLevelSetResolution: number;
	MaxClusterLevelSetResolution: number;
	clone() : GeometryCollectionLevelSetData;
	static C(Other: UObject | any): GeometryCollectionLevelSetData;
}

declare class GeometryCollectionCollisionParticleData { 
	CollisionParticlesFraction: number;
	MaximumCollisionParticles: number;
	clone() : GeometryCollectionCollisionParticleData;
	static C(Other: UObject | any): GeometryCollectionCollisionParticleData;
}

declare class GeometryCollectionCollisionTypeData { 
	CollisionType: ECollisionTypeEnum;
	ImplicitType: EImplicitTypeEnum;
	LevelSet: GeometryCollectionLevelSetData;
	CollisionParticles: GeometryCollectionCollisionParticleData;
	CollisionObjectReductionPercentage: number;
	CollisionMarginFraction: number;
	clone() : GeometryCollectionCollisionTypeData;
	static C(Other: UObject | any): GeometryCollectionCollisionTypeData;
}

declare class GeometryCollectionSizeSpecificData { 
	MaxSize: number;
	CollisionShapes: GeometryCollectionCollisionTypeData[];
	CollisionType: ECollisionTypeEnum;
	ImplicitType: EImplicitTypeEnum;
	MinLevelSetResolution: number;
	MaxLevelSetResolution: number;
	MinClusterLevelSetResolution: number;
	MaxClusterLevelSetResolution: number;
	CollisionObjectReductionPercentage: number;
	CollisionParticlesFraction: number;
	MaximumCollisionParticles: number;
	DamageThreshold: number;
	clone() : GeometryCollectionSizeSpecificData;
	static C(Other: UObject | any): GeometryCollectionSizeSpecificData;
}

declare class GeometryCollection extends UObject { 
	EnableClustering: boolean;
	ClusterGroupIndex: number;
	MaxClusterLevel: number;
	DamageThreshold: number[];
	ClusterConnectionType: EClusterConnectionTypeEnum;
	GeometrySource: GeometryCollectionSource[];
	Materials: MaterialInterface[];
	EmbeddedGeometryExemplar: GeometryCollectionEmbeddedExemplar[];
	bUseFullPrecisionUVs: boolean;
	bStripOnCook: boolean;
	EnableNanite: boolean;
	CollisionType: ECollisionTypeEnum;
	ImplicitType: EImplicitTypeEnum;
	MinLevelSetResolution: number;
	MaxLevelSetResolution: number;
	MinClusterLevelSetResolution: number;
	MaxClusterLevelSetResolution: number;
	CollisionObjectReductionPercentage: number;
	bMassAsDensity: boolean;
	Mass: number;
	MinimumMassClamp: number;
	CollisionParticlesFraction: number;
	MaximumCollisionParticles: number;
	bRemoveOnMaxSleep: boolean;
	MaximumSleepTime: Vector2D;
	RemovalDuration: Vector2D;
	SizeSpecificData: GeometryCollectionSizeSpecificData[];
	EnableRemovePiecesOnFracture: boolean;
	RemoveOnFractureMaterials: MaterialInterface[];
	ThumbnailInfo: ThumbnailInfo;
	PersistentGuid: Guid;
	StateGuid: Guid;
	BoneSelectedMaterialIndex: number;
	static Load(ResourceName: string): GeometryCollection;
	static Find(Outer: UObject, ResourceName: string): GeometryCollection;
	static GetDefaultObject(): GeometryCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollection;
	static C(Other: UObject | any): GeometryCollection;
}

declare type EObjectStateTypeEnum = 'Chaos_NONE' | 'Chaos_Object_Sleeping' | 'Chaos_Object_Kinematic' | 'Chaos_Object_Static' | 'Chaos_Object_Dynamic' | 'Chaos_Object_UserDefined' | 'Chaos_Max';
declare var EObjectStateTypeEnum : { Chaos_NONE:'Chaos_NONE',Chaos_Object_Sleeping:'Chaos_Object_Sleeping',Chaos_Object_Kinematic:'Chaos_Object_Kinematic',Chaos_Object_Static:'Chaos_Object_Static',Chaos_Object_Dynamic:'Chaos_Object_Dynamic',Chaos_Object_UserDefined:'Chaos_Object_UserDefined',Chaos_Max:'Chaos_Max', };
declare type EInitialVelocityTypeEnum = 'Chaos_Initial_Velocity_User_Defined' | 'Chaos_Initial_Velocity_None' | 'Chaos_Max';
declare var EInitialVelocityTypeEnum : { Chaos_Initial_Velocity_User_Defined:'Chaos_Initial_Velocity_User_Defined',Chaos_Initial_Velocity_None:'Chaos_Initial_Velocity_None',Chaos_Max:'Chaos_Max', };
declare type EGeometryCollectionCacheType = 'None' | 'Record' | 'Play' | 'RecordAndPlay' | 'EGeometryCollectionCacheType_MAX';
declare var EGeometryCollectionCacheType : { None:'None',Record:'Record',Play:'Play',RecordAndPlay:'RecordAndPlay',EGeometryCollectionCacheType_MAX:'EGeometryCollectionCacheType_MAX', };
declare class SolverCollisionData { 
	Location: Vector;
	AccumulatedImpulse: Vector;
	Normal: Vector;
	Velocity1: Vector;
	Velocity2: Vector;
	AngularVelocity1: Vector;
	AngularVelocity2: Vector;
	Mass1: number;
	Mass2: number;
	ParticleIndex: number;
	LevelsetIndex: number;
	ParticleIndexMesh: number;
	LevelsetIndexMesh: number;
	clone() : SolverCollisionData;
	static C(Other: UObject | any): SolverCollisionData;
}

declare class SolverBreakingData { 
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	ParticleIndex: number;
	ParticleIndexMesh: number;
	clone() : SolverBreakingData;
	static C(Other: UObject | any): SolverBreakingData;
}

declare class RecordedFrame { 
	Transforms: Transform[];
	TransformIndices: number[];
	PreviousTransformIndices: number[];
	DisabledFlags: boolean[];
	Collisions: SolverCollisionData[];
	Breakings: SolverBreakingData[];
	Trailings: any;
	Timestamp: number;
	clone() : RecordedFrame;
	static C(Other: UObject | any): RecordedFrame;
}

declare class RecordedTransformTrack { 
	Records: RecordedFrame[];
	clone() : RecordedTransformTrack;
	static C(Other: UObject | any): RecordedTransformTrack;
}

declare class GeometryCollectionCache extends UObject { 
	RecordedData: RecordedTransformTrack;
	SupportedCollection: GeometryCollection;
	CompatibleCollectionState: Guid;
	static Load(ResourceName: string): GeometryCollectionCache;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionCache;
	static GetDefaultObject(): GeometryCollectionCache;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionCache;
	static C(Other: UObject | any): GeometryCollectionCache;
}

declare class GeomComponentCacheParameters { 
	CacheMode: EGeometryCollectionCacheType;
	TargetCache: GeometryCollectionCache;
	ReverseCacheBeginTime: number;
	SaveCollisionData: boolean;
	DoGenerateCollisionData: boolean;
	CollisionDataSizeMax: number;
	DoCollisionDataSpatialHash: boolean;
	CollisionDataSpatialHashRadius: number;
	MaxCollisionPerCell: number;
	SaveBreakingData: boolean;
	DoGenerateBreakingData: boolean;
	BreakingDataSizeMax: number;
	DoBreakingDataSpatialHash: boolean;
	BreakingDataSpatialHashRadius: number;
	MaxBreakingPerCell: number;
	SaveTrailingData: boolean;
	DoGenerateTrailingData: boolean;
	TrailingDataSizeMax: number;
	TrailingMinSpeedThreshold: number;
	TrailingMinVolumeThreshold: number;
	clone() : GeomComponentCacheParameters;
	static C(Other: UObject | any): GeomComponentCacheParameters;
}

declare class ChaosBreakEvent { 
	Component: PrimitiveComponent;
	Location: Vector;
	Velocity: Vector;
	AngularVelocity: Vector;
	Mass: number;
	clone() : ChaosBreakEvent;
	static C(Other: UObject | any): ChaosBreakEvent;
}

declare class ChaosRemovalEvent { 
	Component: PrimitiveComponent;
	Location: Vector;
	Mass: number;
	clone() : ChaosRemovalEvent;
	static C(Other: UObject | any): ChaosRemovalEvent;
}

declare class GeometryCollectionRepData { 
	clone() : GeometryCollectionRepData;
	static C(Other: UObject | any): GeometryCollectionRepData;
}

declare type EGeometryCollectionPhysicsTypeEnum = 'Chaos_AngularVelocity' | 'Chaos_DynamicState' | 'Chaos_LinearVelocity' | 'Chaos_InitialAngularVelocity' | 'Chaos_InitialLinearVelocity' | 'Chaos_CollisionGroup' | 'Chaos_LinearForce' | 'Chaos_AngularTorque' | 'Chaos_DisableThreshold' | 'Chaos_SleepingThreshold' | 'Chaos_Max';
declare var EGeometryCollectionPhysicsTypeEnum : { Chaos_AngularVelocity:'Chaos_AngularVelocity',Chaos_DynamicState:'Chaos_DynamicState',Chaos_LinearVelocity:'Chaos_LinearVelocity',Chaos_InitialAngularVelocity:'Chaos_InitialAngularVelocity',Chaos_InitialLinearVelocity:'Chaos_InitialLinearVelocity',Chaos_CollisionGroup:'Chaos_CollisionGroup',Chaos_LinearForce:'Chaos_LinearForce',Chaos_AngularTorque:'Chaos_AngularTorque',Chaos_DisableThreshold:'Chaos_DisableThreshold',Chaos_SleepingThreshold:'Chaos_SleepingThreshold',Chaos_Max:'Chaos_Max', };
declare class GeometryCollectionComponent extends MeshComponent { 
	ChaosSolverActor: ChaosSolverActor;
	RestCollection: GeometryCollection;
	InitializationFields: FieldSystemActor[];
	Simulating: boolean;
	ObjectType: EObjectStateTypeEnum;
	bForceMotionBlur: boolean;
	EnableClustering: boolean;
	ClusterGroupIndex: number;
	MaxClusterLevel: number;
	DamageThreshold: number[];
	bUseSizeSpecificDamageThreshold: boolean;
	ClusterConnectionType: EClusterConnectionTypeEnum;
	CollisionGroup: number;
	CollisionSampleFraction: number;
	LinearEtherDrag: number;
	AngularEtherDrag: number;
	PhysicalMaterial: ChaosPhysicalMaterial;
	InitialVelocityType: EInitialVelocityTypeEnum;
	InitialLinearVelocity: Vector;
	InitialAngularVelocity: Vector;
	PhysicalMaterialOverride: PhysicalMaterial;
	CacheParameters: GeomComponentCacheParameters;
	RestTransforms: Transform[];
	NotifyGeometryCollectionPhysicsStateChange: UnrealEngineMulticastDelegate<(FracturedComponent: GeometryCollectionComponent) => void>;
	NotifyGeometryCollectionPhysicsLoadingStateChange: UnrealEngineMulticastDelegate<(FracturedComponent: GeometryCollectionComponent) => void>;
	OnChaosBreakEvent: UnrealEngineMulticastDelegate<(BreakEvent: ChaosBreakEvent) => void>;
	OnChaosRemovalEvent: UnrealEngineMulticastDelegate<(RemovalEvent: ChaosRemovalEvent) => void>;
	DesiredCacheTime: number;
	CachePlayback: boolean;
	OnChaosPhysicsCollision: UnrealEngineMulticastDelegate<(CollisionInfo: ChaosPhysicsCollisionInfo) => void>;
	bNotifyBreaks: boolean;
	bNotifyCollisions: boolean;
	bNotifyTrailing: boolean;
	bNotifyRemovals: boolean;
	bStoreVelocities: boolean;
	bShowBoneColors: boolean;
	bEnableReplication: boolean;
	bEnableAbandonAfterLevel: boolean;
	ReplicationAbandonClusterLevel: number;
	RepData: GeometryCollectionRepData;
	SelectedBones: number[];
	HighlightedBones: number[];
	DummyBodySetup: BodySetup;
	EditorActor: Actor;
	EmbeddedGeometryComponents: InstancedStaticMeshComponent[];
	static Load(ResourceName: string): GeometryCollectionComponent;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionComponent;
	static GetDefaultObject(): GeometryCollectionComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionComponent;
	SetNotifyRemovals(bNewNotifyRemovals: boolean): void;
	SetNotifyBreaks(bNewNotifyBreaks: boolean): void;
	ReceivePhysicsCollision(CollisionInfo: ChaosPhysicsCollisionInfo): void;
	OnRep_RepData(OldData: GeometryCollectionRepData): void;
	NetAbandonCluster(TransformIndex: number): void;
	ApplyPhysicsField(Enabled: boolean,Target: EGeometryCollectionPhysicsTypeEnum,MetaData: FieldSystemMetaData,Field: FieldNodeBase): void;
	ApplyKinematicField(Radius: number,position: Vector): void;
	static C(Other: UObject | any): GeometryCollectionComponent;
}

declare class GeometryCollectionDebugDrawWarningMessage { 
	clone() : GeometryCollectionDebugDrawWarningMessage;
	static C(Other: UObject | any): GeometryCollectionDebugDrawWarningMessage;
}

declare class GeometryCollectionDebugDrawActorSelectedRigidBody { 
	ID: number;
	Solver: ChaosSolverActor;
	GeometryCollection: GeometryCollectionActor;
	clone() : GeometryCollectionDebugDrawActorSelectedRigidBody;
	static C(Other: UObject | any): GeometryCollectionDebugDrawActorSelectedRigidBody;
}

declare type EGeometryCollectionDebugDrawActorHideGeometry = 'HideNone' | 'HideWithCollision' | 'HideSelected' | 'HideWholeCollection' | 'HideAll' | 'EGeometryCollectionDebugDrawActorHideGeometry_MAX';
declare var EGeometryCollectionDebugDrawActorHideGeometry : { HideNone:'HideNone',HideWithCollision:'HideWithCollision',HideSelected:'HideSelected',HideWholeCollection:'HideWholeCollection',HideAll:'HideAll',EGeometryCollectionDebugDrawActorHideGeometry_MAX:'EGeometryCollectionDebugDrawActorHideGeometry_MAX', };
declare class GeometryCollectionDebugDrawActor extends Actor { 
	WarningMessage: GeometryCollectionDebugDrawWarningMessage;
	SelectedRigidBody: GeometryCollectionDebugDrawActorSelectedRigidBody;
	bDebugDrawWholeCollection: boolean;
	bDebugDrawHierarchy: boolean;
	bDebugDrawClustering: boolean;
	HideGeometry: EGeometryCollectionDebugDrawActorHideGeometry;
	bShowRigidBodyId: boolean;
	bShowRigidBodyCollision: boolean;
	bCollisionAtOrigin: boolean;
	bShowRigidBodyTransform: boolean;
	bShowRigidBodyInertia: boolean;
	bShowRigidBodyVelocity: boolean;
	bShowRigidBodyForce: boolean;
	bShowRigidBodyInfos: boolean;
	bShowTransformIndex: boolean;
	bShowTransform: boolean;
	bShowParent: boolean;
	bShowLevel: boolean;
	bShowConnectivityEdges: boolean;
	bShowGeometryIndex: boolean;
	bShowGeometryTransform: boolean;
	bShowBoundingBox: boolean;
	bShowFaces: boolean;
	bShowFaceIndices: boolean;
	bShowFaceNormals: boolean;
	bShowSingleFace: boolean;
	SingleFaceIndex: number;
	bShowVertices: boolean;
	bShowVertexIndices: boolean;
	bShowVertexNormals: boolean;
	bUseActiveVisualization: boolean;
	PointThickness: number;
	LineThickness: number;
	bTextShadow: boolean;
	TextScale: number;
	NormalScale: number;
	AxisScale: number;
	ArrowScale: number;
	RigidBodyIdColor: Color;
	RigidBodyTransformScale: number;
	RigidBodyCollisionColor: Color;
	RigidBodyInertiaColor: Color;
	RigidBodyVelocityColor: Color;
	RigidBodyForceColor: Color;
	RigidBodyInfoColor: Color;
	TransformIndexColor: Color;
	TransformScale: number;
	LevelColor: Color;
	ParentColor: Color;
	ConnectivityEdgeThickness: number;
	GeometryIndexColor: Color;
	GeometryTransformScale: number;
	BoundingBoxColor: Color;
	FaceColor: Color;
	FaceIndexColor: Color;
	FaceNormalColor: Color;
	SingleFaceColor: Color;
	VertexColor: Color;
	VertexIndexColor: Color;
	VertexNormalColor: Color;
	SpriteComponent: BillboardComponent;
	static GetDefaultObject(): GeometryCollectionDebugDrawActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionDebugDrawActor;
	static C(Other: UObject | any): GeometryCollectionDebugDrawActor;
}

declare class GeometryCollectionRenderLevelSetActor extends Actor { 
	TargetVolumeTexture: VolumeTexture;
	RayMarchMaterial: Material;
	SurfaceTolerance: number;
	Isovalue: number;
	Enabled: boolean;
	RenderVolumeBoundingBox: boolean;
	static GetDefaultObject(): GeometryCollectionRenderLevelSetActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionRenderLevelSetActor;
	static C(Other: UObject | any): GeometryCollectionRenderLevelSetActor;
}

declare class GeometryCollectionDebugDrawComponent extends ActorComponent { 
	GeometryCollectionDebugDrawActor: GeometryCollectionDebugDrawActor;
	GeometryCollectionRenderLevelSetActor: GeometryCollectionRenderLevelSetActor;
	static Load(ResourceName: string): GeometryCollectionDebugDrawComponent;
	static Find(Outer: UObject, ResourceName: string): GeometryCollectionDebugDrawComponent;
	static GetDefaultObject(): GeometryCollectionDebugDrawComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionDebugDrawComponent;
	static C(Other: UObject | any): GeometryCollectionDebugDrawComponent;
}

declare class GeometryCollectionActor extends Actor { 
	GeometryCollectionComponent: GeometryCollectionComponent;
	GeometryCollectionDebugDrawComponent: GeometryCollectionDebugDrawComponent;
	static GetDefaultObject(): GeometryCollectionActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCollectionActor;
	RaycastSingle(Start: Vector,End: Vector,OutHit?: HitResult): {OutHit: HitResult, $: boolean};
	static C(Other: UObject | any): GeometryCollectionActor;
}

declare class ChaosDestructionListener extends SceneComponent { 
	bIsCollisionEventListeningEnabled: boolean;
	bIsBreakingEventListeningEnabled: boolean;
	bIsTrailingEventListeningEnabled: boolean;
	bIsRemovalEventListeningEnabled: boolean;
	CollisionEventRequestSettings: ChaosCollisionEventRequestSettings;
	BreakingEventRequestSettings: ChaosBreakingEventRequestSettings;
	TrailingEventRequestSettings: ChaosTrailingEventRequestSettings;
	RemovalEventRequestSettings: ChaosRemovalEventRequestSettings;
	ChaosSolverActors: any;
	GeometryCollectionActors: any;
	OnCollisionEvents: UnrealEngineMulticastDelegate<(CollisionEvents: ChaosCollisionEventData[]) => void>;
	OnBreakingEvents: UnrealEngineMulticastDelegate<(BreakingEvents: ChaosBreakingEventData[]) => void>;
	OnTrailingEvents: UnrealEngineMulticastDelegate<(TrailingEvents: ChaosTrailingEventData[]) => void>;
	OnRemovalEvents: UnrealEngineMulticastDelegate<(RemovalEvents: ChaosRemovalEventData[]) => void>;
	static Load(ResourceName: string): ChaosDestructionListener;
	static Find(Outer: UObject, ResourceName: string): ChaosDestructionListener;
	static GetDefaultObject(): ChaosDestructionListener;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosDestructionListener;
	SortTrailingEvents(TrailingEvents?: ChaosTrailingEventData[],SortMethod?: EChaosTrailingSortMethod): {TrailingEvents: ChaosTrailingEventData[]};
	SortRemovalEvents(RemovalEvents?: ChaosRemovalEventData[],SortMethod?: EChaosRemovalSortMethod): {RemovalEvents: ChaosRemovalEventData[]};
	SortCollisionEvents(CollisionEvents?: ChaosCollisionEventData[],SortMethod?: EChaosCollisionSortMethod): {CollisionEvents: ChaosCollisionEventData[]};
	SortBreakingEvents(BreakingEvents?: ChaosBreakingEventData[],SortMethod?: EChaosBreakingSortMethod): {BreakingEvents: ChaosBreakingEventData[]};
	SetTrailingEventRequestSettings(InSettings: ChaosTrailingEventRequestSettings): void;
	SetTrailingEventEnabled(bIsEnabled: boolean): void;
	SetRemovalEventRequestSettings(InSettings: ChaosRemovalEventRequestSettings): void;
	SetRemovalEventEnabled(bIsEnabled: boolean): void;
	SetCollisionEventRequestSettings(InSettings: ChaosCollisionEventRequestSettings): void;
	SetCollisionEventEnabled(bIsEnabled: boolean): void;
	SetBreakingEventRequestSettings(InSettings: ChaosBreakingEventRequestSettings): void;
	SetBreakingEventEnabled(bIsEnabled: boolean): void;
	RemoveGeometryCollectionActor(GeometryCollectionActor: GeometryCollectionActor): void;
	RemoveChaosSolverActor(ChaosSolverActor: ChaosSolverActor): void;
	IsEventListening(): boolean;
	AddGeometryCollectionActor(GeometryCollectionActor: GeometryCollectionActor): void;
	AddChaosSolverActor(ChaosSolverActor: ChaosSolverActor): void;
	static C(Other: UObject | any): ChaosDestructionListener;
}

declare class ParticleTransformTrack { 
	RawTransformTrack: RawAnimSequenceTrack;
	BeginOffset: number;
	bDeactivateOnEnd: boolean;
	KeyTimestamps: number[];
	clone() : ParticleTransformTrack;
	static C(Other: UObject | any): ParticleTransformTrack;
}

declare class PerParticleCacheData { 
	TransformData: ParticleTransformTrack;
	CurveData: any;
	clone() : PerParticleCacheData;
	static C(Other: UObject | any): PerParticleCacheData;
}

declare class CacheSpawnableTemplate { 
	DuplicatedTemplate: UObject;
	InitialTransform: Transform;
	ComponentTransform: Transform;
	clone() : CacheSpawnableTemplate;
	static C(Other: UObject | any): CacheSpawnableTemplate;
}

declare class ChaosCache extends UObject { 
	RecordedDuration: number;
	NumRecordedFrames: any;
	TrackToParticle: number[];
	ParticleTracks: PerParticleCacheData[];
	CurveData: any;
	EventTracks: any;
	Spawnable: CacheSpawnableTemplate;
	AdapterGuid: Guid;
	Version: number;
	static Load(ResourceName: string): ChaosCache;
	static Find(Outer: UObject, ResourceName: string): ChaosCache;
	static GetDefaultObject(): ChaosCache;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosCache;
	static C(Other: UObject | any): ChaosCache;
}

declare class ChaosCacheCollection extends UObject { 
	Caches: ChaosCache[];
	static Load(ResourceName: string): ChaosCacheCollection;
	static Find(Outer: UObject, ResourceName: string): ChaosCacheCollection;
	static GetDefaultObject(): ChaosCacheCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosCacheCollection;
	static C(Other: UObject | any): ChaosCacheCollection;
}

declare type ECacheMode = 'None' | 'Play' | 'Record' | 'ECacheMode_MAX';
declare var ECacheMode : { None:'None',Play:'Play',Record:'Record',ECacheMode_MAX:'ECacheMode_MAX', };
declare type EStartMode = 'Timed' | 'Triggered' | 'EStartMode_MAX';
declare var EStartMode : { Timed:'Timed',Triggered:'Triggered',EStartMode_MAX:'EStartMode_MAX', };
declare class ComponentReference { 
	OtherActor: Actor;
	ComponentProperty: string;
	PathToComponent: string;
	clone() : ComponentReference;
	static C(Other: UObject | any): ComponentReference;
}

declare class ObservedComponent { 
	CacheName: string;
	ComponentRef: ComponentReference;
	bIsSimulating: boolean;
	clone() : ObservedComponent;
	static C(Other: UObject | any): ObservedComponent;
}

declare class ChaosCacheManager extends Actor { 
	CacheCollection: ChaosCacheCollection;
	CacheMode: ECacheMode;
	StartMode: EStartMode;
	StartTime: number;
	ObservedComponents: ObservedComponent[];
	static GetDefaultObject(): ChaosCacheManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosCacheManager;
	TriggerComponentByCache(InCacheName: string): void;
	TriggerComponent(InComponent: PrimitiveComponent): void;
	TriggerAll(): void;
	SetStartTime(InStartTime: number): void;
	ResetSingleTransform(InIndex: number): void;
	ResetAllComponentTransforms(): void;
	static C(Other: UObject | any): ChaosCacheManager;
}

declare class ChaosCachePlayer extends ChaosCacheManager { 
	static GetDefaultObject(): ChaosCachePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosCachePlayer;
	static C(Other: UObject | any): ChaosCachePlayer;
}

declare class ActorFactoryCacheManager extends ActorFactory { 
	static Load(ResourceName: string): ActorFactoryCacheManager;
	static Find(Outer: UObject, ResourceName: string): ActorFactoryCacheManager;
	static GetDefaultObject(): ActorFactoryCacheManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryCacheManager;
	static C(Other: UObject | any): ActorFactoryCacheManager;
}

declare class CacheCollectionFactory extends Factory { 
	static Load(ResourceName: string): CacheCollectionFactory;
	static Find(Outer: UObject, ResourceName: string): CacheCollectionFactory;
	static GetDefaultObject(): CacheCollectionFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CacheCollectionFactory;
	static C(Other: UObject | any): CacheCollectionFactory;
}

declare type EVehicleAerofoilType = 'Fixed' | 'Wing' | 'Rudder' | 'Elevator' | 'EVehicleAerofoilType_MAX';
declare var EVehicleAerofoilType : { Fixed:'Fixed',Wing:'Wing',Rudder:'Rudder',Elevator:'Elevator',EVehicleAerofoilType_MAX:'EVehicleAerofoilType_MAX', };
declare class VehicleAerofoilConfig { 
	AerofoilType: EVehicleAerofoilType;
	BoneName: string;
	Offset: Vector;
	UpAxis: Vector;
	Area: number;
	Camber: number;
	MaxControlAngle: number;
	StallAngle: number;
	LiftMultiplier: number;
	DragMultiplier: number;
	clone() : VehicleAerofoilConfig;
	static C(Other: UObject | any): VehicleAerofoilConfig;
}

declare type EVehicleThrustType = 'Fixed' | 'Wing' | 'Rudder' | 'Elevator' | 'EVehicleThrustType_MAX';
declare var EVehicleThrustType : { Fixed:'Fixed',Wing:'Wing',Rudder:'Rudder',Elevator:'Elevator',EVehicleThrustType_MAX:'EVehicleThrustType_MAX', };
declare class VehicleThrustConfig { 
	ThrustType: EVehicleThrustType;
	BoneName: string;
	Offset: Vector;
	ThrustAxis: Vector;
	MaxThrustForce: number;
	MaxControlAngle: number;
	clone() : VehicleThrustConfig;
	static C(Other: UObject | any): VehicleThrustConfig;
}

declare class VehicleTorqueControlConfig { 
	Enabled: boolean;
	YawTorqueScaling: number;
	YawFromSteering: number;
	YawFromRollTorqueScaling: number;
	PitchTorqueScaling: number;
	RollTorqueScaling: number;
	RollFromSteering: number;
	RotationDamping: number;
	clone() : VehicleTorqueControlConfig;
	static C(Other: UObject | any): VehicleTorqueControlConfig;
}

declare class VehicleTargetRotationControlConfig { 
	Enabled: boolean;
	bRollVsSpeedEnabled: boolean;
	RollControlScaling: number;
	RollMaxAngle: number;
	PitchControlScaling: number;
	PitchMaxAngle: number;
	RotationStiffness: number;
	RotationDamping: number;
	MaxAccel: number;
	AutoCentreRollStrength: number;
	AutoCentrePitchStrength: number;
	AutoCentreYawStrength: number;
	clone() : VehicleTargetRotationControlConfig;
	static C(Other: UObject | any): VehicleTargetRotationControlConfig;
}

declare class VehicleStabilizeControlConfig { 
	Enabled: boolean;
	AltitudeHoldZ: number;
	PositionHoldXY: number;
	clone() : VehicleStabilizeControlConfig;
	static C(Other: UObject | any): VehicleStabilizeControlConfig;
}

declare class VehicleReplicatedState { 
	SteeringInput: number;
	ThrottleInput: number;
	BrakeInput: number;
	PitchInput: number;
	RollInput: number;
	YawInput: number;
	HandbrakeInput: number;
	TargetGear: number;
	ThrottleUp: number;
	ThrottleDown: number;
	clone() : VehicleReplicatedState;
	static C(Other: UObject | any): VehicleReplicatedState;
}

declare type EInputFunctionType = 'LinearFunction' | 'SquaredFunction' | 'CustomCurve' | 'EInputFunctionType_MAX';
declare var EInputFunctionType : { LinearFunction:'LinearFunction',SquaredFunction:'SquaredFunction',CustomCurve:'CustomCurve',EInputFunctionType_MAX:'EInputFunctionType_MAX', };
declare class VehicleInputRateConfig { 
	RiseRate: number;
	FallRate: number;
	InputCurveFunction: EInputFunctionType;
	UserCurve: RuntimeFloatCurve;
	clone() : VehicleInputRateConfig;
	static C(Other: UObject | any): VehicleInputRateConfig;
}

declare class ChaosVehicleMovementComponent extends PawnMovementComponent { 
	bReverseAsBrake: boolean;
	Mass: number;
	bEnableCenterOfMassOverride: boolean;
	CenterOfMassOverride: Vector;
	ChassisWidth: number;
	ChassisHeight: number;
	DragCoefficient: number;
	DownforceCoefficient: number;
	DragArea: number;
	DebugDragMagnitude: number;
	InertiaTensorScale: Vector;
	SleepThreshold: number;
	SleepSlopeLimit: number;
	Aerofoils: VehicleAerofoilConfig[];
	Thrusters: VehicleThrustConfig[];
	TorqueControl: VehicleTorqueControlConfig;
	TargetRotationControl: VehicleTargetRotationControlConfig;
	StabilizeControl: VehicleStabilizeControlConfig;
	bRawHandbrakeInput: boolean;
	bRawGearUpInput: boolean;
	bRawGearDownInput: boolean;
	bWasAvoidanceUpdated: boolean;
	bParkEnabled: boolean;
	ReplicatedState: VehicleReplicatedState;
	RawSteeringInput: number;
	RawThrottleInput: number;
	RawBrakeInput: number;
	RawPitchInput: number;
	RawRollInput: number;
	RawYawInput: number;
	SteeringInput: number;
	ThrottleInput: number;
	BrakeInput: number;
	PitchInput: number;
	RollInput: number;
	YawInput: number;
	HandbrakeInput: number;
	bRequiresControllerForInputs: boolean;
	IdleBrakeInput: number;
	StopThreshold: number;
	WrongDirectionThreshold: number;
	ThrottleInputRate: VehicleInputRateConfig;
	BrakeInputRate: VehicleInputRateConfig;
	SteeringInputRate: VehicleInputRateConfig;
	HandbrakeInputRate: VehicleInputRateConfig;
	PitchInputRate: VehicleInputRateConfig;
	RollInputRate: VehicleInputRateConfig;
	YawInputRate: VehicleInputRateConfig;
	OverrideController: Controller;
	static Load(ResourceName: string): ChaosVehicleMovementComponent;
	static Find(Outer: UObject, ResourceName: string): ChaosVehicleMovementComponent;
	static GetDefaultObject(): ChaosVehicleMovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosVehicleMovementComponent;
	SetYawInput(Yaw: number): void;
	SetUseAutomaticGears(bUseAuto: boolean): void;
	SetThrottleInput(Throttle: number): void;
	SetTargetGear(GearNum: number,bImmediate: boolean): void;
	SetSteeringInput(Steering: number): void;
	SetSleeping(bEnableSleep: boolean): void;
	SetRollInput(Roll: number): void;
	SetRequiresControllerForInputs(bRequiresController: boolean): void;
	SetPitchInput(Pitch: number): void;
	SetParked(bParked: boolean): void;
	SetHandbrakeInput(bNewHandbrake: boolean): void;
	SetChangeUpInput(bNewGearUp: boolean): void;
	SetChangeDownInput(bNewGearDown: boolean): void;
	SetBrakeInput(Brake: number): void;
	ServerUpdateState(InSteeringInput: number,InThrottleInput: number,InBrakeInput: number,InHandbrakeInput: number,InCurrentGear: number,InRollInput: number,InPitchInput: number,InYawInput: number): void;
	ResetVehicle(): void;
	IsParked(): boolean;
	IncreaseThrottleInput(ThrottleDelta: number): void;
	GetUseAutoGears(): boolean;
	GetThrottleInput(): number;
	GetTargetGear(): number;
	GetSteeringInput(): number;
	GetHandbrakeInput(): boolean;
	GetForwardSpeedMPH(): number;
	GetForwardSpeed(): number;
	GetCurrentGear(): number;
	GetBrakeInput(): number;
	EnableSelfRighting(InState: boolean): void;
	DecreaseThrottleInput(ThrottleDelta: number): void;
	static C(Other: UObject | any): ChaosVehicleMovementComponent;
}

declare type EAxleType = 'Undefined' | 'Front' | 'Rear' | 'EAxleType_MAX';
declare var EAxleType : { Undefined:'Undefined',Front:'Front',Rear:'Rear',EAxleType_MAX:'EAxleType_MAX', };
declare type ESweepShape = 'Raycast' | 'Spherecast' | 'Shapecast' | 'ESweepShape_MAX';
declare var ESweepShape : { Raycast:'Raycast',Spherecast:'Spherecast',Shapecast:'Shapecast',ESweepShape_MAX:'ESweepShape_MAX', };
declare type ESweepType = 'SimpleSweep' | 'ComplexSweep' | 'ESweepType_MAX';
declare var ESweepType : { SimpleSweep:'SimpleSweep',ComplexSweep:'ComplexSweep',ESweepType_MAX:'ESweepType_MAX', };
declare class ChaosWheelSetup { 
	WheelClass: UnrealEngineClass;
	BoneName: string;
	AdditionalOffset: Vector;
	clone() : ChaosWheelSetup;
	static C(Other: UObject | any): ChaosWheelSetup;
}

declare class VehicleEngineConfig { 
	TorqueCurve: RuntimeFloatCurve;
	MaxTorque: number;
	MaxRPM: number;
	EngineIdleRPM: number;
	EngineBrakeEffect: number;
	EngineRevUpMOI: number;
	EngineRevDownRate: number;
	clone() : VehicleEngineConfig;
	static C(Other: UObject | any): VehicleEngineConfig;
}

declare type EVehicleDifferential = 'Undefined' | 'AllWheelDrive' | 'FrontWheelDrive' | 'RearWheelDrive' | 'EVehicleDifferential_MAX';
declare var EVehicleDifferential : { Undefined:'Undefined',AllWheelDrive:'AllWheelDrive',FrontWheelDrive:'FrontWheelDrive',RearWheelDrive:'RearWheelDrive',EVehicleDifferential_MAX:'EVehicleDifferential_MAX', };
declare class VehicleDifferentialConfig { 
	DifferentialType: EVehicleDifferential;
	FrontRearSplit: number;
	clone() : VehicleDifferentialConfig;
	static C(Other: UObject | any): VehicleDifferentialConfig;
}

declare class VehicleTransmissionConfig { 
	bUseAutomaticGears: boolean;
	bUseAutoReverse: boolean;
	FinalRatio: number;
	ForwardGearRatios: number[];
	ReverseGearRatios: number[];
	ChangeUpRPM: number;
	ChangeDownRPM: number;
	GearChangeTime: number;
	TransmissionEfficiency: number;
	clone() : VehicleTransmissionConfig;
	static C(Other: UObject | any): VehicleTransmissionConfig;
}

declare type ESteeringType = 'SingleAngle' | 'AngleRatio' | 'Ackermann' | 'ESteeringType_MAX';
declare var ESteeringType : { SingleAngle:'SingleAngle',AngleRatio:'AngleRatio',Ackermann:'Ackermann',ESteeringType_MAX:'ESteeringType_MAX', };
declare class VehicleSteeringConfig { 
	SteeringType: ESteeringType;
	AngleRatio: number;
	SteeringCurve: RuntimeFloatCurve;
	clone() : VehicleSteeringConfig;
	static C(Other: UObject | any): VehicleSteeringConfig;
}

declare class BaseSnapshotData { 
	Transform: Transform;
	LinearVelocity: Vector;
	AngularVelocity: Vector;
	clone() : BaseSnapshotData;
	static C(Other: UObject | any): BaseSnapshotData;
}

declare class WheelSnapshot { 
	SuspensionOffset: number;
	WheelRotationAngle: number;
	SteeringAngle: number;
	WheelRadius: number;
	WheelAngularVelocity: number;
	clone() : WheelSnapshot;
	static C(Other: UObject | any): WheelSnapshot;
}

declare class WheeledSnaphotData extends BaseSnapshotData { 
	SelectedGear: number;
	EngineRPM: number;
	WheelSnapshots: WheelSnapshot[];
	clone() : WheeledSnaphotData;
	static C(Other: UObject | any): WheeledSnaphotData;
}

declare class WheelStatus { 
	bInContact: boolean;
	ContactPoint: Vector;
	PhysMaterial: any;
	NormalizedSuspensionLength: number;
	SpringForce: number;
	SlipAngle: number;
	bIsSlipping: boolean;
	SlipMagnitude: number;
	bIsSkidding: boolean;
	SkidMagnitude: number;
	SkidNormal: Vector;
	clone() : WheelStatus;
	static C(Other: UObject | any): WheelStatus;
}

declare class ChaosWheeledVehicleMovementComponent extends ChaosVehicleMovementComponent { 
	bSuspensionEnabled: boolean;
	bWheelFrictionEnabled: boolean;
	WheelSetups: ChaosWheelSetup[];
	WheelTraceCollisionResponses: CollisionResponseContainer;
	bMechanicalSimEnabled: boolean;
	EngineSetup: VehicleEngineConfig;
	DifferentialSetup: VehicleDifferentialConfig;
	TransmissionSetup: VehicleTransmissionConfig;
	SteeringSetup: VehicleSteeringConfig;
	Wheels: ChaosVehicleWheel[];
	static Load(ResourceName: string): ChaosWheeledVehicleMovementComponent;
	static Find(Outer: UObject, ResourceName: string): ChaosWheeledVehicleMovementComponent;
	static GetDefaultObject(): ChaosWheeledVehicleMovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosWheeledVehicleMovementComponent;
	SetWheelSlipGraphMultiplier(WheelIndex: number,Multiplier: number): void;
	SetWheelRadius(WheelIndex: number,Radius: number): void;
	SetWheelMaxSteerAngle(WheelIndex: number,AngleDegrees: number): void;
	SetWheelMaxBrakeTorque(WheelIndex: number,Torque: number): void;
	SetWheelHandbrakeTorque(WheelIndex: number,Torque: number): void;
	SetWheelFrictionMultiplier(WheelIndex: number,Friction: number): void;
	SetWheelClass(WheelIndex: number,InWheelClass: UnrealEngineClass): void;
	SetTractionControlEnabled(WheelIndex: number,Enabled: boolean): void;
	SetSnapshot(SnapshotIn: WheeledSnaphotData): void;
	SetMaxEngineTorque(Torque: number): void;
	SetDragCoefficient(DragCoeff: number): void;
	SetDownforceCoefficient(DownforceCoeff: number): void;
	SetDifferentialFrontRearSplit(FrontRearSlpit: number): void;
	SetAffectedBySteering(WheelIndex: number,Enabled: boolean): void;
	SetAffectedByHandbrake(WheelIndex: number,Enabled: boolean): void;
	SetAffectedByEngine(WheelIndex: number,Enabled: boolean): void;
	SetAffectedByBrake(WheelIndex: number,Enabled: boolean): void;
	SetABSEnabled(WheelIndex: number,Enabled: boolean): void;
	static MakeWheelStatus(bInContact: boolean,ContactPoint?: Vector,PhysMaterial?: PhysicalMaterial,NormalizedSuspensionLength?: number,SpringForce?: number,SlipAngle?: number,bIsSlipping?: boolean,SlipMagnitude?: number,bIsSkidding?: boolean,SkidMagnitude?: number,SkidNormal?: Vector): {ContactPoint: Vector, SkidNormal: Vector, $: WheelStatus};
	static MakeWheelSnapshot(SuspensionOffset: number,WheelRotationAngle: number,SteeringAngle: number,WheelRadius: number,WheelAngularVelocity: number): WheelSnapshot;
	static MakeWheeledSnapshot(Transform: Transform,LinearVelocity: Vector,AngularVelocity: Vector,SelectedGear: number,EngineRPM: number,WheelSnapshots: WheelSnapshot[]): WheeledSnaphotData;
	GetWheelState(WheelIndex: number): WheelStatus;
	GetSnapshot(): WheeledSnaphotData;
	GetNumWheels(): number;
	GetEngineRotationSpeed(): number;
	GetEngineMaxRotationSpeed(): number;
	EnableWheelFriction(InState: boolean): void;
	EnableSuspension(InState: boolean): void;
	EnableMechanicalSim(InState: boolean): void;
	static BreakWheelStatus(Status: WheelStatus,bInContact?: boolean,ContactPoint?: Vector,PhysMaterial?: PhysicalMaterial,NormalizedSuspensionLength?: number,SpringForce?: number,SlipAngle?: number,bIsSlipping?: boolean,SlipMagnitude?: number,bIsSkidding?: boolean,SkidMagnitude?: number,SkidNormal?: Vector): {bInContact: boolean, ContactPoint: Vector, PhysMaterial: PhysicalMaterial, NormalizedSuspensionLength: number, SpringForce: number, SlipAngle: number, bIsSlipping: boolean, SlipMagnitude: number, bIsSkidding: boolean, SkidMagnitude: number, SkidNormal: Vector};
	static BreakWheelSnapshot(Snapshot: WheelSnapshot,SuspensionOffset?: number,WheelRotationAngle?: number,SteeringAngle?: number,WheelRadius?: number,WheelAngularVelocity?: number): {SuspensionOffset: number, WheelRotationAngle: number, SteeringAngle: number, WheelRadius: number, WheelAngularVelocity: number};
	static BreakWheeledSnapshot(Snapshot: WheeledSnaphotData,Transform?: Transform,LinearVelocity?: Vector,AngularVelocity?: Vector,SelectedGear?: number,EngineRPM?: number,WheelSnapshots?: WheelSnapshot[]): {Transform: Transform, LinearVelocity: Vector, AngularVelocity: Vector, SelectedGear: number, EngineRPM: number, WheelSnapshots: WheelSnapshot[]};
	static C(Other: UObject | any): ChaosWheeledVehicleMovementComponent;
}

declare class ChaosVehicleWheel extends UObject { 
	CollisionMesh: StaticMesh;
	AxleType: EAxleType;
	Offset: Vector;
	WheelRadius: number;
	WheelWidth: number;
	CorneringStiffness: number;
	FrictionForceMultiplier: number;
	SideSlipModifier: number;
	SlipThreshold: number;
	SkidThreshold: number;
	MaxSteerAngle: number;
	bAffectedBySteering: boolean;
	bAffectedByBrake: boolean;
	bAffectedByHandbrake: boolean;
	bAffectedByEngine: boolean;
	bABSEnabled: boolean;
	bTractionControlEnabled: boolean;
	LateralSlipGraph: RuntimeFloatCurve;
	SuspensionAxis: Vector;
	SuspensionForceOffset: Vector;
	SuspensionMaxRaise: number;
	SuspensionMaxDrop: number;
	SuspensionDampingRatio: number;
	WheelLoadRatio: number;
	SpringRate: number;
	SpringPreload: number;
	SuspensionSmoothing: number;
	RollbarScaling: number;
	SweepShape: ESweepShape;
	SweepType: ESweepType;
	MaxBrakeTorque: number;
	MaxHandBrakeTorque: number;
	VehicleComponent: ChaosWheeledVehicleMovementComponent;
	WheelIndex: number;
	DebugLongSlip: number;
	DebugLatSlip: number;
	DebugNormalizedTireLoad: number;
	DebugWheelTorque: number;
	DebugLongForce: number;
	DebugLatForce: number;
	Location: Vector;
	OldLocation: Vector;
	Velocity: Vector;
	static Load(ResourceName: string): ChaosVehicleWheel;
	static Find(Outer: UObject, ResourceName: string): ChaosVehicleWheel;
	static GetDefaultObject(): ChaosVehicleWheel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosVehicleWheel;
	IsInAir(): boolean;
	GetWheelRadius(): number;
	GetWheelAngularVelocity(): number;
	GetSuspensionOffset(): number;
	GetSteerAngle(): number;
	GetRotationAngularVelocity(): number;
	GetRotationAngle(): number;
	GetAxleType(): EAxleType;
	static C(Other: UObject | any): ChaosVehicleWheel;
}

declare class WheeledVehiclePawn extends Pawn { 
	Mesh: SkeletalMeshComponent;
	VehicleMovementComponent: ChaosVehicleMovementComponent;
	static GetDefaultObject(): WheeledVehiclePawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WheeledVehiclePawn;
	static C(Other: UObject | any): WheeledVehiclePawn;
}

declare class VehicleAnimationInstance extends AnimInstance { 
	WheeledVehicleComponent: ChaosWheeledVehicleMovementComponent;
	static Load(ResourceName: string): VehicleAnimationInstance;
	static Find(Outer: UObject, ResourceName: string): VehicleAnimationInstance;
	static GetDefaultObject(): VehicleAnimationInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VehicleAnimationInstance;
	GetVehicle(): WheeledVehiclePawn;
	static C(Other: UObject | any): VehicleAnimationInstance;
}

declare class ChaosVehicles extends UObject { 
	static Load(ResourceName: string): ChaosVehicles;
	static Find(Outer: UObject, ResourceName: string): ChaosVehicles;
	static GetDefaultObject(): ChaosVehicles;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChaosVehicles;
	static C(Other: UObject | any): ChaosVehicles;
}

declare class AnimNode_StageCoachWheelController extends AnimNode_SkeletalControlBase { 
	WheelSpokeCount: number;
	MaxAngularVelocity: number;
	ShutterSpeed: number;
	StageCoachBlend: number;
	clone() : AnimNode_StageCoachWheelController;
	static C(Other: UObject | any): AnimNode_StageCoachWheelController;
}

declare class AnimGraphNode_StageCoachWheelController extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_StageCoachWheelController;
	static Load(ResourceName: string): AnimGraphNode_StageCoachWheelController;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_StageCoachWheelController;
	static GetDefaultObject(): AnimGraphNode_StageCoachWheelController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_StageCoachWheelController;
	static C(Other: UObject | any): AnimGraphNode_StageCoachWheelController;
}

declare class AnimNode_WheelController extends AnimNode_SkeletalControlBase { 
	clone() : AnimNode_WheelController;
	static C(Other: UObject | any): AnimNode_WheelController;
}

declare class AnimGraphNode_WheelController extends AnimGraphNode_SkeletalControlBase { 
	UNode: AnimNode_WheelController;
	static Load(ResourceName: string): AnimGraphNode_WheelController;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_WheelController;
	static GetDefaultObject(): AnimGraphNode_WheelController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_WheelController;
	static C(Other: UObject | any): AnimGraphNode_WheelController;
}

declare type ETriggerEvent = 'None' | 'Triggered' | 'Started' | 'Ongoing' | 'Canceled' | 'Completed' | 'ETriggerEvent_MAX';
declare var ETriggerEvent : { None:'None',Triggered:'Triggered',Started:'Started',Ongoing:'Ongoing',Canceled:'Canceled',Completed:'Completed',ETriggerEvent_MAX:'ETriggerEvent_MAX', };
declare class BlueprintEnhancedInputActionBinding { 
	InputAction: InputAction;
	TriggerEvent: ETriggerEvent;
	FunctionNameToBind: string;
	clone() : BlueprintEnhancedInputActionBinding;
	static C(Other: UObject | any): BlueprintEnhancedInputActionBinding;
}

declare class EnhancedInputActionDelegateBinding extends InputDelegateBinding { 
	InputActionDelegateBindings: BlueprintEnhancedInputActionBinding[];
	static Load(ResourceName: string): EnhancedInputActionDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputActionDelegateBinding;
	static GetDefaultObject(): EnhancedInputActionDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputActionDelegateBinding;
	static C(Other: UObject | any): EnhancedInputActionDelegateBinding;
}

declare class EnhancedInputActionValueBinding extends InputDelegateBinding { 
	InputActionValueBindings: BlueprintEnhancedInputActionBinding[];
	static Load(ResourceName: string): EnhancedInputActionValueBinding;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputActionValueBinding;
	static GetDefaultObject(): EnhancedInputActionValueBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputActionValueBinding;
	static C(Other: UObject | any): EnhancedInputActionValueBinding;
}

declare class EnhancedInputComponent extends InputComponent { 
	static Load(ResourceName: string): EnhancedInputComponent;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputComponent;
	static GetDefaultObject(): EnhancedInputComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputComponent;
	GetBoundActionValue(Action: InputAction): InputActionValue;
	static C(Other: UObject | any): EnhancedInputComponent;
}

declare class InputMappingContext extends DataAsset { 
	ContextDescription: string;
	Mappings: EnhancedActionKeyMapping[];
	static Load(ResourceName: string): InputMappingContext;
	static Find(Outer: UObject, ResourceName: string): InputMappingContext;
	static GetDefaultObject(): InputMappingContext;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputMappingContext;
	UnmapKey(Action: InputAction,Key: Key): void;
	UnmapAll(): void;
	UnmapAction(Action: InputAction): void;
	MapKey(Action: InputAction,ToKey: Key): EnhancedActionKeyMapping;
	static C(Other: UObject | any): InputMappingContext;
	RequestRebuildControlMappingsUsingContext(bForceImmediately: boolean): void;
	static RequestRebuildControlMappingsUsingContext(Context: InputMappingContext,bForceImmediately: boolean): void;
}

declare class EnhancedInputLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): EnhancedInputLibrary;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputLibrary;
	static GetDefaultObject(): EnhancedInputLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputLibrary;
	static RequestRebuildControlMappingsUsingContext(Context: InputMappingContext,bForceImmediately: boolean): void;
	static MakeInputActionValue(X: number,Y: number,Z: number,MatchValueType: InputActionValue): InputActionValue;
	static GetBoundActionValue(Actor: Actor,Action: InputAction): InputActionValue;
	static Conv_InputActionValueToString(ActionValue: InputActionValue): string;
	static Conv_InputActionValueToBool(InValue: InputActionValue): boolean;
	static Conv_InputActionValueToAxis3D(ActionValue: InputActionValue): Vector;
	static Conv_InputActionValueToAxis2D(InValue: InputActionValue): Vector2D;
	static Conv_InputActionValueToAxis1D(InValue: InputActionValue): number;
	static BreakInputActionValue(InActionValue: InputActionValue,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static C(Other: UObject | any): EnhancedInputLibrary;
}

declare class ModifyContextOptions { 
	bIgnoreAllPressedKeysUntilRelease: boolean;
	bForceImmediately: boolean;
	clone() : ModifyContextOptions;
	static C(Other: UObject | any): ModifyContextOptions;
}

declare type EInputMappingRebuildType = 'None' | 'Rebuild' | 'RebuildWithFlush' | 'EInputMappingRebuildType_MAX';
declare var EInputMappingRebuildType : { None:'None',Rebuild:'Rebuild',RebuildWithFlush:'RebuildWithFlush',EInputMappingRebuildType_MAX:'EInputMappingRebuildType_MAX', };
declare class PlayerMappableInputConfig extends PrimaryDataAsset { 
	ConfigName: string;
	ConfigDisplayName: string;
	bIsDeprecated: boolean;
	MetaData: UObject;
	Contexts: any;
	static Load(ResourceName: string): PlayerMappableInputConfig;
	static Find(Outer: UObject, ResourceName: string): PlayerMappableInputConfig;
	static GetDefaultObject(): PlayerMappableInputConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerMappableInputConfig;
	ResetToDefault(): void;
	IsDeprecated(): boolean;
	GetPlayerMappableKeys(): EnhancedActionKeyMapping[];
	GetMetadata(): UObject;
	GetMappingContexts(): any;
	GetMappingByName(MappingName: string): EnhancedActionKeyMapping;
	GetKeysBoundToAction(InAction: InputAction): EnhancedActionKeyMapping[];
	GetDisplayName(): string;
	GetConfigName(): string;
	static C(Other: UObject | any): PlayerMappableInputConfig;
}

declare type EMappingQueryIssue = 'NoIssue' | 'ReservedByAction' | 'HidesExistingMapping' | 'HiddenByExistingMapping' | 'CollisionWithMappingInSameContext' | 'ForcesTypePromotion' | 'ForcesTypeDemotion' | 'EMappingQueryIssue_MAX';
declare var EMappingQueryIssue : { NoIssue:'NoIssue',ReservedByAction:'ReservedByAction',HidesExistingMapping:'HidesExistingMapping',HiddenByExistingMapping:'HiddenByExistingMapping',CollisionWithMappingInSameContext:'CollisionWithMappingInSameContext',ForcesTypePromotion:'ForcesTypePromotion',ForcesTypeDemotion:'ForcesTypeDemotion',EMappingQueryIssue_MAX:'EMappingQueryIssue_MAX', };
declare class MappingQueryIssue { 
	Issue: EMappingQueryIssue;
	BlockingContext: InputMappingContext;
	BlockingAction: InputAction;
	clone() : MappingQueryIssue;
	static C(Other: UObject | any): MappingQueryIssue;
}

declare type EMappingQueryResult = 'Error_EnhancedInputNotEnabled' | 'Error_InputContextNotInActiveContexts' | 'Error_InvalidAction' | 'NotMappable' | 'MappingAvailable' | 'EMappingQueryResult_MAX';
declare var EMappingQueryResult : { Error_EnhancedInputNotEnabled:'Error_EnhancedInputNotEnabled',Error_InputContextNotInActiveContexts:'Error_InputContextNotInActiveContexts',Error_InvalidAction:'Error_InvalidAction',NotMappable:'NotMappable',MappingAvailable:'MappingAvailable',EMappingQueryResult_MAX:'EMappingQueryResult_MAX', };
declare class EnhancedInputSubsystemInterface extends Interface { 
	static Load(ResourceName: string): EnhancedInputSubsystemInterface;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputSubsystemInterface;
	static GetDefaultObject(): EnhancedInputSubsystemInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputSubsystemInterface;
	RequestRebuildControlMappings(Options: ModifyContextOptions,RebuildType: EInputMappingRebuildType): void;
	RemovePlayerMappedKey(MappingName: string,Options: ModifyContextOptions): number;
	RemovePlayerMappableConfig(Config: PlayerMappableInputConfig,Options: ModifyContextOptions): void;
	RemoveMappingContext(MappingContext: InputMappingContext,Options: ModifyContextOptions): void;
	QueryMapKeyInContextSet(PrioritizedActiveContexts: InputMappingContext[],InputContext: InputMappingContext,Action: InputAction,Key: Key,OutIssues?: MappingQueryIssue[],BlockingIssues?: EMappingQueryIssue): {OutIssues: MappingQueryIssue[], $: EMappingQueryResult};
	QueryMapKeyInActiveContextSet(InputContext: InputMappingContext,Action: InputAction,Key: Key,OutIssues?: MappingQueryIssue[],BlockingIssues?: EMappingQueryIssue): {OutIssues: MappingQueryIssue[], $: EMappingQueryResult};
	QueryKeysMappedToAction(Action: InputAction): Key[];
	InjectInputVectorForAction(Action: InputAction,Value: Vector,Modifiers: InputModifier[],Triggers: InputTrigger[]): void;
	InjectInputForAction(Action: InputAction,RawValue: InputActionValue,Modifiers: InputModifier[],Triggers: InputTrigger[]): void;
	HasMappingContext(MappingContext: InputMappingContext): boolean;
	ClearAllMappings(): void;
	AddPlayerMappedKey(MappingName: string,NewKey: Key,Options: ModifyContextOptions): number;
	AddPlayerMappableConfig(Config: PlayerMappableInputConfig,Options: ModifyContextOptions): void;
	AddMappingContext(MappingContext: InputMappingContext,Priority: number,Options: ModifyContextOptions): void;
	static C(Other: UObject | any): EnhancedInputSubsystemInterface;
}

declare class EnhancedInputLocalPlayerSubsystem extends LocalPlayerSubsystem { 
	static Load(ResourceName: string): EnhancedInputLocalPlayerSubsystem;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputLocalPlayerSubsystem;
	static GetDefaultObject(): EnhancedInputLocalPlayerSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputLocalPlayerSubsystem;
	static C(Other: UObject | any): EnhancedInputLocalPlayerSubsystem;
}

declare class EnhancedInputEngineSubsystem extends EngineSubsystem { 
	PlayerInput: EnhancedPlayerInput;
	static Load(ResourceName: string): EnhancedInputEngineSubsystem;
	static Find(Outer: UObject, ResourceName: string): EnhancedInputEngineSubsystem;
	static GetDefaultObject(): EnhancedInputEngineSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EnhancedInputEngineSubsystem;
	static C(Other: UObject | any): EnhancedInputEngineSubsystem;
}

declare class BlueprintInputDebugKeyDelegateBinding { 
	InputChord: InputChord;
	InputKeyEvent: EInputEvent;
	FunctionNameToBind: string;
	bExecuteWhenPaused: boolean;
	clone() : BlueprintInputDebugKeyDelegateBinding;
	static C(Other: UObject | any): BlueprintInputDebugKeyDelegateBinding;
}

declare class InputDebugKeyDelegateBinding extends InputDelegateBinding { 
	InputDebugKeyDelegateBindings: BlueprintInputDebugKeyDelegateBinding[];
	static Load(ResourceName: string): InputDebugKeyDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputDebugKeyDelegateBinding;
	static GetDefaultObject(): InputDebugKeyDelegateBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputDebugKeyDelegateBinding;
	static C(Other: UObject | any): InputDebugKeyDelegateBinding;
}

declare type EDeadZoneType = 'Axial' | 'Radial' | 'EDeadZoneType_MAX';
declare var EDeadZoneType : { Axial:'Axial',Radial:'Radial',EDeadZoneType_MAX:'EDeadZoneType_MAX', };
declare class InputModifierDeadZone extends InputModifier { 
	LowerThreshold: number;
	UpperThreshold: number;
	Type: EDeadZoneType;
	static Load(ResourceName: string): InputModifierDeadZone;
	static Find(Outer: UObject, ResourceName: string): InputModifierDeadZone;
	static GetDefaultObject(): InputModifierDeadZone;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierDeadZone;
	static C(Other: UObject | any): InputModifierDeadZone;
}

declare class InputModifierScalar extends InputModifier { 
	Scalar: Vector;
	static Load(ResourceName: string): InputModifierScalar;
	static Find(Outer: UObject, ResourceName: string): InputModifierScalar;
	static GetDefaultObject(): InputModifierScalar;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierScalar;
	static C(Other: UObject | any): InputModifierScalar;
}

declare class InputModifierNegate extends InputModifier { 
	bX: boolean;
	bY: boolean;
	bZ: boolean;
	static Load(ResourceName: string): InputModifierNegate;
	static Find(Outer: UObject, ResourceName: string): InputModifierNegate;
	static GetDefaultObject(): InputModifierNegate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierNegate;
	static C(Other: UObject | any): InputModifierNegate;
}

declare class InputModifierSmooth extends InputModifier { 
	static Load(ResourceName: string): InputModifierSmooth;
	static Find(Outer: UObject, ResourceName: string): InputModifierSmooth;
	static GetDefaultObject(): InputModifierSmooth;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierSmooth;
	static C(Other: UObject | any): InputModifierSmooth;
}

declare class InputModifierResponseCurveExponential extends InputModifier { 
	CurveExponent: Vector;
	static Load(ResourceName: string): InputModifierResponseCurveExponential;
	static Find(Outer: UObject, ResourceName: string): InputModifierResponseCurveExponential;
	static GetDefaultObject(): InputModifierResponseCurveExponential;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierResponseCurveExponential;
	static C(Other: UObject | any): InputModifierResponseCurveExponential;
}

declare class InputModifierResponseCurveUser extends InputModifier { 
	ResponseX: CurveFloat;
	ResponseY: CurveFloat;
	ResponseZ: CurveFloat;
	static Load(ResourceName: string): InputModifierResponseCurveUser;
	static Find(Outer: UObject, ResourceName: string): InputModifierResponseCurveUser;
	static GetDefaultObject(): InputModifierResponseCurveUser;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierResponseCurveUser;
	static C(Other: UObject | any): InputModifierResponseCurveUser;
}

declare type EFOVScalingType = 'Standard' | 'UE4_BackCompat' | 'EFOVScalingType_MAX';
declare var EFOVScalingType : { Standard:'Standard',UE4_BackCompat:'UE4_BackCompat',EFOVScalingType_MAX:'EFOVScalingType_MAX', };
declare class InputModifierFOVScaling extends InputModifier { 
	FOVScale: number;
	FOVScalingType: EFOVScalingType;
	static Load(ResourceName: string): InputModifierFOVScaling;
	static Find(Outer: UObject, ResourceName: string): InputModifierFOVScaling;
	static GetDefaultObject(): InputModifierFOVScaling;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierFOVScaling;
	static C(Other: UObject | any): InputModifierFOVScaling;
}

declare class InputModifierToWorldSpace extends InputModifier { 
	static Load(ResourceName: string): InputModifierToWorldSpace;
	static Find(Outer: UObject, ResourceName: string): InputModifierToWorldSpace;
	static GetDefaultObject(): InputModifierToWorldSpace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierToWorldSpace;
	static C(Other: UObject | any): InputModifierToWorldSpace;
}

declare type EInputAxisSwizzle = 'YXZ' | 'ZYX' | 'XZY' | 'YZX' | 'ZXY' | 'EInputAxisSwizzle_MAX';
declare var EInputAxisSwizzle : { YXZ:'YXZ',ZYX:'ZYX',XZY:'XZY',YZX:'YZX',ZXY:'ZXY',EInputAxisSwizzle_MAX:'EInputAxisSwizzle_MAX', };
declare class InputModifierSwizzleAxis extends InputModifier { 
	Order: EInputAxisSwizzle;
	static Load(ResourceName: string): InputModifierSwizzleAxis;
	static Find(Outer: UObject, ResourceName: string): InputModifierSwizzleAxis;
	static GetDefaultObject(): InputModifierSwizzleAxis;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierSwizzleAxis;
	static C(Other: UObject | any): InputModifierSwizzleAxis;
}

declare class InputModifierCollection extends InputModifier { 
	Modifiers: InputModifier[];
	bPermitValueTypeModification: boolean;
	static Load(ResourceName: string): InputModifierCollection;
	static Find(Outer: UObject, ResourceName: string): InputModifierCollection;
	static GetDefaultObject(): InputModifierCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputModifierCollection;
	static C(Other: UObject | any): InputModifierCollection;
}

declare class InputTriggerTimedBase extends InputTrigger { 
	HeldDuration: number;
	bAffectedByTimeDilation: boolean;
	static Load(ResourceName: string): InputTriggerTimedBase;
	static Find(Outer: UObject, ResourceName: string): InputTriggerTimedBase;
	static GetDefaultObject(): InputTriggerTimedBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerTimedBase;
	static C(Other: UObject | any): InputTriggerTimedBase;
}

declare class InputTriggerDown extends InputTrigger { 
	static Load(ResourceName: string): InputTriggerDown;
	static Find(Outer: UObject, ResourceName: string): InputTriggerDown;
	static GetDefaultObject(): InputTriggerDown;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerDown;
	static C(Other: UObject | any): InputTriggerDown;
}

declare class InputTriggerPressed extends InputTrigger { 
	static Load(ResourceName: string): InputTriggerPressed;
	static Find(Outer: UObject, ResourceName: string): InputTriggerPressed;
	static GetDefaultObject(): InputTriggerPressed;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerPressed;
	static C(Other: UObject | any): InputTriggerPressed;
}

declare class InputTriggerReleased extends InputTrigger { 
	static Load(ResourceName: string): InputTriggerReleased;
	static Find(Outer: UObject, ResourceName: string): InputTriggerReleased;
	static GetDefaultObject(): InputTriggerReleased;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerReleased;
	static C(Other: UObject | any): InputTriggerReleased;
}

declare class InputTriggerHold extends InputTriggerTimedBase { 
	HoldTimeThreshold: number;
	bIsOneShot: boolean;
	static Load(ResourceName: string): InputTriggerHold;
	static Find(Outer: UObject, ResourceName: string): InputTriggerHold;
	static GetDefaultObject(): InputTriggerHold;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerHold;
	static C(Other: UObject | any): InputTriggerHold;
}

declare class InputTriggerHoldAndRelease extends InputTriggerTimedBase { 
	HoldTimeThreshold: number;
	static Load(ResourceName: string): InputTriggerHoldAndRelease;
	static Find(Outer: UObject, ResourceName: string): InputTriggerHoldAndRelease;
	static GetDefaultObject(): InputTriggerHoldAndRelease;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerHoldAndRelease;
	static C(Other: UObject | any): InputTriggerHoldAndRelease;
}

declare class InputTriggerTap extends InputTriggerTimedBase { 
	TapReleaseTimeThreshold: number;
	static Load(ResourceName: string): InputTriggerTap;
	static Find(Outer: UObject, ResourceName: string): InputTriggerTap;
	static GetDefaultObject(): InputTriggerTap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerTap;
	static C(Other: UObject | any): InputTriggerTap;
}

declare class InputTriggerPulse extends InputTriggerTimedBase { 
	bTriggerOnStart: boolean;
	Interval: number;
	TriggerLimit: number;
	static Load(ResourceName: string): InputTriggerPulse;
	static Find(Outer: UObject, ResourceName: string): InputTriggerPulse;
	static GetDefaultObject(): InputTriggerPulse;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerPulse;
	static C(Other: UObject | any): InputTriggerPulse;
}

declare class InputTriggerChordAction extends InputTrigger { 
	ChordAction: InputAction;
	static Load(ResourceName: string): InputTriggerChordAction;
	static Find(Outer: UObject, ResourceName: string): InputTriggerChordAction;
	static GetDefaultObject(): InputTriggerChordAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerChordAction;
	static C(Other: UObject | any): InputTriggerChordAction;
}

declare class InputTriggerChordBlocker extends InputTriggerChordAction { 
	static Load(ResourceName: string): InputTriggerChordBlocker;
	static Find(Outer: UObject, ResourceName: string): InputTriggerChordBlocker;
	static GetDefaultObject(): InputTriggerChordBlocker;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTriggerChordBlocker;
	static C(Other: UObject | any): InputTriggerChordBlocker;
}

declare class K2Node_EnhancedInputAction extends K2Node { 
	InputAction: InputAction;
	static Load(ResourceName: string): K2Node_EnhancedInputAction;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnhancedInputAction;
	static GetDefaultObject(): K2Node_EnhancedInputAction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnhancedInputAction;
	static C(Other: UObject | any): K2Node_EnhancedInputAction;
}

declare class K2Node_EnhancedInputActionEvent extends K2Node_Event { 
	InputAction: InputAction;
	TriggerEvent: ETriggerEvent;
	static Load(ResourceName: string): K2Node_EnhancedInputActionEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_EnhancedInputActionEvent;
	static GetDefaultObject(): K2Node_EnhancedInputActionEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EnhancedInputActionEvent;
	static C(Other: UObject | any): K2Node_EnhancedInputActionEvent;
}

declare class K2Node_GetInputActionValue extends K2Node { 
	InputAction: InputAction;
	static Load(ResourceName: string): K2Node_GetInputActionValue;
	static Find(Outer: UObject, ResourceName: string): K2Node_GetInputActionValue;
	static GetDefaultObject(): K2Node_GetInputActionValue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_GetInputActionValue;
	static C(Other: UObject | any): K2Node_GetInputActionValue;
}

declare class K2Node_InputActionValueAccessor extends K2Node_CallFunction { 
	InputAction: InputAction;
	static Load(ResourceName: string): K2Node_InputActionValueAccessor;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputActionValueAccessor;
	static GetDefaultObject(): K2Node_InputActionValueAccessor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputActionValueAccessor;
	static C(Other: UObject | any): K2Node_InputActionValueAccessor;
}

declare class K2Node_InputDebugKey extends K2Node { 
	InputKey: Key;
	bExecuteWhenPaused: boolean;
	bControl: boolean;
	bAlt: boolean;
	bShift: boolean;
	bCommand: boolean;
	static Load(ResourceName: string): K2Node_InputDebugKey;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputDebugKey;
	static GetDefaultObject(): K2Node_InputDebugKey;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputDebugKey;
	static C(Other: UObject | any): K2Node_InputDebugKey;
}

declare class K2Node_InputDebugKeyEvent extends K2Node_Event { 
	InputChord: InputChord;
	InputKeyEvent: EInputEvent;
	bExecuteWhenPaused: boolean;
	static Load(ResourceName: string): K2Node_InputDebugKeyEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_InputDebugKeyEvent;
	static GetDefaultObject(): K2Node_InputDebugKeyEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InputDebugKeyEvent;
	static C(Other: UObject | any): K2Node_InputDebugKeyEvent;
}

declare class DataRegistryIdFormat { 
	BaseGameplayTag: GameplayTag;
	clone() : DataRegistryIdFormat;
	static C(Other: UObject | any): DataRegistryIdFormat;
}

declare class DataRegistrySource extends UObject { 
	ParentSource: DataRegistrySource;
	static Load(ResourceName: string): DataRegistrySource;
	static Find(Outer: UObject, ResourceName: string): DataRegistrySource;
	static GetDefaultObject(): DataRegistrySource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataRegistrySource;
	static C(Other: UObject | any): DataRegistrySource;
}

declare class DataRegistryCachePolicy { 
	bCacheIsAlwaysVolatile: boolean;
	bUseCurveTableCacheVersion: boolean;
	MinNumberKept: number;
	MaxNumberKept: number;
	ForceKeepSeconds: number;
	ForceReleaseSeconds: number;
	clone() : DataRegistryCachePolicy;
	static C(Other: UObject | any): DataRegistryCachePolicy;
}

declare class DataRegistry extends UObject { 
	RegistryType: string;
	IdFormat: DataRegistryIdFormat;
	ItemStruct: ScriptStruct;
	DataSources: DataRegistrySource[];
	RuntimeSources: DataRegistrySource[];
	TimerUpdateFrequency: number;
	DefaultCachePolicy: DataRegistryCachePolicy;
	static Load(ResourceName: string): DataRegistry;
	static Find(Outer: UObject, ResourceName: string): DataRegistry;
	static GetDefaultObject(): DataRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataRegistry;
	static C(Other: UObject | any): DataRegistry;
}

declare class DataRegistrySettings extends DeveloperSettings { 
	DirectoriesToScan: DirectoryPath[];
	bInitializeAllLoadedRegistries: boolean;
	bIgnoreMissingCookedAssetRegistryData: boolean;
	static Load(ResourceName: string): DataRegistrySettings;
	static Find(Outer: UObject, ResourceName: string): DataRegistrySettings;
	static GetDefaultObject(): DataRegistrySettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataRegistrySettings;
	static C(Other: UObject | any): DataRegistrySettings;
}

declare type EMetaDataRegistrySourceAssetUsage = 'NoAssets' | 'SearchAssets' | 'RegisterAssets' | 'SearchAndRegisterAssets' | 'EMetaDataRegistrySourceAssetUsage_MAX';
declare var EMetaDataRegistrySourceAssetUsage : { NoAssets:'NoAssets',SearchAssets:'SearchAssets',RegisterAssets:'RegisterAssets',SearchAndRegisterAssets:'SearchAndRegisterAssets',EMetaDataRegistrySourceAssetUsage_MAX:'EMetaDataRegistrySourceAssetUsage_MAX', };
declare class AssetManagerSearchRules { 
	AssetScanPaths: string[];
	IncludePatterns: string[];
	ExcludePatterns: string[];
	AssetBaseClass: UnrealEngineClass;
	bHasBlueprintClasses: boolean;
	bForceSynchronousScan: boolean;
	bSkipVirtualPathExpansion: boolean;
	bSkipManagerIncludeCheck: boolean;
	clone() : AssetManagerSearchRules;
	static C(Other: UObject | any): AssetManagerSearchRules;
}

declare class MetaDataRegistrySource extends DataRegistrySource { 
	AssetUsage: EMetaDataRegistrySourceAssetUsage;
	SearchRules: AssetManagerSearchRules;
	RuntimeChildren: any;
	static Load(ResourceName: string): MetaDataRegistrySource;
	static Find(Outer: UObject, ResourceName: string): MetaDataRegistrySource;
	static GetDefaultObject(): MetaDataRegistrySource;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaDataRegistrySource;
	static C(Other: UObject | any): MetaDataRegistrySource;
}

declare class DataRegistrySource_DataTableRules { 
	bPrecacheTable: boolean;
	CachedTableKeepSeconds: number;
	clone() : DataRegistrySource_DataTableRules;
	static C(Other: UObject | any): DataRegistrySource_DataTableRules;
}

declare class DataRegistrySource_CurveTable extends DataRegistrySource { 
	SourceTable: CurveTable;
	TableRules: DataRegistrySource_DataTableRules;
	CachedTable: CurveTable;
	PreloadTable: CurveTable;
	static Load(ResourceName: string): DataRegistrySource_CurveTable;
	static Find(Outer: UObject, ResourceName: string): DataRegistrySource_CurveTable;
	static GetDefaultObject(): DataRegistrySource_CurveTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataRegistrySource_CurveTable;
	static C(Other: UObject | any): DataRegistrySource_CurveTable;
}

declare class MetaDataRegistrySource_CurveTable extends MetaDataRegistrySource { 
	CreatedSource: UnrealEngineClass;
	TableRules: DataRegistrySource_DataTableRules;
	static Load(ResourceName: string): MetaDataRegistrySource_CurveTable;
	static Find(Outer: UObject, ResourceName: string): MetaDataRegistrySource_CurveTable;
	static GetDefaultObject(): MetaDataRegistrySource_CurveTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaDataRegistrySource_CurveTable;
	static C(Other: UObject | any): MetaDataRegistrySource_CurveTable;
}

declare class DataRegistrySource_DataTable extends DataRegistrySource { 
	SourceTable: DataTable;
	TableRules: DataRegistrySource_DataTableRules;
	CachedTable: DataTable;
	PreloadTable: DataTable;
	static Load(ResourceName: string): DataRegistrySource_DataTable;
	static Find(Outer: UObject, ResourceName: string): DataRegistrySource_DataTable;
	static GetDefaultObject(): DataRegistrySource_DataTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataRegistrySource_DataTable;
	static C(Other: UObject | any): DataRegistrySource_DataTable;
}

declare class MetaDataRegistrySource_DataTable extends MetaDataRegistrySource { 
	CreatedSource: UnrealEngineClass;
	TableRules: DataRegistrySource_DataTableRules;
	static Load(ResourceName: string): MetaDataRegistrySource_DataTable;
	static Find(Outer: UObject, ResourceName: string): MetaDataRegistrySource_DataTable;
	static GetDefaultObject(): MetaDataRegistrySource_DataTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MetaDataRegistrySource_DataTable;
	static C(Other: UObject | any): MetaDataRegistrySource_DataTable;
}

declare class DataRegistryId { 
	RegistryType: DataRegistryType;
	ItemName: string;
	clone() : DataRegistryId;
	static C(Other: UObject | any): DataRegistryId;
}

declare class DataRegistryLookup { 
	clone() : DataRegistryLookup;
	static C(Other: UObject | any): DataRegistryLookup;
}

declare type EDataRegistrySubsystemGetItemResult = 'Found' | 'NotFound' | 'EDataRegistrySubsystemGetItemResult_MAX';
declare var EDataRegistrySubsystemGetItemResult : { Found:'Found',NotFound:'NotFound',EDataRegistrySubsystemGetItemResult_MAX:'EDataRegistrySubsystemGetItemResult_MAX', };
declare class DataRegistrySubsystem extends EngineSubsystem { 
	static Load(ResourceName: string): DataRegistrySubsystem;
	static Find(Outer: UObject, ResourceName: string): DataRegistrySubsystem;
	static GetDefaultObject(): DataRegistrySubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataRegistrySubsystem;
	static NotEqual_DataRegistryType(A: DataRegistryType,B: DataRegistryType): boolean;
	static NotEqual_DataRegistryId(A: DataRegistryId,B: DataRegistryId): boolean;
	static IsValidDataRegistryType(DataRegistryType: DataRegistryType): boolean;
	static IsValidDataRegistryId(DataRegistryId: DataRegistryId): boolean;
	static GetCachedItemFromLookupBP(ItemId: DataRegistryId,ResolvedLookup: DataRegistryLookup,OutItem?: TableRowBase): {OutItem: TableRowBase, $: boolean};
	static GetCachedItemBP(ItemId: DataRegistryId,OutItem?: TableRowBase): {OutItem: TableRowBase, $: boolean};
	static FindCachedItemBP(ItemId: DataRegistryId,OutResult?: EDataRegistrySubsystemGetItemResult,OutItem?: TableRowBase): {OutResult: EDataRegistrySubsystemGetItemResult, OutItem: TableRowBase};
	static EvaluateDataRegistryCurve(ItemId: DataRegistryId,InputValue: number,DefaultValue: number,OutResult?: EDataRegistrySubsystemGetItemResult,OutValue?: number): {OutResult: EDataRegistrySubsystemGetItemResult, OutValue: number};
	static EqualEqual_DataRegistryType(A: DataRegistryType,B: DataRegistryType): boolean;
	static EqualEqual_DataRegistryId(A: DataRegistryId,B: DataRegistryId): boolean;
	static Conv_DataRegistryTypeToString(DataRegistryType: DataRegistryType): string;
	static Conv_DataRegistryIdToString(DataRegistryId: DataRegistryId): string;
	static C(Other: UObject | any): DataRegistrySubsystem;
}

declare class AbilityAsync extends CancellableAsyncAction { 
	static Load(ResourceName: string): AbilityAsync;
	static Find(Outer: UObject, ResourceName: string): AbilityAsync;
	static GetDefaultObject(): AbilityAsync;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityAsync;
	EndAction(): void;
	static C(Other: UObject | any): AbilityAsync;
}

declare class AbilityAsync_WaitAttributeChanged extends AbilityAsync { 
	Changed: UnrealEngineMulticastDelegate<(Attribute: GameplayAttribute, NewValue: number, OldValue: number) => void>;
	static Load(ResourceName: string): AbilityAsync_WaitAttributeChanged;
	static Find(Outer: UObject, ResourceName: string): AbilityAsync_WaitAttributeChanged;
	static GetDefaultObject(): AbilityAsync_WaitAttributeChanged;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityAsync_WaitAttributeChanged;
	static WaitForAttributeChanged(TargetActor: Actor,Attribute: GameplayAttribute,OnlyTriggerOnce: boolean): AbilityAsync_WaitAttributeChanged;
	static C(Other: UObject | any): AbilityAsync_WaitAttributeChanged;
}

declare class AbilityAsync_WaitGameplayEffectApplied extends AbilityAsync { 
	OnApplied: UnrealEngineMulticastDelegate<(Source: Actor, SpecHandle: GameplayEffectSpecHandle, ActiveHandle: ActiveGameplayEffectHandle) => void>;
	static Load(ResourceName: string): AbilityAsync_WaitGameplayEffectApplied;
	static Find(Outer: UObject, ResourceName: string): AbilityAsync_WaitGameplayEffectApplied;
	static GetDefaultObject(): AbilityAsync_WaitGameplayEffectApplied;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityAsync_WaitGameplayEffectApplied;
	static WaitGameplayEffectAppliedToActor(TargetActor: Actor,SourceFilter: GameplayTargetDataFilterHandle,SourceTagRequirements: GameplayTagRequirements,TargetTagRequirements: GameplayTagRequirements,TriggerOnce: boolean,ListenForPeriodicEffect: boolean): AbilityAsync_WaitGameplayEffectApplied;
	static C(Other: UObject | any): AbilityAsync_WaitGameplayEffectApplied;
}

declare class AbilityAsync_WaitGameplayEvent extends AbilityAsync { 
	EventReceived: UnrealEngineMulticastDelegate<(Payload: GameplayEventData) => void>;
	static Load(ResourceName: string): AbilityAsync_WaitGameplayEvent;
	static Find(Outer: UObject, ResourceName: string): AbilityAsync_WaitGameplayEvent;
	static GetDefaultObject(): AbilityAsync_WaitGameplayEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityAsync_WaitGameplayEvent;
	static WaitGameplayEventToActor(TargetActor: Actor,EventTag: GameplayTag,OnlyTriggerOnce: boolean,OnlyMatchExact: boolean): AbilityAsync_WaitGameplayEvent;
	static C(Other: UObject | any): AbilityAsync_WaitGameplayEvent;
}

declare class AbilityAsync_WaitGameplayTag extends AbilityAsync { 
	static Load(ResourceName: string): AbilityAsync_WaitGameplayTag;
	static Find(Outer: UObject, ResourceName: string): AbilityAsync_WaitGameplayTag;
	static GetDefaultObject(): AbilityAsync_WaitGameplayTag;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityAsync_WaitGameplayTag;
	static C(Other: UObject | any): AbilityAsync_WaitGameplayTag;
}

declare class AbilityAsync_WaitGameplayTagAdded extends AbilityAsync_WaitGameplayTag { 
	Added: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AbilityAsync_WaitGameplayTagAdded;
	static Find(Outer: UObject, ResourceName: string): AbilityAsync_WaitGameplayTagAdded;
	static GetDefaultObject(): AbilityAsync_WaitGameplayTagAdded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityAsync_WaitGameplayTagAdded;
	static WaitGameplayTagAddToActor(TargetActor: Actor,Tag: GameplayTag,OnlyTriggerOnce: boolean): AbilityAsync_WaitGameplayTagAdded;
	static C(Other: UObject | any): AbilityAsync_WaitGameplayTagAdded;
}

declare class AbilityAsync_WaitGameplayTagRemoved extends AbilityAsync_WaitGameplayTag { 
	Removed: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AbilityAsync_WaitGameplayTagRemoved;
	static Find(Outer: UObject, ResourceName: string): AbilityAsync_WaitGameplayTagRemoved;
	static GetDefaultObject(): AbilityAsync_WaitGameplayTagRemoved;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityAsync_WaitGameplayTagRemoved;
	static WaitGameplayTagRemoveFromActor(TargetActor: Actor,Tag: GameplayTag,OnlyTriggerOnce: boolean): AbilityAsync_WaitGameplayTagRemoved;
	static C(Other: UObject | any): AbilityAsync_WaitGameplayTagRemoved;
}

declare type ETargetDataFilterSelf = 'TDFS_Any' | 'TDFS_NoSelf' | 'TDFS_NoOthers' | 'TDFS_MAX';
declare var ETargetDataFilterSelf : { TDFS_Any:'TDFS_Any',TDFS_NoSelf:'TDFS_NoSelf',TDFS_NoOthers:'TDFS_NoOthers',TDFS_MAX:'TDFS_MAX', };
declare class GameplayTargetDataFilter { 
	SelfActor: Actor;
	RequiredActorClass: UnrealEngineClass;
	SelfFilter: ETargetDataFilterSelf;
	bReverseFilter: boolean;
	clone() : GameplayTargetDataFilter;
	static C(Other: UObject | any): GameplayTargetDataFilter;
	MakeFilterHandle(FilterActor: Actor): GameplayTargetDataFilterHandle;
	static MakeFilterHandle(Filter: GameplayTargetDataFilter,FilterActor: Actor): GameplayTargetDataFilterHandle;
}

declare class AbilitySystemBlueprintLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): AbilitySystemBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): AbilitySystemBlueprintLibrary;
	static GetDefaultObject(): AbilitySystemBlueprintLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilitySystemBlueprintLibrary;
	static TargetDataHasOrigin(TargetData: GameplayAbilityTargetDataHandle,index: number): boolean;
	static TargetDataHasHitResult(HitResult: GameplayAbilityTargetDataHandle,index: number): boolean;
	static TargetDataHasEndPoint(TargetData: GameplayAbilityTargetDataHandle,index: number): boolean;
	static TargetDataHasActor(TargetData: GameplayAbilityTargetDataHandle,index: number): boolean;
	static SetStackCountToMax(SpecHandle: GameplayEffectSpecHandle): GameplayEffectSpecHandle;
	static SetStackCount(SpecHandle: GameplayEffectSpecHandle,StackCount: number): GameplayEffectSpecHandle;
	static SetDuration(SpecHandle: GameplayEffectSpecHandle,Duration: number): GameplayEffectSpecHandle;
	static SendGameplayEventToActor(Actor: Actor,EventTag: GameplayTag,Payload: GameplayEventData): void;
	static RemoveLooseGameplayTags(Actor: Actor,GameplayTags: GameplayTagContainer,bShouldReplicate: boolean): boolean;
	static NotEqual_GameplayAttributeGameplayAttribute(AttributeA: GameplayAttribute,AttributeB: GameplayAttribute): boolean;
	static NotEqual_GameplayAbilitySpecHandle(A: GameplayAbilitySpecHandle,B: GameplayAbilitySpecHandle): boolean;
	static NotEqual_ActiveGameplayEffectHandle(A: ActiveGameplayEffectHandle,B: ActiveGameplayEffectHandle): boolean;
	static MakeSpecHandle(InGameplayEffect: GameplayEffect,InInstigator: Actor,InEffectCauser: Actor,InLevel: number): GameplayEffectSpecHandle;
	static MakeGameplayCueParameters(NormalizedMagnitude: number,RawMagnitude: number,EffectContext: GameplayEffectContextHandle,MatchedTagName: GameplayTag,OriginalTag: GameplayTag,AggregatedSourceTags: GameplayTagContainer,AggregatedTargetTags: GameplayTagContainer,Location: Vector,Normal: Vector,Instigator: Actor,EffectCauser: Actor,SourceObject: UObject,PhysicalMaterial: PhysicalMaterial,GameplayEffectLevel: number,AbilityLevel: number,TargetAttachComponent: SceneComponent,bReplicateLocationWhenUsingMinimalRepProxy: boolean): GameplayCueParameters;
	static MakeFilterHandle(Filter: GameplayTargetDataFilter,FilterActor: Actor): GameplayTargetDataFilterHandle;
	static IsValid(Attribute: GameplayAttribute): boolean;
	static IsInstigatorLocallyControlledPlayer(Parameters: GameplayCueParameters): boolean;
	static IsInstigatorLocallyControlled(Parameters: GameplayCueParameters): boolean;
	static HasHitResult(Parameters: GameplayCueParameters): boolean;
	static GetTargetDataOrigin(TargetData: GameplayAbilityTargetDataHandle,index: number): Transform;
	static GetTargetDataEndPointTransform(TargetData: GameplayAbilityTargetDataHandle,index: number): Transform;
	static GetTargetDataEndPoint(TargetData: GameplayAbilityTargetDataHandle,index: number): Vector;
	static GetOrigin(Parameters: GameplayCueParameters): Vector;
	static GetModifiedAttributeMagnitude(SpecHandle: GameplayEffectSpecHandle,Attribute: GameplayAttribute): number;
	static GetInstigatorTransform(Parameters: GameplayCueParameters): Transform;
	static GetInstigatorActor(Parameters: GameplayCueParameters): Actor;
	static GetHitResultFromTargetData(HitResult: GameplayAbilityTargetDataHandle,index: number): HitResult;
	static GetHitResult(Parameters: GameplayCueParameters): HitResult;
	static GetGameplayEffectUIData(EffectClass: UnrealEngineClass,DataType: UnrealEngineClass): GameplayEffectUIData;
	static GetGameplayEffectFromActiveEffectHandle(ActiveHandle: ActiveGameplayEffectHandle): GameplayEffect;
	static GetGameplayCueEndLocationAndNormal(TargetActor: Actor,Parameters: GameplayCueParameters,Location?: Vector,Normal?: Vector): {Location: Vector, Normal: Vector, $: boolean};
	static GetGameplayCueDirection(TargetActor: Actor,Parameters: GameplayCueParameters,Direction?: Vector): {Direction: Vector, $: boolean};
	static GetGameplayAbilityFromSpecHandle(AbilitySystem: AbilitySystemComponent,AbilitySpecHandle: GameplayAbilitySpecHandle,bIsInstance?: boolean): {bIsInstance: boolean, $: GameplayAbility};
	static GetFloatAttributeFromAbilitySystemComponent(AbilitySystem: AbilitySystemComponent,Attribute: GameplayAttribute,bSuccessfullyFoundAttribute?: boolean): {bSuccessfullyFoundAttribute: boolean, $: number};
	static GetFloatAttributeBaseFromAbilitySystemComponent(AbilitySystemComponent: AbilitySystemComponent,Attribute: GameplayAttribute,bSuccessfullyFoundAttribute?: boolean): {bSuccessfullyFoundAttribute: boolean, $: number};
	static GetFloatAttributeBase(Actor: Actor,Attribute: GameplayAttribute,bSuccessfullyFoundAttribute?: boolean): {bSuccessfullyFoundAttribute: boolean, $: number};
	static GetFloatAttribute(Actor: Actor,Attribute: GameplayAttribute,bSuccessfullyFoundAttribute?: boolean): {bSuccessfullyFoundAttribute: boolean, $: number};
	static GetEffectContext(SpecHandle: GameplayEffectSpecHandle): GameplayEffectContextHandle;
	static GetDataCountFromTargetData(TargetData: GameplayAbilityTargetDataHandle): number;
	static GetAllLinkedGameplayEffectSpecHandles(SpecHandle: GameplayEffectSpecHandle): GameplayEffectSpecHandle[];
	static GetAllActorsFromTargetData(TargetData: GameplayAbilityTargetDataHandle): Actor[];
	static GetActorsFromTargetData(TargetData: GameplayAbilityTargetDataHandle,index: number): Actor[];
	static GetActorCount(Parameters: GameplayCueParameters): number;
	static GetActorByIndex(Parameters: GameplayCueParameters,index: number): Actor;
	static GetActiveGameplayEffectTotalDuration(ActiveHandle: ActiveGameplayEffectHandle): number;
	static GetActiveGameplayEffectStartTime(ActiveHandle: ActiveGameplayEffectHandle): number;
	static GetActiveGameplayEffectStackLimitCount(ActiveHandle: ActiveGameplayEffectHandle): number;
	static GetActiveGameplayEffectStackCount(ActiveHandle: ActiveGameplayEffectHandle): number;
	static GetActiveGameplayEffectRemainingDuration(WorldContextObject: UObject,ActiveHandle: ActiveGameplayEffectHandle): number;
	static GetActiveGameplayEffectExpectedEndTime(ActiveHandle: ActiveGameplayEffectHandle): number;
	static GetActiveGameplayEffectDebugString(ActiveHandle: ActiveGameplayEffectHandle): string;
	static GetAbilitySystemComponent(Actor: Actor): AbilitySystemComponent;
	static FilterTargetData(TargetDataHandle: GameplayAbilityTargetDataHandle,ActorFilterClass: GameplayTargetDataFilterHandle): GameplayAbilityTargetDataHandle;
	static EvaluateAttributeValueWithTagsAndBase(AbilitySystem: AbilitySystemComponent,Attribute: GameplayAttribute,SourceTags: GameplayTagContainer,TargetTags: GameplayTagContainer,BaseValue: number,bSuccess?: boolean): {bSuccess: boolean, $: number};
	static EvaluateAttributeValueWithTags(AbilitySystem: AbilitySystemComponent,Attribute: GameplayAttribute,SourceTags: GameplayTagContainer,TargetTags: GameplayTagContainer,bSuccess?: boolean): {bSuccess: boolean, $: number};
	static EqualEqual_GameplayAttributeGameplayAttribute(AttributeA: GameplayAttribute,AttributeB: GameplayAttribute): boolean;
	static EqualEqual_GameplayAbilitySpecHandle(A: GameplayAbilitySpecHandle,B: GameplayAbilitySpecHandle): boolean;
	static EqualEqual_ActiveGameplayEffectHandle(A: ActiveGameplayEffectHandle,B: ActiveGameplayEffectHandle): boolean;
	static EffectContextSetOrigin(EffectContext: GameplayEffectContextHandle,Origin: Vector): void;
	static EffectContextIsValid(EffectContext: GameplayEffectContextHandle): boolean;
	static EffectContextIsInstigatorLocallyControlled(EffectContext: GameplayEffectContextHandle): boolean;
	static EffectContextHasHitResult(EffectContext: GameplayEffectContextHandle): boolean;
	static EffectContextGetSourceObject(EffectContext: GameplayEffectContextHandle): UObject;
	static EffectContextGetOriginalInstigatorActor(EffectContext: GameplayEffectContextHandle): Actor;
	static EffectContextGetOrigin(EffectContext: GameplayEffectContextHandle): Vector;
	static EffectContextGetInstigatorActor(EffectContext: GameplayEffectContextHandle): Actor;
	static EffectContextGetHitResult(EffectContext: GameplayEffectContextHandle): HitResult;
	static EffectContextGetEffectCauser(EffectContext: GameplayEffectContextHandle): Actor;
	static EffectContextAddHitResult(EffectContext: GameplayEffectContextHandle,HitResult: HitResult,bReset: boolean): void;
	static DoesTargetDataContainActor(TargetData: GameplayAbilityTargetDataHandle,index: number,Actor: Actor): boolean;
	static DoesGameplayCueMeetTagRequirements(Parameters: GameplayCueParameters,SourceTagReqs: GameplayTagRequirements,TargetTagReqs: GameplayTagRequirements): boolean;
	static CloneSpecHandle(InNewInstigator: Actor,InEffectCauser: Actor,GameplayEffectSpecHandle_Clone: GameplayEffectSpecHandle): GameplayEffectSpecHandle;
	static BreakGameplayCueParameters(Parameters: GameplayCueParameters,NormalizedMagnitude?: number,RawMagnitude?: number,EffectContext?: GameplayEffectContextHandle,MatchedTagName?: GameplayTag,OriginalTag?: GameplayTag,AggregatedSourceTags?: GameplayTagContainer,AggregatedTargetTags?: GameplayTagContainer,Location?: Vector,Normal?: Vector,Instigator?: Actor,EffectCauser?: Actor,SourceObject?: UObject,PhysicalMaterial?: PhysicalMaterial,GameplayEffectLevel?: number,AbilityLevel?: number,TargetAttachComponent?: SceneComponent,bReplicateLocationWhenUsingMinimalRepProxy?: boolean): {NormalizedMagnitude: number, RawMagnitude: number, EffectContext: GameplayEffectContextHandle, MatchedTagName: GameplayTag, OriginalTag: GameplayTag, AggregatedSourceTags: GameplayTagContainer, AggregatedTargetTags: GameplayTagContainer, Location: Vector, Normal: Vector, Instigator: Actor, EffectCauser: Actor, SourceObject: UObject, PhysicalMaterial: PhysicalMaterial, GameplayEffectLevel: number, AbilityLevel: number, TargetAttachComponent: SceneComponent, bReplicateLocationWhenUsingMinimalRepProxy: boolean};
	static AssignTagSetByCallerMagnitude(SpecHandle: GameplayEffectSpecHandle,DataTag: GameplayTag,Magnitude: number): GameplayEffectSpecHandle;
	static AssignSetByCallerMagnitude(SpecHandle: GameplayEffectSpecHandle,DataName: string,Magnitude: number): GameplayEffectSpecHandle;
	static AppendTargetDataHandle(TargetHandle: GameplayAbilityTargetDataHandle,HandleToAdd: GameplayAbilityTargetDataHandle): GameplayAbilityTargetDataHandle;
	static AddLooseGameplayTags(Actor: Actor,GameplayTags: GameplayTagContainer,bShouldReplicate: boolean): boolean;
	static AddLinkedGameplayEffectSpec(SpecHandle: GameplayEffectSpecHandle,LinkedGameplayEffectSpec: GameplayEffectSpecHandle): GameplayEffectSpecHandle;
	static AddLinkedGameplayEffect(SpecHandle: GameplayEffectSpecHandle,LinkedGameplayEffect: UnrealEngineClass): GameplayEffectSpecHandle;
	static AddGrantedTags(SpecHandle: GameplayEffectSpecHandle,NewGameplayTags: GameplayTagContainer): GameplayEffectSpecHandle;
	static AddGrantedTag(SpecHandle: GameplayEffectSpecHandle,NewGameplayTag: GameplayTag): GameplayEffectSpecHandle;
	static AddAssetTags(SpecHandle: GameplayEffectSpecHandle,NewGameplayTags: GameplayTagContainer): GameplayEffectSpecHandle;
	static AddAssetTag(SpecHandle: GameplayEffectSpecHandle,NewGameplayTag: GameplayTag): GameplayEffectSpecHandle;
	static AbilityTargetDataFromLocations(SourceLocation: GameplayAbilityTargetingLocationInfo,TargetLocation: GameplayAbilityTargetingLocationInfo): GameplayAbilityTargetDataHandle;
	static AbilityTargetDataFromHitResult(HitResult: HitResult): GameplayAbilityTargetDataHandle;
	static AbilityTargetDataFromActorArray(ActorArray: Actor[],OneTargetPerHandle: boolean): GameplayAbilityTargetDataHandle;
	static AbilityTargetDataFromActor(Actor: Actor): GameplayAbilityTargetDataHandle;
	static C(Other: UObject | any): AbilitySystemBlueprintLibrary;
}

declare class AbilitySystemDebugHUD extends HUD { 
	static GetDefaultObject(): AbilitySystemDebugHUD;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilitySystemDebugHUD;
	static C(Other: UObject | any): AbilitySystemDebugHUD;
}

declare class NetSerializeScriptStructCache { 
	ScriptStructs: ScriptStruct[];
	clone() : NetSerializeScriptStructCache;
	static C(Other: UObject | any): NetSerializeScriptStructCache;
}

declare class GameplayTagReponsePair { 
	Tag: GameplayTag;
	ResponseGameplayEffect: UnrealEngineClass;
	ResponseGameplayEffects: UnrealEngineClass[];
	SoftCountCap: number;
	clone() : GameplayTagReponsePair;
	static C(Other: UObject | any): GameplayTagReponsePair;
}

declare class GameplayTagResponseTableEntry { 
	Positive: GameplayTagReponsePair;
	Negative: GameplayTagReponsePair;
	clone() : GameplayTagResponseTableEntry;
	static C(Other: UObject | any): GameplayTagResponseTableEntry;
}

declare class GameplayTagReponseTable extends DataAsset { 
	Entries: GameplayTagResponseTableEntry[];
	static Load(ResourceName: string): GameplayTagReponseTable;
	static Find(Outer: UObject, ResourceName: string): GameplayTagReponseTable;
	static GetDefaultObject(): GameplayTagReponseTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagReponseTable;
	TagResponseEvent(Tag: GameplayTag,NewCount: number,ASC: AbilitySystemComponent,idx: number): void;
	static C(Other: UObject | any): GameplayTagReponseTable;
}

declare class GameplayCueNotifyData { 
	GameplayCueTag: GameplayTag;
	GameplayCueNotifyObj: SoftObjectPath;
	LoadedGameplayCueClass: UnrealEngineClass;
	clone() : GameplayCueNotifyData;
	static C(Other: UObject | any): GameplayCueNotifyData;
}

declare class GameplayCueSet extends DataAsset { 
	GameplayCueData: GameplayCueNotifyData[];
	static Load(ResourceName: string): GameplayCueSet;
	static Find(Outer: UObject, ResourceName: string): GameplayCueSet;
	static GetDefaultObject(): GameplayCueSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayCueSet;
	static C(Other: UObject | any): GameplayCueSet;
}

declare class GameplayCueObjectLibrary { 
	Paths: string[];
	ActorObjectLibrary: ObjectLibrary;
	StaticObjectLibrary: ObjectLibrary;
	CueSet: GameplayCueSet;
	bShouldSyncScan: boolean;
	bShouldAsyncLoad: boolean;
	bShouldSyncLoad: boolean;
	bHasBeenInitialized: boolean;
	clone() : GameplayCueObjectLibrary;
	static C(Other: UObject | any): GameplayCueObjectLibrary;
}

declare type EGameplayCueEvent = 'OnActive' | 'WhileActive' | 'Executed' | 'Removed' | 'EGameplayCueEvent_MAX';
declare var EGameplayCueEvent : { OnActive:'OnActive',WhileActive:'WhileActive',Executed:'Executed',Removed:'Removed',EGameplayCueEvent_MAX:'EGameplayCueEvent_MAX', };
declare class GameplayCueNotify_Actor extends Actor { 
	bAutoDestroyOnRemove: boolean;
	AutoDestroyDelay: number;
	WarnIfTimelineIsStillRunning: boolean;
	WarnIfLatentActionIsStillRunning: boolean;
	GameplayCueTag: GameplayTag;
	GameplayCueName: string;
	bAutoAttachToOwner: boolean;
	IsOverride: boolean;
	bUniqueInstancePerInstigator: boolean;
	bUniqueInstancePerSourceObject: boolean;
	bAllowMultipleOnActiveEvents: boolean;
	bAllowMultipleWhileActiveEvents: boolean;
	NumPreallocatedInstances: number;
	static GetDefaultObject(): GameplayCueNotify_Actor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayCueNotify_Actor;
	WhileActive(MyTarget: Actor,Parameters: GameplayCueParameters): boolean;
	OnRemove(MyTarget: Actor,Parameters: GameplayCueParameters): boolean;
	OnOwnerDestroyed(DestroyedActor: Actor): void;
	OnExecute(MyTarget: Actor,Parameters: GameplayCueParameters): boolean;
	OnActive(MyTarget: Actor,Parameters: GameplayCueParameters): boolean;
	K2_HandleGameplayCue(MyTarget: Actor,EventType: EGameplayCueEvent,Parameters: GameplayCueParameters): void;
	K2_EndGameplayCue(): void;
	static C(Other: UObject | any): GameplayCueNotify_Actor;
}

declare type EGameplayCuePayloadType = 'CueParameters' | 'FromSpec' | 'EGameplayCuePayloadType_MAX';
declare var EGameplayCuePayloadType : { CueParameters:'CueParameters',FromSpec:'FromSpec',EGameplayCuePayloadType_MAX:'EGameplayCuePayloadType_MAX', };
declare class GameplayCuePendingExecute { 
	PredictionKey: PredictionKey;
	PayloadType: EGameplayCuePayloadType;
	OwningComponent: AbilitySystemComponent;
	FromSpec: GameplayEffectSpecForRPC;
	CueParameters: GameplayCueParameters;
	clone() : GameplayCuePendingExecute;
	static C(Other: UObject | any): GameplayCuePendingExecute;
}

declare class PreallocationInfo { 
	PreallocatedInstances: any;
	ClassesNeedingPreallocation: UnrealEngineClass[];
	clone() : PreallocationInfo;
	static C(Other: UObject | any): PreallocationInfo;
}

declare class GameplayCueManager extends DataAsset { 
	RuntimeGameplayCueObjectLibrary: GameplayCueObjectLibrary;
	EditorGameplayCueObjectLibrary: GameplayCueObjectLibrary;
	LoadedGameplayCueNotifyClasses: UnrealEngineClass[];
	GameplayCueClassesForPreallocation: UnrealEngineClass[];
	PendingExecuteCues: GameplayCuePendingExecute[];
	GameplayCueSendContextCount: number;
	PreallocationInfoList_Internal: PreallocationInfo[];
	static Load(ResourceName: string): GameplayCueManager;
	static Find(Outer: UObject, ResourceName: string): GameplayCueManager;
	static GetDefaultObject(): GameplayCueManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayCueManager;
	static C(Other: UObject | any): GameplayCueManager;
}

declare class AbilitySystemGlobals extends UObject { 
	AbilitySystemGlobalsClassName: SoftClassPath;
	bUseDebugTargetFromHud: boolean;
	ActivateFailIsDeadTag: GameplayTag;
	ActivateFailIsDeadName: string;
	ActivateFailCooldownTag: GameplayTag;
	ActivateFailCooldownName: string;
	ActivateFailCostTag: GameplayTag;
	ActivateFailCostName: string;
	ActivateFailTagsBlockedTag: GameplayTag;
	ActivateFailTagsBlockedName: string;
	ActivateFailTagsMissingTag: GameplayTag;
	ActivateFailTagsMissingName: string;
	ActivateFailNetworkingTag: GameplayTag;
	ActivateFailNetworkingName: string;
	MinimalReplicationTagCountBits: number;
	TargetDataStructCache: NetSerializeScriptStructCache;
	bAllowGameplayModEvaluationChannels: boolean;
	DefaultGameplayModEvaluationChannel: EGameplayModEvaluationChannel;
	GameplayModEvaluationChannelAliases: string;
	GlobalCurveTableName: SoftObjectPath;
	GlobalCurveTable: CurveTable;
	GlobalAttributeMetaDataTableName: SoftObjectPath;
	GlobalAttributeMetaDataTable: DataTable;
	GlobalAttributeSetDefaultsTableName: SoftObjectPath;
	GlobalAttributeSetDefaultsTableNames: SoftObjectPath[];
	GlobalAttributeDefaultsTables: CurveTable[];
	GlobalGameplayCueManagerClass: SoftObjectPath;
	GlobalGameplayCueManagerName: SoftObjectPath;
	GameplayCueNotifyPaths: string[];
	GameplayTagResponseTableName: SoftObjectPath;
	GameplayTagResponseTable: GameplayTagReponseTable;
	PredictTargetGameplayEffects: boolean;
	ReplicateActivationOwnedTags: boolean;
	GlobalGameplayCueManager: GameplayCueManager;
	static Load(ResourceName: string): AbilitySystemGlobals;
	static Find(Outer: UObject, ResourceName: string): AbilitySystemGlobals;
	static GetDefaultObject(): AbilitySystemGlobals;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilitySystemGlobals;
	ToggleIgnoreAbilitySystemCosts(): void;
	ToggleIgnoreAbilitySystemCooldowns(): void;
	ServerEndPlayerAbility(AbilityNameMatch: string): void;
	ServerCancelPlayerAbility(AbilityNameMatch: string): void;
	ServerActivatePlayerAbility(AbilityNameMatch: string): void;
	ListPlayerAbilities(): void;
	static C(Other: UObject | any): AbilitySystemGlobals;
}

declare class AbilitySystemInterface extends Interface { 
	static Load(ResourceName: string): AbilitySystemInterface;
	static Find(Outer: UObject, ResourceName: string): AbilitySystemInterface;
	static GetDefaultObject(): AbilitySystemInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilitySystemInterface;
	static C(Other: UObject | any): AbilitySystemInterface;
}

declare class AbilitySystemReplicationProxyInterface extends Interface { 
	static Load(ResourceName: string): AbilitySystemReplicationProxyInterface;
	static Find(Outer: UObject, ResourceName: string): AbilitySystemReplicationProxyInterface;
	static GetDefaultObject(): AbilitySystemReplicationProxyInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilitySystemReplicationProxyInterface;
	static C(Other: UObject | any): AbilitySystemReplicationProxyInterface;
}

declare class AbilitySystemTestAttributeSet extends AttributeSet { 
	MaxHealth: number;
	Health: number;
	Mana: number;
	MaxMana: number;
	Damage: number;
	SpellDamage: number;
	PhysicalDamage: number;
	CritChance: number;
	CritMultiplier: number;
	ArmorDamageReduction: number;
	DodgeChance: number;
	LifeSteal: number;
	Strength: number;
	StackingAttribute1: number;
	StackingAttribute2: number;
	NoStackAttribute: number;
	static Load(ResourceName: string): AbilitySystemTestAttributeSet;
	static Find(Outer: UObject, ResourceName: string): AbilitySystemTestAttributeSet;
	static GetDefaultObject(): AbilitySystemTestAttributeSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilitySystemTestAttributeSet;
	static C(Other: UObject | any): AbilitySystemTestAttributeSet;
}

declare class AbilitySystemTestPawn extends DefaultPawn { 
	AbilitySystemComponent: AbilitySystemComponent;
	static GetDefaultObject(): AbilitySystemTestPawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilitySystemTestPawn;
	static C(Other: UObject | any): AbilitySystemTestPawn;
}

declare class AbilityTask extends GameplayTask { 
	Ability: GameplayAbility;
	AbilitySystemComponent: AbilitySystemComponent;
	static Load(ResourceName: string): AbilityTask;
	static Find(Outer: UObject, ResourceName: string): AbilityTask;
	static GetDefaultObject(): AbilityTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask;
	static C(Other: UObject | any): AbilityTask;
}

declare type ERootMotionFinishVelocityMode = 'MaintainLastRootMotionVelocity' | 'SetVelocity' | 'ClampVelocity' | 'ERootMotionFinishVelocityMode_MAX';
declare var ERootMotionFinishVelocityMode : { MaintainLastRootMotionVelocity:'MaintainLastRootMotionVelocity',SetVelocity:'SetVelocity',ClampVelocity:'ClampVelocity',ERootMotionFinishVelocityMode_MAX:'ERootMotionFinishVelocityMode_MAX', };
declare class AbilityTask_ApplyRootMotion_Base extends AbilityTask { 
	ForceName: string;
	FinishVelocityMode: ERootMotionFinishVelocityMode;
	FinishSetVelocity: Vector;
	FinishClampVelocity: number;
	MovementComponent: CharacterMovementComponent;
	static Load(ResourceName: string): AbilityTask_ApplyRootMotion_Base;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_ApplyRootMotion_Base;
	static GetDefaultObject(): AbilityTask_ApplyRootMotion_Base;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_ApplyRootMotion_Base;
	static C(Other: UObject | any): AbilityTask_ApplyRootMotion_Base;
}

declare class AbilityTask_ApplyRootMotionConstantForce extends AbilityTask_ApplyRootMotion_Base { 
	OnFinish: UnrealEngineMulticastDelegate<() => void>;
	WorldDirection: Vector;
	Strength: number;
	Duration: number;
	bIsAdditive: boolean;
	StrengthOverTime: CurveFloat;
	bEnableGravity: boolean;
	static Load(ResourceName: string): AbilityTask_ApplyRootMotionConstantForce;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_ApplyRootMotionConstantForce;
	static GetDefaultObject(): AbilityTask_ApplyRootMotionConstantForce;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_ApplyRootMotionConstantForce;
	static ApplyRootMotionConstantForce(OwningAbility: GameplayAbility,TaskInstanceName: string,WorldDirection: Vector,Strength: number,Duration: number,bIsAdditive: boolean,StrengthOverTime: CurveFloat,VelocityOnFinishMode: ERootMotionFinishVelocityMode,SetVelocityOnFinish: Vector,ClampVelocityOnFinish: number,bEnableGravity: boolean): AbilityTask_ApplyRootMotionConstantForce;
	static C(Other: UObject | any): AbilityTask_ApplyRootMotionConstantForce;
}

declare class AbilityTask_ApplyRootMotionJumpForce extends AbilityTask_ApplyRootMotion_Base { 
	OnFinish: UnrealEngineMulticastDelegate<() => void>;
	OnLanded: UnrealEngineMulticastDelegate<() => void>;
	Rotation: Rotator;
	Distance: number;
	Height: number;
	Duration: number;
	MinimumLandedTriggerTime: number;
	bFinishOnLanded: boolean;
	PathOffsetCurve: CurveVector;
	TimeMappingCurve: CurveFloat;
	static Load(ResourceName: string): AbilityTask_ApplyRootMotionJumpForce;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_ApplyRootMotionJumpForce;
	static GetDefaultObject(): AbilityTask_ApplyRootMotionJumpForce;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_ApplyRootMotionJumpForce;
	OnLandedCallback(Hit: HitResult): void;
	Finish(): void;
	static ApplyRootMotionJumpForce(OwningAbility: GameplayAbility,TaskInstanceName: string,Rotation: Rotator,Distance: number,Height: number,Duration: number,MinimumLandedTriggerTime: number,bFinishOnLanded: boolean,VelocityOnFinishMode: ERootMotionFinishVelocityMode,SetVelocityOnFinish: Vector,ClampVelocityOnFinish: number,PathOffsetCurve: CurveVector,TimeMappingCurve: CurveFloat): AbilityTask_ApplyRootMotionJumpForce;
	static C(Other: UObject | any): AbilityTask_ApplyRootMotionJumpForce;
}

declare type ERootMotionMoveToActorTargetOffsetType = 'AlignFromTargetToSource' | 'AlignToTargetForward' | 'AlignToWorldSpace' | 'ERootMotionMoveToActorTargetOffsetType_MAX';
declare var ERootMotionMoveToActorTargetOffsetType : { AlignFromTargetToSource:'AlignFromTargetToSource',AlignToTargetForward:'AlignToTargetForward',AlignToWorldSpace:'AlignToWorldSpace',ERootMotionMoveToActorTargetOffsetType_MAX:'ERootMotionMoveToActorTargetOffsetType_MAX', };
declare class AbilityTask_ApplyRootMotionMoveToActorForce extends AbilityTask_ApplyRootMotion_Base { 
	OnFinished: UnrealEngineMulticastDelegate<(DestinationReached: boolean, TimedOut: boolean, FinalTargetLocation: Vector) => void>;
	StartLocation: Vector;
	TargetLocation: Vector;
	TargetActor: Actor;
	TargetLocationOffset: Vector;
	OffsetAlignment: ERootMotionMoveToActorTargetOffsetType;
	Duration: number;
	bDisableDestinationReachedInterrupt: boolean;
	bSetNewMovementMode: boolean;
	NewMovementMode: EMovementMode;
	bRestrictSpeedToExpected: boolean;
	PathOffsetCurve: CurveVector;
	TimeMappingCurve: CurveFloat;
	TargetLerpSpeedHorizontalCurve: CurveFloat;
	TargetLerpSpeedVerticalCurve: CurveFloat;
	static Load(ResourceName: string): AbilityTask_ApplyRootMotionMoveToActorForce;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_ApplyRootMotionMoveToActorForce;
	static GetDefaultObject(): AbilityTask_ApplyRootMotionMoveToActorForce;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_ApplyRootMotionMoveToActorForce;
	OnTargetActorSwapped(OriginalTarget: Actor,NewTarget: Actor): void;
	OnRep_TargetLocation(): void;
	static ApplyRootMotionMoveToTargetDataActorForce(OwningAbility: GameplayAbility,TaskInstanceName: string,TargetDataHandle: GameplayAbilityTargetDataHandle,TargetDataIndex: number,TargetActorIndex: number,TargetLocationOffset: Vector,OffsetAlignment: ERootMotionMoveToActorTargetOffsetType,Duration: number,TargetLerpSpeedHorizontal: CurveFloat,TargetLerpSpeedVertical: CurveFloat,bSetNewMovementMode: boolean,MovementMode: EMovementMode,bRestrictSpeedToExpected: boolean,PathOffsetCurve: CurveVector,TimeMappingCurve: CurveFloat,VelocityOnFinishMode: ERootMotionFinishVelocityMode,SetVelocityOnFinish: Vector,ClampVelocityOnFinish: number,bDisableDestinationReachedInterrupt: boolean): AbilityTask_ApplyRootMotionMoveToActorForce;
	static ApplyRootMotionMoveToActorForce(OwningAbility: GameplayAbility,TaskInstanceName: string,TargetActor: Actor,TargetLocationOffset: Vector,OffsetAlignment: ERootMotionMoveToActorTargetOffsetType,Duration: number,TargetLerpSpeedHorizontal: CurveFloat,TargetLerpSpeedVertical: CurveFloat,bSetNewMovementMode: boolean,MovementMode: EMovementMode,bRestrictSpeedToExpected: boolean,PathOffsetCurve: CurveVector,TimeMappingCurve: CurveFloat,VelocityOnFinishMode: ERootMotionFinishVelocityMode,SetVelocityOnFinish: Vector,ClampVelocityOnFinish: number,bDisableDestinationReachedInterrupt: boolean): AbilityTask_ApplyRootMotionMoveToActorForce;
	static C(Other: UObject | any): AbilityTask_ApplyRootMotionMoveToActorForce;
}

declare class AbilityTask_ApplyRootMotionMoveToForce extends AbilityTask_ApplyRootMotion_Base { 
	OnTimedOut: UnrealEngineMulticastDelegate<() => void>;
	OnTimedOutAndDestinationReached: UnrealEngineMulticastDelegate<() => void>;
	StartLocation: Vector;
	TargetLocation: Vector;
	Duration: number;
	bSetNewMovementMode: boolean;
	NewMovementMode: EMovementMode;
	bRestrictSpeedToExpected: boolean;
	PathOffsetCurve: CurveVector;
	static Load(ResourceName: string): AbilityTask_ApplyRootMotionMoveToForce;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_ApplyRootMotionMoveToForce;
	static GetDefaultObject(): AbilityTask_ApplyRootMotionMoveToForce;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_ApplyRootMotionMoveToForce;
	static ApplyRootMotionMoveToForce(OwningAbility: GameplayAbility,TaskInstanceName: string,TargetLocation: Vector,Duration: number,bSetNewMovementMode: boolean,MovementMode: EMovementMode,bRestrictSpeedToExpected: boolean,PathOffsetCurve: CurveVector,VelocityOnFinishMode: ERootMotionFinishVelocityMode,SetVelocityOnFinish: Vector,ClampVelocityOnFinish: number): AbilityTask_ApplyRootMotionMoveToForce;
	static C(Other: UObject | any): AbilityTask_ApplyRootMotionMoveToForce;
}

declare class AbilityTask_ApplyRootMotionRadialForce extends AbilityTask_ApplyRootMotion_Base { 
	OnFinish: UnrealEngineMulticastDelegate<() => void>;
	Location: Vector;
	LocationActor: Actor;
	Strength: number;
	Duration: number;
	Radius: number;
	bIsPush: boolean;
	bIsAdditive: boolean;
	bNoZForce: boolean;
	StrengthDistanceFalloff: CurveFloat;
	StrengthOverTime: CurveFloat;
	bUseFixedWorldDirection: boolean;
	FixedWorldDirection: Rotator;
	static Load(ResourceName: string): AbilityTask_ApplyRootMotionRadialForce;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_ApplyRootMotionRadialForce;
	static GetDefaultObject(): AbilityTask_ApplyRootMotionRadialForce;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_ApplyRootMotionRadialForce;
	static ApplyRootMotionRadialForce(OwningAbility: GameplayAbility,TaskInstanceName: string,Location: Vector,LocationActor: Actor,Strength: number,Duration: number,Radius: number,bIsPush: boolean,bIsAdditive: boolean,bNoZForce: boolean,StrengthDistanceFalloff: CurveFloat,StrengthOverTime: CurveFloat,bUseFixedWorldDirection: boolean,FixedWorldDirection: Rotator,VelocityOnFinishMode: ERootMotionFinishVelocityMode,SetVelocityOnFinish: Vector,ClampVelocityOnFinish: number): AbilityTask_ApplyRootMotionRadialForce;
	static C(Other: UObject | any): AbilityTask_ApplyRootMotionRadialForce;
}

declare class AbilityTask_MoveToLocation extends AbilityTask { 
	OnTargetLocationReached: UnrealEngineMulticastDelegate<() => void>;
	StartLocation: Vector;
	TargetLocation: Vector;
	DurationOfMovement: number;
	LerpCurve: CurveFloat;
	LerpCurveVector: CurveVector;
	static Load(ResourceName: string): AbilityTask_MoveToLocation;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_MoveToLocation;
	static GetDefaultObject(): AbilityTask_MoveToLocation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_MoveToLocation;
	static MoveToLocation(OwningAbility: GameplayAbility,TaskInstanceName: string,Location: Vector,Duration: number,OptionalInterpolationCurve: CurveFloat,OptionalVectorInterpolationCurve: CurveVector): AbilityTask_MoveToLocation;
	static C(Other: UObject | any): AbilityTask_MoveToLocation;
}

declare type EAbilityTaskNetSyncType = 'BothWait' | 'OnlyServerWait' | 'OnlyClientWait' | 'EAbilityTaskNetSyncType_MAX';
declare var EAbilityTaskNetSyncType : { BothWait:'BothWait',OnlyServerWait:'OnlyServerWait',OnlyClientWait:'OnlyClientWait',EAbilityTaskNetSyncType_MAX:'EAbilityTaskNetSyncType_MAX', };
declare class AbilityTask_NetworkSyncPoint extends AbilityTask { 
	OnSync: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AbilityTask_NetworkSyncPoint;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_NetworkSyncPoint;
	static GetDefaultObject(): AbilityTask_NetworkSyncPoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_NetworkSyncPoint;
	static WaitNetSync(OwningAbility: GameplayAbility,SyncType: EAbilityTaskNetSyncType): AbilityTask_NetworkSyncPoint;
	OnSignalCallback(): void;
	static C(Other: UObject | any): AbilityTask_NetworkSyncPoint;
}

declare class AbilityTask_PlayMontageAndWait extends AbilityTask { 
	OnCompleted: UnrealEngineMulticastDelegate<() => void>;
	OnBlendOut: UnrealEngineMulticastDelegate<() => void>;
	OnInterrupted: UnrealEngineMulticastDelegate<() => void>;
	OnCancelled: UnrealEngineMulticastDelegate<() => void>;
	MontageToPlay: AnimMontage;
	Rate: number;
	StartSection: string;
	AnimRootMotionTranslationScale: number;
	StartTimeSeconds: number;
	bStopWhenAbilityEnds: boolean;
	static Load(ResourceName: string): AbilityTask_PlayMontageAndWait;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_PlayMontageAndWait;
	static GetDefaultObject(): AbilityTask_PlayMontageAndWait;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_PlayMontageAndWait;
	OnMontageInterrupted(): void;
	OnMontageEnded(Montage: AnimMontage,bInterrupted: boolean): void;
	OnMontageBlendingOut(Montage: AnimMontage,bInterrupted: boolean): void;
	static CreatePlayMontageAndWaitProxy(OwningAbility: GameplayAbility,TaskInstanceName: string,MontageToPlay: AnimMontage,Rate: number,StartSection: string,bStopWhenAbilityEnds: boolean,AnimRootMotionTranslationScale: number,StartTimeSeconds: number): AbilityTask_PlayMontageAndWait;
	static C(Other: UObject | any): AbilityTask_PlayMontageAndWait;
}

declare class AbilityTask_Repeat extends AbilityTask { 
	OnPerformAction: UnrealEngineMulticastDelegate<(ActionNumber: number) => void>;
	OnFinished: UnrealEngineMulticastDelegate<(ActionNumber: number) => void>;
	static Load(ResourceName: string): AbilityTask_Repeat;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_Repeat;
	static GetDefaultObject(): AbilityTask_Repeat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_Repeat;
	static RepeatAction(OwningAbility: GameplayAbility,TimeBetweenActions: number,TotalActionCount: number): AbilityTask_Repeat;
	static C(Other: UObject | any): AbilityTask_Repeat;
}

declare class AbilityTask_SpawnActor extends AbilityTask { 
	Success: UnrealEngineMulticastDelegate<(SpawnedActor: Actor) => void>;
	DidNotSpawn: UnrealEngineMulticastDelegate<(SpawnedActor: Actor) => void>;
	static Load(ResourceName: string): AbilityTask_SpawnActor;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_SpawnActor;
	static GetDefaultObject(): AbilityTask_SpawnActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_SpawnActor;
	static SpawnActor(OwningAbility: GameplayAbility,TargetData: GameplayAbilityTargetDataHandle,Class: UnrealEngineClass): AbilityTask_SpawnActor;
	FinishSpawningActor(OwningAbility: GameplayAbility,TargetData: GameplayAbilityTargetDataHandle,SpawnedActor: Actor): void;
	BeginSpawningActor(OwningAbility: GameplayAbility,TargetData: GameplayAbilityTargetDataHandle,Class: UnrealEngineClass,SpawnedActor?: Actor): {SpawnedActor: Actor, $: boolean};
	static C(Other: UObject | any): AbilityTask_SpawnActor;
}

declare class AbilityTask_StartAbilityState extends AbilityTask { 
	OnStateEnded: UnrealEngineMulticastDelegate<() => void>;
	OnStateInterrupted: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AbilityTask_StartAbilityState;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_StartAbilityState;
	static GetDefaultObject(): AbilityTask_StartAbilityState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_StartAbilityState;
	static StartAbilityState(OwningAbility: GameplayAbility,StateName: string,bEndCurrentState: boolean): AbilityTask_StartAbilityState;
	static C(Other: UObject | any): AbilityTask_StartAbilityState;
}

declare class AbilityTask_VisualizeTargeting extends AbilityTask { 
	TimeElapsed: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AbilityTask_VisualizeTargeting;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_VisualizeTargeting;
	static GetDefaultObject(): AbilityTask_VisualizeTargeting;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_VisualizeTargeting;
	static VisualizeTargetingUsingActor(OwningAbility: GameplayAbility,TargetActor: GameplayAbilityTargetActor,TaskInstanceName: string,Duration: number): AbilityTask_VisualizeTargeting;
	static VisualizeTargeting(OwningAbility: GameplayAbility,Class: UnrealEngineClass,TaskInstanceName: string,Duration: number): AbilityTask_VisualizeTargeting;
	FinishSpawningActor(OwningAbility: GameplayAbility,SpawnedActor: GameplayAbilityTargetActor): void;
	BeginSpawningActor(OwningAbility: GameplayAbility,Class: UnrealEngineClass,SpawnedActor?: GameplayAbilityTargetActor): {SpawnedActor: GameplayAbilityTargetActor, $: boolean};
	static C(Other: UObject | any): AbilityTask_VisualizeTargeting;
}

declare class AbilityTask_WaitAbilityActivate extends AbilityTask { 
	OnActivate: UnrealEngineMulticastDelegate<(ActivatedAbility: GameplayAbility) => void>;
	static Load(ResourceName: string): AbilityTask_WaitAbilityActivate;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitAbilityActivate;
	static GetDefaultObject(): AbilityTask_WaitAbilityActivate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitAbilityActivate;
	static WaitForAbilityActivateWithTagRequirements(OwningAbility: GameplayAbility,TagRequirements: GameplayTagRequirements,IncludeTriggeredAbilities: boolean,TriggerOnce: boolean): AbilityTask_WaitAbilityActivate;
	static WaitForAbilityActivate_Query(OwningAbility: GameplayAbility,Query: GameplayTagQuery,IncludeTriggeredAbilities: boolean,TriggerOnce: boolean): AbilityTask_WaitAbilityActivate;
	static WaitForAbilityActivate(OwningAbility: GameplayAbility,WithTag: GameplayTag,WithoutTag: GameplayTag,IncludeTriggeredAbilities: boolean,TriggerOnce: boolean): AbilityTask_WaitAbilityActivate;
	OnAbilityActivate(ActivatedAbility: GameplayAbility): void;
	static C(Other: UObject | any): AbilityTask_WaitAbilityActivate;
}

declare class AbilityTask_WaitAbilityCommit extends AbilityTask { 
	OnCommit: UnrealEngineMulticastDelegate<(ActivatedAbility: GameplayAbility) => void>;
	static Load(ResourceName: string): AbilityTask_WaitAbilityCommit;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitAbilityCommit;
	static GetDefaultObject(): AbilityTask_WaitAbilityCommit;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitAbilityCommit;
	static WaitForAbilityCommit_Query(OwningAbility: GameplayAbility,Query: GameplayTagQuery,TriggerOnce: boolean): AbilityTask_WaitAbilityCommit;
	static WaitForAbilityCommit(OwningAbility: GameplayAbility,WithTag: GameplayTag,WithoutTage: GameplayTag,TriggerOnce: boolean): AbilityTask_WaitAbilityCommit;
	OnAbilityCommit(ActivatedAbility: GameplayAbility): void;
	static C(Other: UObject | any): AbilityTask_WaitAbilityCommit;
}

declare type EWaitAttributeChangeComparison = 'None' | 'GreaterThan' | 'LessThan' | 'GreaterThanOrEqualTo' | 'LessThanOrEqualTo' | 'NotEqualTo' | 'ExactlyEqualTo' | 'MAX';
declare var EWaitAttributeChangeComparison : { None:'None',GreaterThan:'GreaterThan',LessThan:'LessThan',GreaterThanOrEqualTo:'GreaterThanOrEqualTo',LessThanOrEqualTo:'LessThanOrEqualTo',NotEqualTo:'NotEqualTo',ExactlyEqualTo:'ExactlyEqualTo',MAX:'MAX', };
declare class AbilityTask_WaitAttributeChange extends AbilityTask { 
	OnChange: UnrealEngineMulticastDelegate<() => void>;
	ExternalOwner: AbilitySystemComponent;
	static Load(ResourceName: string): AbilityTask_WaitAttributeChange;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitAttributeChange;
	static GetDefaultObject(): AbilityTask_WaitAttributeChange;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitAttributeChange;
	static WaitForAttributeChangeWithComparison(OwningAbility: GameplayAbility,InAttribute: GameplayAttribute,InWithTag: GameplayTag,InWithoutTag: GameplayTag,InComparisonType: EWaitAttributeChangeComparison,InComparisonValue: number,TriggerOnce: boolean,OptionalExternalOwner: Actor): AbilityTask_WaitAttributeChange;
	static WaitForAttributeChange(OwningAbility: GameplayAbility,Attribute: GameplayAttribute,WithSrcTag: GameplayTag,WithoutSrcTag: GameplayTag,TriggerOnce: boolean,OptionalExternalOwner: Actor): AbilityTask_WaitAttributeChange;
	static C(Other: UObject | any): AbilityTask_WaitAttributeChange;
}

declare class AbilityTask_WaitAttributeChangeRatioThreshold extends AbilityTask { 
	OnChange: UnrealEngineMulticastDelegate<(bMatchesComparison: boolean, CurrentRatio: number) => void>;
	ExternalOwner: AbilitySystemComponent;
	static Load(ResourceName: string): AbilityTask_WaitAttributeChangeRatioThreshold;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitAttributeChangeRatioThreshold;
	static GetDefaultObject(): AbilityTask_WaitAttributeChangeRatioThreshold;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitAttributeChangeRatioThreshold;
	static WaitForAttributeChangeRatioThreshold(OwningAbility: GameplayAbility,AttributeNumerator: GameplayAttribute,AttributeDenominator: GameplayAttribute,ComparisonType: EWaitAttributeChangeComparison,ComparisonValue: number,bTriggerOnce: boolean,OptionalExternalOwner: Actor): AbilityTask_WaitAttributeChangeRatioThreshold;
	static C(Other: UObject | any): AbilityTask_WaitAttributeChangeRatioThreshold;
}

declare class AbilityTask_WaitAttributeChangeThreshold extends AbilityTask { 
	OnChange: UnrealEngineMulticastDelegate<(bMatchesComparison: boolean, CurrentValue: number) => void>;
	ExternalOwner: AbilitySystemComponent;
	static Load(ResourceName: string): AbilityTask_WaitAttributeChangeThreshold;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitAttributeChangeThreshold;
	static GetDefaultObject(): AbilityTask_WaitAttributeChangeThreshold;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitAttributeChangeThreshold;
	static WaitForAttributeChangeThreshold(OwningAbility: GameplayAbility,Attribute: GameplayAttribute,ComparisonType: EWaitAttributeChangeComparison,ComparisonValue: number,bTriggerOnce: boolean,OptionalExternalOwner: Actor): AbilityTask_WaitAttributeChangeThreshold;
	static C(Other: UObject | any): AbilityTask_WaitAttributeChangeThreshold;
}

declare class AbilityTask_WaitCancel extends AbilityTask { 
	OnCancel: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AbilityTask_WaitCancel;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitCancel;
	static GetDefaultObject(): AbilityTask_WaitCancel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitCancel;
	static WaitCancel(OwningAbility: GameplayAbility): AbilityTask_WaitCancel;
	OnLocalCancelCallback(): void;
	OnCancelCallback(): void;
	static C(Other: UObject | any): AbilityTask_WaitCancel;
}

declare class AbilityTask_WaitConfirm extends AbilityTask { 
	OnConfirm: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AbilityTask_WaitConfirm;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitConfirm;
	static GetDefaultObject(): AbilityTask_WaitConfirm;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitConfirm;
	static WaitConfirm(OwningAbility: GameplayAbility): AbilityTask_WaitConfirm;
	OnConfirmCallback(InAbility: GameplayAbility): void;
	static C(Other: UObject | any): AbilityTask_WaitConfirm;
}

declare class AbilityTask_WaitConfirmCancel extends AbilityTask { 
	OnConfirm: UnrealEngineMulticastDelegate<() => void>;
	OnCancel: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AbilityTask_WaitConfirmCancel;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitConfirmCancel;
	static GetDefaultObject(): AbilityTask_WaitConfirmCancel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitConfirmCancel;
	static WaitConfirmCancel(OwningAbility: GameplayAbility): AbilityTask_WaitConfirmCancel;
	OnLocalConfirmCallback(): void;
	OnLocalCancelCallback(): void;
	OnConfirmCallback(): void;
	OnCancelCallback(): void;
	static C(Other: UObject | any): AbilityTask_WaitConfirmCancel;
}

declare class AbilityTask_WaitDelay extends AbilityTask { 
	OnFinish: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AbilityTask_WaitDelay;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitDelay;
	static GetDefaultObject(): AbilityTask_WaitDelay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitDelay;
	static WaitDelay(OwningAbility: GameplayAbility,Time: number): AbilityTask_WaitDelay;
	static C(Other: UObject | any): AbilityTask_WaitDelay;
}

declare class AbilityTask_WaitGameplayEffectApplied extends AbilityTask { 
	ExternalOwner: AbilitySystemComponent;
	static Load(ResourceName: string): AbilityTask_WaitGameplayEffectApplied;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitGameplayEffectApplied;
	static GetDefaultObject(): AbilityTask_WaitGameplayEffectApplied;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitGameplayEffectApplied;
	OnApplyGameplayEffectCallback(Target: AbilitySystemComponent,SpecApplied: GameplayEffectSpec,ActiveHandle: ActiveGameplayEffectHandle): void;
	static C(Other: UObject | any): AbilityTask_WaitGameplayEffectApplied;
}

declare class AbilityTask_WaitGameplayEffectApplied_Self extends AbilityTask_WaitGameplayEffectApplied { 
	OnApplied: UnrealEngineMulticastDelegate<(Source: Actor, SpecHandle: GameplayEffectSpecHandle, ActiveHandle: ActiveGameplayEffectHandle) => void>;
	static Load(ResourceName: string): AbilityTask_WaitGameplayEffectApplied_Self;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitGameplayEffectApplied_Self;
	static GetDefaultObject(): AbilityTask_WaitGameplayEffectApplied_Self;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitGameplayEffectApplied_Self;
	static WaitGameplayEffectAppliedToSelf_Query(OwningAbility: GameplayAbility,SourceFilter: GameplayTargetDataFilterHandle,SourceTagQuery: GameplayTagQuery,TargetTagQuery: GameplayTagQuery,TriggerOnce: boolean,OptionalExternalOwner: Actor,ListenForPeriodicEffect: boolean): AbilityTask_WaitGameplayEffectApplied_Self;
	static WaitGameplayEffectAppliedToSelf(OwningAbility: GameplayAbility,SourceFilter: GameplayTargetDataFilterHandle,SourceTagRequirements: GameplayTagRequirements,TargetTagRequirements: GameplayTagRequirements,TriggerOnce: boolean,OptionalExternalOwner: Actor,ListenForPeriodicEffect: boolean): AbilityTask_WaitGameplayEffectApplied_Self;
	static C(Other: UObject | any): AbilityTask_WaitGameplayEffectApplied_Self;
}

declare class AbilityTask_WaitGameplayEffectApplied_Target extends AbilityTask_WaitGameplayEffectApplied { 
	OnApplied: UnrealEngineMulticastDelegate<(Target: Actor, SpecHandle: GameplayEffectSpecHandle, ActiveHandle: ActiveGameplayEffectHandle) => void>;
	static Load(ResourceName: string): AbilityTask_WaitGameplayEffectApplied_Target;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitGameplayEffectApplied_Target;
	static GetDefaultObject(): AbilityTask_WaitGameplayEffectApplied_Target;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitGameplayEffectApplied_Target;
	static WaitGameplayEffectAppliedToTarget_Query(OwningAbility: GameplayAbility,SourceFilter: GameplayTargetDataFilterHandle,SourceTagQuery: GameplayTagQuery,TargetTagQuery: GameplayTagQuery,TriggerOnce: boolean,OptionalExternalOwner: Actor,ListenForPeriodicEffect: boolean): AbilityTask_WaitGameplayEffectApplied_Target;
	static WaitGameplayEffectAppliedToTarget(OwningAbility: GameplayAbility,TargetFilter: GameplayTargetDataFilterHandle,SourceTagRequirements: GameplayTagRequirements,TargetTagRequirements: GameplayTagRequirements,TriggerOnce: boolean,OptionalExternalOwner: Actor,ListenForPeriodicEffects: boolean): AbilityTask_WaitGameplayEffectApplied_Target;
	static C(Other: UObject | any): AbilityTask_WaitGameplayEffectApplied_Target;
}

declare class AbilityTask_WaitGameplayEffectBlockedImmunity extends AbilityTask { 
	bLocked: UnrealEngineMulticastDelegate<(BlockedSpec: GameplayEffectSpecHandle, ImmunityGameplayEffectHandle: ActiveGameplayEffectHandle) => void>;
	ExternalOwner: AbilitySystemComponent;
	static Load(ResourceName: string): AbilityTask_WaitGameplayEffectBlockedImmunity;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitGameplayEffectBlockedImmunity;
	static GetDefaultObject(): AbilityTask_WaitGameplayEffectBlockedImmunity;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitGameplayEffectBlockedImmunity;
	static WaitGameplayEffectBlockedByImmunity(OwningAbility: GameplayAbility,SourceTagRequirements: GameplayTagRequirements,TargetTagRequirements: GameplayTagRequirements,OptionalExternalTarget: Actor,OnlyTriggerOnce: boolean): AbilityTask_WaitGameplayEffectBlockedImmunity;
	static C(Other: UObject | any): AbilityTask_WaitGameplayEffectBlockedImmunity;
}

declare class GameplayEffectRemovalInfo { 
	bPrematureRemoval: boolean;
	StackCount: number;
	EffectContext: GameplayEffectContextHandle;
	clone() : GameplayEffectRemovalInfo;
	static C(Other: UObject | any): GameplayEffectRemovalInfo;
}

declare class AbilityTask_WaitGameplayEffectRemoved extends AbilityTask { 
	OnRemoved: UnrealEngineMulticastDelegate<(GameplayEffectRemovalInfo: GameplayEffectRemovalInfo) => void>;
	InvalidHandle: UnrealEngineMulticastDelegate<(GameplayEffectRemovalInfo: GameplayEffectRemovalInfo) => void>;
	static Load(ResourceName: string): AbilityTask_WaitGameplayEffectRemoved;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitGameplayEffectRemoved;
	static GetDefaultObject(): AbilityTask_WaitGameplayEffectRemoved;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitGameplayEffectRemoved;
	static WaitForGameplayEffectRemoved(OwningAbility: GameplayAbility,Handle: ActiveGameplayEffectHandle): AbilityTask_WaitGameplayEffectRemoved;
	OnGameplayEffectRemoved(InGameplayEffectRemovalInfo: GameplayEffectRemovalInfo): void;
	static C(Other: UObject | any): AbilityTask_WaitGameplayEffectRemoved;
}

declare class AbilityTask_WaitGameplayEffectStackChange extends AbilityTask { 
	OnChange: UnrealEngineMulticastDelegate<(Handle: ActiveGameplayEffectHandle, NewCount: number, OldCount: number) => void>;
	InvalidHandle: UnrealEngineMulticastDelegate<(Handle: ActiveGameplayEffectHandle, NewCount: number, OldCount: number) => void>;
	static Load(ResourceName: string): AbilityTask_WaitGameplayEffectStackChange;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitGameplayEffectStackChange;
	static GetDefaultObject(): AbilityTask_WaitGameplayEffectStackChange;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitGameplayEffectStackChange;
	static WaitForGameplayEffectStackChange(OwningAbility: GameplayAbility,Handle: ActiveGameplayEffectHandle): AbilityTask_WaitGameplayEffectStackChange;
	OnGameplayEffectStackChange(Handle: ActiveGameplayEffectHandle,NewCount: number,OldCount: number): void;
	static C(Other: UObject | any): AbilityTask_WaitGameplayEffectStackChange;
}

declare class AbilityTask_WaitGameplayEvent extends AbilityTask { 
	EventReceived: UnrealEngineMulticastDelegate<(Payload: GameplayEventData) => void>;
	OptionalExternalTarget: AbilitySystemComponent;
	static Load(ResourceName: string): AbilityTask_WaitGameplayEvent;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitGameplayEvent;
	static GetDefaultObject(): AbilityTask_WaitGameplayEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitGameplayEvent;
	static WaitGameplayEvent(OwningAbility: GameplayAbility,EventTag: GameplayTag,OptionalExternalTarget: Actor,OnlyTriggerOnce: boolean,OnlyMatchExact: boolean): AbilityTask_WaitGameplayEvent;
	static C(Other: UObject | any): AbilityTask_WaitGameplayEvent;
}

declare class AbilityTask_WaitGameplayTag extends AbilityTask { 
	OptionalExternalTarget: AbilitySystemComponent;
	static Load(ResourceName: string): AbilityTask_WaitGameplayTag;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitGameplayTag;
	static GetDefaultObject(): AbilityTask_WaitGameplayTag;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitGameplayTag;
	GameplayTagCallback(Tag: GameplayTag,NewCount: number): void;
	static C(Other: UObject | any): AbilityTask_WaitGameplayTag;
}

declare class AbilityTask_WaitGameplayTagAdded extends AbilityTask_WaitGameplayTag { 
	Added: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AbilityTask_WaitGameplayTagAdded;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitGameplayTagAdded;
	static GetDefaultObject(): AbilityTask_WaitGameplayTagAdded;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitGameplayTagAdded;
	static WaitGameplayTagAdd(OwningAbility: GameplayAbility,Tag: GameplayTag,InOptionalExternalTarget: Actor,OnlyTriggerOnce: boolean): AbilityTask_WaitGameplayTagAdded;
	static C(Other: UObject | any): AbilityTask_WaitGameplayTagAdded;
}

declare class AbilityTask_WaitGameplayTagRemoved extends AbilityTask_WaitGameplayTag { 
	Removed: UnrealEngineMulticastDelegate<() => void>;
	static Load(ResourceName: string): AbilityTask_WaitGameplayTagRemoved;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitGameplayTagRemoved;
	static GetDefaultObject(): AbilityTask_WaitGameplayTagRemoved;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitGameplayTagRemoved;
	static WaitGameplayTagRemove(OwningAbility: GameplayAbility,Tag: GameplayTag,InOptionalExternalTarget: Actor,OnlyTriggerOnce: boolean): AbilityTask_WaitGameplayTagRemoved;
	static C(Other: UObject | any): AbilityTask_WaitGameplayTagRemoved;
}

declare class AbilityTask_WaitInputPress extends AbilityTask { 
	OnPress: UnrealEngineMulticastDelegate<(TimeWaited: number) => void>;
	static Load(ResourceName: string): AbilityTask_WaitInputPress;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitInputPress;
	static GetDefaultObject(): AbilityTask_WaitInputPress;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitInputPress;
	static WaitInputPress(OwningAbility: GameplayAbility,bTestAlreadyPressed: boolean): AbilityTask_WaitInputPress;
	OnPressCallback(): void;
	static C(Other: UObject | any): AbilityTask_WaitInputPress;
}

declare class AbilityTask_WaitInputRelease extends AbilityTask { 
	OnRelease: UnrealEngineMulticastDelegate<(TimeHeld: number) => void>;
	static Load(ResourceName: string): AbilityTask_WaitInputRelease;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitInputRelease;
	static GetDefaultObject(): AbilityTask_WaitInputRelease;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitInputRelease;
	static WaitInputRelease(OwningAbility: GameplayAbility,bTestAlreadyReleased: boolean): AbilityTask_WaitInputRelease;
	OnReleaseCallback(): void;
	static C(Other: UObject | any): AbilityTask_WaitInputRelease;
}

declare class AbilityTask_WaitMovementModeChange extends AbilityTask { 
	OnChange: UnrealEngineMulticastDelegate<(NewMovementMode: EMovementMode) => void>;
	static Load(ResourceName: string): AbilityTask_WaitMovementModeChange;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitMovementModeChange;
	static GetDefaultObject(): AbilityTask_WaitMovementModeChange;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitMovementModeChange;
	OnMovementModeChange(Character: Character,PrevMovementMode: EMovementMode,PreviousCustomMode: number): void;
	static CreateWaitMovementModeChange(OwningAbility: GameplayAbility,NewMode: EMovementMode): AbilityTask_WaitMovementModeChange;
	static C(Other: UObject | any): AbilityTask_WaitMovementModeChange;
}

declare class AbilityTask_WaitOverlap extends AbilityTask { 
	OnOverlap: UnrealEngineMulticastDelegate<(TargetData: GameplayAbilityTargetDataHandle) => void>;
	static Load(ResourceName: string): AbilityTask_WaitOverlap;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitOverlap;
	static GetDefaultObject(): AbilityTask_WaitOverlap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitOverlap;
	static WaitForOverlap(OwningAbility: GameplayAbility): AbilityTask_WaitOverlap;
	OnHitCallback(HitComp: PrimitiveComponent,OtherActor: Actor,OtherComp: PrimitiveComponent,NormalImpulse: Vector,Hit: HitResult): void;
	static C(Other: UObject | any): AbilityTask_WaitOverlap;
}

declare type EGameplayTargetingConfirmation = 'Instant' | 'UserConfirmed' | 'Custom' | 'CustomMulti' | 'EGameplayTargetingConfirmation_MAX';
declare var EGameplayTargetingConfirmation : { Instant:'Instant',UserConfirmed:'UserConfirmed',Custom:'Custom',CustomMulti:'CustomMulti',EGameplayTargetingConfirmation_MAX:'EGameplayTargetingConfirmation_MAX', };
declare class AbilityTask_WaitTargetData extends AbilityTask { 
	ValidData: UnrealEngineMulticastDelegate<(Data: GameplayAbilityTargetDataHandle) => void>;
	Cancelled: UnrealEngineMulticastDelegate<(Data: GameplayAbilityTargetDataHandle) => void>;
	TargetClass: UnrealEngineClass;
	TargetActor: GameplayAbilityTargetActor;
	static Load(ResourceName: string): AbilityTask_WaitTargetData;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitTargetData;
	static GetDefaultObject(): AbilityTask_WaitTargetData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitTargetData;
	static WaitTargetDataUsingActor(OwningAbility: GameplayAbility,TaskInstanceName: string,ConfirmationType: EGameplayTargetingConfirmation,TargetActor: GameplayAbilityTargetActor): AbilityTask_WaitTargetData;
	static WaitTargetData(OwningAbility: GameplayAbility,TaskInstanceName: string,ConfirmationType: EGameplayTargetingConfirmation,Class: UnrealEngineClass): AbilityTask_WaitTargetData;
	OnTargetDataReplicatedCancelledCallback(): void;
	OnTargetDataReplicatedCallback(Data: GameplayAbilityTargetDataHandle,ActivationTag: GameplayTag): void;
	OnTargetDataReadyCallback(Data: GameplayAbilityTargetDataHandle): void;
	OnTargetDataCancelledCallback(Data: GameplayAbilityTargetDataHandle): void;
	FinishSpawningActor(OwningAbility: GameplayAbility,SpawnedActor: GameplayAbilityTargetActor): void;
	BeginSpawningActor(OwningAbility: GameplayAbility,Class: UnrealEngineClass,SpawnedActor?: GameplayAbilityTargetActor): {SpawnedActor: GameplayAbilityTargetActor, $: boolean};
	static C(Other: UObject | any): AbilityTask_WaitTargetData;
}

declare class AbilityTask_WaitVelocityChange extends AbilityTask { 
	OnVelocityChage: UnrealEngineMulticastDelegate<() => void>;
	CachedMovementComponent: MovementComponent;
	static Load(ResourceName: string): AbilityTask_WaitVelocityChange;
	static Find(Outer: UObject, ResourceName: string): AbilityTask_WaitVelocityChange;
	static GetDefaultObject(): AbilityTask_WaitVelocityChange;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilityTask_WaitVelocityChange;
	static CreateWaitVelocityChange(OwningAbility: GameplayAbility,Direction: Vector,MinimumMagnitude: number): AbilityTask_WaitVelocityChange;
	static C(Other: UObject | any): AbilityTask_WaitVelocityChange;
}

declare class GameplayCueTag { 
	GameplayCueTag: GameplayTag;
	clone() : GameplayCueTag;
	static C(Other: UObject | any): GameplayCueTag;
}

declare class AnimNotify_GameplayCue extends AnimNotify { 
	GameplayCue: GameplayCueTag;
	static Load(ResourceName: string): AnimNotify_GameplayCue;
	static Find(Outer: UObject, ResourceName: string): AnimNotify_GameplayCue;
	static GetDefaultObject(): AnimNotify_GameplayCue;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify_GameplayCue;
	static C(Other: UObject | any): AnimNotify_GameplayCue;
}

declare class AnimNotify_GameplayCueState extends AnimNotifyState { 
	GameplayCue: GameplayCueTag;
	static Load(ResourceName: string): AnimNotify_GameplayCueState;
	static Find(Outer: UObject, ResourceName: string): AnimNotify_GameplayCueState;
	static GetDefaultObject(): AnimNotify_GameplayCueState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify_GameplayCueState;
	static C(Other: UObject | any): AnimNotify_GameplayCueState;
}

declare class GameplayAbilityBlueprint extends Blueprint { 
	static Load(ResourceName: string): GameplayAbilityBlueprint;
	static Find(Outer: UObject, ResourceName: string): GameplayAbilityBlueprint;
	static GetDefaultObject(): GameplayAbilityBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbilityBlueprint;
	static C(Other: UObject | any): GameplayAbilityBlueprint;
}

declare type EGameplayAbilityInputBinds = 'Ability1' | 'Ability2' | 'Ability3' | 'Ability4' | 'Ability5' | 'Ability6' | 'Ability7' | 'Ability8' | 'Ability9' | 'EGameplayAbilityInputBinds_MAX';
declare var EGameplayAbilityInputBinds : { Ability1:'Ability1',Ability2:'Ability2',Ability3:'Ability3',Ability4:'Ability4',Ability5:'Ability5',Ability6:'Ability6',Ability7:'Ability7',Ability8:'Ability8',Ability9:'Ability9',EGameplayAbilityInputBinds_MAX:'EGameplayAbilityInputBinds_MAX', };
declare class GameplayAbilityBindInfo { 
	Command: EGameplayAbilityInputBinds;
	GameplayAbilityClass: UnrealEngineClass;
	clone() : GameplayAbilityBindInfo;
	static C(Other: UObject | any): GameplayAbilityBindInfo;
}

declare class GameplayAbilitySet extends DataAsset { 
	Abilities: GameplayAbilityBindInfo[];
	static Load(ResourceName: string): GameplayAbilitySet;
	static Find(Outer: UObject, ResourceName: string): GameplayAbilitySet;
	static GetDefaultObject(): GameplayAbilitySet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbilitySet;
	static C(Other: UObject | any): GameplayAbilitySet;
}

declare class GameplayAbilityTargetActor_Trace extends GameplayAbilityTargetActor { 
	MaxRange: number;
	TraceProfile: CollisionProfileName;
	bTraceAffectsAimPitch: boolean;
	static GetDefaultObject(): GameplayAbilityTargetActor_Trace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbilityTargetActor_Trace;
	static C(Other: UObject | any): GameplayAbilityTargetActor_Trace;
}

declare class GameplayAbilityTargetActor_GroundTrace extends GameplayAbilityTargetActor_Trace { 
	CollisionRadius: number;
	CollisionHeight: number;
	static GetDefaultObject(): GameplayAbilityTargetActor_GroundTrace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbilityTargetActor_GroundTrace;
	static C(Other: UObject | any): GameplayAbilityTargetActor_GroundTrace;
}

declare class GameplayAbilityTargetActor_ActorPlacement extends GameplayAbilityTargetActor_GroundTrace { 
	PlacedActorClass: UnrealEngineClass;
	PlacedActorMaterial: MaterialInterface;
	static GetDefaultObject(): GameplayAbilityTargetActor_ActorPlacement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbilityTargetActor_ActorPlacement;
	static C(Other: UObject | any): GameplayAbilityTargetActor_ActorPlacement;
}

declare class GameplayAbilityTargetActor_Radius extends GameplayAbilityTargetActor { 
	Radius: number;
	static GetDefaultObject(): GameplayAbilityTargetActor_Radius;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbilityTargetActor_Radius;
	static C(Other: UObject | any): GameplayAbilityTargetActor_Radius;
}

declare class GameplayAbilityTargetActor_SingleLineTrace extends GameplayAbilityTargetActor_Trace { 
	static GetDefaultObject(): GameplayAbilityTargetActor_SingleLineTrace;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbilityTargetActor_SingleLineTrace;
	static C(Other: UObject | any): GameplayAbilityTargetActor_SingleLineTrace;
}

declare class GameplayAbilityWorldReticle_ActorVisualization extends GameplayAbilityWorldReticle { 
	CollisionComponent: CapsuleComponent;
	VisualizationComponents: ActorComponent[];
	static GetDefaultObject(): GameplayAbilityWorldReticle_ActorVisualization;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbilityWorldReticle_ActorVisualization;
	static C(Other: UObject | any): GameplayAbilityWorldReticle_ActorVisualization;
}

declare class GameplayAbility_CharacterJump extends GameplayAbility { 
	static Load(ResourceName: string): GameplayAbility_CharacterJump;
	static Find(Outer: UObject, ResourceName: string): GameplayAbility_CharacterJump;
	static GetDefaultObject(): GameplayAbility_CharacterJump;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbility_CharacterJump;
	static C(Other: UObject | any): GameplayAbility_CharacterJump;
}

declare class GameplayAbility_Montage extends GameplayAbility { 
	MontageToPlay: AnimMontage;
	PlayRate: number;
	SectionName: string;
	GameplayEffectClassesWhileAnimating: UnrealEngineClass[];
	GameplayEffectsWhileAnimating: GameplayEffect[];
	static Load(ResourceName: string): GameplayAbility_Montage;
	static Find(Outer: UObject, ResourceName: string): GameplayAbility_Montage;
	static GetDefaultObject(): GameplayAbility_Montage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbility_Montage;
	static C(Other: UObject | any): GameplayAbility_Montage;
}

declare class GameplayCueFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): GameplayCueFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): GameplayCueFunctionLibrary;
	static GetDefaultObject(): GameplayCueFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayCueFunctionLibrary;
	static RemoveGameplayCueOnActor(Target: Actor,GameplayCueTag: GameplayTag,Parameters: GameplayCueParameters): void;
	static MakeGameplayCueParametersFromHitResult(HitResult: HitResult): GameplayCueParameters;
	static ExecuteGameplayCueOnActor(Target: Actor,GameplayCueTag: GameplayTag,Parameters: GameplayCueParameters): void;
	static AddGameplayCueOnActor(Target: Actor,GameplayCueTag: GameplayTag,Parameters: GameplayCueParameters): void;
	static C(Other: UObject | any): GameplayCueFunctionLibrary;
}

declare class GameplayCueInterface extends Interface { 
	static Load(ResourceName: string): GameplayCueInterface;
	static Find(Outer: UObject, ResourceName: string): GameplayCueInterface;
	static GetDefaultObject(): GameplayCueInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayCueInterface;
	ForwardGameplayCueToParent(): void;
	BlueprintCustomHandler(EventType: EGameplayCueEvent,Parameters: GameplayCueParameters): void;
	static C(Other: UObject | any): GameplayCueInterface;
}

declare class GameplayCueNotify_Static extends UObject { 
	GameplayCueTag: GameplayTag;
	GameplayCueName: string;
	IsOverride: boolean;
	static Load(ResourceName: string): GameplayCueNotify_Static;
	static Find(Outer: UObject, ResourceName: string): GameplayCueNotify_Static;
	static GetDefaultObject(): GameplayCueNotify_Static;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayCueNotify_Static;
	WhileActive(MyTarget: Actor,Parameters: GameplayCueParameters): boolean;
	OnRemove(MyTarget: Actor,Parameters: GameplayCueParameters): boolean;
	OnExecute(MyTarget: Actor,Parameters: GameplayCueParameters): boolean;
	OnActive(MyTarget: Actor,Parameters: GameplayCueParameters): boolean;
	K2_HandleGameplayCue(MyTarget: Actor,EventType: EGameplayCueEvent,Parameters: GameplayCueParameters): void;
	static C(Other: UObject | any): GameplayCueNotify_Static;
}

declare type EGameplayCueNotify_LocallyControlledSource = 'InstigatorActor' | 'TargetActor' | 'EGameplayCueNotify_MAX';
declare var EGameplayCueNotify_LocallyControlledSource : { InstigatorActor:'InstigatorActor',TargetActor:'TargetActor',EGameplayCueNotify_MAX:'EGameplayCueNotify_MAX', };
declare type EGameplayCueNotify_LocallyControlledPolicy = 'Always' | 'LocalOnly' | 'NotLocal' | 'EGameplayCueNotify_MAX';
declare var EGameplayCueNotify_LocallyControlledPolicy : { Always:'Always',LocalOnly:'LocalOnly',NotLocal:'NotLocal',EGameplayCueNotify_MAX:'EGameplayCueNotify_MAX', };
declare class GameplayCueNotify_SpawnCondition { 
	LocallyControlledSource: EGameplayCueNotify_LocallyControlledSource;
	LocallyControlledPolicy: EGameplayCueNotify_LocallyControlledPolicy;
	ChanceToPlay: number;
	AllowedSurfaceTypes: EPhysicalSurface[];
	RejectedSurfaceTypes: EPhysicalSurface[];
	clone() : GameplayCueNotify_SpawnCondition;
	static C(Other: UObject | any): GameplayCueNotify_SpawnCondition;
}

declare type EGameplayCueNotify_AttachPolicy = 'DoNotAttach' | 'AttachToTarget' | 'EGameplayCueNotify_MAX';
declare var EGameplayCueNotify_AttachPolicy : { DoNotAttach:'DoNotAttach',AttachToTarget:'AttachToTarget',EGameplayCueNotify_MAX:'EGameplayCueNotify_MAX', };
declare class GameplayCueNotify_PlacementInfo { 
	SocketName: string;
	AttachPolicy: EGameplayCueNotify_AttachPolicy;
	AttachmentRule: EAttachmentRule;
	bOverrideRotation: boolean;
	bOverrideScale: boolean;
	RotationOverride: Rotator;
	ScaleOverride: Vector;
	clone() : GameplayCueNotify_PlacementInfo;
	static C(Other: UObject | any): GameplayCueNotify_PlacementInfo;
}

declare class GameplayCueNotify_ParticleInfo { 
	SpawnConditionOverride: GameplayCueNotify_SpawnCondition;
	PlacementInfoOverride: GameplayCueNotify_PlacementInfo;
	NiagaraSystem: NiagaraSystem;
	bOverrideSpawnCondition: boolean;
	bOverridePlacementInfo: boolean;
	bCastShadow: boolean;
	clone() : GameplayCueNotify_ParticleInfo;
	static C(Other: UObject | any): GameplayCueNotify_ParticleInfo;
}

declare class GameplayCueNotify_SoundParameterInterfaceInfo { 
	StopTriggerName: string;
	clone() : GameplayCueNotify_SoundParameterInterfaceInfo;
	static C(Other: UObject | any): GameplayCueNotify_SoundParameterInterfaceInfo;
}

declare class GameplayCueNotify_SoundInfo { 
	SpawnConditionOverride: GameplayCueNotify_SpawnCondition;
	PlacementInfoOverride: GameplayCueNotify_PlacementInfo;
	Sound: SoundBase;
	SoundCue: SoundBase;
	LoopingFadeOutDuration: number;
	LoopingFadeVolumeLevel: number;
	SoundParameterInterfaceInfo: GameplayCueNotify_SoundParameterInterfaceInfo;
	bOverrideSpawnCondition: boolean;
	bOverridePlacementInfo: boolean;
	bUseSoundParameterInterface: boolean;
	clone() : GameplayCueNotify_SoundInfo;
	static C(Other: UObject | any): GameplayCueNotify_SoundInfo;
}

declare type EGameplayCueNotify_EffectPlaySpace = 'WorldSpace' | 'CameraSpace' | 'EGameplayCueNotify_MAX';
declare var EGameplayCueNotify_EffectPlaySpace : { WorldSpace:'WorldSpace',CameraSpace:'CameraSpace',EGameplayCueNotify_MAX:'EGameplayCueNotify_MAX', };
declare class GameplayCueNotify_CameraShakeInfo { 
	SpawnConditionOverride: GameplayCueNotify_SpawnCondition;
	PlacementInfoOverride: GameplayCueNotify_PlacementInfo;
	CameraShake: UnrealEngineClass;
	ShakeScale: number;
	PlaySpace: EGameplayCueNotify_EffectPlaySpace;
	bOverrideSpawnCondition: boolean;
	bOverridePlacementInfo: boolean;
	bPlayInWorld: boolean;
	WorldInnerRadius: number;
	WorldOuterRadius: number;
	WorldFalloffExponent: number;
	clone() : GameplayCueNotify_CameraShakeInfo;
	static C(Other: UObject | any): GameplayCueNotify_CameraShakeInfo;
}

declare class GameplayCueNotify_CameraAnimInfo { 
	SpawnConditionOverride: GameplayCueNotify_SpawnCondition;
	CameraAnim: CameraAnim;
	AnimScale: number;
	PlayRate: number;
	BlendInTime: number;
	BlendOutTime: number;
	PlaySpace: EGameplayCueNotify_EffectPlaySpace;
	bIsLooping: boolean;
	bRandomStartTime: boolean;
	bOverrideSpawnCondition: boolean;
	clone() : GameplayCueNotify_CameraAnimInfo;
	static C(Other: UObject | any): GameplayCueNotify_CameraAnimInfo;
}

declare class GameplayCueNotify_CameraLensEffectInfo { 
	SpawnConditionOverride: GameplayCueNotify_SpawnCondition;
	PlacementInfoOverride: GameplayCueNotify_PlacementInfo;
	CameraLensEffect: UnrealEngineClass;
	bOverrideSpawnCondition: boolean;
	bOverridePlacementInfo: boolean;
	bPlayInWorld: boolean;
	WorldInnerRadius: number;
	WorldOuterRadius: number;
	clone() : GameplayCueNotify_CameraLensEffectInfo;
	static C(Other: UObject | any): GameplayCueNotify_CameraLensEffectInfo;
}

declare class GameplayCueNotify_ForceFeedbackInfo { 
	SpawnConditionOverride: GameplayCueNotify_SpawnCondition;
	PlacementInfoOverride: GameplayCueNotify_PlacementInfo;
	ForceFeedbackEffect: ForceFeedbackEffect;
	ForceFeedbackTag: string;
	bIsLooping: boolean;
	bOverrideSpawnCondition: boolean;
	bOverridePlacementInfo: boolean;
	bPlayInWorld: boolean;
	WorldIntensity: number;
	WorldAttenuation: ForceFeedbackAttenuation;
	clone() : GameplayCueNotify_ForceFeedbackInfo;
	static C(Other: UObject | any): GameplayCueNotify_ForceFeedbackInfo;
}

declare class GameplayCueNotify_DecalInfo { 
	SpawnConditionOverride: GameplayCueNotify_SpawnCondition;
	PlacementInfoOverride: GameplayCueNotify_PlacementInfo;
	DecalMaterial: MaterialInterface;
	DecalSize: Vector;
	bOverrideSpawnCondition: boolean;
	bOverridePlacementInfo: boolean;
	bOverrideFadeOut: boolean;
	FadeOutStartDelay: number;
	FadeOutDuration: number;
	clone() : GameplayCueNotify_DecalInfo;
	static C(Other: UObject | any): GameplayCueNotify_DecalInfo;
}

declare class GameplayCueNotify_BurstEffects { 
	BurstParticles: GameplayCueNotify_ParticleInfo[];
	BurstSounds: GameplayCueNotify_SoundInfo[];
	BurstCameraShake: GameplayCueNotify_CameraShakeInfo;
	BurstCameraAnim: GameplayCueNotify_CameraAnimInfo;
	BurstCameraLensEffect: GameplayCueNotify_CameraLensEffectInfo;
	BurstForceFeedback: GameplayCueNotify_ForceFeedbackInfo;
	BurstDecal: GameplayCueNotify_DecalInfo;
	clone() : GameplayCueNotify_BurstEffects;
	static C(Other: UObject | any): GameplayCueNotify_BurstEffects;
}

declare class GameplayCueNotify_SpawnResult { 
	FxSystemComponents: FXSystemComponent[];
	AudioComponents: AudioComponent[];
	CameraShakes: CameraShakeBase[];
	CameraAnim: CameraAnimInst;
	CameraLensEffects: any[];
	ForceFeedbackComponent: ForceFeedbackComponent;
	ForceFeedbackTargetPC: PlayerController;
	DecalComponent: DecalComponent;
	clone() : GameplayCueNotify_SpawnResult;
	static C(Other: UObject | any): GameplayCueNotify_SpawnResult;
}

declare class GameplayCueNotify_Burst extends GameplayCueNotify_Static { 
	DefaultSpawnCondition: GameplayCueNotify_SpawnCondition;
	DefaultPlacementInfo: GameplayCueNotify_PlacementInfo;
	BurstEffects: GameplayCueNotify_BurstEffects;
	static Load(ResourceName: string): GameplayCueNotify_Burst;
	static Find(Outer: UObject, ResourceName: string): GameplayCueNotify_Burst;
	static GetDefaultObject(): GameplayCueNotify_Burst;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayCueNotify_Burst;
	OnBurst(Target: Actor,Parameters: GameplayCueParameters,SpawnResults: GameplayCueNotify_SpawnResult): void;
	static C(Other: UObject | any): GameplayCueNotify_Burst;
}

declare class GameplayCueNotify_BurstLatent extends GameplayCueNotify_Actor { 
	DefaultSpawnCondition: GameplayCueNotify_SpawnCondition;
	DefaultPlacementInfo: GameplayCueNotify_PlacementInfo;
	BurstEffects: GameplayCueNotify_BurstEffects;
	BurstSpawnResults: GameplayCueNotify_SpawnResult;
	static GetDefaultObject(): GameplayCueNotify_BurstLatent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayCueNotify_BurstLatent;
	OnBurst(Target: Actor,Parameters: GameplayCueParameters,SpawnResults: GameplayCueNotify_SpawnResult): void;
	static C(Other: UObject | any): GameplayCueNotify_BurstLatent;
}

declare class GameplayCueNotify_HitImpact extends GameplayCueNotify_Static { 
	Sound: SoundBase;
	ParticleSystem: ParticleSystem;
	static Load(ResourceName: string): GameplayCueNotify_HitImpact;
	static Find(Outer: UObject, ResourceName: string): GameplayCueNotify_HitImpact;
	static GetDefaultObject(): GameplayCueNotify_HitImpact;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayCueNotify_HitImpact;
	static C(Other: UObject | any): GameplayCueNotify_HitImpact;
}

declare class GameplayCueNotify_LoopingEffects { 
	LoopingParticles: GameplayCueNotify_ParticleInfo[];
	LoopingSounds: GameplayCueNotify_SoundInfo[];
	LoopingCameraShake: GameplayCueNotify_CameraShakeInfo;
	LoopingCameraAnim: GameplayCueNotify_CameraAnimInfo;
	LoopingCameraLensEffect: GameplayCueNotify_CameraLensEffectInfo;
	LoopingForceFeedback: GameplayCueNotify_ForceFeedbackInfo;
	clone() : GameplayCueNotify_LoopingEffects;
	static C(Other: UObject | any): GameplayCueNotify_LoopingEffects;
}

declare class GameplayCueNotify_Looping extends GameplayCueNotify_Actor { 
	DefaultSpawnCondition: GameplayCueNotify_SpawnCondition;
	DefaultPlacementInfo: GameplayCueNotify_PlacementInfo;
	ApplicationEffects: GameplayCueNotify_BurstEffects;
	ApplicationSpawnResults: GameplayCueNotify_SpawnResult;
	LoopingEffects: GameplayCueNotify_LoopingEffects;
	LoopingSpawnResults: GameplayCueNotify_SpawnResult;
	RecurringEffects: GameplayCueNotify_BurstEffects;
	RecurringSpawnResults: GameplayCueNotify_SpawnResult;
	RemovalEffects: GameplayCueNotify_BurstEffects;
	RemovalSpawnResults: GameplayCueNotify_SpawnResult;
	static GetDefaultObject(): GameplayCueNotify_Looping;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayCueNotify_Looping;
	OnRemoval(Target: Actor,Parameters: GameplayCueParameters,SpawnResults: GameplayCueNotify_SpawnResult): void;
	OnRecurring(Target: Actor,Parameters: GameplayCueParameters,SpawnResults: GameplayCueNotify_SpawnResult): void;
	OnLoopingStart(Target: Actor,Parameters: GameplayCueParameters,SpawnResults: GameplayCueNotify_SpawnResult): void;
	OnApplication(Target: Actor,Parameters: GameplayCueParameters,SpawnResults: GameplayCueNotify_SpawnResult): void;
	static C(Other: UObject | any): GameplayCueNotify_Looping;
}

declare class GameplayCueTranslator extends UObject { 
	static Load(ResourceName: string): GameplayCueTranslator;
	static Find(Outer: UObject, ResourceName: string): GameplayCueTranslator;
	static GetDefaultObject(): GameplayCueTranslator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayCueTranslator;
	static C(Other: UObject | any): GameplayCueTranslator;
}

declare class GameplayCueTranslator_Test extends GameplayCueTranslator { 
	static Load(ResourceName: string): GameplayCueTranslator_Test;
	static Find(Outer: UObject, ResourceName: string): GameplayCueTranslator_Test;
	static GetDefaultObject(): GameplayCueTranslator_Test;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayCueTranslator_Test;
	static C(Other: UObject | any): GameplayCueTranslator_Test;
}

declare class GameplayEffectUIData_TextOnly extends GameplayEffectUIData { 
	Description: string;
	static Load(ResourceName: string): GameplayEffectUIData_TextOnly;
	static Find(Outer: UObject, ResourceName: string): GameplayEffectUIData_TextOnly;
	static GetDefaultObject(): GameplayEffectUIData_TextOnly;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayEffectUIData_TextOnly;
	static C(Other: UObject | any): GameplayEffectUIData_TextOnly;
}

declare class MovieSceneGameplayCueKey { 
	Cue: GameplayCueTag;
	Location: Vector;
	Normal: Vector;
	AttachSocketName: string;
	NormalizedMagnitude: number;
	Instigator: MovieSceneObjectBindingID;
	EffectCauser: MovieSceneObjectBindingID;
	PhysicalMaterial: PhysicalMaterial;
	GameplayEffectLevel: number;
	AbilityLevel: number;
	bAttachToBinding: boolean;
	clone() : MovieSceneGameplayCueKey;
	static C(Other: UObject | any): MovieSceneGameplayCueKey;
}

declare class MovieSceneGameplayCueChannel extends MovieSceneChannel { 
	KeyTimes: FrameNumber[];
	KeyValues: MovieSceneGameplayCueKey[];
	clone() : MovieSceneGameplayCueChannel;
	static C(Other: UObject | any): MovieSceneGameplayCueChannel;
}

declare class MovieSceneGameplayCueTriggerSection extends MovieSceneHookSection { 
	Channel: MovieSceneGameplayCueChannel;
	static Load(ResourceName: string): MovieSceneGameplayCueTriggerSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneGameplayCueTriggerSection;
	static GetDefaultObject(): MovieSceneGameplayCueTriggerSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneGameplayCueTriggerSection;
	static C(Other: UObject | any): MovieSceneGameplayCueTriggerSection;
}

declare class MovieSceneGameplayCueSection extends MovieSceneHookSection { 
	Cue: MovieSceneGameplayCueKey;
	static Load(ResourceName: string): MovieSceneGameplayCueSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneGameplayCueSection;
	static GetDefaultObject(): MovieSceneGameplayCueSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneGameplayCueSection;
	static C(Other: UObject | any): MovieSceneGameplayCueSection;
}

declare class MovieSceneGameplayCueTrack extends MovieSceneNameableTrack { 
	Sections: MovieSceneSection[];
	static Load(ResourceName: string): MovieSceneGameplayCueTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneGameplayCueTrack;
	static GetDefaultObject(): MovieSceneGameplayCueTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneGameplayCueTrack;
	static C(Other: UObject | any): MovieSceneGameplayCueTrack;
}

declare class TickableAttributeSetInterface extends Interface { 
	static Load(ResourceName: string): TickableAttributeSetInterface;
	static Find(Outer: UObject, ResourceName: string): TickableAttributeSetInterface;
	static GetDefaultObject(): TickableAttributeSetInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TickableAttributeSetInterface;
	static C(Other: UObject | any): TickableAttributeSetInterface;
}

declare class GameplayBehaviorConfig extends UObject { 
	BehaviorClass: UnrealEngineClass;
	static Load(ResourceName: string): GameplayBehaviorConfig;
	static Find(Outer: UObject, ResourceName: string): GameplayBehaviorConfig;
	static GetDefaultObject(): GameplayBehaviorConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayBehaviorConfig;
	static C(Other: UObject | any): GameplayBehaviorConfig;
}

declare class GameplayBehavior extends UObject { 
	ActionTag: GameplayTag;
	RelevantActors: Actor[];
	TransientSmartObjectOwner: Actor;
	TransientAvatar: Actor;
	ActiveTasks: GameplayTask[];
	static Load(ResourceName: string): GameplayBehavior;
	static Find(Outer: UObject, ResourceName: string): GameplayBehavior;
	static GetDefaultObject(): GameplayBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayBehavior;
	K2_TriggerBehavior(Avatar: Actor,Config: GameplayBehaviorConfig,SmartObjectOwner: Actor): void;
	K2_OnTriggeredPawn(Avatar: Pawn,Config: GameplayBehaviorConfig,SmartObjectOwner: Actor): void;
	K2_OnTriggeredCharacter(Avatar: Character,Config: GameplayBehaviorConfig,SmartObjectOwner: Actor): void;
	K2_OnTriggered(Avatar: Actor,Config: GameplayBehaviorConfig,SmartObjectOwner: Actor): void;
	K2_OnFinishedPawn(Avatar: Pawn,bWasInterrupted: boolean): void;
	K2_OnFinishedCharacter(Avatar: Character,bWasInterrupted: boolean): void;
	K2_OnFinished(Avatar: Actor,bWasInterrupted: boolean): void;
	K2_GetNextActorIndexInSequence(CurrentIndex: number): number;
	K2_EndBehavior(Avatar: Actor): void;
	K2_AbortBehavior(Avatar: Actor): void;
	static C(Other: UObject | any): GameplayBehavior;
}

declare class BTTask_StopGameplayBehavior extends BTTaskNode { 
	BehaviorToStop: UnrealEngineClass;
	static Load(ResourceName: string): BTTask_StopGameplayBehavior;
	static Find(Outer: UObject, ResourceName: string): BTTask_StopGameplayBehavior;
	static GetDefaultObject(): BTTask_StopGameplayBehavior;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTask_StopGameplayBehavior;
	static C(Other: UObject | any): BTTask_StopGameplayBehavior;
}

declare class GameplayBehaviorConfig_Animation extends GameplayBehaviorConfig { 
	AnimMontage: AnimMontage;
	PlayRate: number;
	StartSectionName: string;
	bLoop: boolean;
	static Load(ResourceName: string): GameplayBehaviorConfig_Animation;
	static Find(Outer: UObject, ResourceName: string): GameplayBehaviorConfig_Animation;
	static GetDefaultObject(): GameplayBehaviorConfig_Animation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayBehaviorConfig_Animation;
	static C(Other: UObject | any): GameplayBehaviorConfig_Animation;
}

declare class GameplayBehaviorConfig_BehaviorTree extends GameplayBehaviorConfig { 
	BehaviorTree: BehaviorTree;
	bRevertToPreviousBTOnFinish: boolean;
	static Load(ResourceName: string): GameplayBehaviorConfig_BehaviorTree;
	static Find(Outer: UObject, ResourceName: string): GameplayBehaviorConfig_BehaviorTree;
	static GetDefaultObject(): GameplayBehaviorConfig_BehaviorTree;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayBehaviorConfig_BehaviorTree;
	static C(Other: UObject | any): GameplayBehaviorConfig_BehaviorTree;
}

declare class GameplayBehaviorManager extends AISubsystem { 
	AgentGameplayBehaviors: any;
	bCreateIfMissing: boolean;
	static Load(ResourceName: string): GameplayBehaviorManager;
	static Find(Outer: UObject, ResourceName: string): GameplayBehaviorManager;
	static GetDefaultObject(): GameplayBehaviorManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayBehaviorManager;
	static C(Other: UObject | any): GameplayBehaviorManager;
}

declare class GameplayBehaviorsBlueprintFunctionLibrary extends BlueprintFunctionLibrary { 
	static Load(ResourceName: string): GameplayBehaviorsBlueprintFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): GameplayBehaviorsBlueprintFunctionLibrary;
	static GetDefaultObject(): GameplayBehaviorsBlueprintFunctionLibrary;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayBehaviorsBlueprintFunctionLibrary;
	static C(Other: UObject | any): GameplayBehaviorsBlueprintFunctionLibrary;
}

declare class MontagePlaybackData { 
	Avatar: Actor;
	AnimMontage: AnimMontage;
	AbilityComponent: AbilitySystemComponent;
	clone() : MontagePlaybackData;
	static C(Other: UObject | any): MontagePlaybackData;
}

declare class GameplayBehavior_AnimationBased extends GameplayBehavior { 
	ActivePlayback: MontagePlaybackData[];
	static Load(ResourceName: string): GameplayBehavior_AnimationBased;
	static Find(Outer: UObject, ResourceName: string): GameplayBehavior_AnimationBased;
	static GetDefaultObject(): GameplayBehavior_AnimationBased;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayBehavior_AnimationBased;
	OnMontageFinished(Montage: AnimMontage,bInterrupted: boolean,InAvatar: Actor): void;
	static C(Other: UObject | any): GameplayBehavior_AnimationBased;
}

