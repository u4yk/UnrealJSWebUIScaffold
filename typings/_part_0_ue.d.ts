declare global {
	function require(name: string): any;
}

declare function gc() : void;
declare type UnrealEngineClass = any;
declare type timeout_handle = any;
declare function setTimeout(fn : (milliseconds: number) => void, timeout : number) : timeout_handle;
declare function clearTimeout(handle : timeout_handle) : void;
declare class UnrealEngineMulticastDelegate<T> {
	Add(fn : T): void;
	Remove(fn : T): void;
}

declare class UnrealEngineDelegate<T> {
	Add(fn : T): void;
	Remove(fn : T): void;
}

declare class Process {
	nextTick(fn : (number) => void): void;
}

declare var process : Process;

declare class Memory {
	exec(ab : ArrayBuffer, fn : (ab : ArrayBuffer) => void): void;
	access(obj : JavascriptMemoryObject): ArrayBuffer;
}

declare var memory : Memory;

declare var GEngine : Engine;

declare var GWorld : World;

declare var Root : JavascriptComponent | any;

declare namespace JSX {
	interface IntrinsicElements {
		[elemName: string]: any;
		div: any;
		span: any;
		text: any;
		img: any;
		input: any;
	}
}

declare class IntPoint { 
	X: number;
	Y: number;
	clone() : IntPoint;
	static C(Other: UObject | any): IntPoint;
	Conv_IntPointToString(): string;
	Add_IntPointInt(B: number): IntPoint;
	Add_IntPointIntPoint(B: IntPoint): IntPoint;
	Conv_IntPointToVector2D(): Vector2D;
	Divide_IntPointInt(B: number): IntPoint;
	Divide_IntPointIntPoint(B: IntPoint): IntPoint;
	Equal_IntPointIntPoint(B: IntPoint): boolean;
	Multiply_IntPointInt(B: number): IntPoint;
	Multiply_IntPointIntPoint(B: IntPoint): IntPoint;
	NotEqual_IntPointIntPoint(B: IntPoint): boolean;
	Subtract_IntPointInt(B: number): IntPoint;
	Subtract_IntPointIntPoint(B: IntPoint): IntPoint;
	ResizeXRCamera(): IntPoint;
	static Conv_IntPointToString(InIntPoint: IntPoint): string;
	static Add_IntPointInt(A: IntPoint,B: number): IntPoint;
	static Add_IntPointIntPoint(A: IntPoint,B: IntPoint): IntPoint;
	static Conv_IntPointToVector2D(InIntPoint: IntPoint): Vector2D;
	static Divide_IntPointInt(A: IntPoint,B: number): IntPoint;
	static Divide_IntPointIntPoint(A: IntPoint,B: IntPoint): IntPoint;
	static Equal_IntPointIntPoint(A: IntPoint,B: IntPoint): boolean;
	static Multiply_IntPointInt(A: IntPoint,B: number): IntPoint;
	static Multiply_IntPointIntPoint(A: IntPoint,B: IntPoint): IntPoint;
	static NotEqual_IntPointIntPoint(A: IntPoint,B: IntPoint): boolean;
	static Subtract_IntPointInt(A: IntPoint,B: number): IntPoint;
	static Subtract_IntPointIntPoint(A: IntPoint,B: IntPoint): IntPoint;
	static ResizeXRCamera(InSize: IntPoint): IntPoint;
	static IntPoint_Down(): IntPoint;
	static IntPoint_Left(): IntPoint;
	static IntPoint_One(): IntPoint;
	static IntPoint_Right(): IntPoint;
	static IntPoint_Up(): IntPoint;
	static IntPoint_Zero(): IntPoint;
}

declare class Box2D { 
	Min: Vector2D;
	Max: Vector2D;
	bIsValid: number;
	clone() : Box2D;
	static C(Other: UObject | any): Box2D;
}

declare type EARLineTraceChannels = 'None' | 'FeaturePoint' | 'GroundPlane' | 'PlaneUsingExtent' | 'PlaneUsingBoundaryPolygon' | 'EARLineTraceChannels_MAX';
declare var EARLineTraceChannels : { None:'None',FeaturePoint:'FeaturePoint',GroundPlane:'GroundPlane',PlaneUsingExtent:'PlaneUsingExtent',PlaneUsingBoundaryPolygon:'PlaneUsingBoundaryPolygon',EARLineTraceChannels_MAX:'EARLineTraceChannels_MAX', };
declare type EJsonLibraryType = 'Invalid' | 'Null' | 'Object' | 'Array' | 'Boolean' | 'Number' | 'String' | 'EJsonLibraryType_MAX';
declare var EJsonLibraryType : { Invalid:'Invalid',Null:'Null',Object:'Object',Array:'Array',Boolean:'Boolean',Number:'Number',String:'String',EJsonLibraryType_MAX:'EJsonLibraryType_MAX', };
declare class Color { 
	B: number;
	G: number;
	R: number;
	A: number;
	clone() : Color;
	static C(Other: UObject | any): Color;
	FromColor(): JsonLibraryValue;
	Conv_ColorToLinearColor(): LinearColor;
	static FromColor(Value: Color): JsonLibraryValue;
	static Conv_ColorToLinearColor(InColor: Color): LinearColor;
}

declare class Timespan { 
	clone() : Timespan;
	static C(Other: UObject | any): Timespan;
	AsTimespan_Timespan(): string;
	Add_TimespanTimespan(B: Timespan): Timespan;
	BreakTimespan(Days?: number,Hours?: number,Minutes?: number,Seconds?: number,Milliseconds?: number): {Days: number, Hours: number, Minutes: number, Seconds: number, Milliseconds: number};
	BreakTimespan2(Days?: number,Hours?: number,Minutes?: number,Seconds?: number,FractionNano?: number): {Days: number, Hours: number, Minutes: number, Seconds: number, FractionNano: number};
	Divide_TimespanFloat(Scalar: number): Timespan;
	EqualEqual_TimespanTimespan(B: Timespan): boolean;
	GetDays(): number;
	GetDuration(): Timespan;
	GetHours(): number;
	GetMilliseconds(): number;
	GetMinutes(): number;
	GetSeconds(): number;
	GetTotalDays(): number;
	GetTotalHours(): number;
	GetTotalMilliseconds(): number;
	GetTotalMinutes(): number;
	GetTotalSeconds(): number;
	Greater_TimespanTimespan(B: Timespan): boolean;
	GreaterEqual_TimespanTimespan(B: Timespan): boolean;
	Less_TimespanTimespan(B: Timespan): boolean;
	LessEqual_TimespanTimespan(B: Timespan): boolean;
	Multiply_TimespanFloat(Scalar: number): Timespan;
	NotEqual_TimespanTimespan(B: Timespan): boolean;
	Subtract_TimespanTimespan(B: Timespan): Timespan;
	TimespanRatio(B: Timespan): number;
	static AsTimespan_Timespan(InTimespan: Timespan): string;
	static Add_TimespanTimespan(A: Timespan,B: Timespan): Timespan;
	static BreakTimespan(InTimespan: Timespan,Days?: number,Hours?: number,Minutes?: number,Seconds?: number,Milliseconds?: number): {Days: number, Hours: number, Minutes: number, Seconds: number, Milliseconds: number};
	static BreakTimespan2(InTimespan: Timespan,Days?: number,Hours?: number,Minutes?: number,Seconds?: number,FractionNano?: number): {Days: number, Hours: number, Minutes: number, Seconds: number, FractionNano: number};
	static Divide_TimespanFloat(A: Timespan,Scalar: number): Timespan;
	static EqualEqual_TimespanTimespan(A: Timespan,B: Timespan): boolean;
	static GetDays(A: Timespan): number;
	static GetDuration(A: Timespan): Timespan;
	static GetHours(A: Timespan): number;
	static GetMilliseconds(A: Timespan): number;
	static GetMinutes(A: Timespan): number;
	static GetSeconds(A: Timespan): number;
	static GetTotalDays(A: Timespan): number;
	static GetTotalHours(A: Timespan): number;
	static GetTotalMilliseconds(A: Timespan): number;
	static GetTotalMinutes(A: Timespan): number;
	static GetTotalSeconds(A: Timespan): number;
	static Greater_TimespanTimespan(A: Timespan,B: Timespan): boolean;
	static GreaterEqual_TimespanTimespan(A: Timespan,B: Timespan): boolean;
	static Less_TimespanTimespan(A: Timespan,B: Timespan): boolean;
	static LessEqual_TimespanTimespan(A: Timespan,B: Timespan): boolean;
	static Multiply_TimespanFloat(A: Timespan,Scalar: number): Timespan;
	static NotEqual_TimespanTimespan(A: Timespan,B: Timespan): boolean;
	static Subtract_TimespanTimespan(A: Timespan,B: Timespan): Timespan;
	static TimespanRatio(A: Timespan,B: Timespan): number;
	static FromDays(Days: number): Timespan;
	static FromHours(Hours: number): Timespan;
	static FromMilliseconds(Milliseconds: number): Timespan;
	static FromMinutes(Minutes: number): Timespan;
	static FromSeconds(Seconds: number): Timespan;
	static MakeTimespan(Days: number,Hours: number,Minutes: number,Seconds: number,Milliseconds: number): Timespan;
	static MakeTimespan2(Days: number,Hours: number,Minutes: number,Seconds: number,FractionNano: number): Timespan;
	static TimespanMaxValue(): Timespan;
	static TimespanMinValue(): Timespan;
	static TimespanZeroValue(): Timespan;
}

declare class DateTime { 
	clone() : DateTime;
	static C(Other: UObject | any): DateTime;
	FromDateTime(): JsonLibraryValue;
	AsDate_DateTime(): string;
	AsDateTime_DateTime(): string;
	AsTime_DateTime(): string;
	AsTimeZoneDate_DateTime(InTimeZone: string): string;
	AsTimeZoneDateTime_DateTime(InTimeZone: string): string;
	AsTimeZoneTime_DateTime(InTimeZone: string): string;
	Add_DateTimeDateTime(B: DateTime): DateTime;
	Add_DateTimeTimespan(B: Timespan): DateTime;
	BreakDateTime(Year?: number,Month?: number,Day?: number,Hour?: number,Minute?: number,Second?: number,Millisecond?: number): {Year: number, Month: number, Day: number, Hour: number, Minute: number, Second: number, Millisecond: number};
	EqualEqual_DateTimeDateTime(B: DateTime): boolean;
	GetDate(): DateTime;
	GetDay(): number;
	GetDayOfYear(): number;
	GetHour(): number;
	GetHour12(): number;
	GetMillisecond(): number;
	GetMinute(): number;
	GetMonth(): number;
	GetSecond(): number;
	GetTimeOfDay(): Timespan;
	GetYear(): number;
	Greater_DateTimeDateTime(B: DateTime): boolean;
	GreaterEqual_DateTimeDateTime(B: DateTime): boolean;
	IsAfternoon(): boolean;
	IsMorning(): boolean;
	Less_DateTimeDateTime(B: DateTime): boolean;
	LessEqual_DateTimeDateTime(B: DateTime): boolean;
	NotEqual_DateTimeDateTime(B: DateTime): boolean;
	Subtract_DateTimeDateTime(B: DateTime): Timespan;
	Subtract_DateTimeTimespan(B: Timespan): DateTime;
	ScheduleLocalNotificationAtTime(LocalTime: boolean,Title: string,Body: string,Action: string,ActivationEvent: string): number;
	ScheduleLocalNotificationBadgeAtTime(LocalTime: boolean,ActivationEvent: string): number;
	static FromDateTime(Value: DateTime): JsonLibraryValue;
	static AsDate_DateTime(InDateTime: DateTime): string;
	static AsDateTime_DateTime(In: DateTime): string;
	static AsTime_DateTime(In: DateTime): string;
	static AsTimeZoneDate_DateTime(InDateTime: DateTime,InTimeZone: string): string;
	static AsTimeZoneDateTime_DateTime(InDateTime: DateTime,InTimeZone: string): string;
	static AsTimeZoneTime_DateTime(InDateTime: DateTime,InTimeZone: string): string;
	static Add_DateTimeDateTime(A: DateTime,B: DateTime): DateTime;
	static Add_DateTimeTimespan(A: DateTime,B: Timespan): DateTime;
	static BreakDateTime(InDateTime: DateTime,Year?: number,Month?: number,Day?: number,Hour?: number,Minute?: number,Second?: number,Millisecond?: number): {Year: number, Month: number, Day: number, Hour: number, Minute: number, Second: number, Millisecond: number};
	static EqualEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static GetDate(A: DateTime): DateTime;
	static GetDay(A: DateTime): number;
	static GetDayOfYear(A: DateTime): number;
	static GetHour(A: DateTime): number;
	static GetHour12(A: DateTime): number;
	static GetMillisecond(A: DateTime): number;
	static GetMinute(A: DateTime): number;
	static GetMonth(A: DateTime): number;
	static GetSecond(A: DateTime): number;
	static GetTimeOfDay(A: DateTime): Timespan;
	static GetYear(A: DateTime): number;
	static Greater_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static GreaterEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static IsAfternoon(A: DateTime): boolean;
	static IsMorning(A: DateTime): boolean;
	static Less_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static LessEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static NotEqual_DateTimeDateTime(A: DateTime,B: DateTime): boolean;
	static Subtract_DateTimeDateTime(A: DateTime,B: DateTime): Timespan;
	static Subtract_DateTimeTimespan(A: DateTime,B: Timespan): DateTime;
	static ScheduleLocalNotificationAtTime(FireDateTime: DateTime,LocalTime: boolean,Title: string,Body: string,Action: string,ActivationEvent: string): number;
	static ScheduleLocalNotificationBadgeAtTime(FireDateTime: DateTime,LocalTime: boolean,ActivationEvent: string): number;
	static DateTimeMaxValue(): DateTime;
	static DateTimeMinValue(): DateTime;
	static MakeDateTime(Year: number,Month: number,Day: number,Hour: number,Minute: number,Second: number,Millisecond: number): DateTime;
	static Now(): DateTime;
	static Today(): DateTime;
	static UtcNow(): DateTime;
}

declare class Guid { 
	A: number;
	B: number;
	C: number;
	D: number;
	clone() : Guid;
	static C(Other: UObject | any): Guid;
	FromGuid(): JsonLibraryValue;
	Conv_GuidToString(): string;
	EqualEqual_GuidGuid(B: Guid): boolean;
	Invalidate_Guid(): {InGuid: Guid};
	IsValid_Guid(): boolean;
	NotEqual_GuidGuid(B: Guid): boolean;
	static FromGuid(Value: Guid): JsonLibraryValue;
	static Conv_GuidToString(InGuid: Guid): string;
	static EqualEqual_GuidGuid(A: Guid,B: Guid): boolean;
	static Invalidate_Guid(InGuid?: Guid): {InGuid: Guid};
	static IsValid_Guid(InGuid: Guid): boolean;
	static NotEqual_GuidGuid(A: Guid,B: Guid): boolean;
	static NewGuid(): Guid;
}

declare type EJsonLibraryNotifyAction = 'None' | 'Added' | 'Removed' | 'Changed' | 'Reset' | 'EJsonLibraryNotifyAction_MAX';
declare var EJsonLibraryNotifyAction : { None:'None',Added:'Added',Removed:'Removed',Changed:'Changed',Reset:'Reset',EJsonLibraryNotifyAction_MAX:'EJsonLibraryNotifyAction_MAX', };
declare class JsonLibraryList { 
	clone() : JsonLibraryList;
	static C(Other: UObject | any): JsonLibraryList;
	ConvertListToArray(): JsonLibraryValue[];
	FromList(): JsonLibraryValue;
	JsonList_AddArray(Value?: JsonLibraryValue[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddBoolean(Value?: boolean): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddColor(Value?: Color): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddDateTime(Value?: DateTime): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddFloat(Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddGuid(Value?: Guid): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddInteger(Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddLinearColor(Value?: LinearColor): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddList(Value?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddMap(Value?: any): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddObject(Value?: JsonLibraryObject): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddRotator(Value?: Rotator): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddString(Value?: string): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddTransform(Value?: Transform): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddValue(Value?: JsonLibraryValue): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AddVector(Value?: Vector): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_Append(List?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AppendBooleanArray(Array?: boolean[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AppendColorArray(Array?: Color[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AppendDateTimeArray(Array?: DateTime[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AppendFloatArray(Array?: number[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AppendGuidArray(Array?: Guid[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AppendIntegerArray(Array?: number[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AppendLinearColorArray(Array?: LinearColor[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AppendObjectArray(Array?: JsonLibraryObject[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AppendRotatorArray(Array?: Rotator[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AppendStringArray(Array?: string[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AppendTransformArray(Array?: Transform[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_AppendVectorArray(Array?: Vector[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_Clear(): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_Count(): number;
	JsonList_Equals(List: JsonLibraryList): boolean;
	JsonList_FindBoolean(Value: boolean,index: number): number;
	JsonList_FindColor(Value: Color,index: number): number;
	JsonList_FindDateTime(Value: DateTime,index: number): number;
	JsonList_FindFloat(Value: number,index: number): number;
	JsonList_FindGuid(Value: Guid,index: number): number;
	JsonList_FindInteger(Value: number,index: number): number;
	JsonList_FindLinearColor(Value: LinearColor,index: number): number;
	JsonList_FindList(Value: JsonLibraryList,index: number): number;
	JsonList_FindObject(Value: JsonLibraryObject,index: number): number;
	JsonList_FindRotator(Value: Rotator,index: number): number;
	JsonList_FindString(Value: string,index: number): number;
	JsonList_FindTransform(Value: Transform,index: number): number;
	JsonList_FindValue(Value: JsonLibraryValue,index: number): number;
	JsonList_FindVector(Value: Vector,index: number): number;
	JsonList_GetArray(index: number): JsonLibraryValue[];
	JsonList_GetBoolean(index: number): boolean;
	JsonList_GetColor(index: number): Color;
	JsonList_GetDateTime(index: number): DateTime;
	JsonList_GetFloat(index: number): number;
	JsonList_GetGuid(index: number): Guid;
	JsonList_GetInteger(index: number): number;
	JsonList_GetLinearColor(index: number): LinearColor;
	JsonList_GetList(index: number): JsonLibraryList;
	JsonList_GetMap(index: number): any;
	JsonList_GetObject(index: number): JsonLibraryObject;
	JsonList_GetRotator(index: number): Rotator;
	JsonList_GetString(index: number): string;
	JsonList_GetTransform(index: number): Transform;
	JsonList_GetValue(index: number): JsonLibraryValue;
	JsonList_GetVector(index: number): Vector;
	JsonList_Inject(index?: number,List?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InjectBooleanArray(index?: number,Array?: boolean[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InjectColorArray(index?: number,Array?: Color[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InjectDateTimeArray(index?: number,Array?: DateTime[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InjectFloatArray(index?: number,Array?: number[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InjectGuidArray(index?: number,Array?: Guid[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InjectIntegerArray(index?: number,Array?: number[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InjectLinearColorArray(index?: number,Array?: LinearColor[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InjectObjectArray(index?: number,Array?: JsonLibraryObject[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InjectRotatorArray(index?: number,Array?: Rotator[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InjectStringArray(index?: number,Array?: string[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InjectTransformArray(index?: number,Array?: Transform[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InjectVectorArray(index?: number,Array?: Vector[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertArray(index?: number,Value?: JsonLibraryValue[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertBoolean(index?: number,Value?: boolean): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertColor(index?: number,Value?: Color): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertDateTime(index?: number,Value?: DateTime): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertFloat(index?: number,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertGuid(index?: number,Value?: Guid): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertInteger(index?: number,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertLinearColor(index?: number,Value?: LinearColor): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertList(index?: number,Value?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertMap(index?: number,Value?: any): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertObject(index?: number,Value?: JsonLibraryObject): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertRotator(index?: number,Value?: Rotator): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertString(index?: number,Value?: string): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertTransform(index?: number,Value?: Transform): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertValue(index?: number,Value?: JsonLibraryValue): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_InsertVector(index?: number,Value?: Vector): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_IsEmpty(): boolean;
	JsonList_IsValid(): boolean;
	JsonList_Remove(index?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveBoolean(Value?: boolean): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveColor(Value?: Color): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveDateTime(Value?: DateTime): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveFloat(Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveGuid(Value?: Guid): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveInteger(Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveLinearColor(Value?: LinearColor): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveList(Value?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveObject(Value?: JsonLibraryObject): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveRotator(Value?: Rotator): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveString(Value?: string): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveTransform(Value?: Transform): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveValue(Value?: JsonLibraryValue): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_RemoveVector(Value?: Vector): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetArray(index?: number,Value?: JsonLibraryValue[]): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetBoolean(index?: number,Value?: boolean): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetColor(index?: number,Value?: Color): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetDateTime(index?: number,Value?: DateTime): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetFloat(index?: number,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetGuid(index?: number,Value?: Guid): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetInteger(index?: number,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetLinearColor(index?: number,Value?: LinearColor): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetList(index?: number,Value?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetMap(index?: number,Value?: any): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetObject(index?: number,Value?: JsonLibraryObject): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetRotator(index?: number,Value?: Rotator): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetString(index?: number,Value?: string): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetTransform(index?: number,Value?: Transform): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetValue(index?: number,Value?: JsonLibraryValue): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_SetVector(index?: number,Value?: Vector): {Target: JsonLibraryList, $: JsonLibraryList};
	JsonList_Stringify(bCondensed: boolean): string;
	JsonList_Swap(IndexA?: number,IndexB?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static ConvertListToArray(List: JsonLibraryList): JsonLibraryValue[];
	static FromList(Value: JsonLibraryList): JsonLibraryValue;
	static JsonList_AddArray(Target?: JsonLibraryList,Value?: JsonLibraryValue[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddBoolean(Target?: JsonLibraryList,Value?: boolean): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddColor(Target?: JsonLibraryList,Value?: Color): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddDateTime(Target?: JsonLibraryList,Value?: DateTime): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddFloat(Target?: JsonLibraryList,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddGuid(Target?: JsonLibraryList,Value?: Guid): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddInteger(Target?: JsonLibraryList,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddLinearColor(Target?: JsonLibraryList,Value?: LinearColor): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddList(Target?: JsonLibraryList,Value?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddMap(Target?: JsonLibraryList,Value?: any): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddObject(Target?: JsonLibraryList,Value?: JsonLibraryObject): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddRotator(Target?: JsonLibraryList,Value?: Rotator): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddString(Target?: JsonLibraryList,Value?: string): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddTransform(Target?: JsonLibraryList,Value?: Transform): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddValue(Target?: JsonLibraryList,Value?: JsonLibraryValue): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AddVector(Target?: JsonLibraryList,Value?: Vector): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_Append(Target?: JsonLibraryList,List?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendBooleanArray(Target?: JsonLibraryList,Array?: boolean[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendColorArray(Target?: JsonLibraryList,Array?: Color[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendDateTimeArray(Target?: JsonLibraryList,Array?: DateTime[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendFloatArray(Target?: JsonLibraryList,Array?: number[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendGuidArray(Target?: JsonLibraryList,Array?: Guid[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendIntegerArray(Target?: JsonLibraryList,Array?: number[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendLinearColorArray(Target?: JsonLibraryList,Array?: LinearColor[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendObjectArray(Target?: JsonLibraryList,Array?: JsonLibraryObject[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendRotatorArray(Target?: JsonLibraryList,Array?: Rotator[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendStringArray(Target?: JsonLibraryList,Array?: string[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendTransformArray(Target?: JsonLibraryList,Array?: Transform[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_AppendVectorArray(Target?: JsonLibraryList,Array?: Vector[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_Clear(Target?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_Count(Target: JsonLibraryList): number;
	static JsonList_Equals(Target: JsonLibraryList,List: JsonLibraryList): boolean;
	static JsonList_FindBoolean(Target: JsonLibraryList,Value: boolean,index: number): number;
	static JsonList_FindColor(Target: JsonLibraryList,Value: Color,index: number): number;
	static JsonList_FindDateTime(Target: JsonLibraryList,Value: DateTime,index: number): number;
	static JsonList_FindFloat(Target: JsonLibraryList,Value: number,index: number): number;
	static JsonList_FindGuid(Target: JsonLibraryList,Value: Guid,index: number): number;
	static JsonList_FindInteger(Target: JsonLibraryList,Value: number,index: number): number;
	static JsonList_FindLinearColor(Target: JsonLibraryList,Value: LinearColor,index: number): number;
	static JsonList_FindList(Target: JsonLibraryList,Value: JsonLibraryList,index: number): number;
	static JsonList_FindObject(Target: JsonLibraryList,Value: JsonLibraryObject,index: number): number;
	static JsonList_FindRotator(Target: JsonLibraryList,Value: Rotator,index: number): number;
	static JsonList_FindString(Target: JsonLibraryList,Value: string,index: number): number;
	static JsonList_FindTransform(Target: JsonLibraryList,Value: Transform,index: number): number;
	static JsonList_FindValue(Target: JsonLibraryList,Value: JsonLibraryValue,index: number): number;
	static JsonList_FindVector(Target: JsonLibraryList,Value: Vector,index: number): number;
	static JsonList_GetArray(Target: JsonLibraryList,index: number): JsonLibraryValue[];
	static JsonList_GetBoolean(Target: JsonLibraryList,index: number): boolean;
	static JsonList_GetColor(Target: JsonLibraryList,index: number): Color;
	static JsonList_GetDateTime(Target: JsonLibraryList,index: number): DateTime;
	static JsonList_GetFloat(Target: JsonLibraryList,index: number): number;
	static JsonList_GetGuid(Target: JsonLibraryList,index: number): Guid;
	static JsonList_GetInteger(Target: JsonLibraryList,index: number): number;
	static JsonList_GetLinearColor(Target: JsonLibraryList,index: number): LinearColor;
	static JsonList_GetList(Target: JsonLibraryList,index: number): JsonLibraryList;
	static JsonList_GetMap(Target: JsonLibraryList,index: number): any;
	static JsonList_GetObject(Target: JsonLibraryList,index: number): JsonLibraryObject;
	static JsonList_GetRotator(Target: JsonLibraryList,index: number): Rotator;
	static JsonList_GetString(Target: JsonLibraryList,index: number): string;
	static JsonList_GetTransform(Target: JsonLibraryList,index: number): Transform;
	static JsonList_GetValue(Target: JsonLibraryList,index: number): JsonLibraryValue;
	static JsonList_GetVector(Target: JsonLibraryList,index: number): Vector;
	static JsonList_Inject(Target?: JsonLibraryList,index?: number,List?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectBooleanArray(Target?: JsonLibraryList,index?: number,Array?: boolean[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectColorArray(Target?: JsonLibraryList,index?: number,Array?: Color[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectDateTimeArray(Target?: JsonLibraryList,index?: number,Array?: DateTime[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectFloatArray(Target?: JsonLibraryList,index?: number,Array?: number[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectGuidArray(Target?: JsonLibraryList,index?: number,Array?: Guid[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectIntegerArray(Target?: JsonLibraryList,index?: number,Array?: number[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectLinearColorArray(Target?: JsonLibraryList,index?: number,Array?: LinearColor[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectObjectArray(Target?: JsonLibraryList,index?: number,Array?: JsonLibraryObject[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectRotatorArray(Target?: JsonLibraryList,index?: number,Array?: Rotator[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectStringArray(Target?: JsonLibraryList,index?: number,Array?: string[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectTransformArray(Target?: JsonLibraryList,index?: number,Array?: Transform[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InjectVectorArray(Target?: JsonLibraryList,index?: number,Array?: Vector[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertArray(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryValue[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertBoolean(Target?: JsonLibraryList,index?: number,Value?: boolean): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertColor(Target?: JsonLibraryList,index?: number,Value?: Color): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertDateTime(Target?: JsonLibraryList,index?: number,Value?: DateTime): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertFloat(Target?: JsonLibraryList,index?: number,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertGuid(Target?: JsonLibraryList,index?: number,Value?: Guid): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertInteger(Target?: JsonLibraryList,index?: number,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertLinearColor(Target?: JsonLibraryList,index?: number,Value?: LinearColor): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertList(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertMap(Target?: JsonLibraryList,index?: number,Value?: any): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertObject(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryObject): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertRotator(Target?: JsonLibraryList,index?: number,Value?: Rotator): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertString(Target?: JsonLibraryList,index?: number,Value?: string): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertTransform(Target?: JsonLibraryList,index?: number,Value?: Transform): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertValue(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryValue): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_InsertVector(Target?: JsonLibraryList,index?: number,Value?: Vector): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_IsEmpty(Target: JsonLibraryList): boolean;
	static JsonList_IsValid(Target: JsonLibraryList): boolean;
	static JsonList_Remove(Target?: JsonLibraryList,index?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveBoolean(Target?: JsonLibraryList,Value?: boolean): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveColor(Target?: JsonLibraryList,Value?: Color): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveDateTime(Target?: JsonLibraryList,Value?: DateTime): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveFloat(Target?: JsonLibraryList,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveGuid(Target?: JsonLibraryList,Value?: Guid): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveInteger(Target?: JsonLibraryList,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveLinearColor(Target?: JsonLibraryList,Value?: LinearColor): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveList(Target?: JsonLibraryList,Value?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveObject(Target?: JsonLibraryList,Value?: JsonLibraryObject): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveRotator(Target?: JsonLibraryList,Value?: Rotator): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveString(Target?: JsonLibraryList,Value?: string): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveTransform(Target?: JsonLibraryList,Value?: Transform): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveValue(Target?: JsonLibraryList,Value?: JsonLibraryValue): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_RemoveVector(Target?: JsonLibraryList,Value?: Vector): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetArray(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryValue[]): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetBoolean(Target?: JsonLibraryList,index?: number,Value?: boolean): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetColor(Target?: JsonLibraryList,index?: number,Value?: Color): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetDateTime(Target?: JsonLibraryList,index?: number,Value?: DateTime): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetFloat(Target?: JsonLibraryList,index?: number,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetGuid(Target?: JsonLibraryList,index?: number,Value?: Guid): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetInteger(Target?: JsonLibraryList,index?: number,Value?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetLinearColor(Target?: JsonLibraryList,index?: number,Value?: LinearColor): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetList(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryList): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetMap(Target?: JsonLibraryList,index?: number,Value?: any): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetObject(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryObject): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetRotator(Target?: JsonLibraryList,index?: number,Value?: Rotator): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetString(Target?: JsonLibraryList,index?: number,Value?: string): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetTransform(Target?: JsonLibraryList,index?: number,Value?: Transform): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetValue(Target?: JsonLibraryList,index?: number,Value?: JsonLibraryValue): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_SetVector(Target?: JsonLibraryList,index?: number,Value?: Vector): {Target: JsonLibraryList, $: JsonLibraryList};
	static JsonList_Stringify(Target: JsonLibraryList,bCondensed: boolean): string;
	static JsonList_Swap(Target?: JsonLibraryList,IndexA?: number,IndexB?: number): {Target: JsonLibraryList, $: JsonLibraryList};
	static ConstructList(Notify: UnrealEngineDelegate<(List: JsonLibraryValue, Action: EJsonLibraryNotifyAction, index: number, Value: JsonLibraryValue) => void>): JsonLibraryList;
	static ConvertArrayToList(Value: JsonLibraryValue[]): JsonLibraryList;
	static ConvertBooleanArrayToList(Value: boolean[]): JsonLibraryList;
	static ConvertColorArrayToList(Value: Color[]): JsonLibraryList;
	static ConvertDateTimeArrayToList(Value: DateTime[]): JsonLibraryList;
	static ConvertFloatArrayToList(Value: number[]): JsonLibraryList;
	static ConvertGuidArrayToList(Value: Guid[]): JsonLibraryList;
	static ConvertIntegerArrayToList(Value: number[]): JsonLibraryList;
	static ConvertLinearColorArrayToList(Value: LinearColor[]): JsonLibraryList;
	static ConvertObjectArrayToList(Value: JsonLibraryObject[]): JsonLibraryList;
	static ConvertRotatorArrayToList(Value: Rotator[]): JsonLibraryList;
	static ConvertStringArrayToList(Value: string[]): JsonLibraryList;
	static ConvertTransformArrayToList(Value: Transform[]): JsonLibraryList;
	static ConvertVectorArrayToList(Value: Vector[]): JsonLibraryList;
	static ParseList(text: string,Notify: UnrealEngineDelegate<(List: JsonLibraryValue, Action: EJsonLibraryNotifyAction, index: number, Value: JsonLibraryValue) => void>): JsonLibraryList;
}

declare class JsonLibraryValue { 
	clone() : JsonLibraryValue;
	static C(Other: UObject | any): JsonLibraryValue;
	ConvertJsonToBytes(): number[];
	JsonValue_Equals(Value: JsonLibraryValue): boolean;
	JsonValue_GetType(): EJsonLibraryType;
	JsonValue_IsGuid(): boolean;
	JsonValue_IsRotator(): boolean;
	JsonValue_IsTransform(): boolean;
	JsonValue_IsValid(): boolean;
	JsonValue_IsVector(): boolean;
	JsonValue_Stringify(bCondensed: boolean): string;
	ToArray(): JsonLibraryValue[];
	ToBoolean(): boolean;
	ToBooleanArray(): boolean[];
	ToBooleanMap(): any;
	ToColor(): Color;
	ToColorArray(): Color[];
	ToColorMap(): any;
	ToDateTime(): DateTime;
	ToDateTimeArray(): DateTime[];
	ToDateTimeMap(): any;
	ToFloat(): number;
	ToFloatArray(): number[];
	ToFloatMap(): any;
	ToGuid(): Guid;
	ToGuidArray(): Guid[];
	ToGuidMap(): any;
	ToInteger(): number;
	ToIntegerArray(): number[];
	ToIntegerMap(): any;
	ToLinearColor(): LinearColor;
	ToLinearColorArray(): LinearColor[];
	ToLinearColorMap(): any;
	ToList(): JsonLibraryList;
	ToMap(): any;
	ToObject(): JsonLibraryObject;
	ToObjectArray(): JsonLibraryObject[];
	ToRotator(): Rotator;
	ToRotatorArray(): Rotator[];
	ToRotatorMap(): any;
	ToString(): string;
	ToStringArray(): string[];
	ToStringMap(): any;
	ToTransform(): Transform;
	ToTransformArray(): Transform[];
	ToTransformMap(): any;
	ToVector(): Vector;
	ToVectorArray(): Vector[];
	ToVectorMap(): any;
	static ConvertJsonToBytes(Data: JsonLibraryValue): number[];
	static JsonValue_Equals(Target: JsonLibraryValue,Value: JsonLibraryValue): boolean;
	static JsonValue_GetType(Target: JsonLibraryValue): EJsonLibraryType;
	static JsonValue_IsGuid(Target: JsonLibraryValue): boolean;
	static JsonValue_IsRotator(Target: JsonLibraryValue): boolean;
	static JsonValue_IsTransform(Target: JsonLibraryValue): boolean;
	static JsonValue_IsValid(Target: JsonLibraryValue): boolean;
	static JsonValue_IsVector(Target: JsonLibraryValue): boolean;
	static JsonValue_Stringify(Target: JsonLibraryValue,bCondensed: boolean): string;
	static ToArray(Target: JsonLibraryValue): JsonLibraryValue[];
	static ToBoolean(Value: JsonLibraryValue): boolean;
	static ToBooleanArray(Target: JsonLibraryValue): boolean[];
	static ToBooleanMap(Target: JsonLibraryValue): any;
	static ToColor(Value: JsonLibraryValue): Color;
	static ToColorArray(Target: JsonLibraryValue): Color[];
	static ToColorMap(Target: JsonLibraryValue): any;
	static ToDateTime(Value: JsonLibraryValue): DateTime;
	static ToDateTimeArray(Target: JsonLibraryValue): DateTime[];
	static ToDateTimeMap(Target: JsonLibraryValue): any;
	static ToFloat(Value: JsonLibraryValue): number;
	static ToFloatArray(Target: JsonLibraryValue): number[];
	static ToFloatMap(Target: JsonLibraryValue): any;
	static ToGuid(Value: JsonLibraryValue): Guid;
	static ToGuidArray(Target: JsonLibraryValue): Guid[];
	static ToGuidMap(Target: JsonLibraryValue): any;
	static ToInteger(Value: JsonLibraryValue): number;
	static ToIntegerArray(Target: JsonLibraryValue): number[];
	static ToIntegerMap(Target: JsonLibraryValue): any;
	static ToLinearColor(Value: JsonLibraryValue): LinearColor;
	static ToLinearColorArray(Target: JsonLibraryValue): LinearColor[];
	static ToLinearColorMap(Target: JsonLibraryValue): any;
	static ToList(Value: JsonLibraryValue): JsonLibraryList;
	static ToMap(Target: JsonLibraryValue): any;
	static ToObject(Value: JsonLibraryValue): JsonLibraryObject;
	static ToObjectArray(Target: JsonLibraryValue): JsonLibraryObject[];
	static ToRotator(Value: JsonLibraryValue): Rotator;
	static ToRotatorArray(Target: JsonLibraryValue): Rotator[];
	static ToRotatorMap(Target: JsonLibraryValue): any;
	static ToString(Value: JsonLibraryValue): string;
	static ToStringArray(Target: JsonLibraryValue): string[];
	static ToStringMap(Target: JsonLibraryValue): any;
	static ToTransform(Value: JsonLibraryValue): Transform;
	static ToTransformArray(Target: JsonLibraryValue): Transform[];
	static ToTransformMap(Target: JsonLibraryValue): any;
	static ToVector(Value: JsonLibraryValue): Vector;
	static ToVectorArray(Target: JsonLibraryValue): Vector[];
	static ToVectorMap(Target: JsonLibraryValue): any;
	static ConvertBytesToJson(Data: number[]): JsonLibraryValue;
	static ConstructNull(): JsonLibraryValue;
	static FromArray(Value: JsonLibraryValue[]): JsonLibraryValue;
	static FromBoolean(Value: boolean): JsonLibraryValue;
	static FromBooleanArray(Value: boolean[]): JsonLibraryValue;
	static FromBooleanMap(Value: any): JsonLibraryValue;
	static FromColorArray(Value: Color[]): JsonLibraryValue;
	static FromColorMap(Value: any): JsonLibraryValue;
	static FromDateTimeArray(Value: DateTime[]): JsonLibraryValue;
	static FromDateTimeMap(Value: any): JsonLibraryValue;
	static FromFloat(Value: number): JsonLibraryValue;
	static FromFloatArray(Value: number[]): JsonLibraryValue;
	static FromFloatMap(Value: any): JsonLibraryValue;
	static FromGuidArray(Value: Guid[]): JsonLibraryValue;
	static FromGuidMap(Value: any): JsonLibraryValue;
	static FromInteger(Value: number): JsonLibraryValue;
	static FromIntegerArray(Value: number[]): JsonLibraryValue;
	static FromIntegerMap(Value: any): JsonLibraryValue;
	static FromLinearColorArray(Value: LinearColor[]): JsonLibraryValue;
	static FromLinearColorMap(Value: any): JsonLibraryValue;
	static FromMap(Value: any): JsonLibraryValue;
	static FromObjectArray(Value: JsonLibraryObject[]): JsonLibraryValue;
	static FromRotatorArray(Value: Rotator[]): JsonLibraryValue;
	static FromRotatorMap(Value: any): JsonLibraryValue;
	static FromString(Value: string): JsonLibraryValue;
	static FromStringArray(Value: string[]): JsonLibraryValue;
	static FromStringMap(Value: any): JsonLibraryValue;
	static FromTransformArray(Value: Transform[]): JsonLibraryValue;
	static FromTransformMap(Value: any): JsonLibraryValue;
	static FromVectorArray(Value: Vector[]): JsonLibraryValue;
	static FromVectorMap(Value: any): JsonLibraryValue;
	static Parse(text: string,bComments: boolean,bTrailingCommas: boolean): JsonLibraryValue;
}

declare class LinearColor { 
	R: number;
	G: number;
	B: number;
	A: number;
	clone() : LinearColor;
	static C(Other: UObject | any): LinearColor;
	ConvertLinearColorToObject(): JsonLibraryObject;
	FromLinearColor(): JsonLibraryValue;
	Conv_ColorToText(): string;
	Conv_ColorToString(): string;
	Add_LinearColorLinearColor(B: LinearColor): LinearColor;
	BreakColor(R?: number,G?: number,B?: number,A?: number): {R: number, G: number, B: number, A: number};
	CInterpTo(Target: LinearColor,DeltaTime: number,InterpSpeed: number): LinearColor;
	Conv_LinearColorToColor(InUseSRGB: boolean): Color;
	Conv_LinearColorToVector(): Vector;
	Divide_LinearColorLinearColor(B: LinearColor): LinearColor;
	EqualEqual_LinearColorLinearColor(B: LinearColor): boolean;
	HSVToRGB_Vector(RGB?: LinearColor): {RGB: LinearColor};
	HSVToRGBLinear(): LinearColor;
	LinearColor_Desaturated(InDesaturation: number): LinearColor;
	LinearColor_Distance(C2: LinearColor): number;
	LinearColor_GetLuminance(): number;
	LinearColor_GetMax(): number;
	LinearColor_GetMin(): number;
	LinearColor_IsNearEqual(B: LinearColor,Tolerance: number): boolean;
	LinearColor_Quantize(): Color;
	LinearColor_QuantizeRound(): Color;
	LinearColor_Set(InColor?: LinearColor): {InOutColor: LinearColor};
	LinearColor_SetFromHSV(H?: number,S?: number,V?: number,A?: number): {InOutColor: LinearColor};
	LinearColor_SetFromPow22(InColor?: Color): {InOutColor: LinearColor};
	LinearColor_SetFromSRGB(InSRGB?: Color): {InOutColor: LinearColor};
	LinearColor_SetRandomHue(): {InOutColor: LinearColor};
	LinearColor_SetRGBA(R?: number,G?: number,B?: number,A?: number): {InOutColor: LinearColor};
	LinearColor_SetTemperature(InTemperature?: number): {InOutColor: LinearColor};
	LinearColor_ToNewOpacity(InOpacity: number): LinearColor;
	LinearColor_ToRGBE(): Color;
	LinearColorLerp(B: LinearColor,Alpha: number): LinearColor;
	LinearColorLerpUsingHSV(B: LinearColor,Alpha: number): LinearColor;
	Multiply_LinearColorFloat(B: number): LinearColor;
	Multiply_LinearColorLinearColor(B: LinearColor): LinearColor;
	NotEqual_LinearColorLinearColor(B: LinearColor): boolean;
	RGBLinearToHSV(): LinearColor;
	RGBToHSV(H?: number,S?: number,V?: number,A?: number): {H: number, S: number, V: number, A: number};
	RGBToHSV_Vector(HSV?: LinearColor): {HSV: LinearColor};
	SelectColor(B: LinearColor,bPickA: boolean): LinearColor;
	Subtract_LinearColorLinearColor(B: LinearColor): LinearColor;
	static ConvertLinearColorToObject(Value: LinearColor): JsonLibraryObject;
	static FromLinearColor(Value: LinearColor): JsonLibraryValue;
	static Conv_ColorToText(InColor: LinearColor): string;
	static Conv_ColorToString(InColor: LinearColor): string;
	static Add_LinearColorLinearColor(A: LinearColor,B: LinearColor): LinearColor;
	static BreakColor(InColor: LinearColor,R?: number,G?: number,B?: number,A?: number): {R: number, G: number, B: number, A: number};
	static CInterpTo(Current: LinearColor,Target: LinearColor,DeltaTime: number,InterpSpeed: number): LinearColor;
	static Conv_LinearColorToColor(InLinearColor: LinearColor,InUseSRGB: boolean): Color;
	static Conv_LinearColorToVector(InLinearColor: LinearColor): Vector;
	static Divide_LinearColorLinearColor(A: LinearColor,B: LinearColor): LinearColor;
	static EqualEqual_LinearColorLinearColor(A: LinearColor,B: LinearColor): boolean;
	static HSVToRGB_Vector(HSV: LinearColor,RGB?: LinearColor): {RGB: LinearColor};
	static HSVToRGBLinear(HSV: LinearColor): LinearColor;
	static LinearColor_Desaturated(InColor: LinearColor,InDesaturation: number): LinearColor;
	static LinearColor_Distance(C1: LinearColor,C2: LinearColor): number;
	static LinearColor_GetLuminance(InColor: LinearColor): number;
	static LinearColor_GetMax(InColor: LinearColor): number;
	static LinearColor_GetMin(InColor: LinearColor): number;
	static LinearColor_IsNearEqual(A: LinearColor,B: LinearColor,Tolerance: number): boolean;
	static LinearColor_Quantize(InColor: LinearColor): Color;
	static LinearColor_QuantizeRound(InColor: LinearColor): Color;
	static LinearColor_Set(InOutColor?: LinearColor,InColor?: LinearColor): {InOutColor: LinearColor};
	static LinearColor_SetFromHSV(InOutColor?: LinearColor,H?: number,S?: number,V?: number,A?: number): {InOutColor: LinearColor};
	static LinearColor_SetFromPow22(InOutColor?: LinearColor,InColor?: Color): {InOutColor: LinearColor};
	static LinearColor_SetFromSRGB(InOutColor?: LinearColor,InSRGB?: Color): {InOutColor: LinearColor};
	static LinearColor_SetRandomHue(InOutColor?: LinearColor): {InOutColor: LinearColor};
	static LinearColor_SetRGBA(InOutColor?: LinearColor,R?: number,G?: number,B?: number,A?: number): {InOutColor: LinearColor};
	static LinearColor_SetTemperature(InOutColor?: LinearColor,InTemperature?: number): {InOutColor: LinearColor};
	static LinearColor_ToNewOpacity(InColor: LinearColor,InOpacity: number): LinearColor;
	static LinearColor_ToRGBE(InLinearColor: LinearColor): Color;
	static LinearColorLerp(A: LinearColor,B: LinearColor,Alpha: number): LinearColor;
	static LinearColorLerpUsingHSV(A: LinearColor,B: LinearColor,Alpha: number): LinearColor;
	static Multiply_LinearColorFloat(A: LinearColor,B: number): LinearColor;
	static Multiply_LinearColorLinearColor(A: LinearColor,B: LinearColor): LinearColor;
	static NotEqual_LinearColorLinearColor(A: LinearColor,B: LinearColor): boolean;
	static RGBLinearToHSV(RGB: LinearColor): LinearColor;
	static RGBToHSV(InColor: LinearColor,H?: number,S?: number,V?: number,A?: number): {H: number, S: number, V: number, A: number};
	static RGBToHSV_Vector(RGB: LinearColor,HSV?: LinearColor): {HSV: LinearColor};
	static SelectColor(A: LinearColor,B: LinearColor,bPickA: boolean): LinearColor;
	static Subtract_LinearColorLinearColor(A: LinearColor,B: LinearColor): LinearColor;
	static Conv_DoubleToLinearColor(InDouble: any): LinearColor;
	static Conv_FloatToLinearColor(InFloat: number): LinearColor;
	static HSVToRGB(H: number,S: number,V: number,A: number): LinearColor;
	static LinearColor_Black(): LinearColor;
	static LinearColor_Blue(): LinearColor;
	static LinearColor_Gray(): LinearColor;
	static LinearColor_Green(): LinearColor;
	static LinearColor_Red(): LinearColor;
	static LinearColor_Transparent(): LinearColor;
	static LinearColor_White(): LinearColor;
	static LinearColor_Yellow(): LinearColor;
	static MakeColor(R: number,G: number,B: number,A: number): LinearColor;
}

declare class JsonLibraryObject { 
	clone() : JsonLibraryObject;
	static C(Other: UObject | any): JsonLibraryObject;
	ConvertObjectToLinearColor(): LinearColor;
	ConvertObjectToMap(): any;
	ConvertObjectToRotator(): Rotator;
	ConvertObjectToTransform(): Transform;
	ConvertObjectToVector(): Vector;
	FromObject(): JsonLibraryValue;
	JsonObject_Add(UObject?: JsonLibraryObject): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_AddBooleanMap(Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_AddColorMap(Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_AddDateTimeMap(Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_AddFloatMap(Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_AddGuidMap(Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_AddIntegerMap(Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_AddLinearColorMap(Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_AddRotatorMap(Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_AddStringMap(Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_AddTransformMap(Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_AddVectorMap(Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_Clear(): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_Count(): number;
	JsonObject_Equals(UObject: JsonLibraryObject): boolean;
	JsonObject_GetArray(Key: string): JsonLibraryValue[];
	JsonObject_GetBoolean(Key: string): boolean;
	JsonObject_GetColor(Key: string): Color;
	JsonObject_GetDateTime(Key: string): DateTime;
	JsonObject_GetFloat(Key: string): number;
	JsonObject_GetGuid(Key: string): Guid;
	JsonObject_GetInteger(Key: string): number;
	JsonObject_GetKeys(): string[];
	JsonObject_GetLinearColor(Key: string): LinearColor;
	JsonObject_GetList(Key: string): JsonLibraryList;
	JsonObject_GetMap(Key: string): any;
	JsonObject_GetObject(Key: string): JsonLibraryObject;
	JsonObject_GetRotator(Key: string): Rotator;
	JsonObject_GetString(Key: string): string;
	JsonObject_GetTransform(Key: string): Transform;
	JsonObject_GetValue(Key: string): JsonLibraryValue;
	JsonObject_GetValues(): JsonLibraryValue[];
	JsonObject_GetVector(Key: string): Vector;
	JsonObject_HasKey(Key: string): boolean;
	JsonObject_IsEmpty(): boolean;
	JsonObject_IsRotator(): boolean;
	JsonObject_IsTransform(): boolean;
	JsonObject_IsValid(): boolean;
	JsonObject_IsVector(): boolean;
	JsonObject_RemoveKey(Key?: string): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetArray(Key?: string,Value?: JsonLibraryValue[]): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetBoolean(Key?: string,Value?: boolean): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetColor(Key?: string,Value?: Color): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetDateTime(Key?: string,Value?: DateTime): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetFloat(Key?: string,Value?: number): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetGuid(Key?: string,Value?: Guid): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetInteger(Key?: string,Value?: number): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetLinearColor(Key?: string,Value?: LinearColor): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetList(Key?: string,Value?: JsonLibraryList): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetMap(Key?: string,Value?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetObject(Key?: string,Value?: JsonLibraryObject): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetRotator(Key?: string,Value?: Rotator): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetString(Key?: string,Value?: string): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetTransform(Key?: string,Value?: Transform): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetValue(Key?: string,Value?: JsonLibraryValue): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_SetVector(Key?: string,Value?: Vector): {Target: JsonLibraryObject, $: JsonLibraryObject};
	JsonObject_Stringify(bCondensed: boolean): string;
	IsValidObject(): boolean;
	static ConvertObjectToLinearColor(UObject: JsonLibraryObject): LinearColor;
	static ConvertObjectToMap(UObject: JsonLibraryObject): any;
	static ConvertObjectToRotator(UObject: JsonLibraryObject): Rotator;
	static ConvertObjectToTransform(UObject: JsonLibraryObject): Transform;
	static ConvertObjectToVector(UObject: JsonLibraryObject): Vector;
	static FromObject(Value: JsonLibraryObject): JsonLibraryValue;
	static JsonObject_Add(Target?: JsonLibraryObject,UObject?: JsonLibraryObject): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddBooleanMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddColorMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddDateTimeMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddFloatMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddGuidMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddIntegerMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddLinearColorMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddRotatorMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddStringMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddTransformMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_AddVectorMap(Target?: JsonLibraryObject,Map?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_Clear(Target?: JsonLibraryObject): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_Count(Target: JsonLibraryObject): number;
	static JsonObject_Equals(Target: JsonLibraryObject,UObject: JsonLibraryObject): boolean;
	static JsonObject_GetArray(Target: JsonLibraryObject,Key: string): JsonLibraryValue[];
	static JsonObject_GetBoolean(Target: JsonLibraryObject,Key: string): boolean;
	static JsonObject_GetColor(Target: JsonLibraryObject,Key: string): Color;
	static JsonObject_GetDateTime(Target: JsonLibraryObject,Key: string): DateTime;
	static JsonObject_GetFloat(Target: JsonLibraryObject,Key: string): number;
	static JsonObject_GetGuid(Target: JsonLibraryObject,Key: string): Guid;
	static JsonObject_GetInteger(Target: JsonLibraryObject,Key: string): number;
	static JsonObject_GetKeys(Target: JsonLibraryObject): string[];
	static JsonObject_GetLinearColor(Target: JsonLibraryObject,Key: string): LinearColor;
	static JsonObject_GetList(Target: JsonLibraryObject,Key: string): JsonLibraryList;
	static JsonObject_GetMap(Target: JsonLibraryObject,Key: string): any;
	static JsonObject_GetObject(Target: JsonLibraryObject,Key: string): JsonLibraryObject;
	static JsonObject_GetRotator(Target: JsonLibraryObject,Key: string): Rotator;
	static JsonObject_GetString(Target: JsonLibraryObject,Key: string): string;
	static JsonObject_GetTransform(Target: JsonLibraryObject,Key: string): Transform;
	static JsonObject_GetValue(Target: JsonLibraryObject,Key: string): JsonLibraryValue;
	static JsonObject_GetValues(Target: JsonLibraryObject): JsonLibraryValue[];
	static JsonObject_GetVector(Target: JsonLibraryObject,Key: string): Vector;
	static JsonObject_HasKey(Target: JsonLibraryObject,Key: string): boolean;
	static JsonObject_IsEmpty(Target: JsonLibraryObject): boolean;
	static JsonObject_IsRotator(Target: JsonLibraryObject): boolean;
	static JsonObject_IsTransform(Target: JsonLibraryObject): boolean;
	static JsonObject_IsValid(Target: JsonLibraryObject): boolean;
	static JsonObject_IsVector(Target: JsonLibraryObject): boolean;
	static JsonObject_RemoveKey(Target?: JsonLibraryObject,Key?: string): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetArray(Target?: JsonLibraryObject,Key?: string,Value?: JsonLibraryValue[]): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetBoolean(Target?: JsonLibraryObject,Key?: string,Value?: boolean): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetColor(Target?: JsonLibraryObject,Key?: string,Value?: Color): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetDateTime(Target?: JsonLibraryObject,Key?: string,Value?: DateTime): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetFloat(Target?: JsonLibraryObject,Key?: string,Value?: number): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetGuid(Target?: JsonLibraryObject,Key?: string,Value?: Guid): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetInteger(Target?: JsonLibraryObject,Key?: string,Value?: number): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetLinearColor(Target?: JsonLibraryObject,Key?: string,Value?: LinearColor): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetList(Target?: JsonLibraryObject,Key?: string,Value?: JsonLibraryList): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetMap(Target?: JsonLibraryObject,Key?: string,Value?: any): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetObject(Target?: JsonLibraryObject,Key?: string,Value?: JsonLibraryObject): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetRotator(Target?: JsonLibraryObject,Key?: string,Value?: Rotator): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetString(Target?: JsonLibraryObject,Key?: string,Value?: string): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetTransform(Target?: JsonLibraryObject,Key?: string,Value?: Transform): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetValue(Target?: JsonLibraryObject,Key?: string,Value?: JsonLibraryValue): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_SetVector(Target?: JsonLibraryObject,Key?: string,Value?: Vector): {Target: JsonLibraryObject, $: JsonLibraryObject};
	static JsonObject_Stringify(Target: JsonLibraryObject,bCondensed: boolean): string;
	static IsValidObject(UObject: JsonLibraryObject): boolean;
	static ConstructObject(Notify: UnrealEngineDelegate<(UObject: JsonLibraryValue, Action: EJsonLibraryNotifyAction, Key: string, Value: JsonLibraryValue) => void>): JsonLibraryObject;
	static ConvertBooleanMapToObject(Value: any): JsonLibraryObject;
	static ConvertColorMapToObject(Value: any): JsonLibraryObject;
	static ConvertDateTimeMapToObject(Value: any): JsonLibraryObject;
	static ConvertFloatMapToObject(Value: any): JsonLibraryObject;
	static ConvertGuidMapToObject(Value: any): JsonLibraryObject;
	static ConvertIntegerMapToObject(Value: any): JsonLibraryObject;
	static ConvertLinearColorMapToObject(Value: any): JsonLibraryObject;
	static ConvertMapToObject(Value: any): JsonLibraryObject;
	static ConvertRotatorMapToObject(Value: any): JsonLibraryObject;
	static ConvertStringMapToObject(Value: any): JsonLibraryObject;
	static ConvertTransformMapToObject(Value: any): JsonLibraryObject;
	static ConvertVectorMapToObject(Value: any): JsonLibraryObject;
	static ParseObject(text: string,Notify: UnrealEngineDelegate<(UObject: JsonLibraryValue, Action: EJsonLibraryNotifyAction, Key: string, Value: JsonLibraryValue) => void>): JsonLibraryObject;
	static ConstructInvalidObject(): JsonLibraryObject;
}

declare type EEasingFunc = 'Linear' | 'Step' | 'SinusoidalIn' | 'SinusoidalOut' | 'SinusoidalInOut' | 'EaseIn' | 'EaseOut' | 'EaseInOut' | 'ExpoIn' | 'ExpoOut' | 'ExpoInOut' | 'CircularIn' | 'CircularOut' | 'CircularInOut' | 'EEasingFunc_MAX';
declare var EEasingFunc : { Linear:'Linear',Step:'Step',SinusoidalIn:'SinusoidalIn',SinusoidalOut:'SinusoidalOut',SinusoidalInOut:'SinusoidalInOut',EaseIn:'EaseIn',EaseOut:'EaseOut',EaseInOut:'EaseInOut',ExpoIn:'ExpoIn',ExpoOut:'ExpoOut',ExpoInOut:'ExpoInOut',CircularIn:'CircularIn',CircularOut:'CircularOut',CircularInOut:'CircularInOut',EEasingFunc_MAX:'EEasingFunc_MAX', };
declare class RandomStream { 
	InitialSeed: number;
	Seed: number;
	clone() : RandomStream;
	static C(Other: UObject | any): RandomStream;
	BreakRandomStream(InitialSeed?: number): {InitialSeed: number};
	RandomBoolFromStream(): boolean;
	RandomFloatFromStream(): number;
	RandomUnitVectorFromStream(): Vector;
	ResetRandomStream(): void;
	SeedRandomStream(): {Stream: RandomStream};
	SetRandomStreamSeed(NewSeed?: number): {Stream: RandomStream};
	static BreakRandomStream(InRandomStream: RandomStream,InitialSeed?: number): {InitialSeed: number};
	static RandomBoolFromStream(Stream: RandomStream): boolean;
	static RandomFloatFromStream(Stream: RandomStream): number;
	static RandomUnitVectorFromStream(Stream: RandomStream): Vector;
	static ResetRandomStream(Stream: RandomStream): void;
	static SeedRandomStream(Stream?: RandomStream): {Stream: RandomStream};
	static SetRandomStreamSeed(Stream?: RandomStream,NewSeed?: number): {Stream: RandomStream};
	static MakeRandomStream(InitialSeed: number): RandomStream;
}

declare class Rotator { 
	Pitch: any;
	Yaw: any;
	Roll: any;
	clone() : Rotator;
	static C(Other: UObject | any): Rotator;
	ConvertRotatorToObject(): JsonLibraryObject;
	FromRotator(): JsonLibraryValue;
	Conv_RotatorToText(): string;
	Conv_RotatorToString(): string;
	BreakRotator(Roll?: number,Pitch?: number,Yaw?: number): {Roll: number, Pitch: number, Yaw: number};
	BreakRotIntoAxes(X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	ComposeRotators(B: Rotator): Rotator;
	Conv_RotatorToQuaternion(): Quat;
	Conv_RotatorToTransform(): Transform;
	Conv_RotatorToVector(): Vector;
	DynamicWeightedMovingAverage_FRotator(PreviousSample: Rotator,MaxDistance: number,MinWeight: number,MaxWeight: number): Rotator;
	EqualEqual_RotatorRotator(B: Rotator,ErrorTolerance: number): boolean;
	GetAxes(X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	GetForwardVector(): Vector;
	GetRightVector(): Vector;
	GetUpVector(): Vector;
	Multiply_RotatorFloat(B: number): Rotator;
	Multiply_RotatorInt(B: number): Rotator;
	NegateRotator(): Rotator;
	NormalizedDeltaRotator(B: Rotator): Rotator;
	NotEqual_RotatorRotator(B: Rotator,ErrorTolerance: number): boolean;
	REase(B: Rotator,Alpha: number,bShortestPath: boolean,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Rotator;
	RInterpTo(Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	RInterpTo_Constant(Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	RLerp(B: Rotator,Alpha: number,bShortestPath: boolean): Rotator;
	SelectRotator(B: Rotator,bPickA: boolean): Rotator;
	WeightedMovingAverage_FRotator(PreviousSample: Rotator,Weight: number): Rotator;
	IsValidAIRotation(): boolean;
	GetOrientationAndPosition(DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	static ConvertRotatorToObject(Value: Rotator): JsonLibraryObject;
	static FromRotator(Value: Rotator): JsonLibraryValue;
	static Conv_RotatorToText(InRot: Rotator): string;
	static Conv_RotatorToString(InRot: Rotator): string;
	static BreakRotator(InRot: Rotator,Roll?: number,Pitch?: number,Yaw?: number): {Roll: number, Pitch: number, Yaw: number};
	static BreakRotIntoAxes(InRot: Rotator,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static ComposeRotators(A: Rotator,B: Rotator): Rotator;
	static Conv_RotatorToQuaternion(InRot: Rotator): Quat;
	static Conv_RotatorToTransform(InRotator: Rotator): Transform;
	static Conv_RotatorToVector(InRot: Rotator): Vector;
	static DynamicWeightedMovingAverage_FRotator(CurrentSample: Rotator,PreviousSample: Rotator,MaxDistance: number,MinWeight: number,MaxWeight: number): Rotator;
	static EqualEqual_RotatorRotator(A: Rotator,B: Rotator,ErrorTolerance: number): boolean;
	static GetAxes(A: Rotator,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static GetForwardVector(InRot: Rotator): Vector;
	static GetRightVector(InRot: Rotator): Vector;
	static GetUpVector(InRot: Rotator): Vector;
	static Multiply_RotatorFloat(A: Rotator,B: number): Rotator;
	static Multiply_RotatorInt(A: Rotator,B: number): Rotator;
	static NegateRotator(A: Rotator): Rotator;
	static NormalizedDeltaRotator(A: Rotator,B: Rotator): Rotator;
	static NotEqual_RotatorRotator(A: Rotator,B: Rotator,ErrorTolerance: number): boolean;
	static REase(A: Rotator,B: Rotator,Alpha: number,bShortestPath: boolean,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Rotator;
	static RInterpTo(Current: Rotator,Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	static RInterpTo_Constant(Current: Rotator,Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	static RLerp(A: Rotator,B: Rotator,Alpha: number,bShortestPath: boolean): Rotator;
	static SelectRotator(A: Rotator,B: Rotator,bPickA: boolean): Rotator;
	static WeightedMovingAverage_FRotator(CurrentSample: Rotator,PreviousSample: Rotator,Weight: number): Rotator;
	static IsValidAIRotation(Rotation: Rotator): boolean;
	static GetOrientationAndPosition(DeviceRotation?: Rotator,DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	static MakeRotator(Roll: number,Pitch: number,Yaw: number): Rotator;
	static RandomRotator(bRoll: boolean): Rotator;
	static RandomRotatorFromStream(bRoll: boolean,Stream: RandomStream): Rotator;
}

declare class QuaternionSpringState { 
	clone() : QuaternionSpringState;
	static C(Other: UObject | any): QuaternionSpringState;
	ResetQuaternionSpringState(): {SpringState: QuaternionSpringState};
	SetQuaternionSpringStateAngularVelocity(AngularVelocity?: Vector): {SpringState: QuaternionSpringState};
	static ResetQuaternionSpringState(SpringState?: QuaternionSpringState): {SpringState: QuaternionSpringState};
	static SetQuaternionSpringStateAngularVelocity(SpringState?: QuaternionSpringState,AngularVelocity?: Vector): {SpringState: QuaternionSpringState};
}

declare class Quat { 
	X: any;
	Y: any;
	Z: any;
	W: any;
	clone() : Quat;
	static C(Other: UObject | any): Quat;
	Add_QuatQuat(B: Quat): Quat;
	BreakQuat(X?: number,Y?: number,Z?: number,W?: number): {X: number, Y: number, Z: number, W: number};
	EqualEqual_QuatQuat(B: Quat,Tolerance: number): boolean;
	Multiply_QuatQuat(B: Quat): Quat;
	NotEqual_QuatQuat(B: Quat,ErrorTolerance: number): boolean;
	Quat_AngularDistance(B: Quat): number;
	Quat_EnforceShortestArcWith(B?: Quat): {A: Quat};
	Quat_Euler(): Vector;
	Quat_Exp(): Quat;
	Quat_GetAngle(): number;
	Quat_GetAxisX(): Vector;
	Quat_GetAxisY(): Vector;
	Quat_GetAxisZ(): Vector;
	Quat_GetRotationAxis(): Vector;
	Quat_Inversed(): Quat;
	Quat_IsFinite(): boolean;
	Quat_IsIdentity(Tolerance: number): boolean;
	Quat_IsNonFinite(): boolean;
	Quat_IsNormalized(): boolean;
	Quat_Log(): Quat;
	Quat_Normalize(Tolerance?: number): {Q: Quat};
	Quat_Normalized(Tolerance: number): Quat;
	Quat_RotateVector(V: Vector): Vector;
	Quat_Rotator(): Rotator;
	Quat_SetComponents(X?: number,Y?: number,Z?: number,W?: number): {Q: Quat};
	Quat_SetFromEuler(Euler?: Vector): {Q: Quat};
	Quat_Size(): number;
	Quat_SizeSquared(): number;
	Quat_UnrotateVector(V: Vector): Vector;
	Quat_VectorForward(): Vector;
	Quat_VectorRight(): Vector;
	Quat_VectorUp(): Vector;
	QuaternionSpringInterp(Target: Quat,SpringState?: QuaternionSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bInitializeFromTarget?: boolean): {SpringState: QuaternionSpringState, $: Quat};
	Subtract_QuatQuat(B: Quat): Quat;
	static Add_QuatQuat(A: Quat,B: Quat): Quat;
	static BreakQuat(InQuat: Quat,X?: number,Y?: number,Z?: number,W?: number): {X: number, Y: number, Z: number, W: number};
	static EqualEqual_QuatQuat(A: Quat,B: Quat,Tolerance: number): boolean;
	static Multiply_QuatQuat(A: Quat,B: Quat): Quat;
	static NotEqual_QuatQuat(A: Quat,B: Quat,ErrorTolerance: number): boolean;
	static Quat_AngularDistance(A: Quat,B: Quat): number;
	static Quat_EnforceShortestArcWith(A?: Quat,B?: Quat): {A: Quat};
	static Quat_Euler(Q: Quat): Vector;
	static Quat_Exp(Q: Quat): Quat;
	static Quat_GetAngle(Q: Quat): number;
	static Quat_GetAxisX(Q: Quat): Vector;
	static Quat_GetAxisY(Q: Quat): Vector;
	static Quat_GetAxisZ(Q: Quat): Vector;
	static Quat_GetRotationAxis(Q: Quat): Vector;
	static Quat_Inversed(Q: Quat): Quat;
	static Quat_IsFinite(Q: Quat): boolean;
	static Quat_IsIdentity(Q: Quat,Tolerance: number): boolean;
	static Quat_IsNonFinite(Q: Quat): boolean;
	static Quat_IsNormalized(Q: Quat): boolean;
	static Quat_Log(Q: Quat): Quat;
	static Quat_Normalize(Q?: Quat,Tolerance?: number): {Q: Quat};
	static Quat_Normalized(Q: Quat,Tolerance: number): Quat;
	static Quat_RotateVector(Q: Quat,V: Vector): Vector;
	static Quat_Rotator(Q: Quat): Rotator;
	static Quat_SetComponents(Q?: Quat,X?: number,Y?: number,Z?: number,W?: number): {Q: Quat};
	static Quat_SetFromEuler(Q?: Quat,Euler?: Vector): {Q: Quat};
	static Quat_Size(Q: Quat): number;
	static Quat_SizeSquared(Q: Quat): number;
	static Quat_UnrotateVector(Q: Quat,V: Vector): Vector;
	static Quat_VectorForward(Q: Quat): Vector;
	static Quat_VectorRight(Q: Quat): Vector;
	static Quat_VectorUp(Q: Quat): Vector;
	static QuaternionSpringInterp(Current: Quat,Target: Quat,SpringState?: QuaternionSpringState,Stiffness?: number,CriticalDampingFactor?: number,DeltaTime?: number,Mass?: number,TargetVelocityAmount?: number,bInitializeFromTarget?: boolean): {SpringState: QuaternionSpringState, $: Quat};
	static Subtract_QuatQuat(A: Quat,B: Quat): Quat;
	static MakeQuat(X: number,Y: number,Z: number,W: number): Quat;
	static Quat_Identity(): Quat;
}

declare class Plane extends Vector { 
	W: any;
	clone() : Plane;
	static C(Other: UObject | any): Plane;
}

declare type EMatrixColumns = 'First' | 'Second' | 'Third' | 'Fourth' | 'EMatrixColumns_MAX';
declare var EMatrixColumns : { First:'First',Second:'Second',Third:'Third',Fourth:'Fourth',EMatrixColumns_MAX:'EMatrixColumns_MAX', };
declare type EAxis = 'None' | 'X' | 'Y' | 'Z' | 'EAxis_MAX';
declare var EAxis : { None:'None',X:'X',Y:'Y',Z:'Z',EAxis_MAX:'EAxis_MAX', };
declare class Vector4 { 
	X: any;
	Y: any;
	Z: any;
	W: any;
	clone() : Vector4;
	static C(Other: UObject | any): Vector4;
	Add_Vector4Vector4(B: Vector4): Vector4;
	BreakVector4(X?: any,Y?: any,Z?: any,W?: any): {X: any, Y: any, Z: any, W: any};
	Conv_Vector4ToQuaternion(): Quat;
	Conv_Vector4ToRotator(): Rotator;
	Conv_Vector4ToVector(): Vector;
	Divide_Vector4Vector4(B: Vector4): Vector4;
	EqualEqual_Vector4Vector4(B: Vector4,ErrorTolerance: number): boolean;
	EqualExactly_Vector4Vector4(B: Vector4): boolean;
	Multiply_Vector4Vector4(B: Vector4): Vector4;
	NotEqual_Vector4Vector4(B: Vector4,ErrorTolerance: number): boolean;
	NotEqualExactly_Vector4Vector4(B: Vector4): boolean;
	Subtract_Vector4Vector4(B: Vector4): Vector4;
	Vector4_Assign(InVector?: Vector4): {A: Vector4};
	Vector4_CrossProduct3(B: Vector4): Vector4;
	Vector4_DotProduct(B: Vector4): any;
	Vector4_DotProduct3(B: Vector4): any;
	Vector4_IsNAN(): boolean;
	Vector4_IsNearlyZero3(Tolerance: number): boolean;
	Vector4_IsNormal3(): boolean;
	Vector4_IsUnit3(SquaredLenthTolerance: number): boolean;
	Vector4_IsZero(): boolean;
	Vector4_MirrorByVector3(SurfaceNormal: Vector4): Vector4;
	Vector4_Negated(): Vector4;
	Vector4_Normal3(Tolerance: number): Vector4;
	Vector4_Normalize3(Tolerance?: number): {A: Vector4};
	Vector4_NormalUnsafe3(): Vector4;
	Vector4_Set(X?: any,Y?: any,Z?: any,W?: any): {A: Vector4};
	Vector4_Size(): any;
	Vector4_Size3(): any;
	Vector4_SizeSquared(): any;
	Vector4_SizeSquared3(): any;
	static Add_Vector4Vector4(A: Vector4,B: Vector4): Vector4;
	static BreakVector4(InVec: Vector4,X?: any,Y?: any,Z?: any,W?: any): {X: any, Y: any, Z: any, W: any};
	static Conv_Vector4ToQuaternion(InVec: Vector4): Quat;
	static Conv_Vector4ToRotator(InVec: Vector4): Rotator;
	static Conv_Vector4ToVector(InVector4: Vector4): Vector;
	static Divide_Vector4Vector4(A: Vector4,B: Vector4): Vector4;
	static EqualEqual_Vector4Vector4(A: Vector4,B: Vector4,ErrorTolerance: number): boolean;
	static EqualExactly_Vector4Vector4(A: Vector4,B: Vector4): boolean;
	static Multiply_Vector4Vector4(A: Vector4,B: Vector4): Vector4;
	static NotEqual_Vector4Vector4(A: Vector4,B: Vector4,ErrorTolerance: number): boolean;
	static NotEqualExactly_Vector4Vector4(A: Vector4,B: Vector4): boolean;
	static Subtract_Vector4Vector4(A: Vector4,B: Vector4): Vector4;
	static Vector4_Assign(A?: Vector4,InVector?: Vector4): {A: Vector4};
	static Vector4_CrossProduct3(A: Vector4,B: Vector4): Vector4;
	static Vector4_DotProduct(A: Vector4,B: Vector4): any;
	static Vector4_DotProduct3(A: Vector4,B: Vector4): any;
	static Vector4_IsNAN(A: Vector4): boolean;
	static Vector4_IsNearlyZero3(A: Vector4,Tolerance: number): boolean;
	static Vector4_IsNormal3(A: Vector4): boolean;
	static Vector4_IsUnit3(A: Vector4,SquaredLenthTolerance: number): boolean;
	static Vector4_IsZero(A: Vector4): boolean;
	static Vector4_MirrorByVector3(Direction: Vector4,SurfaceNormal: Vector4): Vector4;
	static Vector4_Negated(A: Vector4): Vector4;
	static Vector4_Normal3(A: Vector4,Tolerance: number): Vector4;
	static Vector4_Normalize3(A?: Vector4,Tolerance?: number): {A: Vector4};
	static Vector4_NormalUnsafe3(A: Vector4): Vector4;
	static Vector4_Set(A?: Vector4,X?: any,Y?: any,Z?: any,W?: any): {A: Vector4};
	static Vector4_Size(A: Vector4): any;
	static Vector4_Size3(A: Vector4): any;
	static Vector4_SizeSquared(A: Vector4): any;
	static Vector4_SizeSquared3(A: Vector4): any;
	static MakeVector4(X: any,Y: any,Z: any,W: any): Vector4;
	static Vector4_Zero(): Vector4;
}

declare class Matrix { 
	XPlane: Plane;
	YPlane: Plane;
	ZPlane: Plane;
	WPlane: Plane;
	clone() : Matrix;
	static C(Other: UObject | any): Matrix;
	Conv_MatrixToString(): string;
	Add_MatrixMatrix(B: Matrix): Matrix;
	Conv_MatrixToRotator(): Rotator;
	Conv_MatrixToTransform(): Transform;
	EqualEqual_MatrixMatrix(B: Matrix,Tolerance: number): boolean;
	Matrix_ApplyScale(Scale: number): Matrix;
	Matrix_ConcatenateTranslation(Translation: Vector): Matrix;
	Matrix_ContainsNaN(): boolean;
	Matrix_GetColumn(Column: EMatrixColumns): Vector;
	Matrix_GetDeterminant(): number;
	Matrix_GetFrustumBottomPlane(OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	Matrix_GetFrustumFarPlane(OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	Matrix_GetFrustumLeftPlane(OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	Matrix_GetFrustumNearPlane(OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	Matrix_GetFrustumRightPlane(OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	Matrix_GetFrustumTopPlane(OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	Matrix_GetInverse(): Matrix;
	Matrix_GetMatrixWithoutScale(Tolerance: number): Matrix;
	Matrix_GetMaximumAxisScale(): number;
	Matrix_GetOrigin(): Vector;
	Matrix_GetRotator(): Rotator;
	Matrix_GetRotDeterminant(): number;
	Matrix_GetScaledAxes(X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	Matrix_GetScaledAxis(Axis: EAxis): Vector;
	Matrix_GetScaleVector(Tolerance: number): Vector;
	Matrix_GetTransposeAdjoint(): Matrix;
	Matrix_GetTransposed(): Matrix;
	Matrix_GetUnitAxes(X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	Matrix_GetUnitAxis(Axis: EAxis): Vector;
	Matrix_InverseTransformPosition(V: Vector): Vector;
	Matrix_InverseTransformVector(V: Vector): Vector;
	Matrix_Mirror(MirrorAxis: EAxis,FlipAxis: EAxis): Matrix;
	Matrix_RemoveScaling(Tolerance?: number): {M: Matrix};
	Matrix_RemoveTranslation(): Matrix;
	Matrix_ScaleTranslation(Scale3D: Vector): Matrix;
	Matrix_SetAxis(Axis?: EAxis,AxisVector?: Vector): {M: Matrix};
	Matrix_SetColumn(Column?: EMatrixColumns,Value?: Vector): {M: Matrix};
	Matrix_SetOrigin(NewOrigin?: Vector): {M: Matrix};
	Matrix_ToQuat(): Quat;
	Matrix_TransformPosition(V: Vector): Vector4;
	Matrix_TransformVector(V: Vector): Vector4;
	Matrix_TransformVector4(V: Vector4): Vector4;
	Multiply_MatrixFloat(B: any): Matrix;
	Multiply_MatrixMatrix(B: Matrix): Matrix;
	NotEqual_MatrixMatrix(B: Matrix,Tolerance: number): boolean;
	TransformVector4(Vec4: Vector4): Vector4;
	static Conv_MatrixToString(InMatrix: Matrix): string;
	static Add_MatrixMatrix(A: Matrix,B: Matrix): Matrix;
	static Conv_MatrixToRotator(InMatrix: Matrix): Rotator;
	static Conv_MatrixToTransform(InMatrix: Matrix): Transform;
	static EqualEqual_MatrixMatrix(A: Matrix,B: Matrix,Tolerance: number): boolean;
	static Matrix_ApplyScale(M: Matrix,Scale: number): Matrix;
	static Matrix_ConcatenateTranslation(M: Matrix,Translation: Vector): Matrix;
	static Matrix_ContainsNaN(M: Matrix): boolean;
	static Matrix_GetColumn(M: Matrix,Column: EMatrixColumns): Vector;
	static Matrix_GetDeterminant(M: Matrix): number;
	static Matrix_GetFrustumBottomPlane(M: Matrix,OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	static Matrix_GetFrustumFarPlane(M: Matrix,OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	static Matrix_GetFrustumLeftPlane(M: Matrix,OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	static Matrix_GetFrustumNearPlane(M: Matrix,OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	static Matrix_GetFrustumRightPlane(M: Matrix,OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	static Matrix_GetFrustumTopPlane(M: Matrix,OutPlane?: Plane): {OutPlane: Plane, $: boolean};
	static Matrix_GetInverse(M: Matrix): Matrix;
	static Matrix_GetMatrixWithoutScale(M: Matrix,Tolerance: number): Matrix;
	static Matrix_GetMaximumAxisScale(M: Matrix): number;
	static Matrix_GetOrigin(InMatrix: Matrix): Vector;
	static Matrix_GetRotator(M: Matrix): Rotator;
	static Matrix_GetRotDeterminant(M: Matrix): number;
	static Matrix_GetScaledAxes(M: Matrix,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static Matrix_GetScaledAxis(M: Matrix,Axis: EAxis): Vector;
	static Matrix_GetScaleVector(M: Matrix,Tolerance: number): Vector;
	static Matrix_GetTransposeAdjoint(M: Matrix): Matrix;
	static Matrix_GetTransposed(M: Matrix): Matrix;
	static Matrix_GetUnitAxes(M: Matrix,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	static Matrix_GetUnitAxis(M: Matrix,Axis: EAxis): Vector;
	static Matrix_InverseTransformPosition(M: Matrix,V: Vector): Vector;
	static Matrix_InverseTransformVector(M: Matrix,V: Vector): Vector;
	static Matrix_Mirror(M: Matrix,MirrorAxis: EAxis,FlipAxis: EAxis): Matrix;
	static Matrix_RemoveScaling(M?: Matrix,Tolerance?: number): {M: Matrix};
	static Matrix_RemoveTranslation(M: Matrix): Matrix;
	static Matrix_ScaleTranslation(M: Matrix,Scale3D: Vector): Matrix;
	static Matrix_SetAxis(M?: Matrix,Axis?: EAxis,AxisVector?: Vector): {M: Matrix};
	static Matrix_SetColumn(M?: Matrix,Column?: EMatrixColumns,Value?: Vector): {M: Matrix};
	static Matrix_SetOrigin(M?: Matrix,NewOrigin?: Vector): {M: Matrix};
	static Matrix_ToQuat(M: Matrix): Quat;
	static Matrix_TransformPosition(M: Matrix,V: Vector): Vector4;
	static Matrix_TransformVector(M: Matrix,V: Vector): Vector4;
	static Matrix_TransformVector4(M: Matrix,V: Vector4): Vector4;
	static Multiply_MatrixFloat(A: Matrix,B: any): Matrix;
	static Multiply_MatrixMatrix(A: Matrix,B: Matrix): Matrix;
	static NotEqual_MatrixMatrix(A: Matrix,B: Matrix,Tolerance: number): boolean;
	static TransformVector4(Matrix: Matrix,Vec4: Vector4): Vector4;
	static Matrix_Identity(): Matrix;
}

declare type ELerpInterpolationMode = 'QuatInterp' | 'EulerInterp' | 'DualQuatInterp' | 'ELerpInterpolationMode_MAX';
declare var ELerpInterpolationMode : { QuatInterp:'QuatInterp',EulerInterp:'EulerInterp',DualQuatInterp:'DualQuatInterp',ELerpInterpolationMode_MAX:'ELerpInterpolationMode_MAX', };
declare class Transform { 
	Rotation: Quat;
	Translation: Vector;
	Scale3D: Vector;
	clone() : Transform;
	static C(Other: UObject | any): Transform;
	ConvertTransformToObject(): JsonLibraryObject;
	FromTransform(): JsonLibraryValue;
	Conv_TransformToText(): string;
	Conv_TransformToString(): string;
	BreakTransform(Location?: Vector,Rotation?: Rotator,Scale?: Vector): {Location: Vector, Rotation: Rotator, Scale: Vector};
	ComposeTransforms(B: Transform): Transform;
	Conv_TransformToMatrix(): Matrix;
	ConvertTransformToRelative(ParentTransform: Transform): Transform;
	EqualEqual_TransformTransform(B: Transform): boolean;
	FindRelativeLookAtRotation(TargetLocation: Vector): Rotator;
	InverseTransformDirection(Direction: Vector): Vector;
	InverseTransformLocation(Location: Vector): Vector;
	InverseTransformRotation(Rotation: Rotator): Rotator;
	InvertTransform(): Transform;
	MakeRelativeTransform(RelativeTo: Transform): Transform;
	NearlyEqual_TransformTransform(B: Transform,LocationTolerance: number,RotationTolerance: number,Scale3DTolerance: number): boolean;
	SelectTransform(B: Transform,bPickA: boolean): Transform;
	TEase(B: Transform,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Transform;
	TInterpTo(Target: Transform,DeltaTime: number,InterpSpeed: number): Transform;
	TLerp(B: Transform,Alpha: number,InterpMode: ELerpInterpolationMode): Transform;
	Transform_Determinant(): number;
	TransformDirection(Direction: Vector): Vector;
	TransformLocation(Location: Vector): Vector;
	TransformRotation(Rotation: Rotator): Rotator;
	K2_LookAt(TargetPosition: Vector,LookAtVector: Vector,bUseUpVector: boolean,UpVector: Vector,ClampConeInDegree: number): Transform;
	CalibrateExternalTrackingToHMD(): void;
	UpdateExternalTrackingHMDPosition(): void;
	AddTrackedPointWithName(PointName: string,bDeletePointsWithSameName: boolean): boolean;
	CalculateAlignmentTransform(TransformInSecondCoordinateSystem: Transform,AlignmentTransform?: Transform): {AlignmentTransform: Transform};
	SetAlignmentTransform(): void;
	static ConvertTransformToObject(Value: Transform): JsonLibraryObject;
	static FromTransform(Value: Transform): JsonLibraryValue;
	static Conv_TransformToText(InTrans: Transform): string;
	static Conv_TransformToString(InTrans: Transform): string;
	static BreakTransform(InTransform: Transform,Location?: Vector,Rotation?: Rotator,Scale?: Vector): {Location: Vector, Rotation: Rotator, Scale: Vector};
	static ComposeTransforms(A: Transform,B: Transform): Transform;
	static Conv_TransformToMatrix(Transform: Transform): Matrix;
	static ConvertTransformToRelative(Transform: Transform,ParentTransform: Transform): Transform;
	static EqualEqual_TransformTransform(A: Transform,B: Transform): boolean;
	static FindRelativeLookAtRotation(StartTransform: Transform,TargetLocation: Vector): Rotator;
	static InverseTransformDirection(T: Transform,Direction: Vector): Vector;
	static InverseTransformLocation(T: Transform,Location: Vector): Vector;
	static InverseTransformRotation(T: Transform,Rotation: Rotator): Rotator;
	static InvertTransform(T: Transform): Transform;
	static MakeRelativeTransform(A: Transform,RelativeTo: Transform): Transform;
	static NearlyEqual_TransformTransform(A: Transform,B: Transform,LocationTolerance: number,RotationTolerance: number,Scale3DTolerance: number): boolean;
	static SelectTransform(A: Transform,B: Transform,bPickA: boolean): Transform;
	static TEase(A: Transform,B: Transform,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Transform;
	static TInterpTo(Current: Transform,Target: Transform,DeltaTime: number,InterpSpeed: number): Transform;
	static TLerp(A: Transform,B: Transform,Alpha: number,InterpMode: ELerpInterpolationMode): Transform;
	static Transform_Determinant(Transform: Transform): number;
	static TransformDirection(T: Transform,Direction: Vector): Vector;
	static TransformLocation(T: Transform,Location: Vector): Vector;
	static TransformRotation(T: Transform,Rotation: Rotator): Rotator;
	static K2_LookAt(CurrentTransform: Transform,TargetPosition: Vector,LookAtVector: Vector,bUseUpVector: boolean,UpVector: Vector,ClampConeInDegree: number): Transform;
	static CalibrateExternalTrackingToHMD(ExternalTrackingTransform: Transform): void;
	static UpdateExternalTrackingHMDPosition(ExternalTrackingTransform: Transform): void;
	static AddTrackedPointWithName(WorldTransform: Transform,PointName: string,bDeletePointsWithSameName: boolean): boolean;
	static CalculateAlignmentTransform(TransformInFirstCoordinateSystem: Transform,TransformInSecondCoordinateSystem: Transform,AlignmentTransform?: Transform): {AlignmentTransform: Transform};
	static SetAlignmentTransform(InAlignmentTransform: Transform): void;
	static GetAlignmentTransform(): Transform;
}

declare type EARTrackingState = 'Unknown' | 'Tracking' | 'NotTracking' | 'StoppedTracking' | 'EARTrackingState_MAX';
declare var EARTrackingState : { Unknown:'Unknown',Tracking:'Tracking',NotTracking:'NotTracking',StoppedTracking:'StoppedTracking',EARTrackingState_MAX:'EARTrackingState_MAX', };
declare type ETickingGroup = 'TG_PrePhysics' | 'TG_StartPhysics' | 'TG_DuringPhysics' | 'TG_EndPhysics' | 'TG_PostPhysics' | 'TG_PostUpdateWork' | 'TG_LastDemotable' | 'TG_NewlySpawned' | 'TG_MAX';
declare var ETickingGroup : { TG_PrePhysics:'TG_PrePhysics',TG_StartPhysics:'TG_StartPhysics',TG_DuringPhysics:'TG_DuringPhysics',TG_EndPhysics:'TG_EndPhysics',TG_PostPhysics:'TG_PostPhysics',TG_PostUpdateWork:'TG_PostUpdateWork',TG_LastDemotable:'TG_LastDemotable',TG_NewlySpawned:'TG_NewlySpawned',TG_MAX:'TG_MAX', };
declare class TickFunction { 
	TickGroup: ETickingGroup;
	EndTickGroup: ETickingGroup;
	bTickEvenWhenPaused: boolean;
	bCanEverTick: boolean;
	bStartWithTickEnabled: boolean;
	bAllowTickOnDedicatedServer: boolean;
	TickInterval: number;
	clone() : TickFunction;
	static C(Other: UObject | any): TickFunction;
}

declare class ActorComponentTickFunction extends TickFunction { 
	clone() : ActorComponentTickFunction;
	static C(Other: UObject | any): ActorComponentTickFunction;
}

declare class AssetUserData extends UObject { 
	static Load(ResourceName: string): AssetUserData;
	static Find(Outer: UObject, ResourceName: string): AssetUserData;
	static GetDefaultObject(): AssetUserData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetUserData;
	static C(Other: UObject | any): AssetUserData;
}

declare type EComponentCreationMethod = 'Native' | 'SimpleConstructionScript' | 'UserConstructionScript' | 'Instance' | 'EComponentCreationMethod_MAX';
declare var EComponentCreationMethod : { Native:'Native',SimpleConstructionScript:'SimpleConstructionScript',UserConstructionScript:'UserConstructionScript',Instance:'Instance',EComponentCreationMethod_MAX:'EComponentCreationMethod_MAX', };
declare class SimpleMemberReference { 
	MemberParent: UObject;
	MemberName: string;
	MemberGuid: Guid;
	clone() : SimpleMemberReference;
	static C(Other: UObject | any): SimpleMemberReference;
}

declare class ActorTickFunction extends TickFunction { 
	clone() : ActorTickFunction;
	static C(Other: UObject | any): ActorTickFunction;
}

declare type EActorUpdateOverlapsMethod = 'UseConfigDefault' | 'AlwaysUpdate' | 'OnlyUpdateMovable' | 'NeverUpdate' | 'EActorUpdateOverlapsMethod_MAX';
declare var EActorUpdateOverlapsMethod : { UseConfigDefault:'UseConfigDefault',AlwaysUpdate:'AlwaysUpdate',OnlyUpdateMovable:'OnlyUpdateMovable',NeverUpdate:'NeverUpdate',EActorUpdateOverlapsMethod_MAX:'EActorUpdateOverlapsMethod_MAX', };
declare type ENetRole = 'ROLE_None' | 'ROLE_SimulatedProxy' | 'ROLE_AutonomousProxy' | 'ROLE_Authority' | 'ROLE_MAX';
declare var ENetRole : { ROLE_None:'ROLE_None',ROLE_SimulatedProxy:'ROLE_SimulatedProxy',ROLE_AutonomousProxy:'ROLE_AutonomousProxy',ROLE_Authority:'ROLE_Authority',ROLE_MAX:'ROLE_MAX', };
declare type EVectorQuantization = 'RoundWholeNumber' | 'RoundOneDecimal' | 'RoundTwoDecimals' | 'EVectorQuantization_MAX';
declare var EVectorQuantization : { RoundWholeNumber:'RoundWholeNumber',RoundOneDecimal:'RoundOneDecimal',RoundTwoDecimals:'RoundTwoDecimals',EVectorQuantization_MAX:'EVectorQuantization_MAX', };
declare type ERotatorQuantization = 'ByteComponents' | 'ShortComponents' | 'ERotatorQuantization_MAX';
declare var ERotatorQuantization : { ByteComponents:'ByteComponents',ShortComponents:'ShortComponents',ERotatorQuantization_MAX:'ERotatorQuantization_MAX', };
declare class RepMovement { 
	LinearVelocity: Vector;
	AngularVelocity: Vector;
	Location: Vector;
	Rotation: Rotator;
	bSimulatedPhysicSleep: boolean;
	bRepPhysics: boolean;
	LocationQuantizationLevel: EVectorQuantization;
	VelocityQuantizationLevel: EVectorQuantization;
	RotationQuantizationLevel: ERotatorQuantization;
	clone() : RepMovement;
	static C(Other: UObject | any): RepMovement;
}

declare type EActorGridPlacement = 'Bounds' | 'Location' | 'AlwaysLoaded' | 'None' | 'EActorGridPlacement_MAX';
declare var EActorGridPlacement : { Bounds:'Bounds',Location:'Location',AlwaysLoaded:'AlwaysLoaded',None:'None',EActorGridPlacement_MAX:'EActorGridPlacement_MAX', };
declare class Vector_NetQuantize100 extends Vector { 
	clone() : Vector_NetQuantize100;
	static C(Other: UObject | any): Vector_NetQuantize100;
	BreakVector_NetQuantize100(X?: any,Y?: any,Z?: any): {X: any, Y: any, Z: any};
	static BreakVector_NetQuantize100(InVec: Vector_NetQuantize100,X?: any,Y?: any,Z?: any): {X: any, Y: any, Z: any};
	static MakeVector_NetQuantize100(X: any,Y: any,Z: any): Vector_NetQuantize100;
}

declare class RepAttachment { 
	AttachParent: Actor;
	LocationOffset: Vector_NetQuantize100;
	RelativeScale3D: Vector_NetQuantize100;
	RotationOffset: Rotator;
	AttachSocket: string;
	AttachComponent: SceneComponent;
	clone() : RepAttachment;
	static C(Other: UObject | any): RepAttachment;
}

declare type ENetDormancy = 'DORM_Never' | 'DORM_Awake' | 'DORM_DormantAll' | 'DORM_DormantPartial' | 'DORM_Initial' | 'DORM_MAX';
declare var ENetDormancy : { DORM_Never:'DORM_Never',DORM_Awake:'DORM_Awake',DORM_DormantAll:'DORM_DormantAll',DORM_DormantPartial:'DORM_DormantPartial',DORM_Initial:'DORM_Initial',DORM_MAX:'DORM_MAX', };
declare type ESpawnActorCollisionHandlingMethod = 'Undefined' | 'AlwaysSpawn' | 'AdjustIfPossibleButAlwaysSpawn' | 'AdjustIfPossibleButDontSpawnIfColliding' | 'DontSpawnIfColliding' | 'ESpawnActorCollisionHandlingMethod_MAX';
declare var ESpawnActorCollisionHandlingMethod : { Undefined:'Undefined',AlwaysSpawn:'AlwaysSpawn',AdjustIfPossibleButAlwaysSpawn:'AdjustIfPossibleButAlwaysSpawn',AdjustIfPossibleButDontSpawnIfColliding:'AdjustIfPossibleButDontSpawnIfColliding',DontSpawnIfColliding:'DontSpawnIfColliding',ESpawnActorCollisionHandlingMethod_MAX:'ESpawnActorCollisionHandlingMethod_MAX', };
declare type EAutoReceiveInput = 'Disabled' | 'Player0' | 'Player1' | 'Player2' | 'Player3' | 'Player4' | 'Player5' | 'Player6' | 'Player7' | 'EAutoReceiveInput_MAX';
declare var EAutoReceiveInput : { Disabled:'Disabled',Player0:'Player0',Player1:'Player1',Player2:'Player2',Player3:'Player3',Player4:'Player4',Player5:'Player5',Player6:'Player6',Player7:'Player7',EAutoReceiveInput_MAX:'EAutoReceiveInput_MAX', };
declare type EUINavigationAction = 'Accept' | 'Back' | 'Num' | 'Invalid' | 'EUINavigationAction_MAX';
declare var EUINavigationAction : { Accept:'Accept',Back:'Back',Num:'Num',Invalid:'Invalid',EUINavigationAction_MAX:'EUINavigationAction_MAX', };
declare type EControllerHand = 'Left' | 'Right' | 'AnyHand' | 'Pad' | 'ExternalCamera' | 'Gun' | 'HMD' | 'Special_1' | 'Special_2' | 'Special_3' | 'Special_4' | 'Special_5' | 'Special_6' | 'Special_7' | 'Special_8' | 'Special_9' | 'Special_10' | 'Special_11' | 'ControllerHand_Count' | 'EControllerHand_MAX';
declare var EControllerHand : { Left:'Left',Right:'Right',AnyHand:'AnyHand',Pad:'Pad',ExternalCamera:'ExternalCamera',Gun:'Gun',HMD:'HMD',Special_1:'Special_1',Special_2:'Special_2',Special_3:'Special_3',Special_4:'Special_4',Special_5:'Special_5',Special_6:'Special_6',Special_7:'Special_7',Special_8:'Special_8',Special_9:'Special_9',Special_10:'Special_10',Special_11:'Special_11',ControllerHand_Count:'ControllerHand_Count',EControllerHand_MAX:'EControllerHand_MAX', };
declare class Key { 
	KeyName: string;
	clone() : Key;
	static C(Other: UObject | any): Key;
	EqualEqual_KeyKey(B: Key): boolean;
	Key_GetDisplayName(): string;
	Key_GetNavigationAction(): EUINavigationAction;
	Key_IsAnalog(): boolean;
	Key_IsAxis1D(): boolean;
	Key_IsAxis2D(): boolean;
	Key_IsAxis3D(): boolean;
	Key_IsButtonAxis(): boolean;
	Key_IsDigital(): boolean;
	Key_IsGamepadKey(): boolean;
	Key_IsKeyboardKey(): boolean;
	Key_IsModifierKey(): boolean;
	Key_IsMouseButton(): boolean;
	Key_IsValid(): boolean;
	Key_IsVectorAxis(): boolean;
	BreakKey(InteractionProfile?: string,Hand?: EControllerHand,MotionSource?: string,Indentifier?: string,Component?: string): {InteractionProfile: string, Hand: EControllerHand, MotionSource: string, Indentifier: string, Component: string};
	static EqualEqual_KeyKey(A: Key,B: Key): boolean;
	static Key_GetDisplayName(Key: Key): string;
	static Key_GetNavigationAction(InKey: Key): EUINavigationAction;
	static Key_IsAnalog(Key: Key): boolean;
	static Key_IsAxis1D(Key: Key): boolean;
	static Key_IsAxis2D(Key: Key): boolean;
	static Key_IsAxis3D(Key: Key): boolean;
	static Key_IsButtonAxis(Key: Key): boolean;
	static Key_IsDigital(Key: Key): boolean;
	static Key_IsGamepadKey(Key: Key): boolean;
	static Key_IsKeyboardKey(Key: Key): boolean;
	static Key_IsModifierKey(Key: Key): boolean;
	static Key_IsMouseButton(Key: Key): boolean;
	static Key_IsValid(Key: Key): boolean;
	static Key_IsVectorAxis(Key: Key): boolean;
	static BreakKey(InKey: Key,InteractionProfile?: string,Hand?: EControllerHand,MotionSource?: string,Indentifier?: string,Component?: string): {InteractionProfile: string, Hand: EControllerHand, MotionSource: string, Indentifier: string, Component: string};
}

declare class KeyBind { 
	Key: Key;
	Command: string;
	Control: boolean;
	Shift: boolean;
	Alt: boolean;
	Cmd: boolean;
	bIgnoreCtrl: boolean;
	bIgnoreShift: boolean;
	bIgnoreAlt: boolean;
	bIgnoreCmd: boolean;
	bDisabled: boolean;
	clone() : KeyBind;
	static C(Other: UObject | any): KeyBind;
}

declare class PlayerInput extends UObject { 
	DebugExecBindings: KeyBind[];
	InvertedAxis: string[];
	static Load(ResourceName: string): PlayerInput;
	static Find(Outer: UObject, ResourceName: string): PlayerInput;
	static GetDefaultObject(): PlayerInput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerInput;
	SetMouseSensitivity(Sensitivity: number): void;
	SetBind(BindName: string,Command: string): void;
	InvertAxisKey(AxisKey: Key): void;
	InvertAxis(AxisName: string): void;
	ClearSmoothing(): void;
	static C(Other: UObject | any): PlayerInput;
}

declare class CachedKeyToActionInfo { 
	PlayerInput: PlayerInput;
	clone() : CachedKeyToActionInfo;
	static C(Other: UObject | any): CachedKeyToActionInfo;
}

declare type EEndPlayReason = 'Destroyed' | 'LevelTransition' | 'EndPlayInEditor' | 'RemovedFromWorld' | 'Quit' | 'EEndPlayReason_MAX';
declare var EEndPlayReason : { Destroyed:'Destroyed',LevelTransition:'LevelTransition',EndPlayInEditor:'EndPlayInEditor',RemovedFromWorld:'RemovedFromWorld',Quit:'Quit',EEndPlayReason_MAX:'EEndPlayReason_MAX', };
declare type EControllerAnalogStick = 'CAS_LeftStick' | 'CAS_RightStick' | 'CAS_MAX';
declare var EControllerAnalogStick : { CAS_LeftStick:'CAS_LeftStick',CAS_RightStick:'CAS_RightStick',CAS_MAX:'CAS_MAX', };
declare class InputComponent extends ActorComponent { 
	CachedKeyToActionInfo: CachedKeyToActionInfo[];
	static Load(ResourceName: string): InputComponent;
	static Find(Outer: UObject, ResourceName: string): InputComponent;
	static GetDefaultObject(): InputComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputComponent;
	WasControllerKeyJustReleased(Key: Key): boolean;
	WasControllerKeyJustPressed(Key: Key): boolean;
	OnInputOwnerEndPlayed(InOwner: Actor,EndPlayReason: EEndPlayReason): void;
	IsControllerKeyDown(Key: Key): boolean;
	GetTouchState(FingerIndex: number,LocationX?: number,LocationY?: number,bIsCurrentlyPressed?: boolean): {LocationX: number, LocationY: number, bIsCurrentlyPressed: boolean};
	GetControllerVectorKeyState(Key: Key): Vector;
	GetControllerMouseDelta(DeltaX?: number,DeltaY?: number): {DeltaX: number, DeltaY: number};
	GetControllerKeyTimeDown(Key: Key): number;
	GetControllerAnalogStickState(WhichStick: EControllerAnalogStick,StickX?: number,StickY?: number): {StickX: number, StickY: number};
	GetControllerAnalogKeyState(Key: Key): number;
	static C(Other: UObject | any): InputComponent;
}

declare type EAutoPossessAI = 'Disabled' | 'PlacedInWorld' | 'Spawned' | 'PlacedInWorldOrSpawned' | 'EAutoPossessAI_MAX';
declare var EAutoPossessAI : { Disabled:'Disabled',PlacedInWorld:'PlacedInWorld',Spawned:'Spawned',PlacedInWorldOrSpawned:'PlacedInWorldOrSpawned',EAutoPossessAI_MAX:'EAutoPossessAI_MAX', };
declare class PerQualityLevelInt { 
	Default: number;
	PerQuality: any;
	clone() : PerQualityLevelInt;
	static C(Other: UObject | any): PerQualityLevelInt;
}

declare class StreamableRenderAsset extends UObject { 
	ForceMipLevelsToBeResidentTimestamp: any;
	NumCinematicMipLevels: number;
	NoRefStreamingLODBias: PerQualityLevelInt;
	StreamingIndex: number;
	CachedCombinedLODBias: number;
	NeverStream: boolean;
	bGlobalForceMipLevelsToBeResident: boolean;
	bHasStreamingUpdatePending: boolean;
	bForceMiplevelsToBeResident: boolean;
	bIgnoreStreamingMipBias: boolean;
	bUseCinematicMipLevels: boolean;
	static Load(ResourceName: string): StreamableRenderAsset;
	static Find(Outer: UObject, ResourceName: string): StreamableRenderAsset;
	static GetDefaultObject(): StreamableRenderAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StreamableRenderAsset;
	SetForceMipLevelsToBeResident(Seconds: number,CinematicLODGroupMask: number): void;
	static C(Other: UObject | any): StreamableRenderAsset;
}

declare type ETextureSourceCompressionFormat = 'TSCF_None' | 'TSCF_PNG' | 'TSCF_JPEG' | 'TSCF_MAX';
declare var ETextureSourceCompressionFormat : { TSCF_None:'TSCF_None',TSCF_PNG:'TSCF_PNG',TSCF_JPEG:'TSCF_JPEG',TSCF_MAX:'TSCF_MAX', };
declare type ETextureSourceFormat = 'TSF_Invalid' | 'TSF_G8' | 'TSF_BGRA8' | 'TSF_BGRE8' | 'TSF_RGBA16' | 'TSF_RGBA16F' | 'TSF_RGBA8' | 'TSF_RGBE8' | 'TSF_G16' | 'TSF_MAX';
declare var ETextureSourceFormat : { TSF_Invalid:'TSF_Invalid',TSF_G8:'TSF_G8',TSF_BGRA8:'TSF_BGRA8',TSF_BGRE8:'TSF_BGRE8',TSF_RGBA16:'TSF_RGBA16',TSF_RGBA16F:'TSF_RGBA16F',TSF_RGBA8:'TSF_RGBA8',TSF_RGBE8:'TSF_RGBE8',TSF_G16:'TSF_G16',TSF_MAX:'TSF_MAX', };
declare class TextureSourceBlock { 
	BlockX: number;
	BlockY: number;
	SizeX: number;
	SizeY: number;
	NumSlices: number;
	NumMips: number;
	clone() : TextureSourceBlock;
	static C(Other: UObject | any): TextureSourceBlock;
}

declare class TextureSource { 
	ID: Guid;
	BaseBlockX: number;
	BaseBlockY: number;
	SizeX: number;
	SizeY: number;
	NumSlices: number;
	NumMips: number;
	NumLayers: number;
	bPNGCompressed: boolean;
	bLongLatCubemap: boolean;
	CompressionFormat: ETextureSourceCompressionFormat;
	bGuidIsHash: boolean;
	Format: ETextureSourceFormat;
	LayerFormat: ETextureSourceFormat[];
	Blocks: TextureSourceBlock[];
	BlockDataOffsets: any[];
	clone() : TextureSource;
	static C(Other: UObject | any): TextureSource;
}

declare class AssetImportInfo { 
	clone() : AssetImportInfo;
	static C(Other: UObject | any): AssetImportInfo;
}

declare class AssetImportData extends UObject { 
	SourceFilePath: string;
	SourceFileTimestamp: string;
	SourceData: AssetImportInfo;
	static Load(ResourceName: string): AssetImportData;
	static Find(Outer: UObject, ResourceName: string): AssetImportData;
	static GetDefaultObject(): AssetImportData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetImportData;
	ScriptedAddFilename(InPath: string,index: number,SourceFileLabel: string): void;
	K2_GetFirstFilename(): string;
	K2_ExtractFilenames(): string[];
	static C(Other: UObject | any): AssetImportData;
}

declare type ETextureLossyCompressionAmount = 'TLCA_Default' | 'TLCA_None' | 'TLCA_Lowest' | 'TLCA_Low' | 'TLCA_Medium' | 'TLCA_High' | 'TLCA_Highest' | 'TLCA_MAX';
declare var ETextureLossyCompressionAmount : { TLCA_Default:'TLCA_Default',TLCA_None:'TLCA_None',TLCA_Lowest:'TLCA_Lowest',TLCA_Low:'TLCA_Low',TLCA_Medium:'TLCA_Medium',TLCA_High:'TLCA_High',TLCA_Highest:'TLCA_Highest',TLCA_MAX:'TLCA_MAX', };
declare type ETextureCompressionQuality = 'TCQ_Default' | 'TCQ_Lowest' | 'TCQ_Low' | 'TCQ_Medium' | 'TCQ_High' | 'TCQ_Highest' | 'TCQ_MAX';
declare var ETextureCompressionQuality : { TCQ_Default:'TCQ_Default',TCQ_Lowest:'TCQ_Lowest',TCQ_Low:'TCQ_Low',TCQ_Medium:'TCQ_Medium',TCQ_High:'TCQ_High',TCQ_Highest:'TCQ_Highest',TCQ_MAX:'TCQ_MAX', };
declare type ETexturePowerOfTwoSetting = 'None' | 'PadToPowerOfTwo' | 'PadToSquarePowerOfTwo' | 'ETexturePowerOfTwoSetting_MAX';
declare var ETexturePowerOfTwoSetting : { None:'None',PadToPowerOfTwo:'PadToPowerOfTwo',PadToSquarePowerOfTwo:'PadToSquarePowerOfTwo',ETexturePowerOfTwoSetting_MAX:'ETexturePowerOfTwoSetting_MAX', };
declare type TextureMipGenSettings = 'TMGS_FromTextureGroup' | 'TMGS_SimpleAverage' | 'TMGS_Sharpen0' | 'TMGS_Sharpen1' | 'TMGS_Sharpen2' | 'TMGS_Sharpen3' | 'TMGS_Sharpen4' | 'TMGS_Sharpen5' | 'TMGS_Sharpen6' | 'TMGS_Sharpen7' | 'TMGS_Sharpen8' | 'TMGS_Sharpen9' | 'TMGS_Sharpen10' | 'TMGS_NoMipmaps' | 'TMGS_LeaveExistingMips' | 'TMGS_Blur1' | 'TMGS_Blur2' | 'TMGS_Blur3' | 'TMGS_Blur4' | 'TMGS_Blur5' | 'TMGS_Unfiltered' | 'TMGS_Angular' | 'TMGS_MAX';
declare var TextureMipGenSettings : { TMGS_FromTextureGroup:'TMGS_FromTextureGroup',TMGS_SimpleAverage:'TMGS_SimpleAverage',TMGS_Sharpen0:'TMGS_Sharpen0',TMGS_Sharpen1:'TMGS_Sharpen1',TMGS_Sharpen2:'TMGS_Sharpen2',TMGS_Sharpen3:'TMGS_Sharpen3',TMGS_Sharpen4:'TMGS_Sharpen4',TMGS_Sharpen5:'TMGS_Sharpen5',TMGS_Sharpen6:'TMGS_Sharpen6',TMGS_Sharpen7:'TMGS_Sharpen7',TMGS_Sharpen8:'TMGS_Sharpen8',TMGS_Sharpen9:'TMGS_Sharpen9',TMGS_Sharpen10:'TMGS_Sharpen10',TMGS_NoMipmaps:'TMGS_NoMipmaps',TMGS_LeaveExistingMips:'TMGS_LeaveExistingMips',TMGS_Blur1:'TMGS_Blur1',TMGS_Blur2:'TMGS_Blur2',TMGS_Blur3:'TMGS_Blur3',TMGS_Blur4:'TMGS_Blur4',TMGS_Blur5:'TMGS_Blur5',TMGS_Unfiltered:'TMGS_Unfiltered',TMGS_Angular:'TMGS_Angular',TMGS_MAX:'TMGS_MAX', };
declare type ECompositeTextureMode = 'CTM_Disabled' | 'CTM_NormalRoughnessToRed' | 'CTM_NormalRoughnessToGreen' | 'CTM_NormalRoughnessToBlue' | 'CTM_NormalRoughnessToAlpha' | 'CTM_MAX';
declare var ECompositeTextureMode : { CTM_Disabled:'CTM_Disabled',CTM_NormalRoughnessToRed:'CTM_NormalRoughnessToRed',CTM_NormalRoughnessToGreen:'CTM_NormalRoughnessToGreen',CTM_NormalRoughnessToBlue:'CTM_NormalRoughnessToBlue',CTM_NormalRoughnessToAlpha:'CTM_NormalRoughnessToAlpha',CTM_MAX:'CTM_MAX', };
declare type TextureCompressionSettings = 'TC_Default' | 'TC_Normalmap' | 'TC_Masks' | 'TC_Grayscale' | 'TC_Displacementmap' | 'TC_VectorDisplacementmap' | 'TC_HDR' | 'TC_EditorIcon' | 'TC_Alpha' | 'TC_DistanceFieldFont' | 'TC_HDR_Compressed' | 'TC_BC7' | 'TC_HalfFloat' | 'TC_LQ' | 'TC_EncodedReflectionCapture' | 'TC_MAX';
declare var TextureCompressionSettings : { TC_Default:'TC_Default',TC_Normalmap:'TC_Normalmap',TC_Masks:'TC_Masks',TC_Grayscale:'TC_Grayscale',TC_Displacementmap:'TC_Displacementmap',TC_VectorDisplacementmap:'TC_VectorDisplacementmap',TC_HDR:'TC_HDR',TC_EditorIcon:'TC_EditorIcon',TC_Alpha:'TC_Alpha',TC_DistanceFieldFont:'TC_DistanceFieldFont',TC_HDR_Compressed:'TC_HDR_Compressed',TC_BC7:'TC_BC7',TC_HalfFloat:'TC_HalfFloat',TC_LQ:'TC_LQ',TC_EncodedReflectionCapture:'TC_EncodedReflectionCapture',TC_MAX:'TC_MAX', };
declare class TextureFormatSettings { 
	CompressionSettings: TextureCompressionSettings;
	CompressionNoAlpha: boolean;
	CompressionForceAlpha: boolean;
	CompressionNone: boolean;
	CompressionYCoCg: boolean;
	SRGB: boolean;
	clone() : TextureFormatSettings;
	static C(Other: UObject | any): TextureFormatSettings;
}

declare type TextureFilter = 'TF_Nearest' | 'TF_Bilinear' | 'TF_Trilinear' | 'TF_Default' | 'TF_MAX';
declare var TextureFilter : { TF_Nearest:'TF_Nearest',TF_Bilinear:'TF_Bilinear',TF_Trilinear:'TF_Trilinear',TF_Default:'TF_Default',TF_MAX:'TF_MAX', };
declare type ETextureMipLoadOptions = 'Default' | 'AllMips' | 'OnlyFirstMip' | 'ETextureMipLoadOptions_MAX';
declare var ETextureMipLoadOptions : { Default:'Default',AllMips:'AllMips',OnlyFirstMip:'OnlyFirstMip',ETextureMipLoadOptions_MAX:'ETextureMipLoadOptions_MAX', };
declare type TextureGroup = 'TEXTUREGROUP_World' | 'TEXTUREGROUP_WorldNormalMap' | 'TEXTUREGROUP_WorldSpecular' | 'TEXTUREGROUP_Character' | 'TEXTUREGROUP_CharacterNormalMap' | 'TEXTUREGROUP_CharacterSpecular' | 'TEXTUREGROUP_Weapon' | 'TEXTUREGROUP_WeaponNormalMap' | 'TEXTUREGROUP_WeaponSpecular' | 'TEXTUREGROUP_Vehicle' | 'TEXTUREGROUP_VehicleNormalMap' | 'TEXTUREGROUP_VehicleSpecular' | 'TEXTUREGROUP_Cinematic' | 'TEXTUREGROUP_Effects' | 'TEXTUREGROUP_EffectsNotFiltered' | 'TEXTUREGROUP_Skybox' | 'TEXTUREGROUP_UI' | 'TEXTUREGROUP_Lightmap' | 'TEXTUREGROUP_RenderTarget' | 'TEXTUREGROUP_MobileFlattened' | 'TEXTUREGROUP_ProcBuilding_Face' | 'TEXTUREGROUP_ProcBuilding_LightMap' | 'TEXTUREGROUP_Shadowmap' | 'TEXTUREGROUP_ColorLookupTable' | 'TEXTUREGROUP_Terrain_Heightmap' | 'TEXTUREGROUP_Terrain_Weightmap' | 'TEXTUREGROUP_Bokeh' | 'TEXTUREGROUP_IESLightProfile' | 'TEXTUREGROUP_Pixels2D' | 'TEXTUREGROUP_HierarchicalLOD' | 'TEXTUREGROUP_Impostor' | 'TEXTUREGROUP_ImpostorNormalDepth' | 'TEXTUREGROUP_8BitData' | 'TEXTUREGROUP_16BitData' | 'TEXTUREGROUP_Project01' | 'TEXTUREGROUP_Project02' | 'TEXTUREGROUP_Project03' | 'TEXTUREGROUP_Project04' | 'TEXTUREGROUP_Project05' | 'TEXTUREGROUP_Project06' | 'TEXTUREGROUP_Project07' | 'TEXTUREGROUP_Project08' | 'TEXTUREGROUP_Project09' | 'TEXTUREGROUP_Project10' | 'TEXTUREGROUP_Project11' | 'TEXTUREGROUP_Project12' | 'TEXTUREGROUP_Project13' | 'TEXTUREGROUP_Project14' | 'TEXTUREGROUP_Project15' | 'TEXTUREGROUP_Project16' | 'TEXTUREGROUP_MAX';
declare var TextureGroup : { TEXTUREGROUP_World:'TEXTUREGROUP_World',TEXTUREGROUP_WorldNormalMap:'TEXTUREGROUP_WorldNormalMap',TEXTUREGROUP_WorldSpecular:'TEXTUREGROUP_WorldSpecular',TEXTUREGROUP_Character:'TEXTUREGROUP_Character',TEXTUREGROUP_CharacterNormalMap:'TEXTUREGROUP_CharacterNormalMap',TEXTUREGROUP_CharacterSpecular:'TEXTUREGROUP_CharacterSpecular',TEXTUREGROUP_Weapon:'TEXTUREGROUP_Weapon',TEXTUREGROUP_WeaponNormalMap:'TEXTUREGROUP_WeaponNormalMap',TEXTUREGROUP_WeaponSpecular:'TEXTUREGROUP_WeaponSpecular',TEXTUREGROUP_Vehicle:'TEXTUREGROUP_Vehicle',TEXTUREGROUP_VehicleNormalMap:'TEXTUREGROUP_VehicleNormalMap',TEXTUREGROUP_VehicleSpecular:'TEXTUREGROUP_VehicleSpecular',TEXTUREGROUP_Cinematic:'TEXTUREGROUP_Cinematic',TEXTUREGROUP_Effects:'TEXTUREGROUP_Effects',TEXTUREGROUP_EffectsNotFiltered:'TEXTUREGROUP_EffectsNotFiltered',TEXTUREGROUP_Skybox:'TEXTUREGROUP_Skybox',TEXTUREGROUP_UI:'TEXTUREGROUP_UI',TEXTUREGROUP_Lightmap:'TEXTUREGROUP_Lightmap',TEXTUREGROUP_RenderTarget:'TEXTUREGROUP_RenderTarget',TEXTUREGROUP_MobileFlattened:'TEXTUREGROUP_MobileFlattened',TEXTUREGROUP_ProcBuilding_Face:'TEXTUREGROUP_ProcBuilding_Face',TEXTUREGROUP_ProcBuilding_LightMap:'TEXTUREGROUP_ProcBuilding_LightMap',TEXTUREGROUP_Shadowmap:'TEXTUREGROUP_Shadowmap',TEXTUREGROUP_ColorLookupTable:'TEXTUREGROUP_ColorLookupTable',TEXTUREGROUP_Terrain_Heightmap:'TEXTUREGROUP_Terrain_Heightmap',TEXTUREGROUP_Terrain_Weightmap:'TEXTUREGROUP_Terrain_Weightmap',TEXTUREGROUP_Bokeh:'TEXTUREGROUP_Bokeh',TEXTUREGROUP_IESLightProfile:'TEXTUREGROUP_IESLightProfile',TEXTUREGROUP_Pixels2D:'TEXTUREGROUP_Pixels2D',TEXTUREGROUP_HierarchicalLOD:'TEXTUREGROUP_HierarchicalLOD',TEXTUREGROUP_Impostor:'TEXTUREGROUP_Impostor',TEXTUREGROUP_ImpostorNormalDepth:'TEXTUREGROUP_ImpostorNormalDepth',TEXTUREGROUP_8BitData:'TEXTUREGROUP_8BitData',TEXTUREGROUP_16BitData:'TEXTUREGROUP_16BitData',TEXTUREGROUP_Project01:'TEXTUREGROUP_Project01',TEXTUREGROUP_Project02:'TEXTUREGROUP_Project02',TEXTUREGROUP_Project03:'TEXTUREGROUP_Project03',TEXTUREGROUP_Project04:'TEXTUREGROUP_Project04',TEXTUREGROUP_Project05:'TEXTUREGROUP_Project05',TEXTUREGROUP_Project06:'TEXTUREGROUP_Project06',TEXTUREGROUP_Project07:'TEXTUREGROUP_Project07',TEXTUREGROUP_Project08:'TEXTUREGROUP_Project08',TEXTUREGROUP_Project09:'TEXTUREGROUP_Project09',TEXTUREGROUP_Project10:'TEXTUREGROUP_Project10',TEXTUREGROUP_Project11:'TEXTUREGROUP_Project11',TEXTUREGROUP_Project12:'TEXTUREGROUP_Project12',TEXTUREGROUP_Project13:'TEXTUREGROUP_Project13',TEXTUREGROUP_Project14:'TEXTUREGROUP_Project14',TEXTUREGROUP_Project15:'TEXTUREGROUP_Project15',TEXTUREGROUP_Project16:'TEXTUREGROUP_Project16',TEXTUREGROUP_MAX:'TEXTUREGROUP_MAX', };
declare class PerPlatformFloat { 
	Default: number;
	PerPlatform: any;
	clone() : PerPlatformFloat;
	static C(Other: UObject | any): PerPlatformFloat;
}

declare type ETextureDownscaleOptions = 'Default' | 'Unfiltered' | 'SimpleAverage' | 'Sharpen0' | 'Sharpen1' | 'Sharpen2' | 'Sharpen3' | 'Sharpen4' | 'Sharpen5' | 'Sharpen6' | 'Sharpen7' | 'Sharpen8' | 'Sharpen9' | 'Sharpen10' | 'ETextureDownscaleOptions_MAX';
declare var ETextureDownscaleOptions : { Default:'Default',Unfiltered:'Unfiltered',SimpleAverage:'SimpleAverage',Sharpen0:'Sharpen0',Sharpen1:'Sharpen1',Sharpen2:'Sharpen2',Sharpen3:'Sharpen3',Sharpen4:'Sharpen4',Sharpen5:'Sharpen5',Sharpen6:'Sharpen6',Sharpen7:'Sharpen7',Sharpen8:'Sharpen8',Sharpen9:'Sharpen9',Sharpen10:'Sharpen10',ETextureDownscaleOptions_MAX:'ETextureDownscaleOptions_MAX', };
declare type ETextureSourceEncoding = 'TSE_None' | 'TSE_Linear' | 'TSE_sRGB' | 'TSE_ST2084' | 'TSE_Gamma22' | 'TSE_BT1886' | 'TSE_Gamma26' | 'TSE_Cineon' | 'TSE_REDLog' | 'TSE_REDLog3G10' | 'TSE_SLog1' | 'TSE_SLog2' | 'TSE_SLog3' | 'TSE_AlexaV3LogC' | 'TSE_CanonLog' | 'TSE_ProTune' | 'TSE_VLog' | 'TSE_MAX';
declare var ETextureSourceEncoding : { TSE_None:'TSE_None',TSE_Linear:'TSE_Linear',TSE_sRGB:'TSE_sRGB',TSE_ST2084:'TSE_ST2084',TSE_Gamma22:'TSE_Gamma22',TSE_BT1886:'TSE_BT1886',TSE_Gamma26:'TSE_Gamma26',TSE_Cineon:'TSE_Cineon',TSE_REDLog:'TSE_REDLog',TSE_REDLog3G10:'TSE_REDLog3G10',TSE_SLog1:'TSE_SLog1',TSE_SLog2:'TSE_SLog2',TSE_SLog3:'TSE_SLog3',TSE_AlexaV3LogC:'TSE_AlexaV3LogC',TSE_CanonLog:'TSE_CanonLog',TSE_ProTune:'TSE_ProTune',TSE_VLog:'TSE_VLog',TSE_MAX:'TSE_MAX', };
declare type ETextureColorSpace = 'TCS_None' | 'TCS_sRGB' | 'TCS_Rec2020' | 'TCS_ACESAP0' | 'TCS_ACESAP1' | 'TCS_P3DCI' | 'TCS_P3D65' | 'TCS_REDWideGamut' | 'TCS_SonySGamut3' | 'TCS_SonySGamut3Cine' | 'TCS_AlexaWideGamut' | 'TCS_CanonCinemaGamut' | 'TCS_GoProProtuneNative' | 'TCS_PanasonicVGamut' | 'TCS_Custom' | 'TCS_MAX';
declare var ETextureColorSpace : { TCS_None:'TCS_None',TCS_sRGB:'TCS_sRGB',TCS_Rec2020:'TCS_Rec2020',TCS_ACESAP0:'TCS_ACESAP0',TCS_ACESAP1:'TCS_ACESAP1',TCS_P3DCI:'TCS_P3DCI',TCS_P3D65:'TCS_P3D65',TCS_REDWideGamut:'TCS_REDWideGamut',TCS_SonySGamut3:'TCS_SonySGamut3',TCS_SonySGamut3Cine:'TCS_SonySGamut3Cine',TCS_AlexaWideGamut:'TCS_AlexaWideGamut',TCS_CanonCinemaGamut:'TCS_CanonCinemaGamut',TCS_GoProProtuneNative:'TCS_GoProProtuneNative',TCS_PanasonicVGamut:'TCS_PanasonicVGamut',TCS_Custom:'TCS_Custom',TCS_MAX:'TCS_MAX', };
declare type ETextureChromaticAdaptationMethod = 'TCAM_None' | 'TCAM_Bradford' | 'TCAM_CAT02' | 'TCAM_MAX';
declare var ETextureChromaticAdaptationMethod : { TCAM_None:'TCAM_None',TCAM_Bradford:'TCAM_Bradford',TCAM_CAT02:'TCAM_CAT02',TCAM_MAX:'TCAM_MAX', };
declare class TextureSourceColorSettings { 
	EncodingOverride: ETextureSourceEncoding;
	ColorSpace: ETextureColorSpace;
	RedChromaticityCoordinate: Vector2D;
	GreenChromaticityCoordinate: Vector2D;
	BlueChromaticityCoordinate: Vector2D;
	WhiteChromaticityCoordinate: Vector2D;
	ChromaticAdaptationMethod: ETextureChromaticAdaptationMethod;
	clone() : TextureSourceColorSettings;
	static C(Other: UObject | any): TextureSourceColorSettings;
}

declare type EDesiredImageFormat = 'PNG' | 'JPG' | 'BMP' | 'EXR' | 'EDesiredImageFormat_MAX';
declare var EDesiredImageFormat : { PNG:'PNG',JPG:'JPG',BMP:'BMP',EXR:'EXR',EDesiredImageFormat_MAX:'EDesiredImageFormat_MAX', };
declare class ImageWriteOptions { 
	Format: EDesiredImageFormat;
	OnComplete: UnrealEngineDelegate<(bSuccess: boolean) => void>;
	CompressionQuality: number;
	bOverwriteFile: boolean;
	bAsync: boolean;
	clone() : ImageWriteOptions;
	static C(Other: UObject | any): ImageWriteOptions;
}

declare class Texture extends StreamableRenderAsset { 
	Source: TextureSource;
	LightingGuid: Guid;
	SourceFilePath: string;
	AssetImportData: AssetImportData;
	AdjustBrightness: number;
	AdjustBrightnessCurve: number;
	AdjustVibrance: number;
	AdjustSaturation: number;
	AdjustRGBCurve: number;
	AdjustHue: number;
	AdjustMinAlpha: number;
	AdjustMaxAlpha: number;
	CompressionNoAlpha: boolean;
	CompressionNone: boolean;
	DeferCompression: boolean;
	LossyCompressionAmount: ETextureLossyCompressionAmount;
	OodleTextureSdkVersion: string;
	MaxTextureSize: number;
	CompressionQuality: ETextureCompressionQuality;
	bDitherMipMapAlpha: boolean;
	bDoScaleMipsForAlphaCoverage: boolean;
	AlphaCoverageThresholds: Vector4;
	bPreserveBorder: boolean;
	bFlipGreenChannel: boolean;
	PowerOfTwoMode: ETexturePowerOfTwoSetting;
	PaddingColor: Color;
	bChromaKeyTexture: boolean;
	ChromaKeyThreshold: number;
	ChromaKeyColor: Color;
	MipGenSettings: TextureMipGenSettings;
	CompositeTexture: Texture;
	CompositeTextureMode: ECompositeTextureMode;
	CompositePower: number;
	LayerFormatSettings: TextureFormatSettings[];
	LevelIndex: number;
	LODBias: number;
	CompressionSettings: TextureCompressionSettings;
	Filter: TextureFilter;
	MipLoadOptions: ETextureMipLoadOptions;
	LODGroup: TextureGroup;
	Downscale: PerPlatformFloat;
	DownscaleOptions: ETextureDownscaleOptions;
	SRGB: boolean;
	SourceColorSettings: TextureSourceColorSettings;
	bUseLegacyGamma: boolean;
	bNoTiling: boolean;
	VirtualTextureStreaming: boolean;
	CompressionYCoCg: boolean;
	bNotOfflineProcessed: boolean;
	bAsyncResourceReleaseHasBeenStarted: boolean;
	AssetUserData: AssetUserData[];
	static Load(ResourceName: string): Texture;
	static Find(Outer: UObject, ResourceName: string): Texture;
	static GetDefaultObject(): Texture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture;
	static C(Other: UObject | any): Texture;
	SetSplashScreen(Scale: Vector2D,Offset: Vector,bShowLoadingMovie: boolean,bShowOnSet: boolean): void;
	ExportToDisk(Filename: string,Options: ImageWriteOptions): void;
	AddLoadingScreenSplash(Translation: Vector,Rotation: Rotator,Size: Vector2D,DeltaRotation: Rotator,bClearBeforeAdd: boolean): void;
	SetLoadingScreen(Scale: Vector2D,Offset: Vector,bShowLoadingMovie: boolean,bShowOnSet: boolean): void;
	SetSpectatorScreenTexture(): void;
	static SetSplashScreen(Texture: Texture,Scale: Vector2D,Offset: Vector,bShowLoadingMovie: boolean,bShowOnSet: boolean): void;
	static ExportToDisk(Texture: Texture,Filename: string,Options: ImageWriteOptions): void;
	static AddLoadingScreenSplash(Texture: Texture,Translation: Vector,Rotation: Rotator,Size: Vector2D,DeltaRotation: Rotator,bClearBeforeAdd: boolean): void;
	static SetLoadingScreen(Texture: Texture,Scale: Vector2D,Offset: Vector,bShowLoadingMovie: boolean,bShowOnSet: boolean): void;
	static SetSpectatorScreenTexture(InTexture: Texture): void;
}

declare type TextureAddress = 'TA_Wrap' | 'TA_Clamp' | 'TA_Mirror' | 'TA_MAX';
declare var TextureAddress : { TA_Wrap:'TA_Wrap',TA_Clamp:'TA_Clamp',TA_Mirror:'TA_Mirror',TA_MAX:'TA_MAX', };
declare type EImportanceWeight = 'Luminance' | 'Red' | 'Green' | 'Blue' | 'Alpha' | 'EImportanceWeight_MAX';
declare var EImportanceWeight : { Luminance:'Luminance',Red:'Red',Green:'Green',Blue:'Blue',Alpha:'Alpha',EImportanceWeight_MAX:'EImportanceWeight_MAX', };
declare class ImportanceTexture { 
	Size: IntPoint;
	NumMips: number;
	MarginalCDF: number[];
	ConditionalCDF: number[];
	TextureData: Color[];
	Texture: any;
	Weighting: EImportanceWeight;
	clone() : ImportanceTexture;
	static C(Other: UObject | any): ImportanceTexture;
	BreakImportanceTexture(Texture?: Texture2D,WeightingFunc?: EImportanceWeight): {Texture: Texture2D, WeightingFunc: EImportanceWeight};
	ImportanceSample(Rand: Vector2D,Samples: number,Intensity: number,SamplePosition?: Vector2D,SampleColor?: LinearColor,SampleIntensity?: number,SampleSize?: number): {SamplePosition: Vector2D, SampleColor: LinearColor, SampleIntensity: number, SampleSize: number};
	static BreakImportanceTexture(ImportanceTexture: ImportanceTexture,Texture?: Texture2D,WeightingFunc?: EImportanceWeight): {Texture: Texture2D, WeightingFunc: EImportanceWeight};
	static ImportanceSample(Texture: ImportanceTexture,Rand: Vector2D,Samples: number,Intensity: number,SamplePosition?: Vector2D,SampleColor?: LinearColor,SampleIntensity?: number,SampleSize?: number): {SamplePosition: Vector2D, SampleColor: LinearColor, SampleIntensity: number, SampleSize: number};
}

declare class Margin { 
	Left: number;
	Top: number;
	Right: number;
	Bottom: number;
	clone() : Margin;
	static C(Other: UObject | any): Margin;
}

declare type ESlateColorStylingMode = 'UseColor_Specified' | 'UseColor_ColorTable' | 'UseColor_Foreground' | 'UseColor_Foreground_Subdued' | 'UseColor_UseStyle' | 'UseColor_MAX';
declare var ESlateColorStylingMode : { UseColor_Specified:'UseColor_Specified',UseColor_ColorTable:'UseColor_ColorTable',UseColor_Foreground:'UseColor_Foreground',UseColor_Foreground_Subdued:'UseColor_Foreground_Subdued',UseColor_UseStyle:'UseColor_UseStyle',UseColor_MAX:'UseColor_MAX', };
declare class SlateColor { 
	SpecifiedColor: LinearColor;
	ColorUseRule: ESlateColorStylingMode;
	clone() : SlateColor;
	static C(Other: UObject | any): SlateColor;
	static SlateColor_UseForeground(): SlateColor;
	static SlateColor_UseSubduedForeground(): SlateColor;
}

declare type ESlateBrushRoundingType = 'FixedRadius' | 'HalfHeightRadius' | 'ESlateBrushRoundingType_MAX';
declare var ESlateBrushRoundingType : { FixedRadius:'FixedRadius',HalfHeightRadius:'HalfHeightRadius',ESlateBrushRoundingType_MAX:'ESlateBrushRoundingType_MAX', };
declare class SlateBrushOutlineSettings { 
	CornerRadii: Vector4;
	Color: SlateColor;
	Width: number;
	RoundingType: ESlateBrushRoundingType;
	bUseBrushTransparency: boolean;
	clone() : SlateBrushOutlineSettings;
	static C(Other: UObject | any): SlateBrushOutlineSettings;
}

declare class Vector2f { 
	X: number;
	Y: number;
	clone() : Vector2f;
	static C(Other: UObject | any): Vector2f;
}

declare class Box2f { 
	Min: Vector2f;
	Max: Vector2f;
	bIsValid: number;
	clone() : Box2f;
	static C(Other: UObject | any): Box2f;
}

declare type ESlateBrushDrawType = 'NoDrawType' | 'Box' | 'Border' | 'Image' | 'RoundedBox' | 'ESlateBrushDrawType_MAX';
declare var ESlateBrushDrawType : { NoDrawType:'NoDrawType',Box:'Box',Border:'Border',Image:'Image',RoundedBox:'RoundedBox',ESlateBrushDrawType_MAX:'ESlateBrushDrawType_MAX', };
declare type ESlateBrushTileType = 'NoTile' | 'Horizontal' | 'Vertical' | 'Both' | 'ESlateBrushTileType_MAX';
declare var ESlateBrushTileType : { NoTile:'NoTile',Horizontal:'Horizontal',Vertical:'Vertical',Both:'Both',ESlateBrushTileType_MAX:'ESlateBrushTileType_MAX', };
declare type ESlateBrushMirrorType = 'NoMirror' | 'Horizontal' | 'Vertical' | 'Both' | 'ESlateBrushMirrorType_MAX';
declare var ESlateBrushMirrorType : { NoMirror:'NoMirror',Horizontal:'Horizontal',Vertical:'Vertical',Both:'Both',ESlateBrushMirrorType_MAX:'ESlateBrushMirrorType_MAX', };
declare type ESlateBrushImageType = 'NoImage' | 'FullColor' | 'Linear' | 'Vector' | 'ESlateBrushImageType_MAX';
declare var ESlateBrushImageType : { NoImage:'NoImage',FullColor:'FullColor',Linear:'Linear',Vector:'Vector',ESlateBrushImageType_MAX:'ESlateBrushImageType_MAX', };
declare class SubsurfaceProfileStruct { 
	SurfaceAlbedo: LinearColor;
	MeanFreePathColor: LinearColor;
	MeanFreePathDistance: number;
	WorldUnitScale: number;
	bEnableBurley: boolean;
	Tint: LinearColor;
	ScatterRadius: number;
	SubsurfaceColor: LinearColor;
	FalloffColor: LinearColor;
	BoundaryColorBleed: LinearColor;
	ExtinctionScale: number;
	NormalScale: number;
	ScatteringDistribution: number;
	IOR: number;
	Roughness0: number;
	Roughness1: number;
	LobeMix: number;
	TransmissionTintColor: LinearColor;
	clone() : SubsurfaceProfileStruct;
	static C(Other: UObject | any): SubsurfaceProfileStruct;
}

declare class SubsurfaceProfile extends UObject { 
	Settings: SubsurfaceProfileStruct;
	static Load(ResourceName: string): SubsurfaceProfile;
	static Find(Outer: UObject, ResourceName: string): SubsurfaceProfile;
	static GetDefaultObject(): SubsurfaceProfile;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubsurfaceProfile;
	static C(Other: UObject | any): SubsurfaceProfile;
}

declare class LightmassMaterialInterfaceSettings { 
	EmissiveBoost: number;
	DiffuseBoost: number;
	ExportResolutionScale: number;
	bCastShadowAsMasked: boolean;
	bOverrideCastShadowAsMasked: boolean;
	bOverrideEmissiveBoost: boolean;
	bOverrideDiffuseBoost: boolean;
	bOverrideExportResolutionScale: boolean;
	clone() : LightmassMaterialInterfaceSettings;
	static C(Other: UObject | any): LightmassMaterialInterfaceSettings;
}

declare class SoftObjectPath { 
	AssetPathName: string;
	SubPathString: string;
	clone() : SoftObjectPath;
	static C(Other: UObject | any): SoftObjectPath;
	BreakSoftObjectPath(PathString?: string): {PathString: string};
	Conv_SoftObjPathToSoftObjRef(): UObject;
	static BreakSoftObjectPath(InSoftObjectPath: SoftObjectPath,PathString?: string): {PathString: string};
	static Conv_SoftObjPathToSoftObjRef(SoftObjectPath: SoftObjectPath): UObject;
	static MakeSoftObjectPath(PathString: string): SoftObjectPath;
}

declare class MaterialTextureInfo { 
	SamplingScale: number;
	UVChannelIndex: number;
	TextureName: string;
	TextureReference: SoftObjectPath;
	TextureIndex: number;
	clone() : MaterialTextureInfo;
	static C(Other: UObject | any): MaterialTextureInfo;
}

declare class ThumbnailInfo extends UObject { 
	static Load(ResourceName: string): ThumbnailInfo;
	static Find(Outer: UObject, ResourceName: string): ThumbnailInfo;
	static GetDefaultObject(): ThumbnailInfo;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ThumbnailInfo;
	static C(Other: UObject | any): ThumbnailInfo;
}

declare class PhysicalMaterialMask extends UObject { 
	AssetImportData: AssetImportData;
	MaskTexture: Texture;
	UVChannelIndex: number;
	AddressX: TextureAddress;
	AddressY: TextureAddress;
	static Load(ResourceName: string): PhysicalMaterialMask;
	static Find(Outer: UObject, ResourceName: string): PhysicalMaterialMask;
	static GetDefaultObject(): PhysicalMaterialMask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicalMaterialMask;
	static C(Other: UObject | any): PhysicalMaterialMask;
}

declare type EFrictionCombineMode = 'Average' | 'Min' | 'Multiply' | 'Max' | 'EFrictionCombineMode_MAX';
declare var EFrictionCombineMode : { Average:'Average',Min:'Min',Multiply:'Multiply',Max:'Max',EFrictionCombineMode_MAX:'EFrictionCombineMode_MAX', };
declare class PhysicalMaterialPropertyBase extends UObject { 
	static Load(ResourceName: string): PhysicalMaterialPropertyBase;
	static Find(Outer: UObject, ResourceName: string): PhysicalMaterialPropertyBase;
	static GetDefaultObject(): PhysicalMaterialPropertyBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicalMaterialPropertyBase;
	static C(Other: UObject | any): PhysicalMaterialPropertyBase;
}

declare type EPhysicalSurface = 'SurfaceType_Default' | 'SurfaceType1' | 'SurfaceType2' | 'SurfaceType3' | 'SurfaceType4' | 'SurfaceType5' | 'SurfaceType6' | 'SurfaceType7' | 'SurfaceType8' | 'SurfaceType9' | 'SurfaceType10' | 'SurfaceType11' | 'SurfaceType12' | 'SurfaceType13' | 'SurfaceType14' | 'SurfaceType15' | 'SurfaceType16' | 'SurfaceType17' | 'SurfaceType18' | 'SurfaceType19' | 'SurfaceType20' | 'SurfaceType21' | 'SurfaceType22' | 'SurfaceType23' | 'SurfaceType24' | 'SurfaceType25' | 'SurfaceType26' | 'SurfaceType27' | 'SurfaceType28' | 'SurfaceType29' | 'SurfaceType30' | 'SurfaceType31' | 'SurfaceType32' | 'SurfaceType33' | 'SurfaceType34' | 'SurfaceType35' | 'SurfaceType36' | 'SurfaceType37' | 'SurfaceType38' | 'SurfaceType39' | 'SurfaceType40' | 'SurfaceType41' | 'SurfaceType42' | 'SurfaceType43' | 'SurfaceType44' | 'SurfaceType45' | 'SurfaceType46' | 'SurfaceType47' | 'SurfaceType48' | 'SurfaceType49' | 'SurfaceType50' | 'SurfaceType51' | 'SurfaceType52' | 'SurfaceType53' | 'SurfaceType54' | 'SurfaceType55' | 'SurfaceType56' | 'SurfaceType57' | 'SurfaceType58' | 'SurfaceType59' | 'SurfaceType60' | 'SurfaceType61' | 'SurfaceType62' | 'SurfaceType_Max' | 'EPhysicalSurface_MAX';
declare var EPhysicalSurface : { SurfaceType_Default:'SurfaceType_Default',SurfaceType1:'SurfaceType1',SurfaceType2:'SurfaceType2',SurfaceType3:'SurfaceType3',SurfaceType4:'SurfaceType4',SurfaceType5:'SurfaceType5',SurfaceType6:'SurfaceType6',SurfaceType7:'SurfaceType7',SurfaceType8:'SurfaceType8',SurfaceType9:'SurfaceType9',SurfaceType10:'SurfaceType10',SurfaceType11:'SurfaceType11',SurfaceType12:'SurfaceType12',SurfaceType13:'SurfaceType13',SurfaceType14:'SurfaceType14',SurfaceType15:'SurfaceType15',SurfaceType16:'SurfaceType16',SurfaceType17:'SurfaceType17',SurfaceType18:'SurfaceType18',SurfaceType19:'SurfaceType19',SurfaceType20:'SurfaceType20',SurfaceType21:'SurfaceType21',SurfaceType22:'SurfaceType22',SurfaceType23:'SurfaceType23',SurfaceType24:'SurfaceType24',SurfaceType25:'SurfaceType25',SurfaceType26:'SurfaceType26',SurfaceType27:'SurfaceType27',SurfaceType28:'SurfaceType28',SurfaceType29:'SurfaceType29',SurfaceType30:'SurfaceType30',SurfaceType31:'SurfaceType31',SurfaceType32:'SurfaceType32',SurfaceType33:'SurfaceType33',SurfaceType34:'SurfaceType34',SurfaceType35:'SurfaceType35',SurfaceType36:'SurfaceType36',SurfaceType37:'SurfaceType37',SurfaceType38:'SurfaceType38',SurfaceType39:'SurfaceType39',SurfaceType40:'SurfaceType40',SurfaceType41:'SurfaceType41',SurfaceType42:'SurfaceType42',SurfaceType43:'SurfaceType43',SurfaceType44:'SurfaceType44',SurfaceType45:'SurfaceType45',SurfaceType46:'SurfaceType46',SurfaceType47:'SurfaceType47',SurfaceType48:'SurfaceType48',SurfaceType49:'SurfaceType49',SurfaceType50:'SurfaceType50',SurfaceType51:'SurfaceType51',SurfaceType52:'SurfaceType52',SurfaceType53:'SurfaceType53',SurfaceType54:'SurfaceType54',SurfaceType55:'SurfaceType55',SurfaceType56:'SurfaceType56',SurfaceType57:'SurfaceType57',SurfaceType58:'SurfaceType58',SurfaceType59:'SurfaceType59',SurfaceType60:'SurfaceType60',SurfaceType61:'SurfaceType61',SurfaceType62:'SurfaceType62',SurfaceType_Max:'SurfaceType_Max',EPhysicalSurface_MAX:'EPhysicalSurface_MAX', };
declare class PhysicalMaterial extends UObject { 
	Friction: number;
	StaticFriction: number;
	FrictionCombineMode: EFrictionCombineMode;
	bOverrideFrictionCombineMode: boolean;
	Restitution: number;
	RestitutionCombineMode: EFrictionCombineMode;
	bOverrideRestitutionCombineMode: boolean;
	Density: number;
	SleepLinearVelocityThreshold: number;
	SleepAngularVelocityThreshold: number;
	SleepCounterThreshold: number;
	RaiseMassToPower: number;
	DestructibleDamageThresholdScale: number;
	PhysicalMaterialProperty: PhysicalMaterialPropertyBase;
	SurfaceType: EPhysicalSurface;
	static Load(ResourceName: string): PhysicalMaterial;
	static Find(Outer: UObject, ResourceName: string): PhysicalMaterial;
	static GetDefaultObject(): PhysicalMaterial;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicalMaterial;
	static C(Other: UObject | any): PhysicalMaterial;
}

declare type EMaterialParameterAssociation = 'LayerParameter' | 'BlendParameter' | 'GlobalParameter' | 'EMaterialParameterAssociation_MAX';
declare var EMaterialParameterAssociation : { LayerParameter:'LayerParameter',BlendParameter:'BlendParameter',GlobalParameter:'GlobalParameter',EMaterialParameterAssociation_MAX:'EMaterialParameterAssociation_MAX', };
declare type EMaterialFunctionUsage = 'Default' | 'MaterialLayer' | 'MaterialLayerBlend' | 'EMaterialFunctionUsage_MAX';
declare var EMaterialFunctionUsage : { Default:'Default',MaterialLayer:'MaterialLayer',MaterialLayerBlend:'MaterialLayerBlend',EMaterialFunctionUsage_MAX:'EMaterialFunctionUsage_MAX', };
declare type EEdGraphPinDirection = 'EGPD_Input' | 'EGPD_Output' | 'EGPD_MAX';
declare var EEdGraphPinDirection : { EGPD_Input:'EGPD_Input',EGPD_Output:'EGPD_Output',EGPD_MAX:'EGPD_MAX', };
declare class EdGraphTerminalType { 
	TerminalCategory: string;
	TerminalSubCategory: string;
	TerminalSubCategoryObject: any;
	bTerminalIsConst: boolean;
	bTerminalIsWeakPointer: boolean;
	bTerminalIsUObjectWrapper: boolean;
	clone() : EdGraphTerminalType;
	static C(Other: UObject | any): EdGraphTerminalType;
}

declare type EPinContainerType = 'None' | 'Array' | 'Set' | 'Map' | 'EPinContainerType_MAX';
declare var EPinContainerType : { None:'None',Array:'Array',Set:'Set',Map:'Map',EPinContainerType_MAX:'EPinContainerType_MAX', };
declare class EdGraphPinType { 
	PinCategory: string;
	PinSubCategory: string;
	PinSubCategoryObject: any;
	PinSubCategoryMemberReference: SimpleMemberReference;
	PinValueType: EdGraphTerminalType;
	ContainerType: EPinContainerType;
	bIsArray: boolean;
	bIsReference: boolean;
	bIsConst: boolean;
	bIsWeakPointer: boolean;
	bIsUObjectWrapper: boolean;
	bSerializeAsSinglePrecisionFloat: boolean;
	clone() : EdGraphPinType;
	static C(Other: UObject | any): EdGraphPinType;
}

declare class EdGraphPin_Deprecated extends UObject { 
	PinName: string;
	PinFriendlyName: string;
	PinToolTip: string;
	Direction: EEdGraphPinDirection;
	PinType: EdGraphPinType;
	DefaultValue: string;
	AutogeneratedDefaultValue: string;
	DefaultObject: UObject;
	DefaultTextValue: string;
	LinkedTo: EdGraphPin_Deprecated[];
	SubPins: EdGraphPin_Deprecated[];
	ParentPin: EdGraphPin_Deprecated;
	ReferencePassThroughConnection: EdGraphPin_Deprecated;
	bHidden: boolean;
	bNotConnectable: boolean;
	bDefaultValueIsReadOnly: boolean;
	bDefaultValueIsIgnored: boolean;
	bIsDiffing: boolean;
	bAdvancedView: boolean;
	bDisplayAsMutableRef: boolean;
	PersistentGuid: Guid;
	static Load(ResourceName: string): EdGraphPin_Deprecated;
	static Find(Outer: UObject, ResourceName: string): EdGraphPin_Deprecated;
	static GetDefaultObject(): EdGraphPin_Deprecated;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphPin_Deprecated;
	static C(Other: UObject | any): EdGraphPin_Deprecated;
}

declare type ENodeAdvancedPins = 'NoPins' | 'Shown' | 'Hidden' | 'ENodeAdvancedPins_MAX';
declare var ENodeAdvancedPins : { NoPins:'NoPins',Shown:'Shown',Hidden:'Hidden',ENodeAdvancedPins_MAX:'ENodeAdvancedPins_MAX', };
declare type ENodeEnabledState = 'Enabled' | 'Disabled' | 'DevelopmentOnly' | 'ENodeEnabledState_MAX';
declare var ENodeEnabledState : { Enabled:'Enabled',Disabled:'Disabled',DevelopmentOnly:'DevelopmentOnly',ENodeEnabledState_MAX:'ENodeEnabledState_MAX', };
declare type EJavascriptPinContainerType = 'None' | 'Array' | 'Set' | 'Map' | 'EJavascriptPinContainerType_MAX';
declare var EJavascriptPinContainerType : { None:'None',Array:'Array',Set:'Set',Map:'Map',EJavascriptPinContainerType_MAX:'EJavascriptPinContainerType_MAX', };
declare class JavascriptEdGraphPin { 
	clone() : JavascriptEdGraphPin;
	static C(Other: UObject | any): JavascriptEdGraphPin;
	BreakAllPinLinks(): void;
	BreakLinkTo(B: JavascriptEdGraphPin): void;
	GetDirection(): EEdGraphPinDirection;
	GetLinkedPinNum(): number;
	GetLinkedTo(): JavascriptEdGraphPin[];
	GetOwningNode(): EdGraphNode;
	GetParentPin(): JavascriptEdGraphPin;
	GetPinContainerType(): EJavascriptPinContainerType;
	GetPinGUID(): Guid;
	GetPinIndex(): number;
	GetPinName(): string;
	GetPinRefObject(): UObject;
	GetPinType(): EdGraphPinType;
	GetSubPins(): JavascriptEdGraphPin[];
	IsPinHidden(): boolean;
	IsValid(): boolean;
	MakeLinkTo(B: JavascriptEdGraphPin): void;
	SetParentPin(Parent: JavascriptEdGraphPin): void;
	SetPinAdvancedView(bAdvancedView: boolean): void;
	SetPinContainerType(ContainerType: EJavascriptPinContainerType): void;
	SetPinHidden(bHidden: boolean): void;
	SetPinInfo(InPinName: string,InPinToolTip: string): void;
	SetPinRefObject(InObject: UObject): void;
	SetPinType(PinType: EdGraphPinType): void;
	static BreakAllPinLinks(A: JavascriptEdGraphPin): void;
	static BreakLinkTo(A: JavascriptEdGraphPin,B: JavascriptEdGraphPin): void;
	static GetDirection(A: JavascriptEdGraphPin): EEdGraphPinDirection;
	static GetLinkedPinNum(A: JavascriptEdGraphPin): number;
	static GetLinkedTo(A: JavascriptEdGraphPin): JavascriptEdGraphPin[];
	static GetOwningNode(A: JavascriptEdGraphPin): EdGraphNode;
	static GetParentPin(A: JavascriptEdGraphPin): JavascriptEdGraphPin;
	static GetPinContainerType(A: JavascriptEdGraphPin): EJavascriptPinContainerType;
	static GetPinGUID(A: JavascriptEdGraphPin): Guid;
	static GetPinIndex(A: JavascriptEdGraphPin): number;
	static GetPinName(A: JavascriptEdGraphPin): string;
	static GetPinRefObject(InPin: JavascriptEdGraphPin): UObject;
	static GetPinType(A: JavascriptEdGraphPin): EdGraphPinType;
	static GetSubPins(A: JavascriptEdGraphPin): JavascriptEdGraphPin[];
	static IsPinHidden(A: JavascriptEdGraphPin): boolean;
	static IsValid(A: JavascriptEdGraphPin): boolean;
	static MakeLinkTo(A: JavascriptEdGraphPin,B: JavascriptEdGraphPin): void;
	static SetParentPin(A: JavascriptEdGraphPin,Parent: JavascriptEdGraphPin): void;
	static SetPinAdvancedView(A: JavascriptEdGraphPin,bAdvancedView: boolean): void;
	static SetPinContainerType(A: JavascriptEdGraphPin,ContainerType: EJavascriptPinContainerType): void;
	static SetPinHidden(A: JavascriptEdGraphPin,bHidden: boolean): void;
	static SetPinInfo(A: JavascriptEdGraphPin,InPinName: string,InPinToolTip: string): void;
	static SetPinRefObject(InPin: JavascriptEdGraphPin,InObject: UObject): void;
	static SetPinType(Pin: JavascriptEdGraphPin,PinType: EdGraphPinType): void;
	static GetDefaultObject(): JavascriptEdGraphPin;
}

declare class EdGraphNode extends UObject { 
	DeprecatedPins: EdGraphPin_Deprecated[];
	NodePosX: number;
	NodePosY: number;
	NodeWidth: number;
	NodeHeight: number;
	AdvancedPinDisplay: ENodeAdvancedPins;
	EnabledState: ENodeEnabledState;
	bDisplayAsDisabled: boolean;
	bUserSetEnabledState: boolean;
	bIsNodeEnabled: boolean;
	bCanResizeNode: boolean;
	bHasCompilerMessage: boolean;
	bCommentBubblePinned: boolean;
	bCommentBubbleVisible: boolean;
	bCommentBubbleMakeVisible: boolean;
	bCanRenameNode: boolean;
	NodeUpgradeMessage: string;
	NodeComment: string;
	ErrorType: number;
	ErrorMsg: string;
	NodeGuid: Guid;
	static Load(ResourceName: string): EdGraphNode;
	static Find(Outer: UObject, ResourceName: string): EdGraphNode;
	static GetDefaultObject(): EdGraphNode;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphNode;
	static C(Other: UObject | any): EdGraphNode;
	AutowireNewNode(FromPin: JavascriptEdGraphPin): void;
	CanDuplicateNode(): boolean;
	CanUserDeleteNode(): boolean;
	DestroyNode(): void;
	FindPin(PinName: string,Direction: EEdGraphPinDirection): JavascriptEdGraphPin;
	GetPins(): JavascriptEdGraphPin[];
	ResizeNode(NewSize: Vector2D): void;
	static AutowireNewNode(UNode: EdGraphNode,FromPin: JavascriptEdGraphPin): void;
	static CanDuplicateNode(UNode: EdGraphNode): boolean;
	static CanUserDeleteNode(UNode: EdGraphNode): boolean;
	static DestroyNode(UNode: EdGraphNode): void;
	static FindPin(UNode: EdGraphNode,PinName: string,Direction: EEdGraphPinDirection): JavascriptEdGraphPin;
	static GetPins(UNode: EdGraphNode): JavascriptEdGraphPin[];
	static ResizeNode(UNode: EdGraphNode,NewSize: Vector2D): void;
}

declare class MaterialExpressionComment extends MaterialExpression { 
	SizeX: number;
	SizeY: number;
	text: string;
	CommentColor: LinearColor;
	FontSize: number;
	static Load(ResourceName: string): MaterialExpressionComment;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionComment;
	static GetDefaultObject(): MaterialExpressionComment;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionComment;
	static C(Other: UObject | any): MaterialExpressionComment;
}

declare class ExpressionInput { 
	Expression: MaterialExpression;
	OutputIndex: number;
	InputName: string;
	mask: number;
	MaskR: number;
	MaskG: number;
	MaskB: number;
	MaskA: number;
	ExpressionName: string;
	clone() : ExpressionInput;
	static C(Other: UObject | any): ExpressionInput;
}

declare type EFunctionInputType = 'FunctionInput_Scalar' | 'FunctionInput_Vector2' | 'FunctionInput_Vector3' | 'FunctionInput_Vector4' | 'FunctionInput_Texture2D' | 'FunctionInput_TextureCube' | 'FunctionInput_Texture2DArray' | 'FunctionInput_VolumeTexture' | 'FunctionInput_StaticBool' | 'FunctionInput_MaterialAttributes' | 'FunctionInput_TextureExternal' | 'FunctionInput_MAX';
declare var EFunctionInputType : { FunctionInput_Scalar:'FunctionInput_Scalar',FunctionInput_Vector2:'FunctionInput_Vector2',FunctionInput_Vector3:'FunctionInput_Vector3',FunctionInput_Vector4:'FunctionInput_Vector4',FunctionInput_Texture2D:'FunctionInput_Texture2D',FunctionInput_TextureCube:'FunctionInput_TextureCube',FunctionInput_Texture2DArray:'FunctionInput_Texture2DArray',FunctionInput_VolumeTexture:'FunctionInput_VolumeTexture',FunctionInput_StaticBool:'FunctionInput_StaticBool',FunctionInput_MaterialAttributes:'FunctionInput_MaterialAttributes',FunctionInput_TextureExternal:'FunctionInput_TextureExternal',FunctionInput_MAX:'FunctionInput_MAX', };
declare class MaterialExpressionFunctionInput extends MaterialExpression { 
	Preview: ExpressionInput;
	InputName: string;
	Description: string;
	ID: Guid;
	InputType: EFunctionInputType;
	PreviewValue: Vector4;
	bUsePreviewValueAsDefault: boolean;
	SortPriority: number;
	bCompilingFunctionPreview: boolean;
	static Load(ResourceName: string): MaterialExpressionFunctionInput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFunctionInput;
	static GetDefaultObject(): MaterialExpressionFunctionInput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFunctionInput;
	static C(Other: UObject | any): MaterialExpressionFunctionInput;
}

declare class FunctionExpressionInput { 
	ExpressionInput: MaterialExpressionFunctionInput;
	ExpressionInputId: Guid;
	Input: ExpressionInput;
	clone() : FunctionExpressionInput;
	static C(Other: UObject | any): FunctionExpressionInput;
}

declare class MaterialExpressionFunctionOutput extends MaterialExpression { 
	OutputName: string;
	Description: string;
	SortPriority: number;
	A: ExpressionInput;
	bLastPreviewed: boolean;
	ID: Guid;
	static Load(ResourceName: string): MaterialExpressionFunctionOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFunctionOutput;
	static GetDefaultObject(): MaterialExpressionFunctionOutput;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFunctionOutput;
	static C(Other: UObject | any): MaterialExpressionFunctionOutput;
}

declare class ExpressionOutput { 
	OutputName: string;
	mask: number;
	MaskR: number;
	MaskG: number;
	MaskB: number;
	MaskA: number;
	clone() : ExpressionOutput;
	static C(Other: UObject | any): ExpressionOutput;
}

declare class FunctionExpressionOutput { 
	ExpressionOutput: MaterialExpressionFunctionOutput;
	ExpressionOutputId: Guid;
	Output: ExpressionOutput;
	clone() : FunctionExpressionOutput;
	static C(Other: UObject | any): FunctionExpressionOutput;
}

declare class MaterialParameterInfo { 
	Name: string;
	Association: EMaterialParameterAssociation;
	index: number;
	clone() : MaterialParameterInfo;
	static C(Other: UObject | any): MaterialParameterInfo;
}

declare class MaterialExpressionMaterialFunctionCall extends MaterialExpression { 
	MaterialFunction: MaterialFunctionInterface;
	FunctionInputs: FunctionExpressionInput[];
	FunctionOutputs: FunctionExpressionOutput[];
	FunctionParameterInfo: MaterialParameterInfo;
	static Load(ResourceName: string): MaterialExpressionMaterialFunctionCall;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMaterialFunctionCall;
	static GetDefaultObject(): MaterialExpressionMaterialFunctionCall;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMaterialFunctionCall;
	SetMaterialFunction(NewMaterialFunction: MaterialFunctionInterface): boolean;
	static C(Other: UObject | any): MaterialExpressionMaterialFunctionCall;
}

declare type EBlendMode = 'BLEND_Opaque' | 'BLEND_Masked' | 'BLEND_Translucent' | 'BLEND_Additive' | 'BLEND_Modulate' | 'BLEND_AlphaComposite' | 'BLEND_AlphaHoldout' | 'BLEND_MAX';
declare var EBlendMode : { BLEND_Opaque:'BLEND_Opaque',BLEND_Masked:'BLEND_Masked',BLEND_Translucent:'BLEND_Translucent',BLEND_Additive:'BLEND_Additive',BLEND_Modulate:'BLEND_Modulate',BLEND_AlphaComposite:'BLEND_AlphaComposite',BLEND_AlphaHoldout:'BLEND_AlphaHoldout',BLEND_MAX:'BLEND_MAX', };
declare class MaterialFunction extends MaterialFunctionInterface { 
	ParentFunction: MaterialFunction;
	Description: string;
	FunctionExpressions: MaterialExpression[];
	bExposeToLibrary: boolean;
	bPrefixParameterNames: boolean;
	LibraryCategories: string[];
	LibraryCategoriesText: string[];
	FunctionEditorComments: MaterialExpressionComment[];
	PreviewMaterial: Material;
	DependentFunctionExpressionCandidates: MaterialExpressionMaterialFunctionCall[];
	PreviewBlendMode: EBlendMode;
	bReentrantFlag: boolean;
	static Load(ResourceName: string): MaterialFunction;
	static Find(Outer: UObject, ResourceName: string): MaterialFunction;
	static GetDefaultObject(): MaterialFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunction;
	static C(Other: UObject | any): MaterialFunction;
	CreateMaterialExpressionInFunction(ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	DeleteAllMaterialExpressionsInFunction(): void;
	DeleteMaterialExpressionInFunction(Expression: MaterialExpression): void;
	GetNumMaterialExpressionsInFunction(): number;
	LayoutMaterialFunctionExpressions(): void;
	static CreateMaterialExpressionInFunction(MaterialFunction: MaterialFunction,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static DeleteAllMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): void;
	static DeleteMaterialExpressionInFunction(MaterialFunction: MaterialFunction,Expression: MaterialExpression): void;
	static GetNumMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): number;
	static LayoutMaterialFunctionExpressions(MaterialFunction: MaterialFunction): void;
}

declare type EMaterialProperty = 'MP_EmissiveColor' | 'MP_Opacity' | 'MP_OpacityMask' | 'MP_DiffuseColor' | 'MP_SpecularColor' | 'MP_BaseColor' | 'MP_Metallic' | 'MP_Specular' | 'MP_Roughness' | 'MP_Anisotropy' | 'MP_Normal' | 'MP_Tangent' | 'MP_WorldPositionOffset' | 'MP_WorldDisplacement_DEPRECATED' | 'MP_TessellationMultiplier_DEPRECATED' | 'MP_SubsurfaceColor' | 'MP_CustomData0' | 'MP_CustomData1' | 'MP_AmbientOcclusion' | 'MP_Refraction' | 'MP_CustomizedUVs0' | 'MP_CustomizedUVs1' | 'MP_CustomizedUVs2' | 'MP_CustomizedUVs3' | 'MP_CustomizedUVs4' | 'MP_CustomizedUVs5' | 'MP_CustomizedUVs6' | 'MP_CustomizedUVs7' | 'MP_PixelDepthOffset' | 'MP_ShadingModel' | 'MP_FrontMaterial' | 'MP_MaterialAttributes' | 'MP_CustomOutput' | 'MP_MAX';
declare var EMaterialProperty : { MP_EmissiveColor:'MP_EmissiveColor',MP_Opacity:'MP_Opacity',MP_OpacityMask:'MP_OpacityMask',MP_DiffuseColor:'MP_DiffuseColor',MP_SpecularColor:'MP_SpecularColor',MP_BaseColor:'MP_BaseColor',MP_Metallic:'MP_Metallic',MP_Specular:'MP_Specular',MP_Roughness:'MP_Roughness',MP_Anisotropy:'MP_Anisotropy',MP_Normal:'MP_Normal',MP_Tangent:'MP_Tangent',MP_WorldPositionOffset:'MP_WorldPositionOffset',MP_WorldDisplacement_DEPRECATED:'MP_WorldDisplacement_DEPRECATED',MP_TessellationMultiplier_DEPRECATED:'MP_TessellationMultiplier_DEPRECATED',MP_SubsurfaceColor:'MP_SubsurfaceColor',MP_CustomData0:'MP_CustomData0',MP_CustomData1:'MP_CustomData1',MP_AmbientOcclusion:'MP_AmbientOcclusion',MP_Refraction:'MP_Refraction',MP_CustomizedUVs0:'MP_CustomizedUVs0',MP_CustomizedUVs1:'MP_CustomizedUVs1',MP_CustomizedUVs2:'MP_CustomizedUVs2',MP_CustomizedUVs3:'MP_CustomizedUVs3',MP_CustomizedUVs4:'MP_CustomizedUVs4',MP_CustomizedUVs5:'MP_CustomizedUVs5',MP_CustomizedUVs6:'MP_CustomizedUVs6',MP_CustomizedUVs7:'MP_CustomizedUVs7',MP_PixelDepthOffset:'MP_PixelDepthOffset',MP_ShadingModel:'MP_ShadingModel',MP_FrontMaterial:'MP_FrontMaterial',MP_MaterialAttributes:'MP_MaterialAttributes',MP_CustomOutput:'MP_CustomOutput',MP_MAX:'MP_MAX', };
declare class MaterialExpression extends UObject { 
	MaterialExpressionEditorX: number;
	MaterialExpressionEditorY: number;
	GraphNode: EdGraphNode;
	SubgraphExpression: MaterialExpression;
	MaterialExpressionGuid: Guid;
	Material: Material;
	UFunction: MaterialFunction;
	Desc: string;
	bRealtimePreview: boolean;
	bNeedToUpdatePreview: boolean;
	bIsParameterExpression: boolean;
	bCommentBubbleVisible: boolean;
	bShowOutputNameOnPin: boolean;
	bShowMaskColorsOnPin: boolean;
	bHidePreviewWindow: boolean;
	bCollapsed: boolean;
	bShaderInputData: boolean;
	bShowInputs: boolean;
	bShowOutputs: boolean;
	MenuCategories: string[];
	Outputs: ExpressionOutput[];
	static Load(ResourceName: string): MaterialExpression;
	static Find(Outer: UObject, ResourceName: string): MaterialExpression;
	static GetDefaultObject(): MaterialExpression;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpression;
	static C(Other: UObject | any): MaterialExpression;
	ConnectMaterialExpressions(FromOutputName: string,ToExpression: MaterialExpression,ToInputName: string): boolean;
	ConnectMaterialProperty(FromOutputName: string,Property: EMaterialProperty): boolean;
	static ConnectMaterialExpressions(FromExpression: MaterialExpression,FromOutputName: string,ToExpression: MaterialExpression,ToInputName: string): boolean;
	static ConnectMaterialProperty(FromExpression: MaterialExpression,FromOutputName: string,Property: EMaterialProperty): boolean;
}

declare class MaterialInput { 
	Expression: MaterialExpression;
	OutputIndex: number;
	InputName: string;
	mask: number;
	MaskR: number;
	MaskG: number;
	MaskB: number;
	MaskA: number;
	ExpressionName: string;
	clone() : MaterialInput;
	static C(Other: UObject | any): MaterialInput;
}

declare class ColorMaterialInput extends MaterialInput { 
	UseConstant: boolean;
	Constant: Color;
	clone() : ColorMaterialInput;
	static C(Other: UObject | any): ColorMaterialInput;
}

declare class ScalarMaterialInput extends MaterialInput { 
	UseConstant: boolean;
	Constant: number;
	clone() : ScalarMaterialInput;
	static C(Other: UObject | any): ScalarMaterialInput;
}

declare class Vector3f { 
	X: number;
	Y: number;
	Z: number;
	clone() : Vector3f;
	static C(Other: UObject | any): Vector3f;
	Conv_Vector3fToString(): string;
	BreakVector3f(X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	static Conv_Vector3fToString(InVec: Vector3f): string;
	static BreakVector3f(InVec: Vector3f,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
}

declare class VectorMaterialInput extends MaterialInput { 
	UseConstant: boolean;
	Constant: Vector3f;
	clone() : VectorMaterialInput;
	static C(Other: UObject | any): VectorMaterialInput;
}

declare type EMaterialDomain = 'MD_Surface' | 'MD_DeferredDecal' | 'MD_LightFunction' | 'MD_Volume' | 'MD_PostProcess' | 'MD_UI' | 'MD_RuntimeVirtualTexture' | 'MD_MAX';
declare var EMaterialDomain : { MD_Surface:'MD_Surface',MD_DeferredDecal:'MD_DeferredDecal',MD_LightFunction:'MD_LightFunction',MD_Volume:'MD_Volume',MD_PostProcess:'MD_PostProcess',MD_UI:'MD_UI',MD_RuntimeVirtualTexture:'MD_RuntimeVirtualTexture',MD_MAX:'MD_MAX', };
declare type EDecalBlendMode = 'DBM_Translucent' | 'DBM_Stain' | 'DBM_Normal' | 'DBM_Emissive' | 'DBM_DBuffer_ColorNormalRoughness' | 'DBM_DBuffer_Color' | 'DBM_DBuffer_ColorNormal' | 'DBM_DBuffer_ColorRoughness' | 'DBM_DBuffer_Normal' | 'DBM_DBuffer_NormalRoughness' | 'DBM_DBuffer_Roughness' | 'DBM_DBuffer_Emissive' | 'DBM_DBuffer_AlphaComposite' | 'DBM_DBuffer_EmissiveAlphaComposite' | 'DBM_Volumetric_DistanceFunction' | 'DBM_AlphaComposite' | 'DBM_AmbientOcclusion' | 'DBM_MAX';
declare var EDecalBlendMode : { DBM_Translucent:'DBM_Translucent',DBM_Stain:'DBM_Stain',DBM_Normal:'DBM_Normal',DBM_Emissive:'DBM_Emissive',DBM_DBuffer_ColorNormalRoughness:'DBM_DBuffer_ColorNormalRoughness',DBM_DBuffer_Color:'DBM_DBuffer_Color',DBM_DBuffer_ColorNormal:'DBM_DBuffer_ColorNormal',DBM_DBuffer_ColorRoughness:'DBM_DBuffer_ColorRoughness',DBM_DBuffer_Normal:'DBM_DBuffer_Normal',DBM_DBuffer_NormalRoughness:'DBM_DBuffer_NormalRoughness',DBM_DBuffer_Roughness:'DBM_DBuffer_Roughness',DBM_DBuffer_Emissive:'DBM_DBuffer_Emissive',DBM_DBuffer_AlphaComposite:'DBM_DBuffer_AlphaComposite',DBM_DBuffer_EmissiveAlphaComposite:'DBM_DBuffer_EmissiveAlphaComposite',DBM_Volumetric_DistanceFunction:'DBM_Volumetric_DistanceFunction',DBM_AlphaComposite:'DBM_AlphaComposite',DBM_AmbientOcclusion:'DBM_AmbientOcclusion',DBM_MAX:'DBM_MAX', };
declare type EMaterialDecalResponse = 'MDR_None' | 'MDR_ColorNormalRoughness' | 'MDR_Color' | 'MDR_ColorNormal' | 'MDR_ColorRoughness' | 'MDR_Normal' | 'MDR_NormalRoughness' | 'MDR_Roughness' | 'MDR_MAX';
declare var EMaterialDecalResponse : { MDR_None:'MDR_None',MDR_ColorNormalRoughness:'MDR_ColorNormalRoughness',MDR_Color:'MDR_Color',MDR_ColorNormal:'MDR_ColorNormal',MDR_ColorRoughness:'MDR_ColorRoughness',MDR_Normal:'MDR_Normal',MDR_NormalRoughness:'MDR_NormalRoughness',MDR_Roughness:'MDR_Roughness',MDR_MAX:'MDR_MAX', };
declare type EMaterialShadingModel = 'MSM_Unlit' | 'MSM_DefaultLit' | 'MSM_Subsurface' | 'MSM_PreintegratedSkin' | 'MSM_ClearCoat' | 'MSM_SubsurfaceProfile' | 'MSM_TwoSidedFoliage' | 'MSM_Hair' | 'MSM_Cloth' | 'MSM_Eye' | 'MSM_SingleLayerWater' | 'MSM_ThinTranslucent' | 'MSM_Strata' | 'MSM_NUM' | 'MSM_FromMaterialExpression' | 'MSM_MAX';
declare var EMaterialShadingModel : { MSM_Unlit:'MSM_Unlit',MSM_DefaultLit:'MSM_DefaultLit',MSM_Subsurface:'MSM_Subsurface',MSM_PreintegratedSkin:'MSM_PreintegratedSkin',MSM_ClearCoat:'MSM_ClearCoat',MSM_SubsurfaceProfile:'MSM_SubsurfaceProfile',MSM_TwoSidedFoliage:'MSM_TwoSidedFoliage',MSM_Hair:'MSM_Hair',MSM_Cloth:'MSM_Cloth',MSM_Eye:'MSM_Eye',MSM_SingleLayerWater:'MSM_SingleLayerWater',MSM_ThinTranslucent:'MSM_ThinTranslucent',MSM_Strata:'MSM_Strata',MSM_NUM:'MSM_NUM',MSM_FromMaterialExpression:'MSM_FromMaterialExpression',MSM_MAX:'MSM_MAX', };
declare class MaterialShadingModelField { 
	ShadingModelField: any;
	clone() : MaterialShadingModelField;
	static C(Other: UObject | any): MaterialShadingModelField;
}

declare class Vector2MaterialInput extends MaterialInput { 
	UseConstant: boolean;
	ConstantX: number;
	ConstantY: number;
	clone() : Vector2MaterialInput;
	static C(Other: UObject | any): Vector2MaterialInput;
}

declare class MaterialAttributesInput extends ExpressionInput { 
	PropertyConnectedBitmask: number;
	clone() : MaterialAttributesInput;
	static C(Other: UObject | any): MaterialAttributesInput;
}

declare class ShadingModelMaterialInput extends MaterialInput { 
	clone() : ShadingModelMaterialInput;
	static C(Other: UObject | any): ShadingModelMaterialInput;
}

declare class StrataMaterialInput extends MaterialInput { 
	clone() : StrataMaterialInput;
	static C(Other: UObject | any): StrataMaterialInput;
}

declare type EMaterialTranslucencyPass = 'MTP_BeforeDOF' | 'MTP_AfterDOF' | 'MTP_AfterMotionBlur' | 'MTP_MAX';
declare var EMaterialTranslucencyPass : { MTP_BeforeDOF:'MTP_BeforeDOF',MTP_AfterDOF:'MTP_AfterDOF',MTP_AfterMotionBlur:'MTP_AfterMotionBlur',MTP_MAX:'MTP_MAX', };
declare type ETranslucencyLightingMode = 'TLM_VolumetricNonDirectional' | 'TLM_VolumetricDirectional' | 'TLM_VolumetricPerVertexNonDirectional' | 'TLM_VolumetricPerVertexDirectional' | 'TLM_Surface' | 'TLM_SurfacePerPixelLighting' | 'TLM_MAX';
declare var ETranslucencyLightingMode : { TLM_VolumetricNonDirectional:'TLM_VolumetricNonDirectional',TLM_VolumetricDirectional:'TLM_VolumetricDirectional',TLM_VolumetricPerVertexNonDirectional:'TLM_VolumetricPerVertexNonDirectional',TLM_VolumetricPerVertexDirectional:'TLM_VolumetricPerVertexDirectional',TLM_Surface:'TLM_Surface',TLM_SurfacePerPixelLighting:'TLM_SurfacePerPixelLighting',TLM_MAX:'TLM_MAX', };
declare type EMaterialFloatPrecisionMode = 'MFPM_Default' | 'MFPM_Full_MaterialExpressionOnly' | 'MFPM_Full' | 'MFPM_Half' | 'MFPM_MAX';
declare var EMaterialFloatPrecisionMode : { MFPM_Default:'MFPM_Default',MFPM_Full_MaterialExpressionOnly:'MFPM_Full_MaterialExpressionOnly',MFPM_Full:'MFPM_Full',MFPM_Half:'MFPM_Half',MFPM_MAX:'MFPM_MAX', };
declare type EMaterialShadingRate = 'MSR_1x1' | 'MSR_2x1' | 'MSR_1x2' | 'MSR_2x2' | 'MSR_4x2' | 'MSR_2x4' | 'MSR_4x4' | 'MSR_Count' | 'MSR_MAX';
declare var EMaterialShadingRate : { MSR_1x1:'MSR_1x1',MSR_2x1:'MSR_2x1',MSR_1x2:'MSR_1x2',MSR_2x2:'MSR_2x2',MSR_4x2:'MSR_4x2',MSR_2x4:'MSR_2x4',MSR_4x4:'MSR_4x4',MSR_Count:'MSR_Count',MSR_MAX:'MSR_MAX', };
declare class ExpressionExecOutput { 
	Expression: MaterialExpression;
	clone() : ExpressionExecOutput;
	static C(Other: UObject | any): ExpressionExecOutput;
}

declare class MaterialExpressionExecBegin extends MaterialExpression { 
	exec: ExpressionExecOutput;
	static Load(ResourceName: string): MaterialExpressionExecBegin;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionExecBegin;
	static GetDefaultObject(): MaterialExpressionExecBegin;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionExecBegin;
	static C(Other: UObject | any): MaterialExpressionExecBegin;
}

declare class MaterialExpressionExecEnd extends MaterialExpression { 
	static Load(ResourceName: string): MaterialExpressionExecEnd;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionExecEnd;
	static GetDefaultObject(): MaterialExpressionExecEnd;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionExecEnd;
	static C(Other: UObject | any): MaterialExpressionExecEnd;
}

declare class ParameterGroupData { 
	GroupName: string;
	GroupSortPriority: number;
	clone() : ParameterGroupData;
	static C(Other: UObject | any): ParameterGroupData;
}

declare type EBlendableLocation = 'BL_AfterTonemapping' | 'BL_BeforeTonemapping' | 'BL_BeforeTranslucency' | 'BL_ReplacingTonemapper' | 'BL_SSRInput' | 'BL_MAX';
declare var EBlendableLocation : { BL_AfterTonemapping:'BL_AfterTonemapping',BL_BeforeTonemapping:'BL_BeforeTonemapping',BL_BeforeTranslucency:'BL_BeforeTranslucency',BL_ReplacingTonemapper:'BL_ReplacingTonemapper',BL_SSRInput:'BL_SSRInput',BL_MAX:'BL_MAX', };
declare type EMaterialStencilCompare = 'MSC_Less' | 'MSC_LessEqual' | 'MSC_Greater' | 'MSC_GreaterEqual' | 'MSC_Equal' | 'MSC_NotEqual' | 'MSC_Never' | 'MSC_Always' | 'MSC_Count' | 'MSC_MAX';
declare var EMaterialStencilCompare : { MSC_Less:'MSC_Less',MSC_LessEqual:'MSC_LessEqual',MSC_Greater:'MSC_Greater',MSC_GreaterEqual:'MSC_GreaterEqual',MSC_Equal:'MSC_Equal',MSC_NotEqual:'MSC_NotEqual',MSC_Never:'MSC_Never',MSC_Always:'MSC_Always',MSC_Count:'MSC_Count',MSC_MAX:'MSC_MAX', };
declare type ERefractionMode = 'RM_IndexOfRefraction' | 'RM_PixelNormalOffset' | 'RM_MAX';
declare var ERefractionMode : { RM_IndexOfRefraction:'RM_IndexOfRefraction',RM_PixelNormalOffset:'RM_PixelNormalOffset',RM_MAX:'RM_MAX', };
declare type EMaterialUsage = 'MATUSAGE_SkeletalMesh' | 'MATUSAGE_ParticleSprites' | 'MATUSAGE_BeamTrails' | 'MATUSAGE_MeshParticles' | 'MATUSAGE_StaticLighting' | 'MATUSAGE_MorphTargets' | 'MATUSAGE_SplineMesh' | 'MATUSAGE_InstancedStaticMeshes' | 'MATUSAGE_GeometryCollections' | 'MATUSAGE_Clothing' | 'MATUSAGE_NiagaraSprites' | 'MATUSAGE_NiagaraRibbons' | 'MATUSAGE_NiagaraMeshParticles' | 'MATUSAGE_GeometryCache' | 'MATUSAGE_Water' | 'MATUSAGE_HairStrands' | 'MATUSAGE_LidarPointCloud' | 'MATUSAGE_VirtualHeightfieldMesh' | 'MATUSAGE_Nanite' | 'MATUSAGE_MAX';
declare var EMaterialUsage : { MATUSAGE_SkeletalMesh:'MATUSAGE_SkeletalMesh',MATUSAGE_ParticleSprites:'MATUSAGE_ParticleSprites',MATUSAGE_BeamTrails:'MATUSAGE_BeamTrails',MATUSAGE_MeshParticles:'MATUSAGE_MeshParticles',MATUSAGE_StaticLighting:'MATUSAGE_StaticLighting',MATUSAGE_MorphTargets:'MATUSAGE_MorphTargets',MATUSAGE_SplineMesh:'MATUSAGE_SplineMesh',MATUSAGE_InstancedStaticMeshes:'MATUSAGE_InstancedStaticMeshes',MATUSAGE_GeometryCollections:'MATUSAGE_GeometryCollections',MATUSAGE_Clothing:'MATUSAGE_Clothing',MATUSAGE_NiagaraSprites:'MATUSAGE_NiagaraSprites',MATUSAGE_NiagaraRibbons:'MATUSAGE_NiagaraRibbons',MATUSAGE_NiagaraMeshParticles:'MATUSAGE_NiagaraMeshParticles',MATUSAGE_GeometryCache:'MATUSAGE_GeometryCache',MATUSAGE_Water:'MATUSAGE_Water',MATUSAGE_HairStrands:'MATUSAGE_HairStrands',MATUSAGE_LidarPointCloud:'MATUSAGE_LidarPointCloud',MATUSAGE_VirtualHeightfieldMesh:'MATUSAGE_VirtualHeightfieldMesh',MATUSAGE_Nanite:'MATUSAGE_Nanite',MATUSAGE_MAX:'MATUSAGE_MAX', };
declare class Material extends MaterialInterface { 
	PhysMaterial: PhysicalMaterial;
	PhysMaterialMask: PhysicalMaterialMask;
	PhysicalMaterialMap: PhysicalMaterial;
	DiffuseColor: ColorMaterialInput;
	SpecularColor: ColorMaterialInput;
	BaseColor: ColorMaterialInput;
	Metallic: ScalarMaterialInput;
	Specular: ScalarMaterialInput;
	Roughness: ScalarMaterialInput;
	Anisotropy: ScalarMaterialInput;
	Normal: VectorMaterialInput;
	Tangent: VectorMaterialInput;
	EmissiveColor: ColorMaterialInput;
	Opacity: ScalarMaterialInput;
	OpacityMask: ScalarMaterialInput;
	MaterialDomain: EMaterialDomain;
	BlendMode: EBlendMode;
	DecalBlendMode: EDecalBlendMode;
	MaterialDecalResponse: EMaterialDecalResponse;
	ShadingModel: EMaterialShadingModel;
	bCastDynamicShadowAsMasked: boolean;
	ShadingModels: MaterialShadingModelField;
	UsedShadingModels: string;
	OpacityMaskClipValue: number;
	WorldPositionOffset: VectorMaterialInput;
	SubsurfaceColor: ColorMaterialInput;
	ClearCoat: ScalarMaterialInput;
	ClearCoatRoughness: ScalarMaterialInput;
	AmbientOcclusion: ScalarMaterialInput;
	Refraction: ScalarMaterialInput;
	CustomizedUVs: Vector2MaterialInput;
	MaterialAttributes: MaterialAttributesInput;
	PixelDepthOffset: ScalarMaterialInput;
	ShadingModelFromMaterialExpression: ShadingModelMaterialInput;
	FrontMaterial: StrataMaterialInput;
	bEnableSeparateTranslucency: boolean;
	bEnableResponsiveAA: boolean;
	bScreenSpaceReflections: boolean;
	bContactShadows: boolean;
	TwoSided: boolean;
	DitheredLODTransition: boolean;
	DitherOpacityMask: boolean;
	bAllowNegativeEmissiveColor: boolean;
	TranslucencyPass: EMaterialTranslucencyPass;
	TranslucencyLightingMode: ETranslucencyLightingMode;
	bEnableMobileSeparateTranslucency: boolean;
	NumCustomizedUVs: number;
	TranslucencyDirectionalLightingIntensity: number;
	TranslucentShadowDensityScale: number;
	TranslucentSelfShadowDensityScale: number;
	TranslucentSelfShadowSecondDensityScale: number;
	TranslucentSelfShadowSecondOpacity: number;
	TranslucentBackscatteringExponent: number;
	TranslucentMultipleScatteringExtinction: LinearColor;
	TranslucentShadowStartOffset: number;
	bDisableDepthTest: boolean;
	bWriteOnlyAlpha: boolean;
	bGenerateSphericalParticleNormals: boolean;
	bTangentSpaceNormal: boolean;
	bUseEmissiveForDynamicAreaLighting: boolean;
	bUsedAsSpecialEngineMaterial: boolean;
	bUsedWithSkeletalMesh: boolean;
	bUsedWithEditorCompositing: boolean;
	bUsedWithParticleSprites: boolean;
	bUsedWithBeamTrails: boolean;
	bUsedWithMeshParticles: boolean;
	bUsedWithNiagaraSprites: boolean;
	bUsedWithNiagaraRibbons: boolean;
	bUsedWithNiagaraMeshParticles: boolean;
	bUsedWithGeometryCache: boolean;
	bUsedWithStaticLighting: boolean;
	bUsedWithMorphTargets: boolean;
	bUsedWithSplineMeshes: boolean;
	bUsedWithInstancedStaticMeshes: boolean;
	bUsedWithGeometryCollections: boolean;
	bUsesDistortion: boolean;
	bUsedWithClothing: boolean;
	bUsedWithWater: boolean;
	bUsedWithHairStrands: boolean;
	bUsedWithLidarPointCloud: boolean;
	bUsedWithVirtualHeightfieldMesh: boolean;
	bUsedWithNanite: boolean;
	bUsedWithUI: boolean;
	bAutomaticallySetUsageInEditor: boolean;
	bFullyRough: boolean;
	bUseFullPrecision: boolean;
	FloatPrecisionMode: EMaterialFloatPrecisionMode;
	bUseLightmapDirectionality: boolean;
	bMobileEnableHighQualityBRDF: boolean;
	bUseAlphaToCoverage: boolean;
	bForwardRenderUsePreintegratedGFForSimpleIBL: boolean;
	bUseHQForwardReflections: boolean;
	bForwardBlendsSkyLightCubemaps: boolean;
	bUsePlanarForwardReflections: boolean;
	bNormalCurvatureToRoughness: boolean;
	AllowTranslucentCustomDepthWrites: boolean;
	Wireframe: boolean;
	ShadingRate: EMaterialShadingRate;
	EditorX: number;
	EditorY: number;
	EditorPitch: number;
	EditorYaw: number;
	Expressions: MaterialExpression[];
	EditorComments: MaterialExpressionComment[];
	ExpressionExecBegin: MaterialExpressionExecBegin;
	ExpressionExecEnd: MaterialExpressionExecEnd;
	ParameterGroupData: ParameterGroupData[];
	bCanMaskedBeAssumedOpaque: boolean;
	bIsMasked: boolean;
	bIsPreviewMaterial: boolean;
	bIsFunctionPreviewMaterial: boolean;
	bUseMaterialAttributes: boolean;
	bEnableExecWire: boolean;
	bEnableNewHLSLGenerator: boolean;
	bCastRayTracedShadows: boolean;
	bUseTranslucencyVertexFog: boolean;
	bApplyCloudFogging: boolean;
	bIsSky: boolean;
	bComputeFogPerPixel: boolean;
	bOutputTranslucentVelocity: boolean;
	bAllowDevelopmentShaderCompile: boolean;
	bIsMaterialEditorStatsMaterial: boolean;
	BlendableLocation: EBlendableLocation;
	BlendableOutputAlpha: boolean;
	bEnableStencilTest: boolean;
	StencilCompare: EMaterialStencilCompare;
	StencilRefValue: number;
	RefractionMode: ERefractionMode;
	BlendablePriority: number;
	bIsBlendable: boolean;
	UsageFlagWarnings: any;
	RefractionDepthBias: number;
	StateId: Guid;
	bSavedCachedExpressionData: boolean;
	ReferencedTextureGuids: Guid[];
	static Load(ResourceName: string): Material;
	static Find(Outer: UObject, ResourceName: string): Material;
	static GetDefaultObject(): Material;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Material;
	static C(Other: UObject | any): Material;
	CreateMaterialExpression(ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	DeleteAllMaterialExpressions(): void;
	DeleteMaterialExpression(Expression: MaterialExpression): void;
	DuplicateMaterialExpression(MaterialFunction: MaterialFunction,Expression: MaterialExpression): MaterialExpression;
	GetInputsForMaterialExpression(MaterialExpression: MaterialExpression): MaterialExpression[];
	GetMaterialDefaultScalarParameterValue(ParameterName: string): number;
	GetMaterialDefaultStaticSwitchParameterValue(ParameterName: string): boolean;
	GetMaterialDefaultTextureParameterValue(ParameterName: string): Texture;
	GetMaterialDefaultVectorParameterValue(ParameterName: string): LinearColor;
	GetMaterialPropertyInputNode(Property: EMaterialProperty): MaterialExpression;
	GetMaterialSelectedNodes(): any;
	GetNumMaterialExpressions(): number;
	GetUsedTextures(): Texture[];
	HasMaterialUsage(Usage: EMaterialUsage): boolean;
	LayoutMaterialExpressions(): void;
	RecompileMaterial(): void;
	SetMaterialUsage(Usage: EMaterialUsage,bNeedsRecompile?: boolean): {bNeedsRecompile: boolean, $: boolean};
	static CreateMaterialExpression(Material: Material,ExpressionClass: UnrealEngineClass,NodePosX: number,NodePosY: number): MaterialExpression;
	static DeleteAllMaterialExpressions(Material: Material): void;
	static DeleteMaterialExpression(Material: Material,Expression: MaterialExpression): void;
	static DuplicateMaterialExpression(Material: Material,MaterialFunction: MaterialFunction,Expression: MaterialExpression): MaterialExpression;
	static GetInputsForMaterialExpression(Material: Material,MaterialExpression: MaterialExpression): MaterialExpression[];
	static GetMaterialDefaultScalarParameterValue(Material: Material,ParameterName: string): number;
	static GetMaterialDefaultStaticSwitchParameterValue(Material: Material,ParameterName: string): boolean;
	static GetMaterialDefaultTextureParameterValue(Material: Material,ParameterName: string): Texture;
	static GetMaterialDefaultVectorParameterValue(Material: Material,ParameterName: string): LinearColor;
	static GetMaterialPropertyInputNode(Material: Material,Property: EMaterialProperty): MaterialExpression;
	static GetMaterialSelectedNodes(Material: Material): any;
	static GetNumMaterialExpressions(Material: Material): number;
	static GetUsedTextures(Material: Material): Texture[];
	static HasMaterialUsage(Material: Material,Usage: EMaterialUsage): boolean;
	static LayoutMaterialExpressions(Material: Material): void;
	static RecompileMaterial(Material: Material): void;
	static SetMaterialUsage(Material: Material,Usage: EMaterialUsage,bNeedsRecompile?: boolean): {bNeedsRecompile: boolean, $: boolean};
}

declare class MaterialFunctionInterface extends UObject { 
	StateId: Guid;
	MaterialFunctionUsage: EMaterialFunctionUsage;
	CombinedInputTypes: any;
	CombinedOutputTypes: any;
	ThumbnailInfo: ThumbnailInfo;
	static Load(ResourceName: string): MaterialFunctionInterface;
	static Find(Outer: UObject, ResourceName: string): MaterialFunctionInterface;
	static GetDefaultObject(): MaterialFunctionInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunctionInterface;
	static C(Other: UObject | any): MaterialFunctionInterface;
	UpdateMaterialFunction(PreviewMaterial: Material): void;
	static UpdateMaterialFunction(MaterialFunction: MaterialFunctionInterface,PreviewMaterial: Material): void;
}

declare type ESubstanceGenerationMode = 'SGM_PlatformDefault' | 'SGM_Baked' | 'SGM_OnLoadSync' | 'SGM_OnLoadSyncAndCache' | 'SGM_OnLoadAsync' | 'SGM_OnLoadAsyncAndCache' | 'SGM_MAX';
declare var ESubstanceGenerationMode : { SGM_PlatformDefault:'SGM_PlatformDefault',SGM_Baked:'SGM_Baked',SGM_OnLoadSync:'SGM_OnLoadSync',SGM_OnLoadSyncAndCache:'SGM_OnLoadSyncAndCache',SGM_OnLoadAsync:'SGM_OnLoadAsync',SGM_OnLoadAsyncAndCache:'SGM_OnLoadAsyncAndCache',SGM_MAX:'SGM_MAX', };
declare class SubstanceGraphDesc { 
	index: number;
	Label: string;
	Description: string;
	Category: string;
	Keywords: string;
	Author: string;
	AuthorUrl: string;
	UserTag: string;
	clone() : SubstanceGraphDesc;
	static C(Other: UObject | any): SubstanceGraphDesc;
}

declare class SubstanceConnection { 
	OutputIdentifier: string;
	InputImageIdentifier: string;
	clone() : SubstanceConnection;
	static C(Other: UObject | any): SubstanceConnection;
}

declare class SubstanceInstanceFactory extends UObject { 
	mGraphInstances: SubstanceGraphInstance[];
	RelativeSourceFilePath: string;
	AbsoluteSourceFilePath: string;
	SourceFileTimestamp: string;
	GenerationMode: ESubstanceGenerationMode;
	static Load(ResourceName: string): SubstanceInstanceFactory;
	static Find(Outer: UObject, ResourceName: string): SubstanceInstanceFactory;
	static GetDefaultObject(): SubstanceInstanceFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubstanceInstanceFactory;
	GetGraphInstances(): SubstanceGraphInstance[];
	GetGraphDescs(): SubstanceGraphDesc[];
	CreateGraphInstance(GraphDesc: SubstanceGraphDesc,PackageName: string): SubstanceGraphInstance;
	static C(Other: UObject | any): SubstanceInstanceFactory;
	CreateAggregateSubstanceFactory(OutputFactoryGraphIndex: number,InputFactory: SubstanceInstanceFactory,InputFactoryGraphIndex: number,Connections: SubstanceConnection[]): SubstanceInstanceFactory;
	static CreateAggregateSubstanceFactory(OutputFactory: SubstanceInstanceFactory,OutputFactoryGraphIndex: number,InputFactory: SubstanceInstanceFactory,InputFactoryGraphIndex: number,Connections: SubstanceConnection[]): SubstanceInstanceFactory;
}

declare class CurveBase extends UObject { 
	AssetImportData: AssetImportData;
	ImportPath: string;
	static Load(ResourceName: string): CurveBase;
	static Find(Outer: UObject, ResourceName: string): CurveBase;
	static GetDefaultObject(): CurveBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveBase;
	GetValueRange(MinValue?: number,MaxValue?: number): {MinValue: number, MaxValue: number};
	GetTimeRange(MinTime?: number,MaxTime?: number): {MinTime: number, MaxTime: number};
	static C(Other: UObject | any): CurveBase;
}

declare class KeyHandleMap { 
	clone() : KeyHandleMap;
	static C(Other: UObject | any): KeyHandleMap;
}

declare class IndexedCurve { 
	KeyHandlesToIndices: KeyHandleMap;
	clone() : IndexedCurve;
	static C(Other: UObject | any): IndexedCurve;
}

declare type ERichCurveExtrapolation = 'RCCE_Cycle' | 'RCCE_CycleWithOffset' | 'RCCE_Oscillate' | 'RCCE_Linear' | 'RCCE_Constant' | 'RCCE_None' | 'RCCE_MAX';
declare var ERichCurveExtrapolation : { RCCE_Cycle:'RCCE_Cycle',RCCE_CycleWithOffset:'RCCE_CycleWithOffset',RCCE_Oscillate:'RCCE_Oscillate',RCCE_Linear:'RCCE_Linear',RCCE_Constant:'RCCE_Constant',RCCE_None:'RCCE_None',RCCE_MAX:'RCCE_MAX', };
declare class RealCurve extends IndexedCurve { 
	DefaultValue: number;
	PreInfinityExtrap: ERichCurveExtrapolation;
	PostInfinityExtrap: ERichCurveExtrapolation;
	clone() : RealCurve;
	static C(Other: UObject | any): RealCurve;
}

declare type ERichCurveInterpMode = 'RCIM_Linear' | 'RCIM_Constant' | 'RCIM_Cubic' | 'RCIM_None' | 'RCIM_MAX';
declare var ERichCurveInterpMode : { RCIM_Linear:'RCIM_Linear',RCIM_Constant:'RCIM_Constant',RCIM_Cubic:'RCIM_Cubic',RCIM_None:'RCIM_None',RCIM_MAX:'RCIM_MAX', };
declare type ERichCurveTangentMode = 'RCTM_Auto' | 'RCTM_User' | 'RCTM_Break' | 'RCTM_None' | 'RCTM_MAX';
declare var ERichCurveTangentMode : { RCTM_Auto:'RCTM_Auto',RCTM_User:'RCTM_User',RCTM_Break:'RCTM_Break',RCTM_None:'RCTM_None',RCTM_MAX:'RCTM_MAX', };
declare type ERichCurveTangentWeightMode = 'RCTWM_WeightedNone' | 'RCTWM_WeightedArrive' | 'RCTWM_WeightedLeave' | 'RCTWM_WeightedBoth' | 'RCTWM_MAX';
declare var ERichCurveTangentWeightMode : { RCTWM_WeightedNone:'RCTWM_WeightedNone',RCTWM_WeightedArrive:'RCTWM_WeightedArrive',RCTWM_WeightedLeave:'RCTWM_WeightedLeave',RCTWM_WeightedBoth:'RCTWM_WeightedBoth',RCTWM_MAX:'RCTWM_MAX', };
declare class RichCurveKey { 
	InterpMode: ERichCurveInterpMode;
	TangentMode: ERichCurveTangentMode;
	TangentWeightMode: ERichCurveTangentWeightMode;
	Time: number;
	Value: number;
	ArriveTangent: number;
	ArriveTangentWeight: number;
	LeaveTangent: number;
	LeaveTangentWeight: number;
	clone() : RichCurveKey;
	static C(Other: UObject | any): RichCurveKey;
}

declare class RichCurve extends RealCurve { 
	Keys: RichCurveKey[];
	clone() : RichCurve;
	static C(Other: UObject | any): RichCurve;
}

declare class CurveLinearColor extends CurveBase { 
	FloatCurves: RichCurve;
	AdjustHue: number;
	AdjustSaturation: number;
	AdjustBrightness: number;
	AdjustBrightnessCurve: number;
	AdjustVibrance: number;
	AdjustMinAlpha: number;
	AdjustMaxAlpha: number;
	static Load(ResourceName: string): CurveLinearColor;
	static Find(Outer: UObject, ResourceName: string): CurveLinearColor;
	static GetDefaultObject(): CurveLinearColor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveLinearColor;
	GetUnadjustedLinearColorValue(InTime: number): LinearColor;
	GetLinearColorValue(InTime: number): LinearColor;
	GetClampedLinearColorValue(InTime: number): LinearColor;
	static C(Other: UObject | any): CurveLinearColor;
}

declare class CurveAtlasColorAdjustments { 
	bChromaKeyTexture: boolean;
	AdjustBrightness: number;
	AdjustBrightnessCurve: number;
	AdjustVibrance: number;
	AdjustSaturation: number;
	AdjustRGBCurve: number;
	AdjustHue: number;
	AdjustMinAlpha: number;
	AdjustMaxAlpha: number;
	clone() : CurveAtlasColorAdjustments;
	static C(Other: UObject | any): CurveAtlasColorAdjustments;
}

declare class CurveLinearColorAtlas extends Texture2D { 
	bIsDirty: boolean;
	TextureSize: any;
	bSquareResolution: boolean;
	TextureHeight: any;
	GradientCurves: CurveLinearColor[];
	bDisableAllAdjustments: boolean;
	bHasCachedColorAdjustments: boolean;
	CachedColorAdjustments: CurveAtlasColorAdjustments;
	static Load(ResourceName: string): CurveLinearColorAtlas;
	static Find(Outer: UObject, ResourceName: string): CurveLinearColorAtlas;
	static GetDefaultObject(): CurveLinearColorAtlas;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveLinearColorAtlas;
	GetCurvePosition(InCurve: CurveLinearColor,position?: number): {position: number, $: boolean};
	static C(Other: UObject | any): CurveLinearColorAtlas;
}

declare class ScalarParameterAtlasInstanceData { 
	bIsUsedAsAtlasPosition: boolean;
	Curve: CurveLinearColor;
	Atlas: CurveLinearColorAtlas;
	clone() : ScalarParameterAtlasInstanceData;
	static C(Other: UObject | any): ScalarParameterAtlasInstanceData;
}

declare class ScalarParameterValue { 
	ParameterName: string;
	AtlasData: ScalarParameterAtlasInstanceData;
	ParameterInfo: MaterialParameterInfo;
	ParameterValue: number;
	ExpressionGUID: Guid;
	clone() : ScalarParameterValue;
	static C(Other: UObject | any): ScalarParameterValue;
}

declare class VectorParameterValue { 
	ParameterName: string;
	ParameterInfo: MaterialParameterInfo;
	ParameterValue: LinearColor;
	ExpressionGUID: Guid;
	clone() : VectorParameterValue;
	static C(Other: UObject | any): VectorParameterValue;
}

declare class Vector4d { 
	X: any;
	Y: any;
	Z: any;
	W: any;
	clone() : Vector4d;
	static C(Other: UObject | any): Vector4d;
}

declare class DoubleVectorParameterValue { 
	ParameterInfo: MaterialParameterInfo;
	ParameterValue: Vector4d;
	ExpressionGUID: Guid;
	clone() : DoubleVectorParameterValue;
	static C(Other: UObject | any): DoubleVectorParameterValue;
}

declare class TextureParameterValue { 
	ParameterName: string;
	ParameterInfo: MaterialParameterInfo;
	ParameterValue: Texture;
	ExpressionGUID: Guid;
	clone() : TextureParameterValue;
	static C(Other: UObject | any): TextureParameterValue;
}

declare type ERuntimeVirtualTextureMaterialType = 'BaseColor' | 'BaseColor_Normal_DEPRECATED' | 'BaseColor_Normal_Roughness' | 'BaseColor_Normal_Specular' | 'BaseColor_Normal_Specular_YCoCg' | 'BaseColor_Normal_Specular_Mask_YCoCg' | 'WorldHeight' | 'Count' | 'ERuntimeVirtualTextureMaterialType_MAX';
declare var ERuntimeVirtualTextureMaterialType : { BaseColor:'BaseColor',BaseColor_Normal_DEPRECATED:'BaseColor_Normal_DEPRECATED',BaseColor_Normal_Roughness:'BaseColor_Normal_Roughness',BaseColor_Normal_Specular:'BaseColor_Normal_Specular',BaseColor_Normal_Specular_YCoCg:'BaseColor_Normal_Specular_YCoCg',BaseColor_Normal_Specular_Mask_YCoCg:'BaseColor_Normal_Specular_Mask_YCoCg',WorldHeight:'WorldHeight',Count:'Count',ERuntimeVirtualTextureMaterialType_MAX:'ERuntimeVirtualTextureMaterialType_MAX', };
declare class RuntimeVirtualTextureStreamingProxy extends Texture2D { 
	static Load(ResourceName: string): RuntimeVirtualTextureStreamingProxy;
	static Find(Outer: UObject, ResourceName: string): RuntimeVirtualTextureStreamingProxy;
	static GetDefaultObject(): RuntimeVirtualTextureStreamingProxy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeVirtualTextureStreamingProxy;
	static C(Other: UObject | any): RuntimeVirtualTextureStreamingProxy;
}

declare class RuntimeVirtualTexture extends UObject { 
	TileCount: number;
	TileSize: number;
	TileBorderSize: number;
	MaterialType: ERuntimeVirtualTextureMaterialType;
	bCompressTextures: boolean;
	bUseLowQualityCompression: boolean;
	bClearTextures: boolean;
	bSinglePhysicalSpace: boolean;
	bPrivateSpace: boolean;
	bAdaptive: boolean;
	bContinuousUpdate: boolean;
	RemoveLowMips: number;
	LODGroup: TextureGroup;
	Size: number;
	StreamingTexture: RuntimeVirtualTextureStreamingProxy;
	static Load(ResourceName: string): RuntimeVirtualTexture;
	static Find(Outer: UObject, ResourceName: string): RuntimeVirtualTexture;
	static GetDefaultObject(): RuntimeVirtualTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RuntimeVirtualTexture;
	GetTileSize(): number;
	GetTileCount(): number;
	GetTileBorderSize(): number;
	GetSize(): number;
	GetPageTableSize(): number;
	static C(Other: UObject | any): RuntimeVirtualTexture;
}

declare class RuntimeVirtualTextureParameterValue { 
	ParameterInfo: MaterialParameterInfo;
	ParameterValue: RuntimeVirtualTexture;
	ExpressionGUID: Guid;
	clone() : RuntimeVirtualTextureParameterValue;
	static C(Other: UObject | any): RuntimeVirtualTextureParameterValue;
}

declare type EFontCacheType = 'Offline' | 'Runtime' | 'EFontCacheType_MAX';
declare var EFontCacheType : { Offline:'Offline',Runtime:'Runtime',EFontCacheType_MAX:'EFontCacheType_MAX', };
declare class FontCharacter { 
	StartU: number;
	StartV: number;
	USize: number;
	VSize: number;
	TextureIndex: number;
	VerticalOffset: number;
	clone() : FontCharacter;
	static C(Other: UObject | any): FontCharacter;
}

declare type EFontImportCharacterSet = 'FontICS_Default' | 'FontICS_Ansi' | 'FontICS_Symbol' | 'FontICS_MAX';
declare var EFontImportCharacterSet : { FontICS_Default:'FontICS_Default',FontICS_Ansi:'FontICS_Ansi',FontICS_Symbol:'FontICS_Symbol',FontICS_MAX:'FontICS_MAX', };
declare class FontImportOptionsData { 
	FontName: string;
	Height: number;
	bEnableAntialiasing: boolean;
	bEnableBold: boolean;
	bEnableItalic: boolean;
	bEnableUnderline: boolean;
	bAlphaOnly: boolean;
	CharacterSet: EFontImportCharacterSet;
	Chars: string;
	UnicodeRange: string;
	CharsFilePath: string;
	CharsFileWildcard: string;
	bCreatePrintableOnly: boolean;
	bIncludeASCIIRange: boolean;
	ForegroundColor: LinearColor;
	bEnableDropShadow: boolean;
	TexturePageWidth: number;
	TexturePageMaxHeight: number;
	XPadding: number;
	YPadding: number;
	ExtendBoxTop: number;
	ExtendBoxBottom: number;
	ExtendBoxRight: number;
	ExtendBoxLeft: number;
	bEnableLegacyMode: boolean;
	Kerning: number;
	bUseDistanceFieldAlpha: boolean;
	DistanceFieldScaleFactor: number;
	DistanceFieldScanRadiusScale: number;
	clone() : FontImportOptionsData;
	static C(Other: UObject | any): FontImportOptionsData;
}

declare type EFontHinting = 'Default' | 'Auto' | 'AutoLight' | 'Monochrome' | 'None' | 'EFontHinting_MAX';
declare var EFontHinting : { Default:'Default',Auto:'Auto',AutoLight:'AutoLight',Monochrome:'Monochrome',None:'None',EFontHinting_MAX:'EFontHinting_MAX', };
declare type EFontLoadingPolicy = 'LazyLoad' | 'Stream' | 'Inline' | 'EFontLoadingPolicy_MAX';
declare var EFontLoadingPolicy : { LazyLoad:'LazyLoad',Stream:'Stream',Inline:'Inline',EFontLoadingPolicy_MAX:'EFontLoadingPolicy_MAX', };
declare class FontBulkData extends UObject { 
	static Load(ResourceName: string): FontBulkData;
	static Find(Outer: UObject, ResourceName: string): FontBulkData;
	static GetDefaultObject(): FontBulkData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontBulkData;
	static C(Other: UObject | any): FontBulkData;
}

declare class FontData { 
	FontFilename: string;
	Hinting: EFontHinting;
	LoadingPolicy: EFontLoadingPolicy;
	SubFaceIndex: number;
	FontFaceAsset: UObject;
	BulkDataPtr: FontBulkData;
	FontData: number[];
	clone() : FontData;
	static C(Other: UObject | any): FontData;
}

declare class TypefaceEntry { 
	Name: string;
	Font: FontData;
	clone() : TypefaceEntry;
	static C(Other: UObject | any): TypefaceEntry;
}

declare class Typeface { 
	Fonts: TypefaceEntry[];
	clone() : Typeface;
	static C(Other: UObject | any): Typeface;
}

declare class CompositeFallbackFont { 
	Typeface: Typeface;
	ScalingFactor: number;
	clone() : CompositeFallbackFont;
	static C(Other: UObject | any): CompositeFallbackFont;
}

declare type ERangeBoundTypes = 'Exclusive' | 'Inclusive' | 'Open' | 'ERangeBoundTypes_MAX';
declare var ERangeBoundTypes : { Exclusive:'Exclusive',Inclusive:'Inclusive',Open:'Open',ERangeBoundTypes_MAX:'ERangeBoundTypes_MAX', };
declare class Int32RangeBound { 
	Type: ERangeBoundTypes;
	Value: number;
	clone() : Int32RangeBound;
	static C(Other: UObject | any): Int32RangeBound;
}

declare class Int32Range { 
	LowerBound: Int32RangeBound;
	UpperBound: Int32RangeBound;
	clone() : Int32Range;
	static C(Other: UObject | any): Int32Range;
}

declare class CompositeSubFont extends CompositeFallbackFont { 
	CharacterRanges: Int32Range[];
	Cultures: string;
	EditorName: string;
	clone() : CompositeSubFont;
	static C(Other: UObject | any): CompositeSubFont;
}

declare class CompositeFont { 
	DefaultTypeface: Typeface;
	FallbackTypeface: CompositeFallbackFont;
	SubTypefaces: CompositeSubFont[];
	clone() : CompositeFont;
	static C(Other: UObject | any): CompositeFont;
}

declare class Font extends UObject { 
	FontCacheType: EFontCacheType;
	Characters: FontCharacter[];
	Textures: Texture2D[];
	IsRemapped: number;
	EmScale: number;
	Ascent: number;
	Descent: number;
	Leading: number;
	Kerning: number;
	ImportOptions: FontImportOptionsData;
	NumCharacters: number;
	MaxCharHeight: number[];
	ScalingFactor: number;
	LegacyFontSize: number;
	LegacyFontName: string;
	CompositeFont: CompositeFont;
	static Load(ResourceName: string): Font;
	static Find(Outer: UObject, ResourceName: string): Font;
	static GetDefaultObject(): Font;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Font;
	static C(Other: UObject | any): Font;
}

declare class FontParameterValue { 
	ParameterName: string;
	ParameterInfo: MaterialParameterInfo;
	FontValue: Font;
	FontPage: number;
	ExpressionGUID: Guid;
	clone() : FontParameterValue;
	static C(Other: UObject | any): FontParameterValue;
}

declare class MaterialInstanceBasePropertyOverrides { 
	bOverride_OpacityMaskClipValue: boolean;
	bOverride_BlendMode: boolean;
	bOverride_ShadingModel: boolean;
	bOverride_DitheredLODTransition: boolean;
	bOverride_CastDynamicShadowAsMasked: boolean;
	bOverride_TwoSided: boolean;
	bOverride_OutputTranslucentVelocity: boolean;
	TwoSided: boolean;
	DitheredLODTransition: boolean;
	bCastDynamicShadowAsMasked: boolean;
	bOutputTranslucentVelocity: boolean;
	BlendMode: EBlendMode;
	ShadingModel: EMaterialShadingModel;
	OpacityMaskClipValue: number;
	clone() : MaterialInstanceBasePropertyOverrides;
	static C(Other: UObject | any): MaterialInstanceBasePropertyOverrides;
}

declare class StaticParameterBase { 
	ParameterInfo: MaterialParameterInfo;
	bOverride: boolean;
	ExpressionGUID: Guid;
	clone() : StaticParameterBase;
	static C(Other: UObject | any): StaticParameterBase;
}

declare class StaticSwitchParameter extends StaticParameterBase { 
	Value: boolean;
	clone() : StaticSwitchParameter;
	static C(Other: UObject | any): StaticSwitchParameter;
}

declare class StaticComponentMaskParameter extends StaticParameterBase { 
	R: boolean;
	G: boolean;
	B: boolean;
	A: boolean;
	clone() : StaticComponentMaskParameter;
	static C(Other: UObject | any): StaticComponentMaskParameter;
}

declare class StaticTerrainLayerWeightParameter { 
	ParameterInfo: MaterialParameterInfo;
	ExpressionGUID: Guid;
	bOverride: boolean;
	LayerName: string;
	WeightmapIndex: number;
	bWeightBasedBlend: boolean;
	clone() : StaticTerrainLayerWeightParameter;
	static C(Other: UObject | any): StaticTerrainLayerWeightParameter;
}

declare type EMaterialLayerLinkState = 'Uninitialized' | 'LinkedToParent' | 'UnlinkedFromParent' | 'NotFromParent' | 'EMaterialLayerLinkState_MAX';
declare var EMaterialLayerLinkState : { Uninitialized:'Uninitialized',LinkedToParent:'LinkedToParent',UnlinkedFromParent:'UnlinkedFromParent',NotFromParent:'NotFromParent',EMaterialLayerLinkState_MAX:'EMaterialLayerLinkState_MAX', };
declare class MaterialLayersFunctions { 
	Layers: MaterialFunctionInterface[];
	Blends: MaterialFunctionInterface[];
	LayerStates: boolean[];
	LayerNames: string[];
	RestrictToLayerRelatives: boolean[];
	RestrictToBlendRelatives: boolean[];
	LayerGuids: Guid[];
	LayerLinkStates: EMaterialLayerLinkState[];
	DeletedParentLayerGuids: Guid[];
	clone() : MaterialLayersFunctions;
	static C(Other: UObject | any): MaterialLayersFunctions;
}

declare class StaticMaterialLayersParameter extends StaticParameterBase { 
	Value: MaterialLayersFunctions;
	clone() : StaticMaterialLayersParameter;
	static C(Other: UObject | any): StaticMaterialLayersParameter;
}

declare class StaticParameterSet { 
	StaticSwitchParameters: StaticSwitchParameter[];
	StaticComponentMaskParameters: StaticComponentMaskParameter[];
	TerrainLayerWeightParameters: StaticTerrainLayerWeightParameter[];
	MaterialLayers: MaterialLayersFunctions;
	bHasMaterialLayers: boolean;
	MaterialLayersParameters: StaticMaterialLayersParameter[];
	clone() : StaticParameterSet;
	static C(Other: UObject | any): StaticParameterSet;
}

declare class MaterialInstance extends MaterialInterface { 
	PhysMaterial: PhysicalMaterial;
	PhysicalMaterialMap: PhysicalMaterial;
	Parent: MaterialInterface;
	bHasStaticPermutationResource: boolean;
	bOverrideSubsurfaceProfile: boolean;
	ScalarParameterValues: ScalarParameterValue[];
	VectorParameterValues: VectorParameterValue[];
	DoubleVectorParameterValues: DoubleVectorParameterValue[];
	TextureParameterValues: TextureParameterValue[];
	RuntimeVirtualTextureParameterValues: RuntimeVirtualTextureParameterValue[];
	FontParameterValues: FontParameterValue[];
	bOverrideBaseProperties: boolean;
	BasePropertyOverrides: MaterialInstanceBasePropertyOverrides;
	ReferencedTextureGuids: Guid[];
	StaticParameters: StaticParameterSet;
	bSavedCachedData: boolean;
	static Load(ResourceName: string): MaterialInstance;
	static Find(Outer: UObject, ResourceName: string): MaterialInstance;
	static GetDefaultObject(): MaterialInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstance;
	static C(Other: UObject | any): MaterialInstance;
}

declare class MaterialInstanceConstant extends MaterialInstance { 
	ParameterStateId: Guid;
	PhysMaterialMask: PhysicalMaterialMask;
	static Load(ResourceName: string): MaterialInstanceConstant;
	static Find(Outer: UObject, ResourceName: string): MaterialInstanceConstant;
	static GetDefaultObject(): MaterialInstanceConstant;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceConstant;
	K2_GetVectorParameterValue(ParameterName: string): LinearColor;
	K2_GetTextureParameterValue(ParameterName: string): Texture;
	K2_GetScalarParameterValue(ParameterName: string): number;
	static C(Other: UObject | any): MaterialInstanceConstant;
	SetMICBlendMode_EditorOnly(BlendMode: EBlendMode): boolean;
	SetMICDitheredLODTransition_EditorOnly(DitheredLODTransition: boolean): boolean;
	SetMICScalarParam_EditorOnly(ParamName: string,Value: number): boolean;
	SetMICShadingModel_EditorOnly(ShadingModel: EMaterialShadingModel): boolean;
	SetMICTextureParam_EditorOnly(ParamName: string,Texture: Texture2D): boolean;
	SetMICTwoSided_EditorOnly(TwoSided: boolean): boolean;
	SetMICVectorParam_EditorOnly(ParamName: string,Value: LinearColor): boolean;
	UpdateMIC(): void;
	ClearAllMaterialInstanceParameters(): void;
	GetMaterialInstanceRuntimeVirtualTextureParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	GetMaterialInstanceScalarParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): number;
	GetMaterialInstanceStaticSwitchParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	GetMaterialInstanceTextureParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	GetMaterialInstanceVectorParameterValue(ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	SetMaterialInstanceParent(NewParent: MaterialInterface): void;
	SetMaterialInstanceRuntimeVirtualTextureParameterValue(ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceScalarParameterValue(ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceStaticSwitchParameterValue(ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceTextureParameterValue(ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	SetMaterialInstanceVectorParameterValue(ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	UpdateMaterialInstance(): void;
	static SetMICBlendMode_EditorOnly(Material: MaterialInstanceConstant,BlendMode: EBlendMode): boolean;
	static SetMICDitheredLODTransition_EditorOnly(Material: MaterialInstanceConstant,DitheredLODTransition: boolean): boolean;
	static SetMICScalarParam_EditorOnly(Material: MaterialInstanceConstant,ParamName: string,Value: number): boolean;
	static SetMICShadingModel_EditorOnly(Material: MaterialInstanceConstant,ShadingModel: EMaterialShadingModel): boolean;
	static SetMICTextureParam_EditorOnly(Material: MaterialInstanceConstant,ParamName: string,Texture: Texture2D): boolean;
	static SetMICTwoSided_EditorOnly(Material: MaterialInstanceConstant,TwoSided: boolean): boolean;
	static SetMICVectorParam_EditorOnly(Material: MaterialInstanceConstant,ParamName: string,Value: LinearColor): boolean;
	static UpdateMIC(MIC: MaterialInstanceConstant): void;
	static ClearAllMaterialInstanceParameters(Instance: MaterialInstanceConstant): void;
	static GetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): RuntimeVirtualTexture;
	static GetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): number;
	static GetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): boolean;
	static GetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): Texture;
	static GetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Association: EMaterialParameterAssociation): LinearColor;
	static SetMaterialInstanceParent(Instance: MaterialInstanceConstant,NewParent: MaterialInterface): void;
	static SetMaterialInstanceRuntimeVirtualTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: RuntimeVirtualTexture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: number,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: boolean,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: Texture,Association: EMaterialParameterAssociation): boolean;
	static SetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant,ParameterName: string,Value: LinearColor,Association: EMaterialParameterAssociation): boolean;
	static UpdateMaterialInstance(Instance: MaterialInstanceConstant): void;
}

declare class MaterialInstanceDynamic extends MaterialInstance { 
	static Load(ResourceName: string): MaterialInstanceDynamic;
	static Find(Outer: UObject, ResourceName: string): MaterialInstanceDynamic;
	static GetDefaultObject(): MaterialInstanceDynamic;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceDynamic;
	SetVectorParameterValueByInfo(ParameterInfo: MaterialParameterInfo,Value: LinearColor): void;
	SetVectorParameterValue(ParameterName: string,Value: LinearColor): void;
	SetTextureParameterValueByInfo(ParameterInfo: MaterialParameterInfo,Value: Texture): void;
	SetTextureParameterValue(ParameterName: string,Value: Texture): void;
	SetScalarParameterValueByInfo(ParameterInfo: MaterialParameterInfo,Value: number): void;
	SetScalarParameterValue(ParameterName: string,Value: number): void;
	SetRuntimeVirtualTextureParameterValueByInfo(ParameterInfo: MaterialParameterInfo,Value: RuntimeVirtualTexture): void;
	SetRuntimeVirtualTextureParameterValue(ParameterName: string,Value: RuntimeVirtualTexture): void;
	SetDoubleVectorParameterValue(ParameterName: string,Value: Vector): void;
	K2_InterpolateMaterialInstanceParams(SourceA: MaterialInstance,SourceB: MaterialInstance,Alpha: number): void;
	K2_GetVectorParameterValueByInfo(ParameterInfo: MaterialParameterInfo): LinearColor;
	K2_GetVectorParameterValue(ParameterName: string): LinearColor;
	K2_GetTextureParameterValueByInfo(ParameterInfo: MaterialParameterInfo): Texture;
	K2_GetTextureParameterValue(ParameterName: string): Texture;
	K2_GetScalarParameterValueByInfo(ParameterInfo: MaterialParameterInfo): number;
	K2_GetScalarParameterValue(ParameterName: string): number;
	K2_CopyMaterialInstanceParameters(Source: MaterialInterface,bQuickParametersOnly: boolean): void;
	CopyParameterOverrides(MaterialInstance: MaterialInstance): void;
	CopyInterpParameters(Source: MaterialInstance): void;
	static C(Other: UObject | any): MaterialInstanceDynamic;
}

declare type ESubstanceInputType = 'SIT_Float' | 'SIT_Float2' | 'SIT_Float3' | 'SIT_Float4' | 'SIT_Integer' | 'SIT_Image' | 'SIT_Unused_6' | 'SIT_Unused_7' | 'SIT_Integer2' | 'SIT_Integer3' | 'SIT_Integer4' | 'SIT_MAX';
declare var ESubstanceInputType : { SIT_Float:'SIT_Float',SIT_Float2:'SIT_Float2',SIT_Float3:'SIT_Float3',SIT_Float4:'SIT_Float4',SIT_Integer:'SIT_Integer',SIT_Image:'SIT_Image',SIT_Unused_6:'SIT_Unused_6',SIT_Unused_7:'SIT_Unused_7',SIT_Integer2:'SIT_Integer2',SIT_Integer3:'SIT_Integer3',SIT_Integer4:'SIT_Integer4',SIT_MAX:'SIT_MAX', };
declare class SubstanceInputDesc { 
	Name: string;
	Type: ESubstanceInputType;
	clone() : SubstanceInputDesc;
	static C(Other: UObject | any): SubstanceInputDesc;
}

declare class SubstanceIntInputDesc extends SubstanceInputDesc { 
	Min: number[];
	Max: number[];
	Default: number[];
	clone() : SubstanceIntInputDesc;
	static C(Other: UObject | any): SubstanceIntInputDesc;
}

declare class SubstanceInstanceDesc { 
	Name: string;
	Inputs: SubstanceInputDesc[];
	clone() : SubstanceInstanceDesc;
	static C(Other: UObject | any): SubstanceInstanceDesc;
}

declare class SubstanceFloatInputDesc extends SubstanceInputDesc { 
	Min: number[];
	Max: number[];
	Default: number[];
	clone() : SubstanceFloatInputDesc;
	static C(Other: UObject | any): SubstanceFloatInputDesc;
}

declare type ESubstanceTextureSize = 'ERL_16' | 'ERL_32' | 'ERL_64' | 'ERL_128' | 'ERL_256' | 'ERL_512' | 'ERL_1024' | 'ERL_2048' | 'ERL_4096' | 'ERL_8192' | 'ERL_MAX';
declare var ESubstanceTextureSize : { ERL_16:'ERL_16',ERL_32:'ERL_32',ERL_64:'ERL_64',ERL_128:'ERL_128',ERL_256:'ERL_256',ERL_512:'ERL_512',ERL_1024:'ERL_1024',ERL_2048:'ERL_2048',ERL_4096:'ERL_4096',ERL_8192:'ERL_8192',ERL_MAX:'ERL_MAX', };
declare class SubstanceGraphInstance extends UObject { 
	PackageURL: string;
	ParentFactory: SubstanceInstanceFactory;
	ImageSources: any;
	CreatedMaterial: Material;
	ConstantCreatedMaterial: MaterialInstanceConstant;
	DynamicCreatedMaterial: MaterialInstanceDynamic;
	OutputTextureLinkData: any;
	OutputInstances: any;
	bIsFrozen: boolean;
	static Load(ResourceName: string): SubstanceGraphInstance;
	static Find(Outer: UObject, ResourceName: string): SubstanceGraphInstance;
	static GetDefaultObject(): SubstanceGraphInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubstanceGraphInstance;
	SetInputString(Identifier: string,Value: string): void;
	SetInputInt(Identifier: string,InputValues: number[]): void;
	SetInputImg(InputName: string,Value: UObject): boolean;
	SetInputFloat(Identifier: string,InputValues: number[]): void;
	SetInputColor(Identifier: string,Color: LinearColor): void;
	SetInputBool(Identifier: string,bool: boolean): void;
	SaveAllOutputs(ForceSave: boolean): void;
	RenderSync(): void;
	PrepareOutputsForSave(): void;
	GetOutputNames(): string[];
	GetIntInputDesc(Identifier: string): SubstanceIntInputDesc;
	GetInstanceDesc(): SubstanceInstanceDesc;
	GetInputType(InputName: string): ESubstanceInputType;
	GetInputString(Identifier: string): string;
	GetInputNames(): string[];
	GetInputInt(Identifier: string): number[];
	GetInputFloat(Identifier: string): number[];
	GetInputColor(Identifier: string): LinearColor;
	GetInputBool(Identifier: string): boolean;
	GetFloatInputDesc(Identifier: string): SubstanceFloatInputDesc;
	GetDynamicMaterialInstance(Name: string,InParentMaterial: Material): MaterialInstanceDynamic;
	GetConstantMaterial(): MaterialInstanceConstant;
	EnableOutput(Identifier: string,Value: boolean): void;
	Duplicate(): SubstanceGraphInstance;
	CreateOutputs(): void;
	CreateMaterial(PackageName: string,ParentMaterial: Material): void;
	static C(Other: UObject | any): SubstanceGraphInstance;
	AsyncRendering(): void;
	CopyInputParameters(DestGraphInstance: SubstanceGraphInstance): void;
	GetFactoryName(): string;
	GetGraphName(): string;
	GetSubstanceTextures(): Texture2D[];
	ResetInputParameters(): void;
	SetGraphInstanceOutputSize(Width: ESubstanceTextureSize,Height: ESubstanceTextureSize): void;
	SetGraphInstanceOutputSizeInt(Width: number,Height: number): void;
	SyncRendering(): void;
	static AsyncRendering(InstancesToRender: SubstanceGraphInstance): void;
	static CopyInputParameters(SourceGraphInstance: SubstanceGraphInstance,DestGraphInstance: SubstanceGraphInstance): void;
	static GetFactoryName(GraphInstance: SubstanceGraphInstance): string;
	static GetGraphName(GraphInstance: SubstanceGraphInstance): string;
	static GetSubstanceTextures(GraphInstance: SubstanceGraphInstance): Texture2D[];
	static ResetInputParameters(GraphInstance: SubstanceGraphInstance): void;
	static SetGraphInstanceOutputSize(GraphInstance: SubstanceGraphInstance,Width: ESubstanceTextureSize,Height: ESubstanceTextureSize): void;
	static SetGraphInstanceOutputSizeInt(GraphInstance: SubstanceGraphInstance,Width: number,Height: number): void;
	static SyncRendering(InstancesToRender: SubstanceGraphInstance): void;
}

declare type EAttachLocation = 'KeepRelativeOffset' | 'KeepWorldPosition' | 'SnapToTarget' | 'SnapToTargetIncludingScale' | 'EAttachLocation_MAX';
declare var EAttachLocation : { KeepRelativeOffset:'KeepRelativeOffset',KeepWorldPosition:'KeepWorldPosition',SnapToTarget:'SnapToTarget',SnapToTargetIncludingScale:'SnapToTargetIncludingScale',EAttachLocation_MAX:'EAttachLocation_MAX', };
declare class DecalComponent extends SceneComponent { 
	DecalMaterial: MaterialInterface;
	SortOrder: number;
	FadeScreenSize: number;
	FadeStartDelay: number;
	FadeDuration: number;
	FadeInDuration: number;
	FadeInStartDelay: number;
	bDestroyOwnerAfterFade: boolean;
	DecalSize: Vector;
	static Load(ResourceName: string): DecalComponent;
	static Find(Outer: UObject, ResourceName: string): DecalComponent;
	static GetDefaultObject(): DecalComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DecalComponent;
	SetSortOrder(Value: number): void;
	SetFadeScreenSize(NewFadeScreenSize: number): void;
	SetFadeOut(StartDelay: number,Duration: number,DestroyOwnerAfterFade: boolean): void;
	SetFadeIn(StartDelay: number,Duaration: number): void;
	SetDecalMaterial(NewDecalMaterial: MaterialInterface): void;
	GetFadeStartDelay(): number;
	GetFadeInStartDelay(): number;
	GetFadeInDuration(): number;
	GetFadeDuration(): number;
	GetDecalMaterial(): MaterialInterface;
	CreateDynamicMaterialInstance(): MaterialInstanceDynamic;
	static C(Other: UObject | any): DecalComponent;
}

declare class AssetData { 
	ObjectPath: string;
	PackageName: string;
	PackagePath: string;
	AssetName: string;
	AssetClass: string;
	clone() : AssetData;
	static C(Other: UObject | any): AssetData;
	static FindAssetData(AssetPath: string): AssetData;
}

declare class MaterialStatistics { 
	NumVertexShaderInstructions: number;
	NumPixelShaderInstructions: number;
	NumSamplers: number;
	NumVertexTextureSamples: number;
	NumPixelTextureSamples: number;
	NumVirtualTextureSamples: number;
	NumUVScalars: number;
	NumInterpolatorScalars: number;
	clone() : MaterialStatistics;
	static C(Other: UObject | any): MaterialStatistics;
}

declare class MaterialInterface extends UObject { 
	SubsurfaceProfile: SubsurfaceProfile;
	LightmassSettings: LightmassMaterialInterfaceSettings;
	bTextureStreamingDataSorted: boolean;
	TextureStreamingDataVersion: number;
	TextureStreamingData: MaterialTextureInfo[];
	AssetUserData: AssetUserData[];
	TextureStreamingDataMissingEntries: MaterialTextureInfo[];
	PreviewMesh: SoftObjectPath;
	ThumbnailInfo: ThumbnailInfo;
	LayerParameterExpansion: any;
	ParameterOverviewExpansion: any;
	AssetImportData: AssetImportData;
	LightingGuid: Guid;
	static Load(ResourceName: string): MaterialInterface;
	static Find(Outer: UObject, ResourceName: string): MaterialInterface;
	static GetDefaultObject(): MaterialInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInterface;
	SetForceMipLevelsToBeResident(OverrideForceMiplevelsToBeResident: boolean,bForceMiplevelsToBeResidentValue: boolean,ForceDuration: number,CinematicTextureGroups: number,bFastResponse: boolean): void;
	GetPhysicalMaterialMask(): PhysicalMaterialMask;
	GetPhysicalMaterialFromMap(index: number): PhysicalMaterial;
	GetPhysicalMaterial(): PhysicalMaterial;
	GetParameterInfo(Association: EMaterialParameterAssociation,ParameterName: string,LayerFunction: MaterialFunctionInterface): MaterialParameterInfo;
	GetBaseMaterial(): Material;
	static C(Other: UObject | any): MaterialInterface;
	GetSubstances(): SubstanceGraphInstance[];
	CreateMIC_EditorOnly(Name: string): MaterialInstanceConstant;
	SpawnDecalAttached(DecalSize: Vector,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,LifeSpan: number): DecalComponent;
	MakeBrushFromMaterial(Width: number,Height: number): SlateBrush;
	GetChildInstances(ChildInstances?: AssetData[]): {ChildInstances: AssetData[]};
	GetScalarParameterNames(ParameterNames?: string[]): {ParameterNames: string[]};
	GetScalarParameterSource(ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	GetStaticSwitchParameterNames(ParameterNames?: string[]): {ParameterNames: string[]};
	GetStaticSwitchParameterSource(ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	GetStatistics(): MaterialStatistics;
	GetTextureParameterNames(ParameterNames?: string[]): {ParameterNames: string[]};
	GetTextureParameterSource(ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	GetVectorParameterNames(ParameterNames?: string[]): {ParameterNames: string[]};
	GetVectorParameterSource(ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetSubstances(Material: MaterialInterface): SubstanceGraphInstance[];
	static CreateMIC_EditorOnly(Material: MaterialInterface,Name: string): MaterialInstanceConstant;
	static SpawnDecalAttached(DecalMaterial: MaterialInterface,DecalSize: Vector,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,LifeSpan: number): DecalComponent;
	static MakeBrushFromMaterial(Material: MaterialInterface,Width: number,Height: number): SlateBrush;
	static GetChildInstances(Parent: MaterialInterface,ChildInstances?: AssetData[]): {ChildInstances: AssetData[]};
	static GetScalarParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetScalarParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetStaticSwitchParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetStaticSwitchParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetStatistics(Material: MaterialInterface): MaterialStatistics;
	static GetTextureParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetTextureParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
	static GetVectorParameterNames(Material: MaterialInterface,ParameterNames?: string[]): {ParameterNames: string[]};
	static GetVectorParameterSource(Material: MaterialInterface,ParameterName: string,ParameterSource?: SoftObjectPath): {ParameterSource: SoftObjectPath, $: boolean};
}

declare class SlateBrush { 
	ImageSize: Vector2D;
	Margin: Margin;
	Tint: LinearColor;
	TintColor: SlateColor;
	OutlineSettings: SlateBrushOutlineSettings;
	ResourceObject: UObject;
	ResourceName: string;
	UVRegion: Box2f;
	DrawAs: ESlateBrushDrawType;
	Tiling: ESlateBrushTileType;
	Mirroring: ESlateBrushMirrorType;
	ImageType: ESlateBrushImageType;
	bIsDynamicallyLoaded: boolean;
	bHasUObject: boolean;
	clone() : SlateBrush;
	static C(Other: UObject | any): SlateBrush;
	GetBrushResource(): UObject;
	GetBrushResourceAsMaterial(): MaterialInterface;
	GetBrushResourceAsTexture2D(): Texture2D;
	GetDynamicMaterial(): {Brush: SlateBrush, $: MaterialInstanceDynamic};
	SetBrushResourceToMaterial(Material?: MaterialInterface): {Brush: SlateBrush};
	SetBrushResourceToTexture(Texture?: Texture2D): {Brush: SlateBrush};
	EqualEqual_SlateBrush(B: SlateBrush): boolean;
	static GetBrushResource(Brush: SlateBrush): UObject;
	static GetBrushResourceAsMaterial(Brush: SlateBrush): MaterialInterface;
	static GetBrushResourceAsTexture2D(Brush: SlateBrush): Texture2D;
	static GetDynamicMaterial(Brush?: SlateBrush): {Brush: SlateBrush, $: MaterialInstanceDynamic};
	static SetBrushResourceToMaterial(Brush?: SlateBrush,Material?: MaterialInterface): {Brush: SlateBrush};
	static SetBrushResourceToTexture(Brush?: SlateBrush,Texture?: Texture2D): {Brush: SlateBrush};
	static EqualEqual_SlateBrush(A: SlateBrush,B: SlateBrush): boolean;
	static NoResourceBrush(): SlateBrush;
}

declare class Texture2D extends Texture { 
	FirstResourceMemMip: number;
	bTemporarilyDisableStreaming: boolean;
	bHasBeenPaintedInEditor: boolean;
	AddressX: TextureAddress;
	AddressY: TextureAddress;
	ImportedSize: IntPoint;
	static Load(ResourceName: string): Texture2D;
	static Find(Outer: UObject, ResourceName: string): Texture2D;
	static GetDefaultObject(): Texture2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture2D;
	Blueprint_GetSizeY(): number;
	Blueprint_GetSizeX(): number;
	static C(Other: UObject | any): Texture2D;
	Texture2D_SampleUV_EditorOnly(UV: Vector2D): LinearColor;
	MakeImportanceTexture(WeightingFunc: EImportanceWeight): ImportanceTexture;
	MakeBrushFromTexture(Width: number,Height: number): SlateBrush;
	static Texture2D_SampleUV_EditorOnly(Texture: Texture2D,UV: Vector2D): LinearColor;
	static MakeImportanceTexture(Texture: Texture2D,WeightingFunc: EImportanceWeight): ImportanceTexture;
	static MakeBrushFromTexture(Texture: Texture2D,Width: number,Height: number): SlateBrush;
}

declare class SpriteCategoryInfo { 
	Category: string;
	DisplayName: string;
	Description: string;
	clone() : SpriteCategoryInfo;
	static C(Other: UObject | any): SpriteCategoryInfo;
}

declare class BillboardComponent extends PrimitiveComponent { 
	Sprite: Texture2D;
	bIsScreenSizeScaled: boolean;
	ScreenSize: number;
	U: number;
	UL: number;
	V: number;
	VL: number;
	OpacityMaskRefVal: number;
	SpriteCategoryName: string;
	SpriteInfo: SpriteCategoryInfo;
	bUseInEditorScaling: boolean;
	static Load(ResourceName: string): BillboardComponent;
	static Find(Outer: UObject, ResourceName: string): BillboardComponent;
	static GetDefaultObject(): BillboardComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BillboardComponent;
	SetUV(NewU: number,NewUL: number,NewV: number,NewVL: number): void;
	SetSpriteAndUV(NewSprite: Texture2D,NewU: number,NewUL: number,NewV: number,NewVL: number): void;
	SetSprite(NewSprite: Texture2D): void;
	SetOpacityMaskRefVal(RefVal: number): void;
	static C(Other: UObject | any): BillboardComponent;
}

declare class LayerActorStats { 
	Type: UnrealEngineClass;
	Total: number;
	clone() : LayerActorStats;
	static C(Other: UObject | any): LayerActorStats;
}

declare class Layer extends UObject { 
	LayerName: string;
	bIsVisible: boolean;
	ActorStats: LayerActorStats[];
	static Load(ResourceName: string): Layer;
	static Find(Outer: UObject, ResourceName: string): Layer;
	static GetDefaultObject(): Layer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Layer;
	static C(Other: UObject | any): Layer;
}

declare class Model extends UObject { 
	static Load(ResourceName: string): Model;
	static Find(Outer: UObject, ResourceName: string): Model;
	static GetDefaultObject(): Model;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Model;
	static C(Other: UObject | any): Model;
}

declare type EPhysicsType = 'PhysType_Default' | 'PhysType_Kinematic' | 'PhysType_Simulated' | 'PhysType_MAX';
declare var EPhysicsType : { PhysType_Default:'PhysType_Default',PhysType_Kinematic:'PhysType_Kinematic',PhysType_Simulated:'PhysType_Simulated',PhysType_MAX:'PhysType_MAX', };
declare type ECollisionTraceFlag = 'CTF_UseDefault' | 'CTF_UseSimpleAndComplex' | 'CTF_UseSimpleAsComplex' | 'CTF_UseComplexAsSimple' | 'CTF_MAX';
declare var ECollisionTraceFlag : { CTF_UseDefault:'CTF_UseDefault',CTF_UseSimpleAndComplex:'CTF_UseSimpleAndComplex',CTF_UseSimpleAsComplex:'CTF_UseSimpleAsComplex',CTF_UseComplexAsSimple:'CTF_UseComplexAsSimple',CTF_MAX:'CTF_MAX', };
declare type EBodyCollisionResponse = 'BodyCollision_Enabled' | 'BodyCollision_Disabled' | 'BodyCollision_MAX';
declare var EBodyCollisionResponse : { BodyCollision_Enabled:'BodyCollision_Enabled',BodyCollision_Disabled:'BodyCollision_Disabled',BodyCollision_MAX:'BodyCollision_MAX', };
declare class BodySetupCore extends UObject { 
	BoneName: string;
	PhysicsType: EPhysicsType;
	CollisionTraceFlag: ECollisionTraceFlag;
	CollisionReponse: EBodyCollisionResponse;
	static Load(ResourceName: string): BodySetupCore;
	static Find(Outer: UObject, ResourceName: string): BodySetupCore;
	static GetDefaultObject(): BodySetupCore;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BodySetupCore;
	static C(Other: UObject | any): BodySetupCore;
}

declare type ECollisionEnabled = 'NoCollision' | 'QueryOnly' | 'PhysicsOnly' | 'QueryAndPhysics' | 'ECollisionEnabled_MAX';
declare var ECollisionEnabled : { NoCollision:'NoCollision',QueryOnly:'QueryOnly',PhysicsOnly:'PhysicsOnly',QueryAndPhysics:'QueryAndPhysics',ECollisionEnabled_MAX:'ECollisionEnabled_MAX', };
declare class KShapeElem { 
	RestOffset: number;
	bIsGenerated: boolean;
	Name: string;
	bContributeToMass: boolean;
	CollisionEnabled: ECollisionEnabled;
	clone() : KShapeElem;
	static C(Other: UObject | any): KShapeElem;
}

declare class KSphereElem extends KShapeElem { 
	TM: Matrix;
	Center: Vector;
	Radius: number;
	clone() : KSphereElem;
	static C(Other: UObject | any): KSphereElem;
}

declare class KBoxElem extends KShapeElem { 
	TM: Matrix;
	Orientation: Quat;
	Center: Vector;
	Rotation: Rotator;
	X: number;
	Y: number;
	Z: number;
	clone() : KBoxElem;
	static C(Other: UObject | any): KBoxElem;
}

declare class KSphylElem extends KShapeElem { 
	TM: Matrix;
	Orientation: Quat;
	Center: Vector;
	Rotation: Rotator;
	Radius: number;
	Length: number;
	clone() : KSphylElem;
	static C(Other: UObject | any): KSphylElem;
}

declare class Box { 
	Min: Vector;
	Max: Vector;
	IsValid: number;
	clone() : Box;
	static C(Other: UObject | any): Box;
}

declare class KConvexElem extends KShapeElem { 
	VertexData: Vector[];
	IndexData: number[];
	ElemBox: Box;
	Transform: Transform;
	clone() : KConvexElem;
	static C(Other: UObject | any): KConvexElem;
}

declare class KTaperedCapsuleElem extends KShapeElem { 
	Center: Vector;
	Rotation: Rotator;
	Radius0: number;
	Radius1: number;
	Length: number;
	clone() : KTaperedCapsuleElem;
	static C(Other: UObject | any): KTaperedCapsuleElem;
}

declare class KAggregateGeom { 
	SphereElems: KSphereElem[];
	BoxElems: KBoxElem[];
	SphylElems: KSphylElem[];
	ConvexElems: KConvexElem[];
	TaperedCapsuleElems: KTaperedCapsuleElem[];
	clone() : KAggregateGeom;
	static C(Other: UObject | any): KAggregateGeom;
}

declare type EWalkableSlopeBehavior = 'WalkableSlope_Default' | 'WalkableSlope_Increase' | 'WalkableSlope_Decrease' | 'WalkableSlope_Unwalkable' | 'WalkableSlope_Max';
declare var EWalkableSlopeBehavior : { WalkableSlope_Default:'WalkableSlope_Default',WalkableSlope_Increase:'WalkableSlope_Increase',WalkableSlope_Decrease:'WalkableSlope_Decrease',WalkableSlope_Unwalkable:'WalkableSlope_Unwalkable',WalkableSlope_Max:'WalkableSlope_Max', };
declare class WalkableSlopeOverride { 
	WalkableSlopeBehavior: EWalkableSlopeBehavior;
	WalkableSlopeAngle: number;
	clone() : WalkableSlopeOverride;
	static C(Other: UObject | any): WalkableSlopeOverride;
}

declare class BodyInstanceCore { 
	bSimulatePhysics: boolean;
	bOverrideMass: boolean;
	bEnableGravity: boolean;
	bAutoWeld: boolean;
	bStartAwake: boolean;
	bGenerateWakeEvents: boolean;
	bUpdateMassWhenScaleChanges: boolean;
	clone() : BodyInstanceCore;
	static C(Other: UObject | any): BodyInstanceCore;
}

declare type ECollisionChannel = 'ECC_WorldStatic' | 'ECC_WorldDynamic' | 'ECC_Pawn' | 'ECC_Visibility' | 'ECC_Camera' | 'ECC_PhysicsBody' | 'ECC_Vehicle' | 'ECC_Destructible' | 'ECC_EngineTraceChannel1' | 'ECC_EngineTraceChannel2' | 'ECC_EngineTraceChannel3' | 'ECC_EngineTraceChannel4' | 'ECC_EngineTraceChannel5' | 'ECC_EngineTraceChannel6' | 'ECC_GameTraceChannel1' | 'ECC_GameTraceChannel2' | 'ECC_GameTraceChannel3' | 'ECC_GameTraceChannel4' | 'ECC_GameTraceChannel5' | 'ECC_GameTraceChannel6' | 'ECC_GameTraceChannel7' | 'ECC_GameTraceChannel8' | 'ECC_GameTraceChannel9' | 'ECC_GameTraceChannel10' | 'ECC_GameTraceChannel11' | 'ECC_GameTraceChannel12' | 'ECC_GameTraceChannel13' | 'ECC_GameTraceChannel14' | 'ECC_GameTraceChannel15' | 'ECC_GameTraceChannel16' | 'ECC_GameTraceChannel17' | 'ECC_GameTraceChannel18' | 'ECC_OverlapAll_Deprecated' | 'ECC_MAX';
declare var ECollisionChannel : { ECC_WorldStatic:'ECC_WorldStatic',ECC_WorldDynamic:'ECC_WorldDynamic',ECC_Pawn:'ECC_Pawn',ECC_Visibility:'ECC_Visibility',ECC_Camera:'ECC_Camera',ECC_PhysicsBody:'ECC_PhysicsBody',ECC_Vehicle:'ECC_Vehicle',ECC_Destructible:'ECC_Destructible',ECC_EngineTraceChannel1:'ECC_EngineTraceChannel1',ECC_EngineTraceChannel2:'ECC_EngineTraceChannel2',ECC_EngineTraceChannel3:'ECC_EngineTraceChannel3',ECC_EngineTraceChannel4:'ECC_EngineTraceChannel4',ECC_EngineTraceChannel5:'ECC_EngineTraceChannel5',ECC_EngineTraceChannel6:'ECC_EngineTraceChannel6',ECC_GameTraceChannel1:'ECC_GameTraceChannel1',ECC_GameTraceChannel2:'ECC_GameTraceChannel2',ECC_GameTraceChannel3:'ECC_GameTraceChannel3',ECC_GameTraceChannel4:'ECC_GameTraceChannel4',ECC_GameTraceChannel5:'ECC_GameTraceChannel5',ECC_GameTraceChannel6:'ECC_GameTraceChannel6',ECC_GameTraceChannel7:'ECC_GameTraceChannel7',ECC_GameTraceChannel8:'ECC_GameTraceChannel8',ECC_GameTraceChannel9:'ECC_GameTraceChannel9',ECC_GameTraceChannel10:'ECC_GameTraceChannel10',ECC_GameTraceChannel11:'ECC_GameTraceChannel11',ECC_GameTraceChannel12:'ECC_GameTraceChannel12',ECC_GameTraceChannel13:'ECC_GameTraceChannel13',ECC_GameTraceChannel14:'ECC_GameTraceChannel14',ECC_GameTraceChannel15:'ECC_GameTraceChannel15',ECC_GameTraceChannel16:'ECC_GameTraceChannel16',ECC_GameTraceChannel17:'ECC_GameTraceChannel17',ECC_GameTraceChannel18:'ECC_GameTraceChannel18',ECC_OverlapAll_Deprecated:'ECC_OverlapAll_Deprecated',ECC_MAX:'ECC_MAX', };
declare type ESleepFamily = 'Normal' | 'Sensitive' | 'Custom' | 'ESleepFamily_MAX';
declare var ESleepFamily : { Normal:'Normal',Sensitive:'Sensitive',Custom:'Custom',ESleepFamily_MAX:'ESleepFamily_MAX', };
declare type EDOFMode = 'Default' | 'SixDOF' | 'YZPlane' | 'XZPlane' | 'XYPlane' | 'CustomPlane' | 'None' | 'EDOFMode_MAX';
declare var EDOFMode : { Default:'Default',SixDOF:'SixDOF',YZPlane:'YZPlane',XZPlane:'XZPlane',XYPlane:'XYPlane',CustomPlane:'CustomPlane',None:'None',EDOFMode_MAX:'EDOFMode_MAX', };
declare type ECollisionResponse = 'ECR_Ignore' | 'ECR_Overlap' | 'ECR_Block' | 'ECR_MAX';
declare var ECollisionResponse : { ECR_Ignore:'ECR_Ignore',ECR_Overlap:'ECR_Overlap',ECR_Block:'ECR_Block',ECR_MAX:'ECR_MAX', };
declare class CollisionResponseContainer { 
	WorldStatic: ECollisionResponse;
	WorldDynamic: ECollisionResponse;
	Pawn: ECollisionResponse;
	Visibility: ECollisionResponse;
	Camera: ECollisionResponse;
	PhysicsBody: ECollisionResponse;
	Vehicle: ECollisionResponse;
	Destructible: ECollisionResponse;
	EngineTraceChannel1: ECollisionResponse;
	EngineTraceChannel2: ECollisionResponse;
	EngineTraceChannel3: ECollisionResponse;
	EngineTraceChannel4: ECollisionResponse;
	EngineTraceChannel5: ECollisionResponse;
	EngineTraceChannel6: ECollisionResponse;
	GameTraceChannel1: ECollisionResponse;
	GameTraceChannel2: ECollisionResponse;
	GameTraceChannel3: ECollisionResponse;
	GameTraceChannel4: ECollisionResponse;
	GameTraceChannel5: ECollisionResponse;
	GameTraceChannel6: ECollisionResponse;
	GameTraceChannel7: ECollisionResponse;
	GameTraceChannel8: ECollisionResponse;
	GameTraceChannel9: ECollisionResponse;
	GameTraceChannel10: ECollisionResponse;
	GameTraceChannel11: ECollisionResponse;
	GameTraceChannel12: ECollisionResponse;
	GameTraceChannel13: ECollisionResponse;
	GameTraceChannel14: ECollisionResponse;
	GameTraceChannel15: ECollisionResponse;
	GameTraceChannel16: ECollisionResponse;
	GameTraceChannel17: ECollisionResponse;
	GameTraceChannel18: ECollisionResponse;
	clone() : CollisionResponseContainer;
	static C(Other: UObject | any): CollisionResponseContainer;
}

declare class ResponseChannel { 
	Channel: string;
	Response: ECollisionResponse;
	clone() : ResponseChannel;
	static C(Other: UObject | any): ResponseChannel;
}

declare class CollisionResponse { 
	ResponseToChannels: CollisionResponseContainer;
	ResponseArray: ResponseChannel[];
	clone() : CollisionResponse;
	static C(Other: UObject | any): CollisionResponse;
}

declare class BodyInstance extends BodyInstanceCore { 
	ObjectType: ECollisionChannel;
	CollisionEnabled: ECollisionEnabled;
	SleepFamily: ESleepFamily;
	DOFMode: EDOFMode;
	bUseCCD: boolean;
	bIgnoreAnalyticCollisions: boolean;
	bNotifyRigidBodyCollision: boolean;
	bSmoothEdgeCollisions: boolean;
	bLockTranslation: boolean;
	bLockRotation: boolean;
	bLockXTranslation: boolean;
	bLockYTranslation: boolean;
	bLockZTranslation: boolean;
	bLockXRotation: boolean;
	bLockYRotation: boolean;
	bLockZRotation: boolean;
	bOverrideMaxAngularVelocity: boolean;
	bOverrideMaxDepenetrationVelocity: boolean;
	bOverrideWalkableSlopeOnInstance: boolean;
	bInterpolateWhenSubStepping: boolean;
	ResponseToChannels: CollisionResponseContainer;
	CollisionProfileName: string;
	PositionSolverIterationCount: number;
	VelocitySolverIterationCount: number;
	CollisionResponses: CollisionResponse;
	MaxDepenetrationVelocity: number;
	MassInKgOverride: number;
	LinearDamping: number;
	AngularDamping: number;
	CustomDOFPlaneNormal: Vector;
	COMNudge: Vector;
	MassScale: number;
	InertiaTensorScale: Vector;
	WalkableSlopeOverride: WalkableSlopeOverride;
	PhysMaterialOverride: PhysicalMaterial;
	MaxAngularVelocity: number;
	CustomSleepThresholdMultiplier: number;
	StabilizationThresholdMultiplier: number;
	PhysicsBlendWeight: number;
	clone() : BodyInstance;
	static C(Other: UObject | any): BodyInstance;
}

declare class BodySetup extends BodySetupCore { 
	AggGeom: KAggregateGeom;
	bAlwaysFullAnimWeight: boolean;
	bConsiderForBounds: boolean;
	bMeshCollideAll: boolean;
	bDoubleSidedGeometry: boolean;
	bGenerateNonMirroredCollision: boolean;
	bSharedCookedData: boolean;
	bGenerateMirroredCollision: boolean;
	bSupportUVsAndFaceRemap: boolean;
	bNeverNeedsCookedCollisionData: boolean;
	PhysMaterial: PhysicalMaterial;
	WalkableSlopeOverride: WalkableSlopeOverride;
	BuildScale: number;
	DefaultInstance: BodyInstance;
	BuildScale3D: Vector;
	static Load(ResourceName: string): BodySetup;
	static Find(Outer: UObject, ResourceName: string): BodySetup;
	static GetDefaultObject(): BodySetup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BodySetup;
	static C(Other: UObject | any): BodySetup;
}

declare class ModelComponent extends PrimitiveComponent { 
	ModelBodySetup: BodySetup;
	static Load(ResourceName: string): ModelComponent;
	static Find(Outer: UObject, ResourceName: string): ModelComponent;
	static GetDefaultObject(): ModelComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ModelComponent;
	static C(Other: UObject | any): ModelComponent;
}

declare class LevelActorContainer extends UObject { 
	Actors: Actor[];
	static Load(ResourceName: string): LevelActorContainer;
	static Find(Outer: UObject, ResourceName: string): LevelActorContainer;
	static GetDefaultObject(): LevelActorContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelActorContainer;
	static C(Other: UObject | any): LevelActorContainer;
}

declare class BlueprintCore extends UObject { 
	SkeletonGeneratedClass: UnrealEngineClass;
	GeneratedClass: UnrealEngineClass;
	bLegacyNeedToPurgeSkelRefs: boolean;
	BlueprintGuid: Guid;
	static Load(ResourceName: string): BlueprintCore;
	static Find(Outer: UObject, ResourceName: string): BlueprintCore;
	static GetDefaultObject(): BlueprintCore;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintCore;
	static C(Other: UObject | any): BlueprintCore;
}

declare type EBlueprintType = 'BPTYPE_Normal' | 'BPTYPE_Const' | 'BPTYPE_MacroLibrary' | 'BPTYPE_Interface' | 'BPTYPE_LevelScript' | 'BPTYPE_FunctionLibrary' | 'BPTYPE_MAX';
declare var EBlueprintType : { BPTYPE_Normal:'BPTYPE_Normal',BPTYPE_Const:'BPTYPE_Const',BPTYPE_MacroLibrary:'BPTYPE_MacroLibrary',BPTYPE_Interface:'BPTYPE_Interface',BPTYPE_LevelScript:'BPTYPE_LevelScript',BPTYPE_FunctionLibrary:'BPTYPE_FunctionLibrary',BPTYPE_MAX:'BPTYPE_MAX', };
declare type EBlueprintNativizationFlag = 'Disabled' | 'Dependency' | 'ExplicitlyEnabled' | 'EBlueprintNativizationFlag_MAX';
declare var EBlueprintNativizationFlag : { Disabled:'Disabled',Dependency:'Dependency',ExplicitlyEnabled:'ExplicitlyEnabled',EBlueprintNativizationFlag_MAX:'EBlueprintNativizationFlag_MAX', };
declare type EBlueprintCompileMode = 'Default' | 'Development' | 'FinalRelease' | 'EBlueprintCompileMode_MAX';
declare var EBlueprintCompileMode : { Default:'Default',Development:'Development',FinalRelease:'FinalRelease',EBlueprintCompileMode_MAX:'EBlueprintCompileMode_MAX', };
declare type EBlueprintStatus = 'BS_Unknown' | 'BS_Dirty' | 'BS_Error' | 'BS_UpToDate' | 'BS_BeingCreated' | 'BS_UpToDateWithWarnings' | 'BS_MAX';
declare var EBlueprintStatus : { BS_Unknown:'BS_Unknown',BS_Dirty:'BS_Dirty',BS_Error:'BS_Error',BS_UpToDate:'BS_UpToDate',BS_BeingCreated:'BS_BeingCreated',BS_UpToDateWithWarnings:'BS_UpToDateWithWarnings',BS_MAX:'BS_MAX', };
declare class Field extends UObject { 
	static Load(ResourceName: string): Field;
	static Find(Outer: UObject, ResourceName: string): Field;
	static GetDefaultObject(): Field;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Field;
	static C(Other: UObject | any): Field;
	HasMetaData(Key: string): boolean;
	GetMetaData(Key: string): string;
	static HasMetaData(Field: Field,Key: string): boolean;
	static GetMetaData(Field: Field,Key: string): string;
}

declare class Struct extends Field { 
	static Load(ResourceName: string): Struct;
	static Find(Outer: UObject, ResourceName: string): Struct;
	static GetDefaultObject(): Struct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Struct;
	static C(Other: UObject | any): Struct;
}

declare class BlueprintComponentChangedPropertyInfo { 
	PropertyName: string;
	ArrayIndex: number;
	PropertyScope: Struct;
	clone() : BlueprintComponentChangedPropertyInfo;
	static C(Other: UObject | any): BlueprintComponentChangedPropertyInfo;
}

declare class BlueprintCookedComponentInstancingData { 
	ChangedPropertyList: BlueprintComponentChangedPropertyInfo[];
	bHasValidCookedData: boolean;
	clone() : BlueprintCookedComponentInstancingData;
	static C(Other: UObject | any): BlueprintCookedComponentInstancingData;
}

declare class BPVariableMetaDataEntry { 
	DataKey: string;
	DataValue: string;
	clone() : BPVariableMetaDataEntry;
	static C(Other: UObject | any): BPVariableMetaDataEntry;
}

declare class SCS_Node extends UObject { 
	ComponentClass: UnrealEngineClass;
	ComponentTemplate: ActorComponent;
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	CategoryName: string;
	AttachToName: string;
	ParentComponentOrVariableName: string;
	ParentComponentOwnerClassName: string;
	bIsParentComponentNative: boolean;
	ChildNodes: SCS_Node[];
	MetaDataArray: BPVariableMetaDataEntry[];
	VariableGuid: Guid;
	bIsNative: boolean;
	NativeComponentName: string;
	bVariableNameAutoGenerated: boolean;
	InternalVariableName: string;
	static Load(ResourceName: string): SCS_Node;
	static Find(Outer: UObject, ResourceName: string): SCS_Node;
	static GetDefaultObject(): SCS_Node;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SCS_Node;
	static C(Other: UObject | any): SCS_Node;
}

declare class SimpleConstructionScript extends UObject { 
	RootNodes: SCS_Node[];
	AllNodes: SCS_Node[];
	DefaultSceneRootNode: SCS_Node;
	RootNode: SCS_Node;
	ActorComponentNodes: SCS_Node[];
	static Load(ResourceName: string): SimpleConstructionScript;
	static Find(Outer: UObject, ResourceName: string): SimpleConstructionScript;
	static GetDefaultObject(): SimpleConstructionScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SimpleConstructionScript;
	static C(Other: UObject | any): SimpleConstructionScript;
}

declare class EdGraphSchema extends UObject { 
	static Load(ResourceName: string): EdGraphSchema;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema;
	static GetDefaultObject(): EdGraphSchema;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema;
	static C(Other: UObject | any): EdGraphSchema;
	SetNodeMetaData(UNode: EdGraphNode,KeyValue: string): boolean;
	TryConnection(A: JavascriptEdGraphPin,B: JavascriptEdGraphPin): boolean;
	static SetNodeMetaData(Schema: EdGraphSchema,UNode: EdGraphNode,KeyValue: string): boolean;
	static TryConnection(Schema: EdGraphSchema,A: JavascriptEdGraphPin,B: JavascriptEdGraphPin): boolean;
}

declare class EdGraph extends UObject { 
	Schema: UnrealEngineClass;
	Nodes: EdGraphNode[];
	bEditable: boolean;
	bAllowDeletion: boolean;
	bAllowRenaming: boolean;
	SubGraphs: EdGraph[];
	GraphGuid: Guid;
	InterfaceGuid: Guid;
	static Load(ResourceName: string): EdGraph;
	static Find(Outer: UObject, ResourceName: string): EdGraph;
	static GetDefaultObject(): EdGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraph;
	static C(Other: UObject | any): EdGraph;
	RenameGraph(NewNameStr: string): void;
	static RenameGraph(Graph: EdGraph,NewNameStr: string): void;
}

declare type ETimelineLengthMode = 'TL_TimelineLength' | 'TL_LastKeyFrame' | 'TL_MAX';
declare var ETimelineLengthMode : { TL_TimelineLength:'TL_TimelineLength',TL_LastKeyFrame:'TL_LastKeyFrame',TL_MAX:'TL_MAX', };
declare class TTTrackBase { 
	TrackName: string;
	bIsExternalCurve: boolean;
	bIsExpanded: boolean;
	bIsCurveViewSynchronized: boolean;
	clone() : TTTrackBase;
	static C(Other: UObject | any): TTTrackBase;
}

declare class CurveFloat extends CurveBase { 
	FloatCurve: RichCurve;
	bIsEventCurve: boolean;
	static Load(ResourceName: string): CurveFloat;
	static Find(Outer: UObject, ResourceName: string): CurveFloat;
	static GetDefaultObject(): CurveFloat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveFloat;
	GetFloatValue(InTime: number): number;
	static C(Other: UObject | any): CurveFloat;
}

declare class TTEventTrack extends TTTrackBase { 
	FunctionName: string;
	CurveKeys: CurveFloat;
	clone() : TTEventTrack;
	static C(Other: UObject | any): TTEventTrack;
}

declare class TTPropertyTrack extends TTTrackBase { 
	PropertyName: string;
	clone() : TTPropertyTrack;
	static C(Other: UObject | any): TTPropertyTrack;
}

declare class TTFloatTrack extends TTPropertyTrack { 
	CurveFloat: CurveFloat;
	clone() : TTFloatTrack;
	static C(Other: UObject | any): TTFloatTrack;
}

declare class CurveVector extends CurveBase { 
	FloatCurves: RichCurve;
	static Load(ResourceName: string): CurveVector;
	static Find(Outer: UObject, ResourceName: string): CurveVector;
	static GetDefaultObject(): CurveVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveVector;
	GetVectorValue(InTime: number): Vector;
	static C(Other: UObject | any): CurveVector;
}

declare class TTVectorTrack extends TTPropertyTrack { 
	CurveVector: CurveVector;
	clone() : TTVectorTrack;
	static C(Other: UObject | any): TTVectorTrack;
}

declare class TTLinearColorTrack extends TTPropertyTrack { 
	CurveLinearColor: CurveLinearColor;
	clone() : TTLinearColorTrack;
	static C(Other: UObject | any): TTLinearColorTrack;
}

declare class TTTrackId { 
	TrackType: number;
	TrackIndex: number;
	clone() : TTTrackId;
	static C(Other: UObject | any): TTTrackId;
}

declare class TimelineTemplate extends UObject { 
	TimeLineLength: number;
	LengthMode: ETimelineLengthMode;
	bAutoPlay: boolean;
	bLoop: boolean;
	bReplicated: boolean;
	bIgnoreTimeDilation: boolean;
	EventTracks: TTEventTrack[];
	FloatTracks: TTFloatTrack[];
	VectorTracks: TTVectorTrack[];
	LinearColorTracks: TTLinearColorTrack[];
	MetaDataArray: BPVariableMetaDataEntry[];
	TimelineGuid: Guid;
	TimelineTickGroup: ETickingGroup;
	VariableName: string;
	DirectionPropertyName: string;
	UpdateFunctionName: string;
	FinishedFunctionName: string;
	TrackDisplayOrder: TTTrackId[];
	static Load(ResourceName: string): TimelineTemplate;
	static Find(Outer: UObject, ResourceName: string): TimelineTemplate;
	static GetDefaultObject(): TimelineTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimelineTemplate;
	static C(Other: UObject | any): TimelineTemplate;
}

declare class BPComponentClassOverride { 
	ComponentName: string;
	ComponentClass: UnrealEngineClass;
	clone() : BPComponentClassOverride;
	static C(Other: UObject | any): BPComponentClassOverride;
}

declare class ComponentKey { 
	OwnerClass: UnrealEngineClass;
	SCSVariableName: string;
	AssociatedGuid: Guid;
	clone() : ComponentKey;
	static C(Other: UObject | any): ComponentKey;
}

declare class ComponentOverrideRecord { 
	ComponentClass: UnrealEngineClass;
	ComponentTemplate: ActorComponent;
	ComponentKey: ComponentKey;
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	clone() : ComponentOverrideRecord;
	static C(Other: UObject | any): ComponentOverrideRecord;
}

declare class InheritableComponentHandler extends UObject { 
	Records: ComponentOverrideRecord[];
	UnnecessaryComponents: ActorComponent[];
	static Load(ResourceName: string): InheritableComponentHandler;
	static Find(Outer: UObject, ResourceName: string): InheritableComponentHandler;
	static GetDefaultObject(): InheritableComponentHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InheritableComponentHandler;
	static C(Other: UObject | any): InheritableComponentHandler;
}

declare type ELifetimeCondition = 'COND_None' | 'COND_InitialOnly' | 'COND_OwnerOnly' | 'COND_SkipOwner' | 'COND_SimulatedOnly' | 'COND_AutonomousOnly' | 'COND_SimulatedOrPhysics' | 'COND_InitialOrOwner' | 'COND_Custom' | 'COND_ReplayOrOwner' | 'COND_ReplayOnly' | 'COND_SimulatedOnlyNoReplay' | 'COND_SimulatedOrPhysicsNoReplay' | 'COND_SkipReplay' | 'COND_Never' | 'COND_Max';
declare var ELifetimeCondition : { COND_None:'COND_None',COND_InitialOnly:'COND_InitialOnly',COND_OwnerOnly:'COND_OwnerOnly',COND_SkipOwner:'COND_SkipOwner',COND_SimulatedOnly:'COND_SimulatedOnly',COND_AutonomousOnly:'COND_AutonomousOnly',COND_SimulatedOrPhysics:'COND_SimulatedOrPhysics',COND_InitialOrOwner:'COND_InitialOrOwner',COND_Custom:'COND_Custom',COND_ReplayOrOwner:'COND_ReplayOrOwner',COND_ReplayOnly:'COND_ReplayOnly',COND_SimulatedOnlyNoReplay:'COND_SimulatedOnlyNoReplay',COND_SimulatedOrPhysicsNoReplay:'COND_SimulatedOrPhysicsNoReplay',COND_SkipReplay:'COND_SkipReplay',COND_Never:'COND_Never',COND_Max:'COND_Max', };
declare class BPVariableDescription { 
	VarName: string;
	VarGuid: Guid;
	VarType: EdGraphPinType;
	FriendlyName: string;
	Category: string;
	PropertyFlags: any;
	RepNotifyFunc: string;
	ReplicationCondition: ELifetimeCondition;
	MetaDataArray: BPVariableMetaDataEntry[];
	DefaultValue: string;
	clone() : BPVariableDescription;
	static C(Other: UObject | any): BPVariableDescription;
}

declare class Interface extends UObject { 
	static Load(ResourceName: string): Interface;
	static Find(Outer: UObject, ResourceName: string): Interface;
	static GetDefaultObject(): Interface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Interface;
	static C(Other: UObject | any): Interface;
}

declare class BPInterfaceDescription { 
	Interface: UnrealEngineClass;
	Graphs: EdGraph[];
	clone() : BPInterfaceDescription;
	static C(Other: UObject | any): BPInterfaceDescription;
}

declare class EditedDocumentInfo { 
	EditedObjectPath: SoftObjectPath;
	SavedViewOffset: Vector2D;
	SavedZoomAmount: number;
	EditedObject: UObject;
	clone() : EditedDocumentInfo;
	static C(Other: UObject | any): EditedDocumentInfo;
}

declare class BPEditorBookmarkNode { 
	NodeGuid: Guid;
	ParentGuid: Guid;
	DisplayName: string;
	clone() : BPEditorBookmarkNode;
	static C(Other: UObject | any): BPEditorBookmarkNode;
}

declare class Breakpoint extends UObject { 
	static Load(ResourceName: string): Breakpoint;
	static Find(Outer: UObject, ResourceName: string): Breakpoint;
	static GetDefaultObject(): Breakpoint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Breakpoint;
	static C(Other: UObject | any): Breakpoint;
}

declare class EdGraphPinReference { 
	OwningNode: any;
	PinId: Guid;
	clone() : EdGraphPinReference;
	static C(Other: UObject | any): EdGraphPinReference;
}

declare class BlueprintExtension extends UObject { 
	static Load(ResourceName: string): BlueprintExtension;
	static Find(Outer: UObject, ResourceName: string): BlueprintExtension;
	static GetDefaultObject(): BlueprintExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintExtension;
	static C(Other: UObject | any): BlueprintExtension;
}

declare class Blueprint extends BlueprintCore { 
	ParentClass: UnrealEngineClass;
	BlueprintType: EBlueprintType;
	bRecompileOnLoad: boolean;
	bHasBeenRegenerated: boolean;
	bIsRegeneratingOnLoad: boolean;
	bBeingCompiled: boolean;
	bIsNewlyCreated: boolean;
	bForceFullEditor: boolean;
	bQueuedForCompilation: boolean;
	bRunConstructionScriptOnDrag: boolean;
	bRunConstructionScriptInSequencer: boolean;
	bGenerateConstClass: boolean;
	bGenerateAbstractClass: boolean;
	bDisplayCompilePIEWarning: boolean;
	bDeprecate: boolean;
	bDuplicatingReadOnly: boolean;
	NativizationFlag: EBlueprintNativizationFlag;
	CompileMode: EBlueprintCompileMode;
	Status: EBlueprintStatus;
	BlueprintDisplayName: string;
	BlueprintDescription: string;
	BlueprintNamespace: string;
	BlueprintCategory: string;
	HideCategories: string[];
	BlueprintSystemVersion: number;
	SimpleConstructionScript: SimpleConstructionScript;
	UbergraphPages: EdGraph[];
	FunctionGraphs: EdGraph[];
	DelegateSignatureGraphs: EdGraph[];
	MacroGraphs: EdGraph[];
	IntermediateGeneratedGraphs: EdGraph[];
	EventGraphs: EdGraph[];
	PRIVATE_CachedMacroInfo: any;
	ComponentTemplates: ActorComponent[];
	Timelines: TimelineTemplate[];
	ComponentClassOverrides: BPComponentClassOverride[];
	InheritableComponentHandler: InheritableComponentHandler;
	NewVariables: BPVariableDescription[];
	CategorySorting: string[];
	ImportedNamespaces: any;
	ImplementedInterfaces: BPInterfaceDescription[];
	LastEditedDocuments: EditedDocumentInfo[];
	Bookmarks: any;
	BookmarkNodes: BPEditorBookmarkNode[];
	Breakpoints: Breakpoint[];
	WatchedPins: EdGraphPinReference[];
	DeprecatedPinWatches: EdGraphPin_Deprecated[];
	ComponentTemplateNameIndex: any;
	OldToNewComponentTemplateNames: any;
	Extensions: BlueprintExtension[];
	ThumbnailInfo: ThumbnailInfo;
	CrcLastCompiledCDO: any;
	CrcLastCompiledSignature: any;
	bCachedDependenciesUpToDate: boolean;
	CachedDependencies: any;
	CachedDependents: any;
	CachedUDSDependencies: any;
	OriginalClass: UnrealEngineClass;
	static Load(ResourceName: string): Blueprint;
	static Find(Outer: UObject, ResourceName: string): Blueprint;
	static GetDefaultObject(): Blueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Blueprint;
	static C(Other: UObject | any): Blueprint;
	AddComponentsToBlueprint(Components: ActorComponent[],bHarvesting: boolean,OptionalNewRootComponent: ActorComponent,bKeepMobility: boolean): void;
	CompileBlueprint(): void;
	GetParentClassOfBlueprint(): UnrealEngineClass;
	RemoveComponentFromBlueprint(RemoveComponent: ActorComponent,bPromoteChildren: boolean): void;
	GetBlueprintGeneratedClass(): UnrealEngineClass;
	AddFunctionGraph(FuncName: string): EdGraph;
	CompileBlueprint(): void;
	FindEventGraph(): EdGraph;
	FindGraph(GraphName: string): EdGraph;
	RemoveFunctionGraph(FuncName: string): void;
	RemoveGraph(Graph: EdGraph): void;
	RemoveUnusedNodes(): void;
	RemoveUnusedVariables(): number;
	ReparentBlueprint(NewParentClass: UnrealEngineClass): void;
	ReplaceVariableReferences(OldVarName: string,NewVarName: string): void;
	UpgradeOperatorNodes(): void;
	static AddComponentsToBlueprint(Blueprint: Blueprint,Components: ActorComponent[],bHarvesting: boolean,OptionalNewRootComponent: ActorComponent,bKeepMobility: boolean): void;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static GetParentClassOfBlueprint(Blueprint: Blueprint): UnrealEngineClass;
	static RemoveComponentFromBlueprint(Blueprint: Blueprint,RemoveComponent: ActorComponent,bPromoteChildren: boolean): void;
	static GetBlueprintGeneratedClass(Blueprint: Blueprint): UnrealEngineClass;
	static AddFunctionGraph(Blueprint: Blueprint,FuncName: string): EdGraph;
	static CompileBlueprint(Blueprint: Blueprint): void;
	static FindEventGraph(Blueprint: Blueprint): EdGraph;
	static FindGraph(Blueprint: Blueprint,GraphName: string): EdGraph;
	static RemoveFunctionGraph(Blueprint: Blueprint,FuncName: string): void;
	static RemoveGraph(Blueprint: Blueprint,Graph: EdGraph): void;
	static RemoveUnusedNodes(Blueprint: Blueprint): void;
	static RemoveUnusedVariables(Blueprint: Blueprint): number;
	static ReparentBlueprint(Blueprint: Blueprint,NewParentClass: UnrealEngineClass): void;
	static ReplaceVariableReferences(Blueprint: Blueprint,OldVarName: string,NewVarName: string): void;
	static UpgradeOperatorNodes(Blueprint: Blueprint): void;
}

declare class LevelScriptBlueprint extends Blueprint { 
	FriendlyName: string;
	static Load(ResourceName: string): LevelScriptBlueprint;
	static Find(Outer: UObject, ResourceName: string): LevelScriptBlueprint;
	static GetDefaultObject(): LevelScriptBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelScriptBlueprint;
	static C(Other: UObject | any): LevelScriptBlueprint;
}

declare class IntVector { 
	X: number;
	Y: number;
	Z: number;
	clone() : IntVector;
	static C(Other: UObject | any): IntVector;
	Conv_IntVectorToString(): string;
	Conv_IntVectorToVector(): Vector;
	static Conv_IntVectorToString(InIntVec: IntVector): string;
	static Conv_IntVectorToVector(InIntVector: IntVector): Vector;
	static Conv_IntToIntVector(inInt: number): IntVector;
}

declare class LevelScriptActor extends Actor { 
	bInputEnabled: boolean;
	static GetDefaultObject(): LevelScriptActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelScriptActor;
	WorldOriginLocationChanged(OldOriginLocation: IntVector,NewOriginLocation: IntVector): void;
	SetCinematicMode(bCinematicMode: boolean,bHidePlayer: boolean,bAffectsHUD: boolean,bAffectsMovement: boolean,bAffectsTurning: boolean): void;
	RemoteEvent(EventName: string): boolean;
	LevelReset(): void;
	static C(Other: UObject | any): LevelScriptActor;
}

declare class NavAreaBase extends UObject { 
	static Load(ResourceName: string): NavAreaBase;
	static Find(Outer: UObject, ResourceName: string): NavAreaBase;
	static GetDefaultObject(): NavAreaBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavAreaBase;
	static C(Other: UObject | any): NavAreaBase;
}

declare class ShapeComponent extends PrimitiveComponent { 
	ShapeBodySetup: BodySetup;
	AreaClass: UnrealEngineClass;
	ShapeColor: Color;
	bDrawOnlyIfSelected: boolean;
	bShouldCollideWhenPlacing: boolean;
	bDynamicObstacle: boolean;
	static Load(ResourceName: string): ShapeComponent;
	static Find(Outer: UObject, ResourceName: string): ShapeComponent;
	static GetDefaultObject(): ShapeComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShapeComponent;
	static C(Other: UObject | any): ShapeComponent;
}

declare class CapsuleComponent extends ShapeComponent { 
	CapsuleHalfHeight: number;
	CapsuleRadius: number;
	CapsuleHeight: number;
	static Load(ResourceName: string): CapsuleComponent;
	static Find(Outer: UObject, ResourceName: string): CapsuleComponent;
	static GetDefaultObject(): CapsuleComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CapsuleComponent;
	SetCapsuleSize(InRadius: number,InHalfHeight: number,bUpdateOverlaps: boolean): void;
	SetCapsuleRadius(Radius: number,bUpdateOverlaps: boolean): void;
	SetCapsuleHalfHeight(HalfHeight: number,bUpdateOverlaps: boolean): void;
	GetUnscaledCapsuleSize_WithoutHemisphere(OutRadius?: number,OutHalfHeightWithoutHemisphere?: number): {OutRadius: number, OutHalfHeightWithoutHemisphere: number};
	GetUnscaledCapsuleSize(OutRadius?: number,OutHalfHeight?: number): {OutRadius: number, OutHalfHeight: number};
	GetUnscaledCapsuleRadius(): number;
	GetUnscaledCapsuleHalfHeight_WithoutHemisphere(): number;
	GetUnscaledCapsuleHalfHeight(): number;
	GetShapeScale(): number;
	GetScaledCapsuleSize_WithoutHemisphere(OutRadius?: number,OutHalfHeightWithoutHemisphere?: number): {OutRadius: number, OutHalfHeightWithoutHemisphere: number};
	GetScaledCapsuleSize(OutRadius?: number,OutHalfHeight?: number): {OutRadius: number, OutHalfHeight: number};
	GetScaledCapsuleRadius(): number;
	GetScaledCapsuleHalfHeight_WithoutHemisphere(): number;
	GetScaledCapsuleHalfHeight(): number;
	static C(Other: UObject | any): CapsuleComponent;
}

declare class NavigationObjectBase extends Actor { 
	CapsuleComponent: CapsuleComponent;
	GoodSprite: BillboardComponent;
	BadSprite: BillboardComponent;
	bIsPIEPlayerStart: boolean;
	static GetDefaultObject(): NavigationObjectBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationObjectBase;
	static C(Other: UObject | any): NavigationObjectBase;
}

declare class NavigationDataChunk extends UObject { 
	NavigationDataName: string;
	static Load(ResourceName: string): NavigationDataChunk;
	static Find(Outer: UObject, ResourceName: string): NavigationDataChunk;
	static GetDefaultObject(): NavigationDataChunk;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationDataChunk;
	static C(Other: UObject | any): NavigationDataChunk;
}

declare type ELightingBuildQuality = 'Quality_Preview' | 'Quality_Medium' | 'Quality_High' | 'Quality_Production' | 'Quality_MAX';
declare var ELightingBuildQuality : { Quality_Preview:'Quality_Preview',Quality_Medium:'Quality_Medium',Quality_High:'Quality_High',Quality_Production:'Quality_Production',Quality_MAX:'Quality_MAX', };
declare class MapBuildDataRegistry extends UObject { 
	LevelLightingQuality: ELightingBuildQuality;
	static Load(ResourceName: string): MapBuildDataRegistry;
	static Find(Outer: UObject, ResourceName: string): MapBuildDataRegistry;
	static GetDefaultObject(): MapBuildDataRegistry;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MapBuildDataRegistry;
	static C(Other: UObject | any): MapBuildDataRegistry;
}

declare type ETextureSizingType = 'TextureSizingType_UseSingleTextureSize' | 'TextureSizingType_UseAutomaticBiasedSizes' | 'TextureSizingType_UseManualOverrideTextureSize' | 'TextureSizingType_UseSimplygonAutomaticSizing' | 'TextureSizingType_AutomaticFromTexelDensity' | 'TextureSizingType_AutomaticFromMeshScreenSize' | 'TextureSizingType_AutomaticFromMeshDrawDistance' | 'TextureSizingType_MAX';
declare var ETextureSizingType : { TextureSizingType_UseSingleTextureSize:'TextureSizingType_UseSingleTextureSize',TextureSizingType_UseAutomaticBiasedSizes:'TextureSizingType_UseAutomaticBiasedSizes',TextureSizingType_UseManualOverrideTextureSize:'TextureSizingType_UseManualOverrideTextureSize',TextureSizingType_UseSimplygonAutomaticSizing:'TextureSizingType_UseSimplygonAutomaticSizing',TextureSizingType_AutomaticFromTexelDensity:'TextureSizingType_AutomaticFromTexelDensity',TextureSizingType_AutomaticFromMeshScreenSize:'TextureSizingType_AutomaticFromMeshScreenSize',TextureSizingType_AutomaticFromMeshDrawDistance:'TextureSizingType_AutomaticFromMeshDrawDistance',TextureSizingType_MAX:'TextureSizingType_MAX', };
declare type EMaterialMergeType = 'MaterialMergeType_Default' | 'MaterialMergeType_Simplygon' | 'MaterialMergeType_MAX';
declare var EMaterialMergeType : { MaterialMergeType_Default:'MaterialMergeType_Default',MaterialMergeType_Simplygon:'MaterialMergeType_Simplygon',MaterialMergeType_MAX:'MaterialMergeType_MAX', };
declare class MaterialProxySettings { 
	TextureSizingType: ETextureSizingType;
	TextureSize: IntPoint;
	TargetTexelDensityPerMeter: number;
	MeshMaxScreenSizePercent: number;
	MeshMinDrawDistance: number;
	GutterSpace: number;
	MetallicConstant: number;
	RoughnessConstant: number;
	AnisotropyConstant: number;
	SpecularConstant: number;
	OpacityConstant: number;
	OpacityMaskConstant: number;
	AmbientOcclusionConstant: number;
	MaterialMergeType: EMaterialMergeType;
	BlendMode: EBlendMode;
	bAllowTwoSidedMaterial: boolean;
	bNormalMap: boolean;
	bTangentMap: boolean;
	bMetallicMap: boolean;
	bRoughnessMap: boolean;
	bAnisotropyMap: boolean;
	bSpecularMap: boolean;
	bEmissiveMap: boolean;
	bOpacityMap: boolean;
	bOpacityMaskMap: boolean;
	bAmbientOcclusionMap: boolean;
	DiffuseTextureSize: IntPoint;
	NormalTextureSize: IntPoint;
	TangentTextureSize: IntPoint;
	MetallicTextureSize: IntPoint;
	RoughnessTextureSize: IntPoint;
	AnisotropyTextureSize: IntPoint;
	SpecularTextureSize: IntPoint;
	EmissiveTextureSize: IntPoint;
	OpacityTextureSize: IntPoint;
	OpacityMaskTextureSize: IntPoint;
	AmbientOcclusionTextureSize: IntPoint;
	clone() : MaterialProxySettings;
	static C(Other: UObject | any): MaterialProxySettings;
}

declare class LevelSimplificationDetails { 
	bCreatePackagePerAsset: boolean;
	DetailsPercentage: number;
	StaticMeshMaterialSettings: MaterialProxySettings;
	bOverrideLandscapeExportLOD: boolean;
	LandscapeExportLOD: number;
	LandscapeMaterialSettings: MaterialProxySettings;
	bBakeFoliageToLandscape: boolean;
	bBakeGrassToLandscape: boolean;
	bGenerateMeshNormalMap: boolean;
	bGenerateMeshMetallicMap: boolean;
	bGenerateMeshRoughnessMap: boolean;
	bGenerateMeshSpecularMap: boolean;
	bGenerateLandscapeNormalMap: boolean;
	bGenerateLandscapeMetallicMap: boolean;
	bGenerateLandscapeRoughnessMap: boolean;
	bGenerateLandscapeSpecularMap: boolean;
	clone() : LevelSimplificationDetails;
	static C(Other: UObject | any): LevelSimplificationDetails;
}

declare type EActorPackagingScheme = 'Original' | 'Reduced' | 'EActorPackagingScheme_MAX';
declare var EActorPackagingScheme : { Original:'Original',Reduced:'Reduced',EActorPackagingScheme_MAX:'EActorPackagingScheme_MAX', };
declare type EVisibilityAggressiveness = 'VIS_LeastAggressive' | 'VIS_ModeratelyAggressive' | 'VIS_MostAggressive' | 'VIS_Max';
declare var EVisibilityAggressiveness : { VIS_LeastAggressive:'VIS_LeastAggressive',VIS_ModeratelyAggressive:'VIS_ModeratelyAggressive',VIS_MostAggressive:'VIS_MostAggressive',VIS_Max:'VIS_Max', };
declare class DynamicBlueprintBinding extends UObject { 
	static Load(ResourceName: string): DynamicBlueprintBinding;
	static Find(Outer: UObject, ResourceName: string): DynamicBlueprintBinding;
	static GetDefaultObject(): DynamicBlueprintBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicBlueprintBinding;
	static C(Other: UObject | any): DynamicBlueprintBinding;
}

declare type EGameplayEffectDurationType = 'Instant' | 'Infinite' | 'HasDuration' | 'EGameplayEffectDurationType_MAX';
declare var EGameplayEffectDurationType : { Instant:'Instant',Infinite:'Infinite',HasDuration:'HasDuration',EGameplayEffectDurationType_MAX:'EGameplayEffectDurationType_MAX', };
declare type EGameplayEffectMagnitudeCalculation = 'ScalableFloat' | 'AttributeBased' | 'CustomCalculationClass' | 'SetByCaller' | 'EGameplayEffectMagnitudeCalculation_MAX';
declare var EGameplayEffectMagnitudeCalculation : { ScalableFloat:'ScalableFloat',AttributeBased:'AttributeBased',CustomCalculationClass:'CustomCalculationClass',SetByCaller:'SetByCaller',EGameplayEffectMagnitudeCalculation_MAX:'EGameplayEffectMagnitudeCalculation_MAX', };
declare type EEvaluateCurveTableResult = 'RowFound' | 'RowNotFound' | 'EEvaluateCurveTableResult_MAX';
declare var EEvaluateCurveTableResult : { RowFound:'RowFound',RowNotFound:'RowNotFound',EEvaluateCurveTableResult_MAX:'EEvaluateCurveTableResult_MAX', };
declare class CurveTable extends UObject { 
	AssetImportData: AssetImportData;
	ImportPath: string;
	static Load(ResourceName: string): CurveTable;
	static Find(Outer: UObject, ResourceName: string): CurveTable;
	static GetDefaultObject(): CurveTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveTable;
	static C(Other: UObject | any): CurveTable;
	AddRichCurve(Key: string,InCurve: RichCurve): void;
	NotifyUpdateCurveTable(): void;
	EvaluateCurveTableRow(RowName: string,InXY: number,OutResult?: EEvaluateCurveTableResult,OutXY?: number,ContextString?: string): {OutResult: EEvaluateCurveTableResult, OutXY: number};
	static AddRichCurve(InCurveTable: CurveTable,Key: string,InCurve: RichCurve): void;
	static NotifyUpdateCurveTable(InCurveTable: CurveTable): void;
	static EvaluateCurveTableRow(CurveTable: CurveTable,RowName: string,InXY: number,OutResult?: EEvaluateCurveTableResult,OutXY?: number,ContextString?: string): {OutResult: EEvaluateCurveTableResult, OutXY: number};
}

declare class CurveTableRowHandle { 
	CurveTable: CurveTable;
	RowName: string;
	clone() : CurveTableRowHandle;
	static C(Other: UObject | any): CurveTableRowHandle;
}

declare class DataRegistryType { 
	Name: string;
	clone() : DataRegistryType;
	static C(Other: UObject | any): DataRegistryType;
}

declare class ScalableFloat { 
	Value: number;
	Curve: CurveTableRowHandle;
	RegistryType: DataRegistryType;
	clone() : ScalableFloat;
	static C(Other: UObject | any): ScalableFloat;
}

declare class GameplayAttribute { 
	AttributeName: string;
	Attribute: any;
	AttributeOwner: Struct;
	clone() : GameplayAttribute;
	static C(Other: UObject | any): GameplayAttribute;
	EqualEqual_GameplayAttributeGameplayAttribute(AttributeB: GameplayAttribute): boolean;
	IsValid(): boolean;
	NotEqual_GameplayAttributeGameplayAttribute(AttributeB: GameplayAttribute): boolean;
	static EqualEqual_GameplayAttributeGameplayAttribute(AttributeA: GameplayAttribute,AttributeB: GameplayAttribute): boolean;
	static IsValid(Attribute: GameplayAttribute): boolean;
	static NotEqual_GameplayAttributeGameplayAttribute(AttributeA: GameplayAttribute,AttributeB: GameplayAttribute): boolean;
}

declare type EGameplayEffectAttributeCaptureSource = 'Source' | 'Target' | 'EGameplayEffectAttributeCaptureSource_MAX';
declare var EGameplayEffectAttributeCaptureSource : { Source:'Source',Target:'Target',EGameplayEffectAttributeCaptureSource_MAX:'EGameplayEffectAttributeCaptureSource_MAX', };
declare class GameplayEffectAttributeCaptureDefinition { 
	AttributeToCapture: GameplayAttribute;
	AttributeSource: EGameplayEffectAttributeCaptureSource;
	bSnapshot: boolean;
	clone() : GameplayEffectAttributeCaptureDefinition;
	static C(Other: UObject | any): GameplayEffectAttributeCaptureDefinition;
}

declare type EAttributeBasedFloatCalculationType = 'AttributeMagnitude' | 'AttributeBaseValue' | 'AttributeBonusMagnitude' | 'AttributeMagnitudeEvaluatedUpToChannel' | 'EAttributeBasedFloatCalculationType_MAX';
declare var EAttributeBasedFloatCalculationType : { AttributeMagnitude:'AttributeMagnitude',AttributeBaseValue:'AttributeBaseValue',AttributeBonusMagnitude:'AttributeBonusMagnitude',AttributeMagnitudeEvaluatedUpToChannel:'AttributeMagnitudeEvaluatedUpToChannel',EAttributeBasedFloatCalculationType_MAX:'EAttributeBasedFloatCalculationType_MAX', };
declare type EGameplayModEvaluationChannel = 'Channel0' | 'Channel1' | 'Channel2' | 'Channel3' | 'Channel4' | 'Channel5' | 'Channel6' | 'Channel7' | 'Channel8' | 'Channel9' | 'Channel_MAX' | 'EGameplayModEvaluationChannel_MAX';
declare var EGameplayModEvaluationChannel : { Channel0:'Channel0',Channel1:'Channel1',Channel2:'Channel2',Channel3:'Channel3',Channel4:'Channel4',Channel5:'Channel5',Channel6:'Channel6',Channel7:'Channel7',Channel8:'Channel8',Channel9:'Channel9',Channel_MAX:'Channel_MAX',EGameplayModEvaluationChannel_MAX:'EGameplayModEvaluationChannel_MAX', };
declare class GameplayTag { 
	TagName: string;
	clone() : GameplayTag;
	static C(Other: UObject | any): GameplayTag;
	EqualEqual_GameplayTag(B: GameplayTag): boolean;
	GetDebugStringFromGameplayTag(): string;
	GetTagName(): string;
	IsGameplayTagValid(): boolean;
	MakeGameplayTagContainerFromTag(): GameplayTagContainer;
	MakeLiteralGameplayTag(): GameplayTag;
	MatchesAnyTags(OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	MatchesTag(TagTwo: GameplayTag,bExactMatch: boolean): boolean;
	NotEqual_GameplayTag(B: GameplayTag): boolean;
	NotEqual_TagTag(B: string): boolean;
	static EqualEqual_GameplayTag(A: GameplayTag,B: GameplayTag): boolean;
	static GetDebugStringFromGameplayTag(GameplayTag: GameplayTag): string;
	static GetTagName(GameplayTag: GameplayTag): string;
	static IsGameplayTagValid(GameplayTag: GameplayTag): boolean;
	static MakeGameplayTagContainerFromTag(SingleTag: GameplayTag): GameplayTagContainer;
	static MakeLiteralGameplayTag(Value: GameplayTag): GameplayTag;
	static MatchesAnyTags(TagOne: GameplayTag,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static MatchesTag(TagOne: GameplayTag,TagTwo: GameplayTag,bExactMatch: boolean): boolean;
	static NotEqual_GameplayTag(A: GameplayTag,B: GameplayTag): boolean;
	static NotEqual_TagTag(A: GameplayTag,B: string): boolean;
}

declare class GameplayTagQuery { 
	TokenStreamVersion: number;
	TagDictionary: GameplayTag[];
	QueryTokenStream: number[];
	UserDescription: string;
	AutoDescription: string;
	clone() : GameplayTagQuery;
	static C(Other: UObject | any): GameplayTagQuery;
	IsTagQueryEmpty(): boolean;
	MakeGameplayTagQuery(): GameplayTagQuery;
	static IsTagQueryEmpty(TagQuery: GameplayTagQuery): boolean;
	static MakeGameplayTagQuery(TagQuery: GameplayTagQuery): GameplayTagQuery;
}

declare class GameplayTagContainer { 
	GameplayTags: GameplayTag[];
	ParentTags: GameplayTag[];
	clone() : GameplayTagContainer;
	static C(Other: UObject | any): GameplayTagContainer;
	AddGameplayTag(Tag?: GameplayTag): {TagContainer: GameplayTagContainer};
	AppendGameplayTagContainers(InTagContainer?: GameplayTagContainer): {InOutTagContainer: GameplayTagContainer};
	BreakGameplayTagContainer(GameplayTags?: GameplayTag[]): {GameplayTags: GameplayTag[]};
	DoesContainerMatchTagQuery(TagQuery: GameplayTagQuery): boolean;
	EqualEqual_GameplayTagContainer(B: GameplayTagContainer): boolean;
	GetDebugStringFromGameplayTagContainer(): string;
	GetNumGameplayTagsInContainer(): number;
	HasAllTags(OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	HasAnyTags(OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	HasTag(Tag: GameplayTag,bExactMatch: boolean): boolean;
	MakeLiteralGameplayTagContainer(): GameplayTagContainer;
	NotEqual_GameplayTagContainer(B: GameplayTagContainer): boolean;
	NotEqual_TagContainerTagContainer(B: string): boolean;
	RemoveGameplayTag(Tag?: GameplayTag): {TagContainer: GameplayTagContainer, $: boolean};
	static AddGameplayTag(TagContainer?: GameplayTagContainer,Tag?: GameplayTag): {TagContainer: GameplayTagContainer};
	static AppendGameplayTagContainers(InOutTagContainer?: GameplayTagContainer,InTagContainer?: GameplayTagContainer): {InOutTagContainer: GameplayTagContainer};
	static BreakGameplayTagContainer(GameplayTagContainer: GameplayTagContainer,GameplayTags?: GameplayTag[]): {GameplayTags: GameplayTag[]};
	static DoesContainerMatchTagQuery(TagContainer: GameplayTagContainer,TagQuery: GameplayTagQuery): boolean;
	static EqualEqual_GameplayTagContainer(A: GameplayTagContainer,B: GameplayTagContainer): boolean;
	static GetDebugStringFromGameplayTagContainer(TagContainer: GameplayTagContainer): string;
	static GetNumGameplayTagsInContainer(TagContainer: GameplayTagContainer): number;
	static HasAllTags(TagContainer: GameplayTagContainer,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static HasAnyTags(TagContainer: GameplayTagContainer,OtherContainer: GameplayTagContainer,bExactMatch: boolean): boolean;
	static HasTag(TagContainer: GameplayTagContainer,Tag: GameplayTag,bExactMatch: boolean): boolean;
	static MakeLiteralGameplayTagContainer(Value: GameplayTagContainer): GameplayTagContainer;
	static NotEqual_GameplayTagContainer(A: GameplayTagContainer,B: GameplayTagContainer): boolean;
	static NotEqual_TagContainerTagContainer(A: GameplayTagContainer,B: string): boolean;
	static RemoveGameplayTag(TagContainer?: GameplayTagContainer,Tag?: GameplayTag): {TagContainer: GameplayTagContainer, $: boolean};
	static MakeGameplayTagContainerFromArray(GameplayTags: GameplayTag[]): GameplayTagContainer;
}

declare class AttributeBasedFloat { 
	Coefficient: ScalableFloat;
	PreMultiplyAdditiveValue: ScalableFloat;
	PostMultiplyAdditiveValue: ScalableFloat;
	BackingAttribute: GameplayEffectAttributeCaptureDefinition;
	AttributeCurve: CurveTableRowHandle;
	AttributeCalculationType: EAttributeBasedFloatCalculationType;
	FinalChannel: EGameplayModEvaluationChannel;
	SourceTagFilter: GameplayTagContainer;
	TargetTagFilter: GameplayTagContainer;
	clone() : AttributeBasedFloat;
	static C(Other: UObject | any): AttributeBasedFloat;
}

declare class GameplayEffectCalculation extends UObject { 
	RelevantAttributesToCapture: GameplayEffectAttributeCaptureDefinition[];
	static Load(ResourceName: string): GameplayEffectCalculation;
	static Find(Outer: UObject, ResourceName: string): GameplayEffectCalculation;
	static GetDefaultObject(): GameplayEffectCalculation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayEffectCalculation;
	static C(Other: UObject | any): GameplayEffectCalculation;
}

declare class GameplayEffectModifiedAttribute { 
	Attribute: GameplayAttribute;
	TotalMagnitude: number;
	clone() : GameplayEffectModifiedAttribute;
	static C(Other: UObject | any): GameplayEffectModifiedAttribute;
}

declare class GameplayEffectAttributeCaptureSpec { 
	BackingDefinition: GameplayEffectAttributeCaptureDefinition;
	clone() : GameplayEffectAttributeCaptureSpec;
	static C(Other: UObject | any): GameplayEffectAttributeCaptureSpec;
}

declare class GameplayEffectAttributeCaptureSpecContainer { 
	SourceAttributes: GameplayEffectAttributeCaptureSpec[];
	TargetAttributes: GameplayEffectAttributeCaptureSpec[];
	bHasNonSnapshottedAttributes: boolean;
	clone() : GameplayEffectAttributeCaptureSpecContainer;
	static C(Other: UObject | any): GameplayEffectAttributeCaptureSpecContainer;
}

declare class TagContainerAggregator { 
	CapturedActorTags: GameplayTagContainer;
	CapturedSpecTags: GameplayTagContainer;
	ScopedTags: GameplayTagContainer;
	clone() : TagContainerAggregator;
	static C(Other: UObject | any): TagContainerAggregator;
}

declare class ModifierSpec { 
	EvaluatedMagnitude: number;
	clone() : ModifierSpec;
	static C(Other: UObject | any): ModifierSpec;
}

declare type EGameplayAbilityReplicationPolicy = 'ReplicateNo' | 'ReplicateYes' | 'EGameplayAbilityReplicationPolicy_MAX';
declare var EGameplayAbilityReplicationPolicy : { ReplicateNo:'ReplicateNo',ReplicateYes:'ReplicateYes',EGameplayAbilityReplicationPolicy_MAX:'EGameplayAbilityReplicationPolicy_MAX', };
declare type EGameplayAbilityInstancingPolicy = 'NonInstanced' | 'InstancedPerActor' | 'InstancedPerExecution' | 'EGameplayAbilityInstancingPolicy_MAX';
declare var EGameplayAbilityInstancingPolicy : { NonInstanced:'NonInstanced',InstancedPerActor:'InstancedPerActor',InstancedPerExecution:'InstancedPerExecution',EGameplayAbilityInstancingPolicy_MAX:'EGameplayAbilityInstancingPolicy_MAX', };
declare type EGameplayAbilityActivationMode = 'Authority' | 'NonAuthority' | 'Predicting' | 'Confirmed' | 'Rejected' | 'EGameplayAbilityActivationMode_MAX';
declare var EGameplayAbilityActivationMode : { Authority:'Authority',NonAuthority:'NonAuthority',Predicting:'Predicting',Confirmed:'Confirmed',Rejected:'Rejected',EGameplayAbilityActivationMode_MAX:'EGameplayAbilityActivationMode_MAX', };
declare class PackageMap extends UObject { 
	static Load(ResourceName: string): PackageMap;
	static Find(Outer: UObject, ResourceName: string): PackageMap;
	static GetDefaultObject(): PackageMap;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PackageMap;
	static C(Other: UObject | any): PackageMap;
}

declare class PredictionKey { 
	PredictiveConnection: PackageMap;
	Current: any;
	Base: any;
	bIsStale: boolean;
	bIsServerInitiated: boolean;
	clone() : PredictionKey;
	static C(Other: UObject | any): PredictionKey;
}

declare class GameplayAbilityActivationInfo { 
	ActivationMode: EGameplayAbilityActivationMode;
	bCanBeEndedByOtherInstance: boolean;
	PredictionKeyWhenActivated: PredictionKey;
	clone() : GameplayAbilityActivationInfo;
	static C(Other: UObject | any): GameplayAbilityActivationInfo;
}

declare class Vector_NetQuantize extends Vector { 
	clone() : Vector_NetQuantize;
	static C(Other: UObject | any): Vector_NetQuantize;
	BreakVector_NetQuantize(X?: any,Y?: any,Z?: any): {X: any, Y: any, Z: any};
	static BreakVector_NetQuantize(InVec: Vector_NetQuantize,X?: any,Y?: any,Z?: any): {X: any, Y: any, Z: any};
	static MakeVector_NetQuantize(X: any,Y: any,Z: any): Vector_NetQuantize;
}

declare class Vector_NetQuantizeNormal extends Vector { 
	clone() : Vector_NetQuantizeNormal;
	static C(Other: UObject | any): Vector_NetQuantizeNormal;
	BreakVector_NetQuantizeNormal(X?: any,Y?: any,Z?: any): {X: any, Y: any, Z: any};
	static BreakVector_NetQuantizeNormal(InVec: Vector_NetQuantizeNormal,X?: any,Y?: any,Z?: any): {X: any, Y: any, Z: any};
	static MakeVector_NetQuantizeNormal(X: any,Y: any,Z: any): Vector_NetQuantizeNormal;
}

declare class ActorInstanceHandle { 
	Actor: any;
	clone() : ActorInstanceHandle;
	static C(Other: UObject | any): ActorInstanceHandle;
}

declare class Vector_NetQuantize10 extends Vector { 
	clone() : Vector_NetQuantize10;
	static C(Other: UObject | any): Vector_NetQuantize10;
	BreakVector_NetQuantize10(X?: any,Y?: any,Z?: any): {X: any, Y: any, Z: any};
	static BreakVector_NetQuantize10(InVec: Vector_NetQuantize10,X?: any,Y?: any,Z?: any): {X: any, Y: any, Z: any};
	static MakeVector_NetQuantize10(X: any,Y: any,Z: any): Vector_NetQuantize10;
}

declare class GameplayTagRequirements { 
	RequireTags: GameplayTagContainer;
	IgnoreTags: GameplayTagContainer;
	clone() : GameplayTagRequirements;
	static C(Other: UObject | any): GameplayTagRequirements;
}

declare class GameplayCueParameters { 
	NormalizedMagnitude: number;
	RawMagnitude: number;
	EffectContext: GameplayEffectContextHandle;
	MatchedTagName: GameplayTag;
	OriginalTag: GameplayTag;
	AggregatedSourceTags: GameplayTagContainer;
	AggregatedTargetTags: GameplayTagContainer;
	Location: Vector_NetQuantize10;
	Normal: Vector_NetQuantizeNormal;
	Instigator: any;
	EffectCauser: any;
	SourceObject: any;
	PhysicalMaterial: any;
	GameplayEffectLevel: number;
	AbilityLevel: number;
	TargetAttachComponent: any;
	bReplicateLocationWhenUsingMinimalRepProxy: boolean;
	clone() : GameplayCueParameters;
	static C(Other: UObject | any): GameplayCueParameters;
	BreakGameplayCueParameters(NormalizedMagnitude?: number,RawMagnitude?: number,EffectContext?: GameplayEffectContextHandle,MatchedTagName?: GameplayTag,OriginalTag?: GameplayTag,AggregatedSourceTags?: GameplayTagContainer,AggregatedTargetTags?: GameplayTagContainer,Location?: Vector,Normal?: Vector,Instigator?: Actor,EffectCauser?: Actor,SourceObject?: UObject,PhysicalMaterial?: PhysicalMaterial,GameplayEffectLevel?: number,AbilityLevel?: number,TargetAttachComponent?: SceneComponent,bReplicateLocationWhenUsingMinimalRepProxy?: boolean): {NormalizedMagnitude: number, RawMagnitude: number, EffectContext: GameplayEffectContextHandle, MatchedTagName: GameplayTag, OriginalTag: GameplayTag, AggregatedSourceTags: GameplayTagContainer, AggregatedTargetTags: GameplayTagContainer, Location: Vector, Normal: Vector, Instigator: Actor, EffectCauser: Actor, SourceObject: UObject, PhysicalMaterial: PhysicalMaterial, GameplayEffectLevel: number, AbilityLevel: number, TargetAttachComponent: SceneComponent, bReplicateLocationWhenUsingMinimalRepProxy: boolean};
	DoesGameplayCueMeetTagRequirements(SourceTagReqs: GameplayTagRequirements,TargetTagReqs: GameplayTagRequirements): boolean;
	GetActorByIndex(index: number): Actor;
	GetActorCount(): number;
	GetHitResult(): HitResult;
	GetInstigatorActor(): Actor;
	GetInstigatorTransform(): Transform;
	GetOrigin(): Vector;
	HasHitResult(): boolean;
	IsInstigatorLocallyControlled(): boolean;
	IsInstigatorLocallyControlledPlayer(): boolean;
	static BreakGameplayCueParameters(Parameters: GameplayCueParameters,NormalizedMagnitude?: number,RawMagnitude?: number,EffectContext?: GameplayEffectContextHandle,MatchedTagName?: GameplayTag,OriginalTag?: GameplayTag,AggregatedSourceTags?: GameplayTagContainer,AggregatedTargetTags?: GameplayTagContainer,Location?: Vector,Normal?: Vector,Instigator?: Actor,EffectCauser?: Actor,SourceObject?: UObject,PhysicalMaterial?: PhysicalMaterial,GameplayEffectLevel?: number,AbilityLevel?: number,TargetAttachComponent?: SceneComponent,bReplicateLocationWhenUsingMinimalRepProxy?: boolean): {NormalizedMagnitude: number, RawMagnitude: number, EffectContext: GameplayEffectContextHandle, MatchedTagName: GameplayTag, OriginalTag: GameplayTag, AggregatedSourceTags: GameplayTagContainer, AggregatedTargetTags: GameplayTagContainer, Location: Vector, Normal: Vector, Instigator: Actor, EffectCauser: Actor, SourceObject: UObject, PhysicalMaterial: PhysicalMaterial, GameplayEffectLevel: number, AbilityLevel: number, TargetAttachComponent: SceneComponent, bReplicateLocationWhenUsingMinimalRepProxy: boolean};
	static DoesGameplayCueMeetTagRequirements(Parameters: GameplayCueParameters,SourceTagReqs: GameplayTagRequirements,TargetTagReqs: GameplayTagRequirements): boolean;
	static GetActorByIndex(Parameters: GameplayCueParameters,index: number): Actor;
	static GetActorCount(Parameters: GameplayCueParameters): number;
	static GetHitResult(Parameters: GameplayCueParameters): HitResult;
	static GetInstigatorActor(Parameters: GameplayCueParameters): Actor;
	static GetInstigatorTransform(Parameters: GameplayCueParameters): Transform;
	static GetOrigin(Parameters: GameplayCueParameters): Vector;
	static HasHitResult(Parameters: GameplayCueParameters): boolean;
	static IsInstigatorLocallyControlled(Parameters: GameplayCueParameters): boolean;
	static IsInstigatorLocallyControlledPlayer(Parameters: GameplayCueParameters): boolean;
	static MakeGameplayCueParameters(NormalizedMagnitude: number,RawMagnitude: number,EffectContext: GameplayEffectContextHandle,MatchedTagName: GameplayTag,OriginalTag: GameplayTag,AggregatedSourceTags: GameplayTagContainer,AggregatedTargetTags: GameplayTagContainer,Location: Vector,Normal: Vector,Instigator: Actor,EffectCauser: Actor,SourceObject: UObject,PhysicalMaterial: PhysicalMaterial,GameplayEffectLevel: number,AbilityLevel: number,TargetAttachComponent: SceneComponent,bReplicateLocationWhenUsingMinimalRepProxy: boolean): GameplayCueParameters;
}

declare class GameplayTargetDataFilterHandle { 
	clone() : GameplayTargetDataFilterHandle;
	static C(Other: UObject | any): GameplayTargetDataFilterHandle;
}

declare class GameplayAbilityTargetDataHandle { 
	clone() : GameplayAbilityTargetDataHandle;
	static C(Other: UObject | any): GameplayAbilityTargetDataHandle;
	AppendTargetDataHandle(HandleToAdd: GameplayAbilityTargetDataHandle): GameplayAbilityTargetDataHandle;
	DoesTargetDataContainActor(index: number,Actor: Actor): boolean;
	FilterTargetData(ActorFilterClass: GameplayTargetDataFilterHandle): GameplayAbilityTargetDataHandle;
	GetActorsFromTargetData(index: number): Actor[];
	GetAllActorsFromTargetData(): Actor[];
	GetDataCountFromTargetData(): number;
	GetHitResultFromTargetData(index: number): HitResult;
	GetTargetDataEndPoint(index: number): Vector;
	GetTargetDataEndPointTransform(index: number): Transform;
	GetTargetDataOrigin(index: number): Transform;
	TargetDataHasActor(index: number): boolean;
	TargetDataHasEndPoint(index: number): boolean;
	TargetDataHasHitResult(index: number): boolean;
	TargetDataHasOrigin(index: number): boolean;
	static AppendTargetDataHandle(TargetHandle: GameplayAbilityTargetDataHandle,HandleToAdd: GameplayAbilityTargetDataHandle): GameplayAbilityTargetDataHandle;
	static DoesTargetDataContainActor(TargetData: GameplayAbilityTargetDataHandle,index: number,Actor: Actor): boolean;
	static FilterTargetData(TargetDataHandle: GameplayAbilityTargetDataHandle,ActorFilterClass: GameplayTargetDataFilterHandle): GameplayAbilityTargetDataHandle;
	static GetActorsFromTargetData(TargetData: GameplayAbilityTargetDataHandle,index: number): Actor[];
	static GetAllActorsFromTargetData(TargetData: GameplayAbilityTargetDataHandle): Actor[];
	static GetDataCountFromTargetData(TargetData: GameplayAbilityTargetDataHandle): number;
	static GetHitResultFromTargetData(HitResult: GameplayAbilityTargetDataHandle,index: number): HitResult;
	static GetTargetDataEndPoint(TargetData: GameplayAbilityTargetDataHandle,index: number): Vector;
	static GetTargetDataEndPointTransform(TargetData: GameplayAbilityTargetDataHandle,index: number): Transform;
	static GetTargetDataOrigin(TargetData: GameplayAbilityTargetDataHandle,index: number): Transform;
	static TargetDataHasActor(TargetData: GameplayAbilityTargetDataHandle,index: number): boolean;
	static TargetDataHasEndPoint(TargetData: GameplayAbilityTargetDataHandle,index: number): boolean;
	static TargetDataHasHitResult(HitResult: GameplayAbilityTargetDataHandle,index: number): boolean;
	static TargetDataHasOrigin(TargetData: GameplayAbilityTargetDataHandle,index: number): boolean;
	static AbilityTargetDataFromActorArray(ActorArray: Actor[],OneTargetPerHandle: boolean): GameplayAbilityTargetDataHandle;
}

declare class HitResult { 
	FaceIndex: number;
	Time: number;
	Distance: number;
	Location: Vector_NetQuantize;
	ImpactPoint: Vector_NetQuantize;
	Normal: Vector_NetQuantizeNormal;
	ImpactNormal: Vector_NetQuantizeNormal;
	TraceStart: Vector_NetQuantize;
	TraceEnd: Vector_NetQuantize;
	PenetrationDepth: number;
	MyItem: number;
	Item: number;
	ElementIndex: number;
	bBlockingHit: boolean;
	bStartPenetrating: boolean;
	PhysMaterial: any;
	HitObjectHandle: ActorInstanceHandle;
	Component: any;
	BoneName: string;
	MyBoneName: string;
	clone() : HitResult;
	static C(Other: UObject | any): HitResult;
	MakeGameplayCueParametersFromHitResult(): GameplayCueParameters;
	AbilityTargetDataFromHitResult(): GameplayAbilityTargetDataHandle;
	BreakHitResult(bBlockingHit?: boolean,bInitialOverlap?: boolean,Time?: number,Distance?: number,Location?: Vector,ImpactPoint?: Vector,Normal?: Vector,ImpactNormal?: Vector,PhysMat?: PhysicalMaterial,HitActor?: Actor,HitComponent?: PrimitiveComponent,HitBoneName?: string,BoneName?: string,HitItem?: number,ElementIndex?: number,FaceIndex?: number,TraceStart?: Vector,TraceEnd?: Vector): {bBlockingHit: boolean, bInitialOverlap: boolean, Time: number, Distance: number, Location: Vector, ImpactPoint: Vector, Normal: Vector, ImpactNormal: Vector, PhysMat: PhysicalMaterial, HitActor: Actor, HitComponent: PrimitiveComponent, HitBoneName: string, BoneName: string, HitItem: number, ElementIndex: number, FaceIndex: number, TraceStart: Vector, TraceEnd: Vector};
	FindCollisionUV(UVChannel: number,UV?: Vector2D): {UV: Vector2D, $: boolean};
	GetSurfaceType(): EPhysicalSurface;
	static MakeGameplayCueParametersFromHitResult(HitResult: HitResult): GameplayCueParameters;
	static AbilityTargetDataFromHitResult(HitResult: HitResult): GameplayAbilityTargetDataHandle;
	static BreakHitResult(Hit: HitResult,bBlockingHit?: boolean,bInitialOverlap?: boolean,Time?: number,Distance?: number,Location?: Vector,ImpactPoint?: Vector,Normal?: Vector,ImpactNormal?: Vector,PhysMat?: PhysicalMaterial,HitActor?: Actor,HitComponent?: PrimitiveComponent,HitBoneName?: string,BoneName?: string,HitItem?: number,ElementIndex?: number,FaceIndex?: number,TraceStart?: Vector,TraceEnd?: Vector): {bBlockingHit: boolean, bInitialOverlap: boolean, Time: number, Distance: number, Location: Vector, ImpactPoint: Vector, Normal: Vector, ImpactNormal: Vector, PhysMat: PhysicalMaterial, HitActor: Actor, HitComponent: PrimitiveComponent, HitBoneName: string, BoneName: string, HitItem: number, ElementIndex: number, FaceIndex: number, TraceStart: Vector, TraceEnd: Vector};
	static FindCollisionUV(Hit: HitResult,UVChannel: number,UV?: Vector2D): {UV: Vector2D, $: boolean};
	static GetSurfaceType(Hit: HitResult): EPhysicalSurface;
	static MakeHitResult(bBlockingHit: boolean,bInitialOverlap: boolean,Time: number,Distance: number,Location: Vector,ImpactPoint: Vector,Normal: Vector,ImpactNormal: Vector,PhysMat: PhysicalMaterial,HitActor: Actor,HitComponent: PrimitiveComponent,HitBoneName: string,BoneName: string,HitItem: number,ElementIndex: number,FaceIndex: number,TraceStart: Vector,TraceEnd: Vector): HitResult;
}

declare class GameplayEffectContextHandle { 
	clone() : GameplayEffectContextHandle;
	static C(Other: UObject | any): GameplayEffectContextHandle;
	EffectContextAddHitResult(HitResult: HitResult,bReset: boolean): void;
	EffectContextGetEffectCauser(): Actor;
	EffectContextGetHitResult(): HitResult;
	EffectContextGetInstigatorActor(): Actor;
	EffectContextGetOrigin(): Vector;
	EffectContextGetOriginalInstigatorActor(): Actor;
	EffectContextGetSourceObject(): UObject;
	EffectContextHasHitResult(): boolean;
	EffectContextIsInstigatorLocallyControlled(): boolean;
	EffectContextIsValid(): boolean;
	EffectContextSetOrigin(Origin: Vector): void;
	static EffectContextAddHitResult(EffectContext: GameplayEffectContextHandle,HitResult: HitResult,bReset: boolean): void;
	static EffectContextGetEffectCauser(EffectContext: GameplayEffectContextHandle): Actor;
	static EffectContextGetHitResult(EffectContext: GameplayEffectContextHandle): HitResult;
	static EffectContextGetInstigatorActor(EffectContext: GameplayEffectContextHandle): Actor;
	static EffectContextGetOrigin(EffectContext: GameplayEffectContextHandle): Vector;
	static EffectContextGetOriginalInstigatorActor(EffectContext: GameplayEffectContextHandle): Actor;
	static EffectContextGetSourceObject(EffectContext: GameplayEffectContextHandle): UObject;
	static EffectContextHasHitResult(EffectContext: GameplayEffectContextHandle): boolean;
	static EffectContextIsInstigatorLocallyControlled(EffectContext: GameplayEffectContextHandle): boolean;
	static EffectContextIsValid(EffectContext: GameplayEffectContextHandle): boolean;
	static EffectContextSetOrigin(EffectContext: GameplayEffectContextHandle,Origin: Vector): void;
}

declare class GameplayEventData { 
	EventTag: GameplayTag;
	Instigator: Actor;
	Target: Actor;
	OptionalObject: UObject;
	OptionalObject2: UObject;
	ContextHandle: GameplayEffectContextHandle;
	InstigatorTags: GameplayTagContainer;
	TargetTags: GameplayTagContainer;
	EventMagnitude: number;
	TargetData: GameplayAbilityTargetDataHandle;
	clone() : GameplayEventData;
	static C(Other: UObject | any): GameplayEventData;
}

declare type EGameplayAbilityNetExecutionPolicy = 'LocalPredicted' | 'LocalOnly' | 'ServerInitiated' | 'ServerOnly' | 'EGameplayAbilityNetExecutionPolicy_MAX';
declare var EGameplayAbilityNetExecutionPolicy : { LocalPredicted:'LocalPredicted',LocalOnly:'LocalOnly',ServerInitiated:'ServerInitiated',ServerOnly:'ServerOnly',EGameplayAbilityNetExecutionPolicy_MAX:'EGameplayAbilityNetExecutionPolicy_MAX', };
declare type EGameplayAbilityNetSecurityPolicy = 'ClientOrServer' | 'ServerOnlyExecution' | 'ServerOnlyTermination' | 'ServerOnly' | 'EGameplayAbilityNetSecurityPolicy_MAX';
declare var EGameplayAbilityNetSecurityPolicy : { ClientOrServer:'ClientOrServer',ServerOnlyExecution:'ServerOnlyExecution',ServerOnlyTermination:'ServerOnlyTermination',ServerOnly:'ServerOnly',EGameplayAbilityNetSecurityPolicy_MAX:'EGameplayAbilityNetSecurityPolicy_MAX', };
declare type EGameplayAbilityTriggerSource = 'GameplayEvent' | 'OwnedTagAdded' | 'OwnedTagPresent' | 'EGameplayAbilityTriggerSource_MAX';
declare var EGameplayAbilityTriggerSource : { GameplayEvent:'GameplayEvent',OwnedTagAdded:'OwnedTagAdded',OwnedTagPresent:'OwnedTagPresent',EGameplayAbilityTriggerSource_MAX:'EGameplayAbilityTriggerSource_MAX', };
declare class AbilityTriggerData { 
	TriggerTag: GameplayTag;
	TriggerSource: EGameplayAbilityTriggerSource;
	clone() : AbilityTriggerData;
	static C(Other: UObject | any): AbilityTriggerData;
}

declare type ETaskResourceOverlapPolicy = 'StartOnTop' | 'StartAtEnd' | 'ETaskResourceOverlapPolicy_MAX';
declare var ETaskResourceOverlapPolicy : { StartOnTop:'StartOnTop',StartAtEnd:'StartAtEnd',ETaskResourceOverlapPolicy_MAX:'ETaskResourceOverlapPolicy_MAX', };
declare class GameplayTask extends UObject { 
	InstanceName: string;
	ResourceOverlapPolicy: ETaskResourceOverlapPolicy;
	ChildTask: GameplayTask;
	static Load(ResourceName: string): GameplayTask;
	static Find(Outer: UObject, ResourceName: string): GameplayTask;
	static GetDefaultObject(): GameplayTask;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask;
	ReadyForActivation(): void;
	EndTask(): void;
	static C(Other: UObject | any): GameplayTask;
}

declare type EBoneTranslationRetargetingMode = 'Animation' | 'Skeleton' | 'AnimationScaled' | 'AnimationRelative' | 'OrientAndScale' | 'EBoneTranslationRetargetingMode_MAX';
declare var EBoneTranslationRetargetingMode : { Animation:'Animation',Skeleton:'Skeleton',AnimationScaled:'AnimationScaled',AnimationRelative:'AnimationRelative',OrientAndScale:'OrientAndScale',EBoneTranslationRetargetingMode_MAX:'EBoneTranslationRetargetingMode_MAX', };
declare class BoneNode { 
	Name: string;
	ParentIndex: number;
	TranslationRetargetingMode: EBoneTranslationRetargetingMode;
	clone() : BoneNode;
	static C(Other: UObject | any): BoneNode;
}

declare class VirtualBone { 
	SourceBoneName: string;
	TargetBoneName: string;
	VirtualBoneName: string;
	clone() : VirtualBone;
	static C(Other: UObject | any): VirtualBone;
}

declare class MeshComponent extends PrimitiveComponent { 
	OverrideMaterials: MaterialInterface[];
	bEnableMaterialParameterCaching: boolean;
	static Load(ResourceName: string): MeshComponent;
	static Find(Outer: UObject, ResourceName: string): MeshComponent;
	static GetDefaultObject(): MeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshComponent;
	SetVectorParameterValueOnMaterials(ParameterName: string,ParameterValue: Vector): void;
	SetScalarParameterValueOnMaterials(ParameterName: string,ParameterValue: number): void;
	PrestreamTextures(Seconds: number,bPrioritizeCharacterTextures: boolean,CinematicTextureGroups: number): void;
	IsMaterialSlotNameValid(MaterialSlotName: string): boolean;
	GetMaterialSlotNames(): string[];
	GetMaterials(): MaterialInterface[];
	GetMaterialIndex(MaterialSlotName: string): number;
	static C(Other: UObject | any): MeshComponent;
}

declare class SkeletalMeshEditorData extends UObject { 
	static Load(ResourceName: string): SkeletalMeshEditorData;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshEditorData;
	static GetDefaultObject(): SkeletalMeshEditorData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshEditorData;
	static C(Other: UObject | any): SkeletalMeshEditorData;
}

declare class BoxSphereBounds { 
	Origin: Vector;
	BoxExtent: Vector;
	SphereRadius: any;
	clone() : BoxSphereBounds;
	static C(Other: UObject | any): BoxSphereBounds;
	BreakBoxSphereBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	static BreakBoxSphereBounds(InBoxSphereBounds: BoxSphereBounds,Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
}

declare class MeshUVChannelInfo { 
	bInitialized: boolean;
	bOverrideDensities: boolean;
	LocalUVDensities: number;
	clone() : MeshUVChannelInfo;
	static C(Other: UObject | any): MeshUVChannelInfo;
}

declare class SkeletalMaterial { 
	MaterialInterface: MaterialInterface;
	MaterialSlotName: string;
	bEnableShadowCasting: boolean;
	bRecomputeTangent: boolean;
	ImportedMaterialSlotName: string;
	UVChannelData: MeshUVChannelInfo;
	clone() : SkeletalMaterial;
	static C(Other: UObject | any): SkeletalMaterial;
}

declare class BoneMirrorInfo { 
	SourceIndex: number;
	BoneFlipAxis: EAxis;
	clone() : BoneMirrorInfo;
	static C(Other: UObject | any): BoneMirrorInfo;
}

declare class SkeletalMeshBuildSettings { 
	bRecomputeNormals: boolean;
	bRecomputeTangents: boolean;
	bUseMikkTSpace: boolean;
	bComputeWeightedNormals: boolean;
	bRemoveDegenerates: boolean;
	bUseHighPrecisionTangentBasis: boolean;
	bUseFullPrecisionUVs: boolean;
	bUseBackwardsCompatibleF16TruncUVs: boolean;
	ThresholdPosition: number;
	ThresholdTangentNormal: number;
	ThresholdUV: number;
	MorphThresholdPosition: number;
	clone() : SkeletalMeshBuildSettings;
	static C(Other: UObject | any): SkeletalMeshBuildSettings;
}

declare type SkeletalMeshTerminationCriterion = 'SMTC_NumOfTriangles' | 'SMTC_NumOfVerts' | 'SMTC_TriangleOrVert' | 'SMTC_AbsNumOfTriangles' | 'SMTC_AbsNumOfVerts' | 'SMTC_AbsTriangleOrVert' | 'SMTC_MAX';
declare var SkeletalMeshTerminationCriterion : { SMTC_NumOfTriangles:'SMTC_NumOfTriangles',SMTC_NumOfVerts:'SMTC_NumOfVerts',SMTC_TriangleOrVert:'SMTC_TriangleOrVert',SMTC_AbsNumOfTriangles:'SMTC_AbsNumOfTriangles',SMTC_AbsNumOfVerts:'SMTC_AbsNumOfVerts',SMTC_AbsTriangleOrVert:'SMTC_AbsTriangleOrVert',SMTC_MAX:'SMTC_MAX', };
declare type SkeletalMeshOptimizationType = 'SMOT_NumOfTriangles' | 'SMOT_MaxDeviation' | 'SMOT_TriangleOrDeviation' | 'SMOT_MAX';
declare var SkeletalMeshOptimizationType : { SMOT_NumOfTriangles:'SMOT_NumOfTriangles',SMOT_MaxDeviation:'SMOT_MaxDeviation',SMOT_TriangleOrDeviation:'SMOT_TriangleOrDeviation',SMOT_MAX:'SMOT_MAX', };
declare type SkeletalMeshOptimizationImportance = 'SMOI_Off' | 'SMOI_Lowest' | 'SMOI_Low' | 'SMOI_Normal' | 'SMOI_High' | 'SMOI_Highest' | 'SMOI_MAX';
declare var SkeletalMeshOptimizationImportance : { SMOI_Off:'SMOI_Off',SMOI_Lowest:'SMOI_Lowest',SMOI_Low:'SMOI_Low',SMOI_Normal:'SMOI_Normal',SMOI_High:'SMOI_High',SMOI_Highest:'SMOI_Highest',SMOI_MAX:'SMOI_MAX', };
declare class BoneReference { 
	BoneName: string;
	clone() : BoneReference;
	static C(Other: UObject | any): BoneReference;
}

declare class FrameRate { 
	Numerator: number;
	Denominator: number;
	clone() : FrameRate;
	static C(Other: UObject | any): FrameRate;
	BreakFrameRate(Numerator?: number,Denominator?: number): {Numerator: number, Denominator: number};
	Conv_FrameRateToSeconds(): number;
	IsValid_Framerate(): boolean;
	IsValid_MultipleOf(OtherFramerate: FrameRate): boolean;
	static BreakFrameRate(InFrameRate: FrameRate,Numerator?: number,Denominator?: number): {Numerator: number, Denominator: number};
	static Conv_FrameRateToSeconds(InFrameRate: FrameRate): number;
	static IsValid_Framerate(InFrameRate: FrameRate): boolean;
	static IsValid_MultipleOf(InFrameRate: FrameRate,OtherFramerate: FrameRate): boolean;
	static MakeFrameRate(Numerator: number,Denominator: number): FrameRate;
	static GetTimecodeFrameRate(): FrameRate;
}

declare class TrackToSkeletonMap { 
	BoneTreeIndex: number;
	clone() : TrackToSkeletonMap;
	static C(Other: UObject | any): TrackToSkeletonMap;
}

declare class AnimBoneCompressionCodec extends UObject { 
	Description: string;
	static Load(ResourceName: string): AnimBoneCompressionCodec;
	static Find(Outer: UObject, ResourceName: string): AnimBoneCompressionCodec;
	static GetDefaultObject(): AnimBoneCompressionCodec;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBoneCompressionCodec;
	static C(Other: UObject | any): AnimBoneCompressionCodec;
}

declare class AnimBoneCompressionSettings extends UObject { 
	Codecs: AnimBoneCompressionCodec[];
	ErrorThreshold: number;
	bForceBelowThreshold: boolean;
	static Load(ResourceName: string): AnimBoneCompressionSettings;
	static Find(Outer: UObject, ResourceName: string): AnimBoneCompressionSettings;
	static GetDefaultObject(): AnimBoneCompressionSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBoneCompressionSettings;
	static C(Other: UObject | any): AnimBoneCompressionSettings;
}

declare class AnimCurveCompressionCodec extends UObject { 
	static Load(ResourceName: string): AnimCurveCompressionCodec;
	static Find(Outer: UObject, ResourceName: string): AnimCurveCompressionCodec;
	static GetDefaultObject(): AnimCurveCompressionCodec;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCurveCompressionCodec;
	static C(Other: UObject | any): AnimCurveCompressionCodec;
}

declare class AnimCurveCompressionSettings extends UObject { 
	Codec: AnimCurveCompressionCodec;
	static Load(ResourceName: string): AnimCurveCompressionSettings;
	static Find(Outer: UObject, ResourceName: string): AnimCurveCompressionSettings;
	static GetDefaultObject(): AnimCurveCompressionSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCurveCompressionSettings;
	static C(Other: UObject | any): AnimCurveCompressionSettings;
}

declare type EAdditiveAnimationType = 'AAT_None' | 'AAT_LocalSpaceBase' | 'AAT_RotationOffsetMeshSpace' | 'AAT_MAX';
declare var EAdditiveAnimationType : { AAT_None:'AAT_None',AAT_LocalSpaceBase:'AAT_LocalSpaceBase',AAT_RotationOffsetMeshSpace:'AAT_RotationOffsetMeshSpace',AAT_MAX:'AAT_MAX', };
declare type EAdditiveBasePoseType = 'ABPT_None' | 'ABPT_RefPose' | 'ABPT_AnimScaled' | 'ABPT_AnimFrame' | 'ABPT_LocalAnimFrame' | 'ABPT_MAX';
declare var EAdditiveBasePoseType : { ABPT_None:'ABPT_None',ABPT_RefPose:'ABPT_RefPose',ABPT_AnimScaled:'ABPT_AnimScaled',ABPT_AnimFrame:'ABPT_AnimFrame',ABPT_LocalAnimFrame:'ABPT_LocalAnimFrame',ABPT_MAX:'ABPT_MAX', };
declare type EAnimInterpolationType = 'Linear' | 'Step' | 'EAnimInterpolationType_MAX';
declare var EAnimInterpolationType : { Linear:'Linear',Step:'Step',EAnimInterpolationType_MAX:'EAnimInterpolationType_MAX', };
declare type ERootMotionRootLock = 'RefPose' | 'AnimFirstFrame' | 'Zero' | 'ERootMotionRootLock_MAX';
declare var ERootMotionRootLock : { RefPose:'RefPose',AnimFirstFrame:'AnimFirstFrame',Zero:'Zero',ERootMotionRootLock_MAX:'ERootMotionRootLock_MAX', };
declare class AnimSyncMarker { 
	MarkerName: string;
	Time: number;
	TrackIndex: number;
	Guid: Guid;
	clone() : AnimSyncMarker;
	static C(Other: UObject | any): AnimSyncMarker;
}

declare class Quat4f { 
	X: number;
	Y: number;
	Z: number;
	W: number;
	clone() : Quat4f;
	static C(Other: UObject | any): Quat4f;
}

declare class RawAnimSequenceTrack { 
	PosKeys: Vector3f[];
	RotKeys: Quat4f[];
	ScaleKeys: Vector3f[];
	clone() : RawAnimSequenceTrack;
	static C(Other: UObject | any): RawAnimSequenceTrack;
	GetPositionalKeys(): Vector[];
	GetRotationalKeys(): Quat[];
	GetScaleKeys(): Vector[];
	static GetPositionalKeys(Track: RawAnimSequenceTrack): Vector[];
	static GetRotationalKeys(Track: RawAnimSequenceTrack): Quat[];
	static GetScaleKeys(Track: RawAnimSequenceTrack): Vector[];
}

declare class BoneAnimationTrack { 
	InternalTrackData: RawAnimSequenceTrack;
	BoneTreeIndex: number;
	Name: string;
	clone() : BoneAnimationTrack;
	static C(Other: UObject | any): BoneAnimationTrack;
}

declare class CustomAttribute { 
	Name: string;
	VariantType: number;
	Times: number[];
	clone() : CustomAttribute;
	static C(Other: UObject | any): CustomAttribute;
}

declare class CustomAttributePerBoneData { 
	BoneTreeIndex: number;
	Attributes: CustomAttribute[];
	clone() : CustomAttributePerBoneData;
	static C(Other: UObject | any): CustomAttributePerBoneData;
}

declare type ERawCurveTrackTypes = 'RCT_Float' | 'RCT_Vector' | 'RCT_Transform' | 'RCT_MAX';
declare var ERawCurveTrackTypes : { RCT_Float:'RCT_Float',RCT_Vector:'RCT_Vector',RCT_Transform:'RCT_Transform',RCT_MAX:'RCT_MAX', };
declare class AnimSequence extends AnimSequenceBase { 
	ImportFileFramerate: number;
	ImportResampleFramerate: number;
	NumFrames: number;
	NumberOfKeys: number;
	SamplingFrameRate: FrameRate;
	TrackToSkeletonMapTable: TrackToSkeletonMap[];
	RawDataGuid: Guid;
	AnimationTrackNames: string[];
	bAllowFrameStripping: boolean;
	CompressionErrorThresholdScale: number;
	BoneCompressionSettings: AnimBoneCompressionSettings;
	CurveCompressionSettings: AnimCurveCompressionSettings;
	AdditiveAnimType: EAdditiveAnimationType;
	RefPoseType: EAdditiveBasePoseType;
	RefFrameIndex: number;
	RefPoseSeq: AnimSequence;
	RetargetSource: string;
	RetargetSourceAsset: SkeletalMesh;
	RetargetSourceAssetReferencePose: Transform[];
	Interpolation: EAnimInterpolationType;
	bEnableRootMotion: boolean;
	RootMotionRootLock: ERootMotionRootLock;
	bForceRootLock: boolean;
	bUseNormalizedRootMotionScale: boolean;
	bRootMotionSettingsCopiedFromMontage: boolean;
	CompressCommandletVersion: number;
	bDoNotOverrideCompression: boolean;
	AssetImportData: AssetImportData;
	SourceFilePath: string;
	SourceFileTimestamp: string;
	bNeedsRebake: boolean;
	AuthoredSyncMarkers: AnimSyncMarker[];
	TargetFrameRate: FrameRate;
	NumberOfSampledKeys: number;
	NumberOfSampledFrames: number;
	ResampledAnimationTrackData: BoneAnimationTrack[];
	PerBoneCustomAttributeData: CustomAttributePerBoneData[];
	AttributeCurves: any;
	static Load(ResourceName: string): AnimSequence;
	static Find(Outer: UObject, ResourceName: string): AnimSequence;
	static GetDefaultObject(): AnimSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequence;
	RemoveCustomAttribute(BoneName: string,AttributeName: string): void;
	RemoveAllCustomAttributesForBone(BoneName: string): void;
	RemoveAllCustomAttributes(): void;
	AddBoneStringCustomAttribute(BoneName: string,AttributeName: string,TimeKeys: number[],ValueKeys: string[]): void;
	AddBoneIntegerCustomAttribute(BoneName: string,AttributeName: string,TimeKeys: number[],ValueKeys: number[]): void;
	AddBoneFloatCustomAttribute(BoneName: string,AttributeName: string,TimeKeys: number[],ValueKeys: number[]): void;
	static C(Other: UObject | any): AnimSequence;
	AddAnimationSyncMarker(MarkerName: string,Time: number,NotifyTrackName: string): void;
	AddCurve(CurveName: string,CurveType: ERawCurveTrackTypes,bMetaDataCurve: boolean): void;
	AddFloatCurveKey(CurveName: string,Time: number,Value: number): void;
	AddFloatCurveKeys(CurveName: string,Times: number[],Values: number[]): void;
	AddTransformationCurveKey(CurveName: string,Time: number,Transform: Transform): void;
	AddTransformationCurveKeys(CurveName: string,Times: number[],Transforms: Transform[]): void;
	AddVectorCurveKey(CurveName: string,Time: number,Vector: Vector): void;
	AddVectorCurveKeys(CurveName: string,Times: number[],Vectors: Vector[]): void;
	AddVirtualBone(SourceBoneName: string,TargetBoneName: string,VirtualBoneName?: string): {VirtualBoneName: string};
	DoesBoneNameExist(BoneName: string,bExists?: boolean): {bExists: boolean};
	DoesCurveExist(CurveName: string,CurveType: ERawCurveTrackTypes): boolean;
	FinalizeBoneAnimation(): void;
	GetAdditiveAnimationType(AdditiveAnimationType?: EAdditiveAnimationType): {AdditiveAnimationType: EAdditiveAnimationType};
	GetAdditiveBasePoseType(AdditiveBasePoseType?: EAdditiveBasePoseType): {AdditiveBasePoseType: EAdditiveBasePoseType};
	GetAnimationCurveNames(CurveType: ERawCurveTrackTypes,CurveNames?: string[]): {CurveNames: string[]};
	GetAnimationInterpolationType(InterpolationType?: EAnimInterpolationType): {InterpolationType: EAnimInterpolationType};
	GetAnimationSyncMarkers(Markers?: AnimSyncMarker[]): {Markers: AnimSyncMarker[]};
	GetAnimationSyncMarkersForTrack(NotifyTrackName: string,Markers?: AnimSyncMarker[]): {Markers: AnimSyncMarker[]};
	GetBoneCompressionSettings(CompressionSettings?: AnimBoneCompressionSettings): {CompressionSettings: AnimBoneCompressionSettings};
	GetCurveCompressionSettings(CompressionSettings?: AnimCurveCompressionSettings): {CompressionSettings: AnimCurveCompressionSettings};
	GetFloatKeys(CurveName: string,Times?: number[],Values?: number[]): {Times: number[], Values: number[]};
	GetRootMotionLockType(LockType?: ERootMotionRootLock): {LockType: ERootMotionRootLock};
	GetTransformationKeys(CurveName: string,Times?: number[],Values?: Transform[]): {Times: number[], Values: Transform[]};
	GetUniqueMarkerNames(MarkerNames?: string[]): {MarkerNames: string[]};
	GetVectorKeys(CurveName: string,Times?: number[],Values?: Vector[]): {Times: number[], Values: Vector[]};
	IsRootMotionEnabled(): boolean;
	IsRootMotionLockForced(): boolean;
	IsValidAnimationSyncMarkerName(MarkerName: string): boolean;
	RemoveAllAnimationSyncMarkers(): void;
	RemoveAllBoneAnimation(): void;
	RemoveAllCurveData(): void;
	RemoveAllVirtualBones(): void;
	RemoveAnimationSyncMarkersByName(MarkerName: string): number;
	RemoveAnimationSyncMarkersByTrack(NotifyTrackName: string): number;
	RemoveBoneAnimation(BoneName: string,bIncludeChildren: boolean,bFinalize: boolean): void;
	RemoveCurve(CurveName: string,bRemoveNameFromSkeleton: boolean): void;
	RemoveVirtualBone(VirtualBoneName: string): void;
	RemoveVirtualBones(VirtualBoneNames: string[]): void;
	SetAdditiveAnimationType(AdditiveAnimationType: EAdditiveAnimationType): void;
	SetAdditiveBasePoseType(AdditiveBasePoseType: EAdditiveBasePoseType): void;
	SetAnimationInterpolationType(InterpolationType: EAnimInterpolationType): void;
	SetBoneCompressionSettings(CompressionSettings: AnimBoneCompressionSettings): void;
	SetCurveCompressionSettings(CompressionSettings: AnimCurveCompressionSettings): void;
	SetIsRootMotionLockForced(bForced: boolean): void;
	SetRootMotionEnabled(bEnabled: boolean): void;
	SetRootMotionLockType(RootMotionLockType: ERootMotionRootLock): void;
	static AddAnimationSyncMarker(AnimationSequence: AnimSequence,MarkerName: string,Time: number,NotifyTrackName: string): void;
	static AddCurve(AnimationSequence: AnimSequence,CurveName: string,CurveType: ERawCurveTrackTypes,bMetaDataCurve: boolean): void;
	static AddFloatCurveKey(AnimationSequence: AnimSequence,CurveName: string,Time: number,Value: number): void;
	static AddFloatCurveKeys(AnimationSequence: AnimSequence,CurveName: string,Times: number[],Values: number[]): void;
	static AddTransformationCurveKey(AnimationSequence: AnimSequence,CurveName: string,Time: number,Transform: Transform): void;
	static AddTransformationCurveKeys(AnimationSequence: AnimSequence,CurveName: string,Times: number[],Transforms: Transform[]): void;
	static AddVectorCurveKey(AnimationSequence: AnimSequence,CurveName: string,Time: number,Vector: Vector): void;
	static AddVectorCurveKeys(AnimationSequence: AnimSequence,CurveName: string,Times: number[],Vectors: Vector[]): void;
	static AddVirtualBone(AnimationSequence: AnimSequence,SourceBoneName: string,TargetBoneName: string,VirtualBoneName?: string): {VirtualBoneName: string};
	static DoesBoneNameExist(AnimationSequence: AnimSequence,BoneName: string,bExists?: boolean): {bExists: boolean};
	static DoesCurveExist(AnimationSequence: AnimSequence,CurveName: string,CurveType: ERawCurveTrackTypes): boolean;
	static FinalizeBoneAnimation(AnimationSequence: AnimSequence): void;
	static GetAdditiveAnimationType(AnimationSequence: AnimSequence,AdditiveAnimationType?: EAdditiveAnimationType): {AdditiveAnimationType: EAdditiveAnimationType};
	static GetAdditiveBasePoseType(AnimationSequence: AnimSequence,AdditiveBasePoseType?: EAdditiveBasePoseType): {AdditiveBasePoseType: EAdditiveBasePoseType};
	static GetAnimationCurveNames(AnimationSequence: AnimSequence,CurveType: ERawCurveTrackTypes,CurveNames?: string[]): {CurveNames: string[]};
	static GetAnimationInterpolationType(AnimationSequence: AnimSequence,InterpolationType?: EAnimInterpolationType): {InterpolationType: EAnimInterpolationType};
	static GetAnimationSyncMarkers(AnimationSequence: AnimSequence,Markers?: AnimSyncMarker[]): {Markers: AnimSyncMarker[]};
	static GetAnimationSyncMarkersForTrack(AnimationSequence: AnimSequence,NotifyTrackName: string,Markers?: AnimSyncMarker[]): {Markers: AnimSyncMarker[]};
	static GetBoneCompressionSettings(AnimationSequence: AnimSequence,CompressionSettings?: AnimBoneCompressionSettings): {CompressionSettings: AnimBoneCompressionSettings};
	static GetCurveCompressionSettings(AnimationSequence: AnimSequence,CompressionSettings?: AnimCurveCompressionSettings): {CompressionSettings: AnimCurveCompressionSettings};
	static GetFloatKeys(AnimationSequence: AnimSequence,CurveName: string,Times?: number[],Values?: number[]): {Times: number[], Values: number[]};
	static GetRootMotionLockType(AnimationSequence: AnimSequence,LockType?: ERootMotionRootLock): {LockType: ERootMotionRootLock};
	static GetTransformationKeys(AnimationSequence: AnimSequence,CurveName: string,Times?: number[],Values?: Transform[]): {Times: number[], Values: Transform[]};
	static GetUniqueMarkerNames(AnimationSequence: AnimSequence,MarkerNames?: string[]): {MarkerNames: string[]};
	static GetVectorKeys(AnimationSequence: AnimSequence,CurveName: string,Times?: number[],Values?: Vector[]): {Times: number[], Values: Vector[]};
	static IsRootMotionEnabled(AnimationSequence: AnimSequence): boolean;
	static IsRootMotionLockForced(AnimationSequence: AnimSequence): boolean;
	static IsValidAnimationSyncMarkerName(AnimationSequence: AnimSequence,MarkerName: string): boolean;
	static RemoveAllAnimationSyncMarkers(AnimationSequence: AnimSequence): void;
	static RemoveAllBoneAnimation(AnimationSequence: AnimSequence): void;
	static RemoveAllCurveData(AnimationSequence: AnimSequence): void;
	static RemoveAllVirtualBones(AnimationSequence: AnimSequence): void;
	static RemoveAnimationSyncMarkersByName(AnimationSequence: AnimSequence,MarkerName: string): number;
	static RemoveAnimationSyncMarkersByTrack(AnimationSequence: AnimSequence,NotifyTrackName: string): number;
	static RemoveBoneAnimation(AnimationSequence: AnimSequence,BoneName: string,bIncludeChildren: boolean,bFinalize: boolean): void;
	static RemoveCurve(AnimationSequence: AnimSequence,CurveName: string,bRemoveNameFromSkeleton: boolean): void;
	static RemoveVirtualBone(AnimationSequence: AnimSequence,VirtualBoneName: string): void;
	static RemoveVirtualBones(AnimationSequence: AnimSequence,VirtualBoneNames: string[]): void;
	static SetAdditiveAnimationType(AnimationSequence: AnimSequence,AdditiveAnimationType: EAdditiveAnimationType): void;
	static SetAdditiveBasePoseType(AnimationSequence: AnimSequence,AdditiveBasePoseType: EAdditiveBasePoseType): void;
	static SetAnimationInterpolationType(AnimationSequence: AnimSequence,InterpolationType: EAnimInterpolationType): void;
	static SetBoneCompressionSettings(AnimationSequence: AnimSequence,CompressionSettings: AnimBoneCompressionSettings): void;
	static SetCurveCompressionSettings(AnimationSequence: AnimSequence,CompressionSettings: AnimCurveCompressionSettings): void;
	static SetIsRootMotionLockForced(AnimationSequence: AnimSequence,bForced: boolean): void;
	static SetRootMotionEnabled(AnimationSequence: AnimSequence,bEnabled: boolean): void;
	static SetRootMotionLockType(AnimationSequence: AnimSequence,RootMotionLockType: ERootMotionRootLock): void;
}

declare class SkeletalMeshOptimizationSettings { 
	TerminationCriterion: SkeletalMeshTerminationCriterion;
	NumOfTrianglesPercentage: number;
	NumOfVertPercentage: number;
	MaxNumOfTriangles: any;
	MaxNumOfVerts: any;
	MaxNumOfTrianglesPercentage: any;
	MaxNumOfVertsPercentage: any;
	MaxDeviationPercentage: number;
	ReductionMethod: SkeletalMeshOptimizationType;
	SilhouetteImportance: SkeletalMeshOptimizationImportance;
	TextureImportance: SkeletalMeshOptimizationImportance;
	ShadingImportance: SkeletalMeshOptimizationImportance;
	SkinningImportance: SkeletalMeshOptimizationImportance;
	bRemapMorphTargets: boolean;
	bRecalcNormals: boolean;
	WeldingThreshold: number;
	NormalsThreshold: number;
	MaxBonesPerVertex: number;
	bEnforceBoneBoundaries: boolean;
	bMergeCoincidentVertBones: boolean;
	VolumeImportance: number;
	bLockEdges: boolean;
	bLockColorBounaries: boolean;
	BaseLOD: number;
	BonesToRemove: BoneReference[];
	BakePose: AnimSequence;
	clone() : SkeletalMeshOptimizationSettings;
	static C(Other: UObject | any): SkeletalMeshOptimizationSettings;
}

declare class SectionReference { 
	SectionIndex: number;
	clone() : SectionReference;
	static C(Other: UObject | any): SectionReference;
}

declare type ESkinCacheUsage = 'Auto' | 'Disabled' | 'Enabled' | 'ESkinCacheUsage_MAX';
declare var ESkinCacheUsage : { Auto:'Auto',Disabled:'Disabled',Enabled:'Enabled',ESkinCacheUsage_MAX:'ESkinCacheUsage_MAX', };
declare class SkeletalMeshLODInfo { 
	ScreenSize: PerPlatformFloat;
	LODHysteresis: number;
	LODMaterialMap: number[];
	bEnableShadowCasting: boolean[];
	RemovedBones: string[];
	BuildSettings: SkeletalMeshBuildSettings;
	ReductionSettings: SkeletalMeshOptimizationSettings;
	BonesToRemove: BoneReference[];
	BonesToPrioritize: BoneReference[];
	SectionsToPrioritize: SectionReference[];
	WeightOfPrioritization: number;
	BakePose: AnimSequence;
	BakePoseOverride: AnimSequence;
	SourceImportFilename: string;
	SkinCacheUsage: ESkinCacheUsage;
	MorphTargetPositionErrorTolerance: number;
	bHasBeenSimplified: boolean;
	bHasPerLODVertexColors: boolean;
	bAllowCPUAccess: boolean;
	bSupportUniformlyDistributedSampling: boolean;
	bImportWithBaseMesh: boolean;
	clone() : SkeletalMeshLODInfo;
	static C(Other: UObject | any): SkeletalMeshLODInfo;
}

declare class PerPlatformInt { 
	Default: number;
	PerPlatform: any;
	clone() : PerPlatformInt;
	static C(Other: UObject | any): PerPlatformInt;
}

declare class PerPlatformBool { 
	Default: boolean;
	PerPlatform: any;
	clone() : PerPlatformBool;
	static C(Other: UObject | any): PerPlatformBool;
}

declare class DataAsset extends UObject { 
	NativeClass: UnrealEngineClass;
	static Load(ResourceName: string): DataAsset;
	static Find(Outer: UObject, ResourceName: string): DataAsset;
	static GetDefaultObject(): DataAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataAsset;
	static C(Other: UObject | any): DataAsset;
}

declare type EBoneFilterActionOption = 'Remove' | 'Keep' | 'Invalid' | 'EBoneFilterActionOption_MAX';
declare var EBoneFilterActionOption : { Remove:'Remove',Keep:'Keep',Invalid:'Invalid',EBoneFilterActionOption_MAX:'EBoneFilterActionOption_MAX', };
declare class BoneFilter { 
	bExcludeSelf: boolean;
	BoneName: string;
	clone() : BoneFilter;
	static C(Other: UObject | any): BoneFilter;
}

declare class SkeletalMeshLODGroupSettings { 
	ScreenSize: PerPlatformFloat;
	LODHysteresis: number;
	BoneFilterActionOption: EBoneFilterActionOption;
	BoneList: BoneFilter[];
	BonesToPrioritize: string[];
	SectionsToPrioritize: number[];
	WeightOfPrioritization: number;
	BakePose: AnimSequence;
	ReductionSettings: SkeletalMeshOptimizationSettings;
	clone() : SkeletalMeshLODGroupSettings;
	static C(Other: UObject | any): SkeletalMeshLODGroupSettings;
}

declare class SkeletalMeshLODSettings extends DataAsset { 
	MinLOD: PerPlatformInt;
	DisableBelowMinLodStripping: PerPlatformBool;
	bOverrideLODStreamingSettings: boolean;
	bSupportLODStreaming: PerPlatformBool;
	MaxNumStreamedLODs: PerPlatformInt;
	MaxNumOptionalLODs: PerPlatformInt;
	LODGroups: SkeletalMeshLODGroupSettings[];
	static Load(ResourceName: string): SkeletalMeshLODSettings;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshLODSettings;
	static GetDefaultObject(): SkeletalMeshLODSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshLODSettings;
	static C(Other: UObject | any): SkeletalMeshLODSettings;
}

declare class PhysicalAnimationData { 
	BodyName: string;
	bIsLocalSimulation: boolean;
	OrientationStrength: number;
	AngularVelocityStrength: number;
	PositionStrength: number;
	VelocityStrength: number;
	MaxLinearForce: number;
	MaxAngularForce: number;
	clone() : PhysicalAnimationData;
	static C(Other: UObject | any): PhysicalAnimationData;
}

declare class PhysicalAnimationProfile { 
	ProfileName: string;
	PhysicalAnimationData: PhysicalAnimationData;
	clone() : PhysicalAnimationProfile;
	static C(Other: UObject | any): PhysicalAnimationProfile;
}

declare class SkeletalBodySetup extends BodySetup { 
	CurrentPhysicalAnimationProfile: PhysicalAnimationProfile;
	bSkipScaleFromAnimation: boolean;
	PhysicalAnimationData: PhysicalAnimationProfile[];
	static Load(ResourceName: string): SkeletalBodySetup;
	static Find(Outer: UObject, ResourceName: string): SkeletalBodySetup;
	static GetDefaultObject(): SkeletalBodySetup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalBodySetup;
	static C(Other: UObject | any): SkeletalBodySetup;
}

declare class ConstraintInstanceBase { 
	clone() : ConstraintInstanceBase;
	static C(Other: UObject | any): ConstraintInstanceBase;
}

declare class ConstraintBaseParams { 
	Stiffness: number;
	Damping: number;
	Restitution: number;
	ContactDistance: number;
	bSoftConstraint: boolean;
	clone() : ConstraintBaseParams;
	static C(Other: UObject | any): ConstraintBaseParams;
}

declare type ELinearConstraintMotion = 'LCM_Free' | 'LCM_Limited' | 'LCM_Locked' | 'LCM_MAX';
declare var ELinearConstraintMotion : { LCM_Free:'LCM_Free',LCM_Limited:'LCM_Limited',LCM_Locked:'LCM_Locked',LCM_MAX:'LCM_MAX', };
declare class LinearConstraint extends ConstraintBaseParams { 
	Limit: number;
	XMotion: ELinearConstraintMotion;
	YMotion: ELinearConstraintMotion;
	ZMotion: ELinearConstraintMotion;
	clone() : LinearConstraint;
	static C(Other: UObject | any): LinearConstraint;
}

declare type EAngularConstraintMotion = 'ACM_Free' | 'ACM_Limited' | 'ACM_Locked' | 'ACM_MAX';
declare var EAngularConstraintMotion : { ACM_Free:'ACM_Free',ACM_Limited:'ACM_Limited',ACM_Locked:'ACM_Locked',ACM_MAX:'ACM_MAX', };
declare class ConeConstraint extends ConstraintBaseParams { 
	Swing1LimitDegrees: number;
	Swing2LimitDegrees: number;
	Swing1Motion: EAngularConstraintMotion;
	Swing2Motion: EAngularConstraintMotion;
	clone() : ConeConstraint;
	static C(Other: UObject | any): ConeConstraint;
}

declare class TwistConstraint extends ConstraintBaseParams { 
	TwistLimitDegrees: number;
	TwistMotion: EAngularConstraintMotion;
	clone() : TwistConstraint;
	static C(Other: UObject | any): TwistConstraint;
}

declare class ConstraintDrive { 
	Stiffness: number;
	Damping: number;
	MaxForce: number;
	bEnablePositionDrive: boolean;
	bEnableVelocityDrive: boolean;
	clone() : ConstraintDrive;
	static C(Other: UObject | any): ConstraintDrive;
}

declare class LinearDriveConstraint { 
	PositionTarget: Vector;
	VelocityTarget: Vector;
	XDrive: ConstraintDrive;
	YDrive: ConstraintDrive;
	ZDrive: ConstraintDrive;
	bEnablePositionDrive: boolean;
	clone() : LinearDriveConstraint;
	static C(Other: UObject | any): LinearDriveConstraint;
}

declare type EAngularDriveMode = 'SLERP' | 'TwistAndSwing' | 'EAngularDriveMode_MAX';
declare var EAngularDriveMode : { SLERP:'SLERP',TwistAndSwing:'TwistAndSwing',EAngularDriveMode_MAX:'EAngularDriveMode_MAX', };
declare class AngularDriveConstraint { 
	TwistDrive: ConstraintDrive;
	SwingDrive: ConstraintDrive;
	SlerpDrive: ConstraintDrive;
	OrientationTarget: Rotator;
	AngularVelocityTarget: Vector;
	AngularDriveMode: EAngularDriveMode;
	clone() : AngularDriveConstraint;
	static C(Other: UObject | any): AngularDriveConstraint;
}

declare type EConstraintPlasticityType = 'CCPT_Free' | 'CCPT_Shrink' | 'CCPT_Grow' | 'CCPT_MAX';
declare var EConstraintPlasticityType : { CCPT_Free:'CCPT_Free',CCPT_Shrink:'CCPT_Shrink',CCPT_Grow:'CCPT_Grow',CCPT_MAX:'CCPT_MAX', };
declare class ConstraintProfileProperties { 
	ProjectionLinearTolerance: number;
	ProjectionAngularTolerance: number;
	ProjectionLinearAlpha: number;
	ProjectionAngularAlpha: number;
	ShockPropagationAlpha: number;
	LinearBreakThreshold: number;
	LinearPlasticityThreshold: number;
	AngularBreakThreshold: number;
	AngularPlasticityThreshold: number;
	ContactTransferScale: number;
	LinearLimit: LinearConstraint;
	ConeLimit: ConeConstraint;
	TwistLimit: TwistConstraint;
	LinearDrive: LinearDriveConstraint;
	AngularDrive: AngularDriveConstraint;
	bDisableCollision: boolean;
	bParentDominates: boolean;
	bEnableLinearProjection: boolean;
	bEnableAngularProjection: boolean;
	bEnableShockPropagation: boolean;
	bEnableProjection: boolean;
	bEnableSoftProjection: boolean;
	bAngularBreakable: boolean;
	bAngularPlasticity: boolean;
	bLinearBreakable: boolean;
	bLinearPlasticity: boolean;
	LinearPlasticityType: EConstraintPlasticityType;
	clone() : ConstraintProfileProperties;
	static C(Other: UObject | any): ConstraintProfileProperties;
}

declare class ConstraintInstance extends ConstraintInstanceBase { 
	JointName: string;
	ConstraintBone1: string;
	ConstraintBone2: string;
	Pos1: Vector;
	PriAxis1: Vector;
	SecAxis1: Vector;
	Pos2: Vector;
	PriAxis2: Vector;
	SecAxis2: Vector;
	AngularRotationOffset: Rotator;
	bScaleLinearLimits: boolean;
	ProfileInstance: ConstraintProfileProperties;
	bDisableCollision: boolean;
	bEnableProjection: boolean;
	ProjectionLinearTolerance: number;
	ProjectionAngularTolerance: number;
	LinearXMotion: ELinearConstraintMotion;
	LinearYMotion: ELinearConstraintMotion;
	LinearZMotion: ELinearConstraintMotion;
	LinearLimitSize: number;
	bLinearLimitSoft: boolean;
	LinearLimitStiffness: number;
	LinearLimitDamping: number;
	bLinearBreakable: boolean;
	LinearBreakThreshold: number;
	AngularSwing1Motion: EAngularConstraintMotion;
	AngularTwistMotion: EAngularConstraintMotion;
	AngularSwing2Motion: EAngularConstraintMotion;
	bSwingLimitSoft: boolean;
	bTwistLimitSoft: boolean;
	Swing1LimitAngle: number;
	TwistLimitAngle: number;
	Swing2LimitAngle: number;
	SwingLimitStiffness: number;
	SwingLimitDamping: number;
	TwistLimitStiffness: number;
	TwistLimitDamping: number;
	bAngularBreakable: boolean;
	AngularBreakThreshold: number;
	bLinearXPositionDrive: boolean;
	bLinearXVelocityDrive: boolean;
	bLinearYPositionDrive: boolean;
	bLinearYVelocityDrive: boolean;
	bLinearZPositionDrive: boolean;
	bLinearZVelocityDrive: boolean;
	bLinearPositionDrive: boolean;
	bLinearVelocityDrive: boolean;
	LinearPositionTarget: Vector;
	LinearVelocityTarget: Vector;
	LinearDriveSpring: number;
	LinearDriveDamping: number;
	LinearDriveForceLimit: number;
	bSwingPositionDrive: boolean;
	bSwingVelocityDrive: boolean;
	bTwistPositionDrive: boolean;
	bTwistVelocityDrive: boolean;
	bAngularSlerpDrive: boolean;
	bAngularOrientationDrive: boolean;
	bEnableSwingDrive: boolean;
	bEnableTwistDrive: boolean;
	bAngularVelocityDrive: boolean;
	AngularPositionTarget: Quat;
	AngularDriveMode: EAngularDriveMode;
	AngularOrientationTarget: Rotator;
	AngularVelocityTarget: Vector;
	AngularDriveSpring: number;
	AngularDriveDamping: number;
	AngularDriveForceLimit: number;
	clone() : ConstraintInstance;
	static C(Other: UObject | any): ConstraintInstance;
}

declare class PhysicsConstraintProfileHandle { 
	ProfileProperties: ConstraintProfileProperties;
	ProfileName: string;
	clone() : PhysicsConstraintProfileHandle;
	static C(Other: UObject | any): PhysicsConstraintProfileHandle;
}

declare class PhysicsConstraintTemplate extends UObject { 
	DefaultInstance: ConstraintInstance;
	ProfileHandles: PhysicsConstraintProfileHandle[];
	DefaultProfile: ConstraintProfileProperties;
	JointName: string;
	ConstraintBone1: string;
	ConstraintBone2: string;
	Pos1: Vector;
	PriAxis1: Vector;
	SecAxis1: Vector;
	Pos2: Vector;
	PriAxis2: Vector;
	SecAxis2: Vector;
	bEnableProjection: boolean;
	ProjectionLinearTolerance: number;
	ProjectionAngularTolerance: number;
	LinearXMotion: ELinearConstraintMotion;
	LinearYMotion: ELinearConstraintMotion;
	LinearZMotion: ELinearConstraintMotion;
	LinearLimitSize: number;
	bLinearLimitSoft: boolean;
	LinearLimitStiffness: number;
	LinearLimitDamping: number;
	bLinearBreakable: boolean;
	LinearBreakThreshold: number;
	AngularSwing1Motion: EAngularConstraintMotion;
	AngularSwing2Motion: EAngularConstraintMotion;
	AngularTwistMotion: EAngularConstraintMotion;
	bSwingLimitSoft: boolean;
	bTwistLimitSoft: boolean;
	Swing1LimitAngle: number;
	Swing2LimitAngle: number;
	TwistLimitAngle: number;
	SwingLimitStiffness: number;
	SwingLimitDamping: number;
	TwistLimitStiffness: number;
	TwistLimitDamping: number;
	bAngularBreakable: boolean;
	AngularBreakThreshold: number;
	static Load(ResourceName: string): PhysicsConstraintTemplate;
	static Find(Outer: UObject, ResourceName: string): PhysicsConstraintTemplate;
	static GetDefaultObject(): PhysicsConstraintTemplate;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsConstraintTemplate;
	static C(Other: UObject | any): PhysicsConstraintTemplate;
}

declare class PhysicsAssetSolverSettings { 
	PositionIterations: number;
	VelocityIterations: number;
	ProjectionIterations: number;
	CullDistance: number;
	MaxDepenetrationVelocity: number;
	FixedTimeStep: number;
	clone() : PhysicsAssetSolverSettings;
	static C(Other: UObject | any): PhysicsAssetSolverSettings;
}

declare class SolverIterations { 
	SolverIterations: number;
	JointIterations: number;
	CollisionIterations: number;
	SolverPushOutIterations: number;
	JointPushOutIterations: number;
	CollisionPushOutIterations: number;
	clone() : SolverIterations;
	static C(Other: UObject | any): SolverIterations;
}

declare type EPhysicsAssetSolverType = 'RBAN' | 'World' | 'EPhysicsAssetSolverType_MAX';
declare var EPhysicsAssetSolverType : { RBAN:'RBAN',World:'World',EPhysicsAssetSolverType_MAX:'EPhysicsAssetSolverType_MAX', };
declare class ConstraintInstanceAccessor { 
	Owner: any;
	index: any;
	clone() : ConstraintInstanceAccessor;
	static C(Other: UObject | any): ConstraintInstanceAccessor;
	CopyParams(SourceAccessor?: ConstraintInstanceAccessor,bKeepPosition?: boolean,bKeepRotation?: boolean): {Accessor: ConstraintInstanceAccessor, SourceAccessor: ConstraintInstanceAccessor};
	GetAngularBreakable(bAngularBreakable?: boolean,AngularBreakThreshold?: number): {Accessor: ConstraintInstanceAccessor, bAngularBreakable: boolean, AngularBreakThreshold: number};
	GetAngularDriveMode(OutDriveMode?: EAngularDriveMode): {Accessor: ConstraintInstanceAccessor, OutDriveMode: EAngularDriveMode};
	GetAngularDriveParams(OutPositionStrength?: number,OutVelocityStrength?: number,OutForceLimit?: number): {Accessor: ConstraintInstanceAccessor, OutPositionStrength: number, OutVelocityStrength: number, OutForceLimit: number};
	GetAngularLimits(Swing1MotionType?: EAngularConstraintMotion,Swing1LimitAngle?: number,Swing2MotionType?: EAngularConstraintMotion,Swing2LimitAngle?: number,TwistMotionType?: EAngularConstraintMotion,TwistLimitAngle?: number): {Accessor: ConstraintInstanceAccessor, Swing1MotionType: EAngularConstraintMotion, Swing1LimitAngle: number, Swing2MotionType: EAngularConstraintMotion, Swing2LimitAngle: number, TwistMotionType: EAngularConstraintMotion, TwistLimitAngle: number};
	GetAngularOrientationTarget(OutPosTarget?: Rotator): {Accessor: ConstraintInstanceAccessor, OutPosTarget: Rotator};
	GetAngularPlasticity(bAngularPlasticity?: boolean,AngularPlasticityThreshold?: number): {Accessor: ConstraintInstanceAccessor, bAngularPlasticity: boolean, AngularPlasticityThreshold: number};
	GetAngularSoftSwingLimitParams(bSoftSwingLimit?: boolean,SwingLimitStiffness?: number,SwingLimitDamping?: number,SwingLimitRestitution?: number,SwingLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor, bSoftSwingLimit: boolean, SwingLimitStiffness: number, SwingLimitDamping: number, SwingLimitRestitution: number, SwingLimitContactDistance: number};
	GetAngularSoftTwistLimitParams(bSoftTwistLimit?: boolean,TwistLimitStiffness?: number,TwistLimitDamping?: number,TwistLimitRestitution?: number,TwistLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor, bSoftTwistLimit: boolean, TwistLimitStiffness: number, TwistLimitDamping: number, TwistLimitRestitution: number, TwistLimitContactDistance: number};
	GetAngularVelocityDriveSLERP(bOutEnableSLERP?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableSLERP: boolean};
	GetAngularVelocityDriveTwistAndSwing(bOutEnableTwistDrive?: boolean,bOutEnableSwingDrive?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableTwistDrive: boolean, bOutEnableSwingDrive: boolean};
	GetAngularVelocityTarget(OutVelTarget?: Vector): {Accessor: ConstraintInstanceAccessor, OutVelTarget: Vector};
	GetAttachedBodyNames(ParentBody?: string,ChildBody?: string): {Accessor: ConstraintInstanceAccessor, ParentBody: string, ChildBody: string};
	GetContactTransferScale(ContactTransferScale?: number): {Accessor: ConstraintInstanceAccessor, ContactTransferScale: number};
	GetDisableCollsion(): {Accessor: ConstraintInstanceAccessor, $: boolean};
	GetLinearBreakable(bLinearBreakable?: boolean,LinearBreakThreshold?: number): {Accessor: ConstraintInstanceAccessor, bLinearBreakable: boolean, LinearBreakThreshold: number};
	GetLinearDriveParams(OutPositionStrength?: number,OutVelocityStrength?: number,OutForceLimit?: number): {Accessor: ConstraintInstanceAccessor, OutPositionStrength: number, OutVelocityStrength: number, OutForceLimit: number};
	GetLinearLimits(XMotion?: ELinearConstraintMotion,YMotion?: ELinearConstraintMotion,ZMotion?: ELinearConstraintMotion,Limit?: number): {Accessor: ConstraintInstanceAccessor, XMotion: ELinearConstraintMotion, YMotion: ELinearConstraintMotion, ZMotion: ELinearConstraintMotion, Limit: number};
	GetLinearPlasticity(bLinearPlasticity?: boolean,LinearPlasticityThreshold?: number,PlasticityType?: EConstraintPlasticityType): {Accessor: ConstraintInstanceAccessor, bLinearPlasticity: boolean, LinearPlasticityThreshold: number, PlasticityType: EConstraintPlasticityType};
	GetLinearPositionDrive(bOutEnableDriveX?: boolean,bOutEnableDriveY?: boolean,bOutEnableDriveZ?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableDriveX: boolean, bOutEnableDriveY: boolean, bOutEnableDriveZ: boolean};
	GetLinearPositionTarget(OutPosTarget?: Vector): {Accessor: ConstraintInstanceAccessor, OutPosTarget: Vector};
	GetLinearSoftLimitParams(bSoftLinearLimit?: boolean,LinearLimitStiffness?: number,LinearLimitDamping?: number,LinearLimitRestitution?: number,LinearLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor, bSoftLinearLimit: boolean, LinearLimitStiffness: number, LinearLimitDamping: number, LinearLimitRestitution: number, LinearLimitContactDistance: number};
	GetLinearVelocityDrive(bOutEnableDriveX?: boolean,bOutEnableDriveY?: boolean,bOutEnableDriveZ?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableDriveX: boolean, bOutEnableDriveY: boolean, bOutEnableDriveZ: boolean};
	GetLinearVelocityTarget(OutVelTarget?: Vector): {Accessor: ConstraintInstanceAccessor, OutVelTarget: Vector};
	GetOrientationDriveSLERP(bOutEnableSLERP?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableSLERP: boolean};
	GetOrientationDriveTwistAndSwing(bOutEnableTwistDrive?: boolean,bOutEnableSwingDrive?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableTwistDrive: boolean, bOutEnableSwingDrive: boolean};
	GetParentDominates(): {Accessor: ConstraintInstanceAccessor, $: boolean};
	GetProjectionParams(bEnableProjection?: boolean,ProjectionLinearAlpha?: number,ProjectionAngularAlpha?: number): {Accessor: ConstraintInstanceAccessor, bEnableProjection: boolean, ProjectionLinearAlpha: number, ProjectionAngularAlpha: number};
	SetAngularBreakable(bAngularBreakable?: boolean,AngularBreakThreshold?: number): {Accessor: ConstraintInstanceAccessor};
	SetAngularDriveMode(DriveMode?: EAngularDriveMode): {Accessor: ConstraintInstanceAccessor};
	SetAngularDriveParams(PositionStrength?: number,VelocityStrength?: number,InForceLimit?: number): {Accessor: ConstraintInstanceAccessor};
	SetAngularLimits(Swing1MotionType?: EAngularConstraintMotion,Swing1LimitAngle?: number,Swing2MotionType?: EAngularConstraintMotion,Swing2LimitAngle?: number,TwistMotionType?: EAngularConstraintMotion,TwistLimitAngle?: number): {Accessor: ConstraintInstanceAccessor};
	SetAngularOrientationTarget(InPosTarget?: Rotator): {Accessor: ConstraintInstanceAccessor};
	SetAngularPlasticity(bAngularPlasticity?: boolean,AngularPlasticityThreshold?: number): {Accessor: ConstraintInstanceAccessor};
	SetAngularSoftSwingLimitParams(bSoftSwingLimit?: boolean,SwingLimitStiffness?: number,SwingLimitDamping?: number,SwingLimitRestitution?: number,SwingLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor};
	SetAngularSoftTwistLimitParams(bSoftTwistLimit?: boolean,TwistLimitStiffness?: number,TwistLimitDamping?: number,TwistLimitRestitution?: number,TwistLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor};
	SetAngularVelocityDriveSLERP(bEnableSLERP?: boolean): {Accessor: ConstraintInstanceAccessor};
	SetAngularVelocityDriveTwistAndSwing(bEnableTwistDrive?: boolean,bEnableSwingDrive?: boolean): {Accessor: ConstraintInstanceAccessor};
	SetAngularVelocityTarget(InVelTarget?: Vector): {Accessor: ConstraintInstanceAccessor};
	SetContactTransferScale(ContactTransferScale?: number): {Accessor: ConstraintInstanceAccessor};
	SetDisableCollision(bDisableCollision?: boolean): {Accessor: ConstraintInstanceAccessor};
	SetLinearBreakable(bLinearBreakable?: boolean,LinearBreakThreshold?: number): {Accessor: ConstraintInstanceAccessor};
	SetLinearDriveParams(PositionStrength?: number,VelocityStrength?: number,InForceLimit?: number): {Accessor: ConstraintInstanceAccessor};
	SetLinearLimits(XMotion?: ELinearConstraintMotion,YMotion?: ELinearConstraintMotion,ZMotion?: ELinearConstraintMotion,Limit?: number): {Accessor: ConstraintInstanceAccessor};
	SetLinearPlasticity(bLinearPlasticity?: boolean,LinearPlasticityThreshold?: number,PlasticityType?: EConstraintPlasticityType): {Accessor: ConstraintInstanceAccessor};
	SetLinearPositionDrive(bEnableDriveX?: boolean,bEnableDriveY?: boolean,bEnableDriveZ?: boolean): {Accessor: ConstraintInstanceAccessor};
	SetLinearPositionTarget(InPosTarget?: Vector): {Accessor: ConstraintInstanceAccessor};
	SetLinearSoftLimitParams(bSoftLinearLimit?: boolean,LinearLimitStiffness?: number,LinearLimitDamping?: number,LinearLimitRestitution?: number,LinearLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor};
	SetLinearVelocityDrive(bEnableDriveX?: boolean,bEnableDriveY?: boolean,bEnableDriveZ?: boolean): {Accessor: ConstraintInstanceAccessor};
	SetLinearVelocityTarget(InVelTarget?: Vector): {Accessor: ConstraintInstanceAccessor};
	SetOrientationDriveSLERP(bEnableSLERP?: boolean): {Accessor: ConstraintInstanceAccessor};
	SetOrientationDriveTwistAndSwing(bEnableTwistDrive?: boolean,bEnableSwingDrive?: boolean): {Accessor: ConstraintInstanceAccessor};
	SetParentDominates(bParentDominates?: boolean): {Accessor: ConstraintInstanceAccessor};
	SetProjectionParams(bEnableProjection?: boolean,ProjectionLinearAlpha?: number,ProjectionAngularAlpha?: number): {Accessor: ConstraintInstanceAccessor};
	static CopyParams(Accessor?: ConstraintInstanceAccessor,SourceAccessor?: ConstraintInstanceAccessor,bKeepPosition?: boolean,bKeepRotation?: boolean): {Accessor: ConstraintInstanceAccessor, SourceAccessor: ConstraintInstanceAccessor};
	static GetAngularBreakable(Accessor?: ConstraintInstanceAccessor,bAngularBreakable?: boolean,AngularBreakThreshold?: number): {Accessor: ConstraintInstanceAccessor, bAngularBreakable: boolean, AngularBreakThreshold: number};
	static GetAngularDriveMode(Accessor?: ConstraintInstanceAccessor,OutDriveMode?: EAngularDriveMode): {Accessor: ConstraintInstanceAccessor, OutDriveMode: EAngularDriveMode};
	static GetAngularDriveParams(Accessor?: ConstraintInstanceAccessor,OutPositionStrength?: number,OutVelocityStrength?: number,OutForceLimit?: number): {Accessor: ConstraintInstanceAccessor, OutPositionStrength: number, OutVelocityStrength: number, OutForceLimit: number};
	static GetAngularLimits(Accessor?: ConstraintInstanceAccessor,Swing1MotionType?: EAngularConstraintMotion,Swing1LimitAngle?: number,Swing2MotionType?: EAngularConstraintMotion,Swing2LimitAngle?: number,TwistMotionType?: EAngularConstraintMotion,TwistLimitAngle?: number): {Accessor: ConstraintInstanceAccessor, Swing1MotionType: EAngularConstraintMotion, Swing1LimitAngle: number, Swing2MotionType: EAngularConstraintMotion, Swing2LimitAngle: number, TwistMotionType: EAngularConstraintMotion, TwistLimitAngle: number};
	static GetAngularOrientationTarget(Accessor?: ConstraintInstanceAccessor,OutPosTarget?: Rotator): {Accessor: ConstraintInstanceAccessor, OutPosTarget: Rotator};
	static GetAngularPlasticity(Accessor?: ConstraintInstanceAccessor,bAngularPlasticity?: boolean,AngularPlasticityThreshold?: number): {Accessor: ConstraintInstanceAccessor, bAngularPlasticity: boolean, AngularPlasticityThreshold: number};
	static GetAngularSoftSwingLimitParams(Accessor?: ConstraintInstanceAccessor,bSoftSwingLimit?: boolean,SwingLimitStiffness?: number,SwingLimitDamping?: number,SwingLimitRestitution?: number,SwingLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor, bSoftSwingLimit: boolean, SwingLimitStiffness: number, SwingLimitDamping: number, SwingLimitRestitution: number, SwingLimitContactDistance: number};
	static GetAngularSoftTwistLimitParams(Accessor?: ConstraintInstanceAccessor,bSoftTwistLimit?: boolean,TwistLimitStiffness?: number,TwistLimitDamping?: number,TwistLimitRestitution?: number,TwistLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor, bSoftTwistLimit: boolean, TwistLimitStiffness: number, TwistLimitDamping: number, TwistLimitRestitution: number, TwistLimitContactDistance: number};
	static GetAngularVelocityDriveSLERP(Accessor?: ConstraintInstanceAccessor,bOutEnableSLERP?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableSLERP: boolean};
	static GetAngularVelocityDriveTwistAndSwing(Accessor?: ConstraintInstanceAccessor,bOutEnableTwistDrive?: boolean,bOutEnableSwingDrive?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableTwistDrive: boolean, bOutEnableSwingDrive: boolean};
	static GetAngularVelocityTarget(Accessor?: ConstraintInstanceAccessor,OutVelTarget?: Vector): {Accessor: ConstraintInstanceAccessor, OutVelTarget: Vector};
	static GetAttachedBodyNames(Accessor?: ConstraintInstanceAccessor,ParentBody?: string,ChildBody?: string): {Accessor: ConstraintInstanceAccessor, ParentBody: string, ChildBody: string};
	static GetContactTransferScale(Accessor?: ConstraintInstanceAccessor,ContactTransferScale?: number): {Accessor: ConstraintInstanceAccessor, ContactTransferScale: number};
	static GetDisableCollsion(Accessor?: ConstraintInstanceAccessor): {Accessor: ConstraintInstanceAccessor, $: boolean};
	static GetLinearBreakable(Accessor?: ConstraintInstanceAccessor,bLinearBreakable?: boolean,LinearBreakThreshold?: number): {Accessor: ConstraintInstanceAccessor, bLinearBreakable: boolean, LinearBreakThreshold: number};
	static GetLinearDriveParams(Accessor?: ConstraintInstanceAccessor,OutPositionStrength?: number,OutVelocityStrength?: number,OutForceLimit?: number): {Accessor: ConstraintInstanceAccessor, OutPositionStrength: number, OutVelocityStrength: number, OutForceLimit: number};
	static GetLinearLimits(Accessor?: ConstraintInstanceAccessor,XMotion?: ELinearConstraintMotion,YMotion?: ELinearConstraintMotion,ZMotion?: ELinearConstraintMotion,Limit?: number): {Accessor: ConstraintInstanceAccessor, XMotion: ELinearConstraintMotion, YMotion: ELinearConstraintMotion, ZMotion: ELinearConstraintMotion, Limit: number};
	static GetLinearPlasticity(Accessor?: ConstraintInstanceAccessor,bLinearPlasticity?: boolean,LinearPlasticityThreshold?: number,PlasticityType?: EConstraintPlasticityType): {Accessor: ConstraintInstanceAccessor, bLinearPlasticity: boolean, LinearPlasticityThreshold: number, PlasticityType: EConstraintPlasticityType};
	static GetLinearPositionDrive(Accessor?: ConstraintInstanceAccessor,bOutEnableDriveX?: boolean,bOutEnableDriveY?: boolean,bOutEnableDriveZ?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableDriveX: boolean, bOutEnableDriveY: boolean, bOutEnableDriveZ: boolean};
	static GetLinearPositionTarget(Accessor?: ConstraintInstanceAccessor,OutPosTarget?: Vector): {Accessor: ConstraintInstanceAccessor, OutPosTarget: Vector};
	static GetLinearSoftLimitParams(Accessor?: ConstraintInstanceAccessor,bSoftLinearLimit?: boolean,LinearLimitStiffness?: number,LinearLimitDamping?: number,LinearLimitRestitution?: number,LinearLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor, bSoftLinearLimit: boolean, LinearLimitStiffness: number, LinearLimitDamping: number, LinearLimitRestitution: number, LinearLimitContactDistance: number};
	static GetLinearVelocityDrive(Accessor?: ConstraintInstanceAccessor,bOutEnableDriveX?: boolean,bOutEnableDriveY?: boolean,bOutEnableDriveZ?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableDriveX: boolean, bOutEnableDriveY: boolean, bOutEnableDriveZ: boolean};
	static GetLinearVelocityTarget(Accessor?: ConstraintInstanceAccessor,OutVelTarget?: Vector): {Accessor: ConstraintInstanceAccessor, OutVelTarget: Vector};
	static GetOrientationDriveSLERP(Accessor?: ConstraintInstanceAccessor,bOutEnableSLERP?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableSLERP: boolean};
	static GetOrientationDriveTwistAndSwing(Accessor?: ConstraintInstanceAccessor,bOutEnableTwistDrive?: boolean,bOutEnableSwingDrive?: boolean): {Accessor: ConstraintInstanceAccessor, bOutEnableTwistDrive: boolean, bOutEnableSwingDrive: boolean};
	static GetParentDominates(Accessor?: ConstraintInstanceAccessor): {Accessor: ConstraintInstanceAccessor, $: boolean};
	static GetProjectionParams(Accessor?: ConstraintInstanceAccessor,bEnableProjection?: boolean,ProjectionLinearAlpha?: number,ProjectionAngularAlpha?: number): {Accessor: ConstraintInstanceAccessor, bEnableProjection: boolean, ProjectionLinearAlpha: number, ProjectionAngularAlpha: number};
	static SetAngularBreakable(Accessor?: ConstraintInstanceAccessor,bAngularBreakable?: boolean,AngularBreakThreshold?: number): {Accessor: ConstraintInstanceAccessor};
	static SetAngularDriveMode(Accessor?: ConstraintInstanceAccessor,DriveMode?: EAngularDriveMode): {Accessor: ConstraintInstanceAccessor};
	static SetAngularDriveParams(Accessor?: ConstraintInstanceAccessor,PositionStrength?: number,VelocityStrength?: number,InForceLimit?: number): {Accessor: ConstraintInstanceAccessor};
	static SetAngularLimits(Accessor?: ConstraintInstanceAccessor,Swing1MotionType?: EAngularConstraintMotion,Swing1LimitAngle?: number,Swing2MotionType?: EAngularConstraintMotion,Swing2LimitAngle?: number,TwistMotionType?: EAngularConstraintMotion,TwistLimitAngle?: number): {Accessor: ConstraintInstanceAccessor};
	static SetAngularOrientationTarget(Accessor?: ConstraintInstanceAccessor,InPosTarget?: Rotator): {Accessor: ConstraintInstanceAccessor};
	static SetAngularPlasticity(Accessor?: ConstraintInstanceAccessor,bAngularPlasticity?: boolean,AngularPlasticityThreshold?: number): {Accessor: ConstraintInstanceAccessor};
	static SetAngularSoftSwingLimitParams(Accessor?: ConstraintInstanceAccessor,bSoftSwingLimit?: boolean,SwingLimitStiffness?: number,SwingLimitDamping?: number,SwingLimitRestitution?: number,SwingLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor};
	static SetAngularSoftTwistLimitParams(Accessor?: ConstraintInstanceAccessor,bSoftTwistLimit?: boolean,TwistLimitStiffness?: number,TwistLimitDamping?: number,TwistLimitRestitution?: number,TwistLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor};
	static SetAngularVelocityDriveSLERP(Accessor?: ConstraintInstanceAccessor,bEnableSLERP?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetAngularVelocityDriveTwistAndSwing(Accessor?: ConstraintInstanceAccessor,bEnableTwistDrive?: boolean,bEnableSwingDrive?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetAngularVelocityTarget(Accessor?: ConstraintInstanceAccessor,InVelTarget?: Vector): {Accessor: ConstraintInstanceAccessor};
	static SetContactTransferScale(Accessor?: ConstraintInstanceAccessor,ContactTransferScale?: number): {Accessor: ConstraintInstanceAccessor};
	static SetDisableCollision(Accessor?: ConstraintInstanceAccessor,bDisableCollision?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetLinearBreakable(Accessor?: ConstraintInstanceAccessor,bLinearBreakable?: boolean,LinearBreakThreshold?: number): {Accessor: ConstraintInstanceAccessor};
	static SetLinearDriveParams(Accessor?: ConstraintInstanceAccessor,PositionStrength?: number,VelocityStrength?: number,InForceLimit?: number): {Accessor: ConstraintInstanceAccessor};
	static SetLinearLimits(Accessor?: ConstraintInstanceAccessor,XMotion?: ELinearConstraintMotion,YMotion?: ELinearConstraintMotion,ZMotion?: ELinearConstraintMotion,Limit?: number): {Accessor: ConstraintInstanceAccessor};
	static SetLinearPlasticity(Accessor?: ConstraintInstanceAccessor,bLinearPlasticity?: boolean,LinearPlasticityThreshold?: number,PlasticityType?: EConstraintPlasticityType): {Accessor: ConstraintInstanceAccessor};
	static SetLinearPositionDrive(Accessor?: ConstraintInstanceAccessor,bEnableDriveX?: boolean,bEnableDriveY?: boolean,bEnableDriveZ?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetLinearPositionTarget(Accessor?: ConstraintInstanceAccessor,InPosTarget?: Vector): {Accessor: ConstraintInstanceAccessor};
	static SetLinearSoftLimitParams(Accessor?: ConstraintInstanceAccessor,bSoftLinearLimit?: boolean,LinearLimitStiffness?: number,LinearLimitDamping?: number,LinearLimitRestitution?: number,LinearLimitContactDistance?: number): {Accessor: ConstraintInstanceAccessor};
	static SetLinearVelocityDrive(Accessor?: ConstraintInstanceAccessor,bEnableDriveX?: boolean,bEnableDriveY?: boolean,bEnableDriveZ?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetLinearVelocityTarget(Accessor?: ConstraintInstanceAccessor,InVelTarget?: Vector): {Accessor: ConstraintInstanceAccessor};
	static SetOrientationDriveSLERP(Accessor?: ConstraintInstanceAccessor,bEnableSLERP?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetOrientationDriveTwistAndSwing(Accessor?: ConstraintInstanceAccessor,bEnableTwistDrive?: boolean,bEnableSwingDrive?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetParentDominates(Accessor?: ConstraintInstanceAccessor,bParentDominates?: boolean): {Accessor: ConstraintInstanceAccessor};
	static SetProjectionParams(Accessor?: ConstraintInstanceAccessor,bEnableProjection?: boolean,ProjectionLinearAlpha?: number,ProjectionAngularAlpha?: number): {Accessor: ConstraintInstanceAccessor};
}

declare class PhysicsAsset extends UObject { 
	DefaultSkelMesh: SkeletalMesh;
	PreviewSkeletalMesh: SkeletalMesh;
	PhysicalAnimationProfiles: string[];
	ConstraintProfiles: string[];
	CurrentPhysicalAnimationProfileName: string;
	CurrentConstraintProfileName: string;
	BoundsBodies: number[];
	SkeletalBodySetups: SkeletalBodySetup[];
	ConstraintSetup: PhysicsConstraintTemplate[];
	SolverSettings: PhysicsAssetSolverSettings;
	SolverIterations: SolverIterations;
	SolverType: EPhysicsAssetSolverType;
	bNotForDedicatedServer: boolean;
	ThumbnailInfo: ThumbnailInfo;
	BodySetup: BodySetup[];
	static Load(ResourceName: string): PhysicsAsset;
	static Find(Outer: UObject, ResourceName: string): PhysicsAsset;
	static GetDefaultObject(): PhysicsAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsAsset;
	GetConstraints(bIncludesTerminated: boolean,OutConstraints?: ConstraintInstanceAccessor[]): {OutConstraints: ConstraintInstanceAccessor[]};
	GetConstraintByName(ConstraintName: string): ConstraintInstanceAccessor;
	GetConstraintByBoneNames(Bone1Name: string,Bone2Name: string): ConstraintInstanceAccessor;
	static C(Other: UObject | any): PhysicsAsset;
}

declare class NodeMappingContainer extends UObject { 
	SourceItems: any;
	TargetItems: any;
	SourceToTarget: any;
	SourceAsset: UObject;
	TargetAsset: UObject;
	static Load(ResourceName: string): NodeMappingContainer;
	static Find(Outer: UObject, ResourceName: string): NodeMappingContainer;
	static GetDefaultObject(): NodeMappingContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NodeMappingContainer;
	static C(Other: UObject | any): NodeMappingContainer;
}

declare class PreviewAttachedObjectPair { 
	AttachedObject: UObject;
	UObject: UObject;
	AttachedTo: string;
	clone() : PreviewAttachedObjectPair;
	static C(Other: UObject | any): PreviewAttachedObjectPair;
}

declare class PreviewAssetAttachContainer { 
	AttachedObjects: PreviewAttachedObjectPair[];
	clone() : PreviewAssetAttachContainer;
	static C(Other: UObject | any): PreviewAssetAttachContainer;
}

declare type EClothLODBiasMode = 'MappingsToSameLOD' | 'MappingsToMinLOD' | 'MappingsToAnyLOD' | 'EClothLODBiasMode_MAX';
declare var EClothLODBiasMode : { MappingsToSameLOD:'MappingsToSameLOD',MappingsToMinLOD:'MappingsToMinLOD',MappingsToAnyLOD:'MappingsToAnyLOD',EClothLODBiasMode_MAX:'EClothLODBiasMode_MAX', };
declare class MorphTarget extends UObject { 
	BaseSkelMesh: SkeletalMesh;
	static Load(ResourceName: string): MorphTarget;
	static Find(Outer: UObject, ResourceName: string): MorphTarget;
	static GetDefaultObject(): MorphTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MorphTarget;
	static C(Other: UObject | any): MorphTarget;
}

declare class ClothPhysicsProperties_Legacy { 
	VerticalResistance: number;
	HorizontalResistance: number;
	BendResistance: number;
	ShearResistance: number;
	Friction: number;
	Damping: number;
	TetherStiffness: number;
	TetherLimit: number;
	Drag: number;
	StiffnessFrequency: number;
	GravityScale: number;
	MassScale: number;
	InertiaBlend: number;
	SelfCollisionThickness: number;
	SelfCollisionSquashScale: number;
	SelfCollisionStiffness: number;
	SolverFrequency: number;
	FiberCompression: number;
	FiberExpansion: number;
	FiberResistance: number;
	clone() : ClothPhysicsProperties_Legacy;
	static C(Other: UObject | any): ClothPhysicsProperties_Legacy;
}

declare class ClothingAssetData_Legacy { 
	AssetName: string;
	ApexFileName: string;
	bClothPropertiesChanged: boolean;
	PhysicsProperties: ClothPhysicsProperties_Legacy;
	clone() : ClothingAssetData_Legacy;
	static C(Other: UObject | any): ClothingAssetData_Legacy;
}

declare type ERootMotionMode = 'NoRootMotionExtraction' | 'IgnoreRootMotion' | 'RootMotionFromEverything' | 'RootMotionFromMontagesOnly' | 'ERootMotionMode_MAX';
declare var ERootMotionMode : { NoRootMotionExtraction:'NoRootMotionExtraction',IgnoreRootMotion:'IgnoreRootMotion',RootMotionFromEverything:'RootMotionFromEverything',RootMotionFromMontagesOnly:'RootMotionFromMontagesOnly',ERootMotionMode_MAX:'ERootMotionMode_MAX', };
declare class SoftClassPath extends SoftObjectPath { 
	clone() : SoftClassPath;
	static C(Other: UObject | any): SoftClassPath;
	BreakSoftClassPath(PathString?: string): {PathString: string};
	Conv_SoftClassPathToSoftClassRef(): Class;
	static BreakSoftClassPath(InSoftClassPath: SoftClassPath,PathString?: string): {PathString: string};
	static Conv_SoftClassPathToSoftClassRef(SoftClassPath: SoftClassPath): Class;
	static MakeSoftClassPath(PathString: string): SoftClassPath;
}

declare class StructBase { 
	clone() : StructBase;
	static C(Other: UObject | any): StructBase;
}

declare class ScriptStruct extends Struct { 
	static Load(ResourceName: string): ScriptStruct;
	static Find(Outer: UObject, ResourceName: string): ScriptStruct;
	static GetDefaultObject(): ScriptStruct;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScriptStruct;
	static C(Other: UObject | any): ScriptStruct;
	StructFromJson(UObject: JsonLibraryObject,OutStruct?: StructBase): {OutStruct: StructBase, $: boolean};
	StructToJson(struct: StructBase): JsonLibraryObject;
	static StructFromJson(StructType: ScriptStruct,UObject: JsonLibraryObject,OutStruct?: StructBase): {OutStruct: StructBase, $: boolean};
	static StructToJson(StructType: ScriptStruct,struct: StructBase): JsonLibraryObject;
}

declare class TableRowBase { 
	clone() : TableRowBase;
	static C(Other: UObject | any): TableRowBase;
}

declare class DataTable extends UObject { 
	RowStruct: ScriptStruct;
	bStripFromClientBuilds: boolean;
	bIgnoreExtraFields: boolean;
	bIgnoreMissingFields: boolean;
	ImportKeyField: string;
	AssetImportData: AssetImportData;
	ImportPath: string;
	RowStructName: string;
	RowsSerializedWithTags: number[];
	TemporarilyReferencedObjects: any;
	static Load(ResourceName: string): DataTable;
	static Find(Outer: UObject, ResourceName: string): DataTable;
	static GetDefaultObject(): DataTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataTable;
	static C(Other: UObject | any): DataTable;
	GetDataTableAsJSON(InDTExportFlags: number): string;
	DoesDataTableRowExist(RowName: string): boolean;
	FillDataTableFromCSVFile(CSVFilePath: string): boolean;
	FillDataTableFromCSVString(CSVString: string): boolean;
	FillDataTableFromJSONFile(JSONFilePath: string,ImportRowStruct: ScriptStruct): boolean;
	FillDataTableFromJSONString(JsonString: string): boolean;
	GetDataTableColumnAsString(PropertyName: string): string[];
	GetDataTableRowFromName(RowName: string,OutRow?: TableRowBase): {OutRow: TableRowBase, $: boolean};
	GetDataTableRowNames(OutRowNames?: string[]): {OutRowNames: string[]};
	static GetDataTableAsJSON(InDataTable: DataTable,InDTExportFlags: number): string;
	static DoesDataTableRowExist(Table: DataTable,RowName: string): boolean;
	static FillDataTableFromCSVFile(DataTable: DataTable,CSVFilePath: string): boolean;
	static FillDataTableFromCSVString(DataTable: DataTable,CSVString: string): boolean;
	static FillDataTableFromJSONFile(DataTable: DataTable,JSONFilePath: string,ImportRowStruct: ScriptStruct): boolean;
	static FillDataTableFromJSONString(DataTable: DataTable,JsonString: string): boolean;
	static GetDataTableColumnAsString(DataTable: DataTable,PropertyName: string): string[];
	static GetDataTableRowFromName(Table: DataTable,RowName: string,OutRow?: TableRowBase): {OutRow: TableRowBase, $: boolean};
	static GetDataTableRowNames(Table: DataTable,OutRowNames?: string[]): {OutRowNames: string[]};
}

declare type EMirrorFindReplaceMethod = 'Prefix' | 'Suffix' | 'RegularExpression' | 'EMirrorFindReplaceMethod_MAX';
declare var EMirrorFindReplaceMethod : { Prefix:'Prefix',Suffix:'Suffix',RegularExpression:'RegularExpression',EMirrorFindReplaceMethod_MAX:'EMirrorFindReplaceMethod_MAX', };
declare class MirrorFindReplaceExpression { 
	FindExpression: string;
	ReplaceExpression: string;
	FindReplaceMethod: EMirrorFindReplaceMethod;
	clone() : MirrorFindReplaceExpression;
	static C(Other: UObject | any): MirrorFindReplaceExpression;
}

declare class MirrorDataTable extends DataTable { 
	MirrorFindReplaceExpressions: MirrorFindReplaceExpression[];
	MirrorAxis: EAxis;
	Skeleton: Skeleton;
	static Load(ResourceName: string): MirrorDataTable;
	static Find(Outer: UObject, ResourceName: string): MirrorDataTable;
	static GetDefaultObject(): MirrorDataTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MirrorDataTable;
	static C(Other: UObject | any): MirrorDataTable;
}

declare class AnimNotifyEventReference { 
	MirrorTable: MirrorDataTable;
	NotifySource: UObject;
	clone() : AnimNotifyEventReference;
	static C(Other: UObject | any): AnimNotifyEventReference;
	IsTriggeredByState(AnimInstance: AnimInstance,StateName: string): boolean;
	IsTriggeredByStateInStateMachine(AnimInstance: AnimInstance,StateMachineName: string,StateName: string): boolean;
	IsTriggeredByStateMachine(AnimInstance: AnimInstance,StateMachineName: string): boolean;
	GetMirrorDataTable(): MirrorDataTable;
	IsTriggeredByMirroredAnimation(): boolean;
	static IsTriggeredByState(EventReference: AnimNotifyEventReference,AnimInstance: AnimInstance,StateName: string): boolean;
	static IsTriggeredByStateInStateMachine(EventReference: AnimNotifyEventReference,AnimInstance: AnimInstance,StateMachineName: string,StateName: string): boolean;
	static IsTriggeredByStateMachine(EventReference: AnimNotifyEventReference,AnimInstance: AnimInstance,StateMachineName: string): boolean;
	static GetMirrorDataTable(EventReference: AnimNotifyEventReference): MirrorDataTable;
	static IsTriggeredByMirroredAnimation(EventReference: AnimNotifyEventReference): boolean;
}

declare class AnimNotifyQueue { 
	AnimNotifies: AnimNotifyEventReference[];
	UnfilteredMontageAnimNotifies: any;
	clone() : AnimNotifyQueue;
	static C(Other: UObject | any): AnimNotifyQueue;
}

declare type EAnimLinkMethod = 'Absolute' | 'Relative' | 'Proportional' | 'EAnimLinkMethod_MAX';
declare var EAnimLinkMethod : { Absolute:'Absolute',Relative:'Relative',Proportional:'Proportional',EAnimLinkMethod_MAX:'EAnimLinkMethod_MAX', };
declare class AnimLinkableElement { 
	LinkedMontage: AnimMontage;
	SlotIndex: number;
	SegmentIndex: number;
	LinkMethod: EAnimLinkMethod;
	CachedLinkMethod: EAnimLinkMethod;
	SegmentBeginTime: number;
	SegmentLength: number;
	LinkValue: number;
	LinkedSequence: AnimSequenceBase;
	clone() : AnimLinkableElement;
	static C(Other: UObject | any): AnimLinkableElement;
}

declare class AnimNotify extends UObject { 
	NotifyColor: Color;
	bShouldFireInEditor: boolean;
	static Load(ResourceName: string): AnimNotify;
	static Find(Outer: UObject, ResourceName: string): AnimNotify;
	static GetDefaultObject(): AnimNotify;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify;
	Received_Notify(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase,EventReference: AnimNotifyEventReference): boolean;
	GetNotifyName(): string;
	GetDefaultTriggerWeightThreshold(): number;
	static C(Other: UObject | any): AnimNotify;
}

declare class AnimNotifyState extends UObject { 
	NotifyColor: Color;
	bShouldFireInEditor: boolean;
	static Load(ResourceName: string): AnimNotifyState;
	static Find(Outer: UObject, ResourceName: string): AnimNotifyState;
	static GetDefaultObject(): AnimNotifyState;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotifyState;
	Received_NotifyTick(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase,FrameDeltaTime: number,EventReference: AnimNotifyEventReference): boolean;
	Received_NotifyEnd(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase,EventReference: AnimNotifyEventReference): boolean;
	Received_NotifyBegin(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase,TotalDuration: number,EventReference: AnimNotifyEventReference): boolean;
	GetNotifyName(): string;
	GetDefaultTriggerWeightThreshold(): number;
	static C(Other: UObject | any): AnimNotifyState;
}

declare type EMontageNotifyTickType = 'Queued' | 'BranchingPoint' | 'EMontageNotifyTickType_MAX';
declare var EMontageNotifyTickType : { Queued:'Queued',BranchingPoint:'BranchingPoint',EMontageNotifyTickType_MAX:'EMontageNotifyTickType_MAX', };
declare type ENotifyFilterType = 'NoFiltering' | 'LOD' | 'ENotifyFilterType_MAX';
declare var ENotifyFilterType : { NoFiltering:'NoFiltering',LOD:'LOD',ENotifyFilterType_MAX:'ENotifyFilterType_MAX', };
declare class AnimNotifyEvent extends AnimLinkableElement { 
	DisplayTime: number;
	TriggerTimeOffset: number;
	EndTriggerTimeOffset: number;
	TriggerWeightThreshold: number;
	NotifyName: string;
	Notify: AnimNotify;
	NotifyStateClass: AnimNotifyState;
	Duration: number;
	EndLink: AnimLinkableElement;
	bConvertedFromBranchingPoint: boolean;
	MontageTickType: EMontageNotifyTickType;
	NotifyTriggerChance: number;
	NotifyFilterType: ENotifyFilterType;
	NotifyFilterLOD: number;
	bTriggerOnDedicatedServer: boolean;
	bTriggerOnFollower: boolean;
	NotifyColor: Color;
	Guid: Guid;
	TrackIndex: number;
	clone() : AnimNotifyEvent;
	static C(Other: UObject | any): AnimNotifyEvent;
	GetAnimNotifyEventDuration(): number;
	GetAnimNotifyEventTriggerTime(): number;
	static GetAnimNotifyEventDuration(NotifyEvent: AnimNotifyEvent): number;
	static GetAnimNotifyEventTriggerTime(NotifyEvent: AnimNotifyEvent): number;
}

declare class PoseSnapshot { 
	LocalTransforms: Transform[];
	BoneNames: string[];
	SkeletalMeshName: string;
	SnapshotName: string;
	bIsValid: boolean;
	clone() : PoseSnapshot;
	static C(Other: UObject | any): PoseSnapshot;
}

declare type ETeleportType = 'None' | 'TeleportPhysics' | 'ResetPhysics' | 'ETeleportType_MAX';
declare var ETeleportType : { None:'None',TeleportPhysics:'TeleportPhysics',ResetPhysics:'ResetPhysics',ETeleportType_MAX:'ETeleportType_MAX', };
declare class BlendProfileBoneEntry { 
	BoneReference: BoneReference;
	BlendScale: number;
	clone() : BlendProfileBoneEntry;
	static C(Other: UObject | any): BlendProfileBoneEntry;
}

declare type EBlendProfileMode = 'TimeFactor' | 'WeightFactor' | 'BlendMask' | 'EBlendProfileMode_MAX';
declare var EBlendProfileMode : { TimeFactor:'TimeFactor',WeightFactor:'WeightFactor',BlendMask:'BlendMask',EBlendProfileMode_MAX:'EBlendProfileMode_MAX', };
declare class BlendProfile extends UObject { 
	OwningSkeleton: Skeleton;
	ProfileEntries: BlendProfileBoneEntry[];
	Mode: EBlendProfileMode;
	static Load(ResourceName: string): BlendProfile;
	static Find(Outer: UObject, ResourceName: string): BlendProfile;
	static GetDefaultObject(): BlendProfile;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendProfile;
	static C(Other: UObject | any): BlendProfile;
}

declare type EAlphaBlendOption = 'Linear' | 'Cubic' | 'HermiteCubic' | 'Sinusoidal' | 'QuadraticInOut' | 'CubicInOut' | 'QuarticInOut' | 'QuinticInOut' | 'CircularIn' | 'CircularOut' | 'CircularInOut' | 'ExpIn' | 'ExpOut' | 'ExpInOut' | 'Custom' | 'EAlphaBlendOption_MAX';
declare var EAlphaBlendOption : { Linear:'Linear',Cubic:'Cubic',HermiteCubic:'HermiteCubic',Sinusoidal:'Sinusoidal',QuadraticInOut:'QuadraticInOut',CubicInOut:'CubicInOut',QuarticInOut:'QuarticInOut',QuinticInOut:'QuinticInOut',CircularIn:'CircularIn',CircularOut:'CircularOut',CircularInOut:'CircularInOut',ExpIn:'ExpIn',ExpOut:'ExpOut',ExpInOut:'ExpInOut',Custom:'Custom',EAlphaBlendOption_MAX:'EAlphaBlendOption_MAX', };
declare class AlphaBlendArgs { 
	CustomCurve: CurveFloat;
	BlendTime: number;
	BlendOption: EAlphaBlendOption;
	clone() : AlphaBlendArgs;
	static C(Other: UObject | any): AlphaBlendArgs;
}

declare type EMontageBlendMode = 'Standard' | 'Inertialization' | 'EMontageBlendMode_MAX';
declare var EMontageBlendMode : { Standard:'Standard',Inertialization:'Inertialization',EMontageBlendMode_MAX:'EMontageBlendMode_MAX', };
declare class MontageBlendSettings { 
	BlendProfile: BlendProfile;
	Blend: AlphaBlendArgs;
	BlendMode: EMontageBlendMode;
	clone() : MontageBlendSettings;
	static C(Other: UObject | any): MontageBlendSettings;
}

declare type EMontagePlayReturnType = 'MontageLength' | 'Duration' | 'EMontagePlayReturnType_MAX';
declare var EMontagePlayReturnType : { MontageLength:'MontageLength',Duration:'Duration',EMontagePlayReturnType_MAX:'EMontagePlayReturnType_MAX', };
declare class MarkerSyncAnimPosition { 
	PreviousMarkerName: string;
	NextMarkerName: string;
	PositionBetweenMarkers: number;
	clone() : MarkerSyncAnimPosition;
	static C(Other: UObject | any): MarkerSyncAnimPosition;
}

declare type EAnimCurveType = 'AttributeCurve' | 'MaterialCurve' | 'MorphTargetCurve' | 'MaxAnimCurveType' | 'EAnimCurveType_MAX';
declare var EAnimCurveType : { AttributeCurve:'AttributeCurve',MaterialCurve:'MaterialCurve',MorphTargetCurve:'MorphTargetCurve',MaxAnimCurveType:'MaxAnimCurveType',EAnimCurveType_MAX:'EAnimCurveType_MAX', };
declare class CachedAnimStateData { 
	StateMachineName: string;
	StateName: string;
	clone() : CachedAnimStateData;
	static C(Other: UObject | any): CachedAnimStateData;
}

declare type EAnimNodeReferenceConversionResult = 'Succeeded' | 'Failed' | 'EAnimNodeReferenceConversionResult_MAX';
declare var EAnimNodeReferenceConversionResult : { Succeeded:'Succeeded',Failed:'Failed',EAnimNodeReferenceConversionResult_MAX:'EAnimNodeReferenceConversionResult_MAX', };
declare class SkeletalControlReference extends AnimNodeReference { 
	clone() : SkeletalControlReference;
	static C(Other: UObject | any): SkeletalControlReference;
	GetAlpha(): number;
	SetAlpha(Alpha: number): SkeletalControlReference;
	static GetAlpha(SkeletalControl: SkeletalControlReference): number;
	static SetAlpha(SkeletalControl: SkeletalControlReference,Alpha: number): SkeletalControlReference;
}

declare class SequencePlayerReference extends AnimNodeReference { 
	clone() : SequencePlayerReference;
	static C(Other: UObject | any): SequencePlayerReference;
	GetAccumulatedTime(): number;
	GetLoopAnimation(): boolean;
	GetPlayRate(): number;
	GetSequence(SequenceBase?: AnimSequenceBase): {SequenceBase: AnimSequenceBase, $: SequencePlayerReference};
	GetSequencePure(): AnimSequenceBase;
	GetStartPosition(): number;
	SetAccumulatedTime(Time: number): SequencePlayerReference;
	SetPlayRate(PlayRate: number): SequencePlayerReference;
	SetSequence(Sequence: AnimSequenceBase): SequencePlayerReference;
	SetStartPosition(StartPosition: number): SequencePlayerReference;
	static GetAccumulatedTime(SequencePlayer: SequencePlayerReference): number;
	static GetLoopAnimation(SequencePlayer: SequencePlayerReference): boolean;
	static GetPlayRate(SequencePlayer: SequencePlayerReference): number;
	static GetSequence(SequencePlayer: SequencePlayerReference,SequenceBase?: AnimSequenceBase): {SequenceBase: AnimSequenceBase, $: SequencePlayerReference};
	static GetSequencePure(SequencePlayer: SequencePlayerReference): AnimSequenceBase;
	static GetStartPosition(SequencePlayer: SequencePlayerReference): number;
	static SetAccumulatedTime(SequencePlayer: SequencePlayerReference,Time: number): SequencePlayerReference;
	static SetPlayRate(SequencePlayer: SequencePlayerReference,PlayRate: number): SequencePlayerReference;
	static SetSequence(SequencePlayer: SequencePlayerReference,Sequence: AnimSequenceBase): SequencePlayerReference;
	static SetStartPosition(SequencePlayer: SequencePlayerReference,StartPosition: number): SequencePlayerReference;
}

declare class SequenceEvaluatorReference extends AnimNodeReference { 
	clone() : SequenceEvaluatorReference;
	static C(Other: UObject | any): SequenceEvaluatorReference;
	GetAccumulatedTime(): number;
	GetSequence(): AnimSequenceBase;
	SetExplicitTime(Time: number): SequenceEvaluatorReference;
	SetSequence(Sequence: AnimSequenceBase): SequenceEvaluatorReference;
	static GetAccumulatedTime(SequenceEvaluator: SequenceEvaluatorReference): number;
	static GetSequence(SequenceEvaluator: SequenceEvaluatorReference): AnimSequenceBase;
	static SetExplicitTime(SequenceEvaluator: SequenceEvaluatorReference,Time: number): SequenceEvaluatorReference;
	static SetSequence(SequenceEvaluator: SequenceEvaluatorReference,Sequence: AnimSequenceBase): SequenceEvaluatorReference;
}

declare class LinkedAnimGraphReference extends AnimNodeReference { 
	clone() : LinkedAnimGraphReference;
	static C(Other: UObject | any): LinkedAnimGraphReference;
	GetLinkedAnimInstance(): AnimInstance;
	HasLinkedAnimInstance(): boolean;
	static GetLinkedAnimInstance(UNode: LinkedAnimGraphReference): AnimInstance;
	static HasLinkedAnimInstance(UNode: LinkedAnimGraphReference): boolean;
}

declare class AnimationStateResultReference extends AnimNodeReference { 
	clone() : AnimationStateResultReference;
	static C(Other: UObject | any): AnimationStateResultReference;
}

declare class AnimNodeReference { 
	clone() : AnimNodeReference;
	static C(Other: UObject | any): AnimNodeReference;
	ConvertToSkeletalControl(Result?: EAnimNodeReferenceConversionResult): {Result: EAnimNodeReferenceConversionResult, $: SkeletalControlReference};
	ConvertToSkeletalControlPure(SkeletalControl?: SkeletalControlReference,Result?: boolean): {SkeletalControl: SkeletalControlReference, Result: boolean};
	ConvertToSequencePlayer(Result?: EAnimNodeReferenceConversionResult): {Result: EAnimNodeReferenceConversionResult, $: SequencePlayerReference};
	ConvertToSequencePlayerPure(SequencePlayer?: SequencePlayerReference,Result?: boolean): {SequencePlayer: SequencePlayerReference, Result: boolean};
	ConvertToSequenceEvaluator(Result?: EAnimNodeReferenceConversionResult): {Result: EAnimNodeReferenceConversionResult, $: SequenceEvaluatorReference};
	ConvertToSequenceEvaluatorPure(SequenceEvaluator?: SequenceEvaluatorReference,Result?: boolean): {SequenceEvaluator: SequenceEvaluatorReference, Result: boolean};
	ConvertToLinkedAnimGraph(Result?: EAnimNodeReferenceConversionResult): {Result: EAnimNodeReferenceConversionResult, $: LinkedAnimGraphReference};
	ConvertToLinkedAnimGraphPure(LinkedAnimGraph?: LinkedAnimGraphReference,Result?: boolean): {LinkedAnimGraph: LinkedAnimGraphReference, Result: boolean};
	ConvertToAnimationStateResult(AnimationState?: AnimationStateResultReference,Result?: EAnimNodeReferenceConversionResult): {AnimationState: AnimationStateResultReference, Result: EAnimNodeReferenceConversionResult};
	ConvertToAnimationStateResultPure(AnimationState?: AnimationStateResultReference,Result?: boolean): {AnimationState: AnimationStateResultReference, Result: boolean};
	static ConvertToSkeletalControl(UNode: AnimNodeReference,Result?: EAnimNodeReferenceConversionResult): {Result: EAnimNodeReferenceConversionResult, $: SkeletalControlReference};
	static ConvertToSkeletalControlPure(UNode: AnimNodeReference,SkeletalControl?: SkeletalControlReference,Result?: boolean): {SkeletalControl: SkeletalControlReference, Result: boolean};
	static ConvertToSequencePlayer(UNode: AnimNodeReference,Result?: EAnimNodeReferenceConversionResult): {Result: EAnimNodeReferenceConversionResult, $: SequencePlayerReference};
	static ConvertToSequencePlayerPure(UNode: AnimNodeReference,SequencePlayer?: SequencePlayerReference,Result?: boolean): {SequencePlayer: SequencePlayerReference, Result: boolean};
	static ConvertToSequenceEvaluator(UNode: AnimNodeReference,Result?: EAnimNodeReferenceConversionResult): {Result: EAnimNodeReferenceConversionResult, $: SequenceEvaluatorReference};
	static ConvertToSequenceEvaluatorPure(UNode: AnimNodeReference,SequenceEvaluator?: SequenceEvaluatorReference,Result?: boolean): {SequenceEvaluator: SequenceEvaluatorReference, Result: boolean};
	static ConvertToLinkedAnimGraph(UNode: AnimNodeReference,Result?: EAnimNodeReferenceConversionResult): {Result: EAnimNodeReferenceConversionResult, $: LinkedAnimGraphReference};
	static ConvertToLinkedAnimGraphPure(UNode: AnimNodeReference,LinkedAnimGraph?: LinkedAnimGraphReference,Result?: boolean): {LinkedAnimGraph: LinkedAnimGraphReference, Result: boolean};
	static ConvertToAnimationStateResult(UNode: AnimNodeReference,AnimationState?: AnimationStateResultReference,Result?: EAnimNodeReferenceConversionResult): {AnimationState: AnimationStateResultReference, Result: EAnimNodeReferenceConversionResult};
	static ConvertToAnimationStateResultPure(UNode: AnimNodeReference,AnimationState?: AnimationStateResultReference,Result?: boolean): {AnimationState: AnimationStateResultReference, Result: boolean};
}

declare class AnimInstance extends UObject { 
	CurrentSkeleton: Skeleton;
	RootMotionMode: ERootMotionMode;
	bUseMultiThreadedAnimationUpdate: boolean;
	bUsingCopyPoseFromMesh: boolean;
	bReceiveNotifiesFromLinkedInstances: boolean;
	bPropagateNotifiesToLinkedInstances: boolean;
	bUseMainInstanceMontageEvaluationData: boolean;
	bQueueMontageEvents: boolean;
	OnMontageBlendingOut: UnrealEngineMulticastDelegate<(Montage: AnimMontage, bInterrupted: boolean) => void>;
	OnMontageStarted: UnrealEngineMulticastDelegate<(Montage: AnimMontage) => void>;
	OnMontageEnded: UnrealEngineMulticastDelegate<(Montage: AnimMontage, bInterrupted: boolean) => void>;
	OnAllMontageInstancesEnded: UnrealEngineMulticastDelegate<() => void>;
	PostCompileValidationClassName: SoftClassPath;
	NotifyQueue: AnimNotifyQueue;
	ActiveAnimNotifyState: AnimNotifyEvent[];
	ActiveAnimNotifyEventReference: AnimNotifyEventReference[];
	static Load(ResourceName: string): AnimInstance;
	static Find(Outer: UObject, ResourceName: string): AnimInstance;
	static GetDefaultObject(): AnimInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimInstance;
	WasAnimNotifyTriggeredInStateMachine(MachineIndex: number,AnimNotifyType: UnrealEngineClass): boolean;
	WasAnimNotifyTriggeredInSourceState(MachineIndex: number,StateIndex: number,AnimNotifyType: UnrealEngineClass): boolean;
	WasAnimNotifyTriggeredInAnyState(AnimNotifyType: UnrealEngineClass): boolean;
	WasAnimNotifyStateActiveInStateMachine(MachineIndex: number,AnimNotifyStateType: UnrealEngineClass): boolean;
	WasAnimNotifyStateActiveInSourceState(MachineIndex: number,StateIndex: number,AnimNotifyStateType: UnrealEngineClass): boolean;
	WasAnimNotifyStateActiveInAnyState(AnimNotifyStateType: UnrealEngineClass): boolean;
	WasAnimNotifyNameTriggeredInStateMachine(MachineIndex: number,NotifyName: string): boolean;
	WasAnimNotifyNameTriggeredInSourceState(MachineIndex: number,StateIndex: number,NotifyName: string): boolean;
	WasAnimNotifyNameTriggeredInAnyState(NotifyName: string): boolean;
	UnlockAIResources(bUnlockMovement: boolean,UnlockAILogic: boolean): void;
	UnlinkAnimClassLayers(InClass: UnrealEngineClass): void;
	TryGetPawnOwner(): Pawn;
	StopSlotAnimation(InBlendOutTime: number,SlotNodeName: string): void;
	SnapshotPose(Snapshot?: PoseSnapshot): {Snapshot: PoseSnapshot};
	SetUseMainInstanceMontageEvaluationData(bSet: boolean): void;
	SetRootMotionMode(Value: ERootMotionMode): void;
	SetReceiveNotifiesFromLinkedInstances(bSet: boolean): void;
	SetPropagateNotifiesToLinkedInstances(bSet: boolean): void;
	SetMorphTarget(MorphTargetName: string,Value: number): void;
	SavePoseSnapshot(SnapshotName: string): void;
	ResetDynamics(InTeleportType: ETeleportType): void;
	RequestSlotGroupInertialization(InSlotGroupName: string,Duration: number): void;
	RemovePoseSnapshot(SnapshotName: string): void;
	PlaySlotAnimationAsDynamicMontage_WithBlendSettings(Asset: AnimSequenceBase,SlotNodeName: string,BlendInSettings: MontageBlendSettings,BlendOutSettings: MontageBlendSettings,InPlayRate: number,LoopCount: number,BlendOutTriggerTime: number,InTimeToStartMontageAt: number): AnimMontage;
	PlaySlotAnimationAsDynamicMontage_WithBlendArgs(Asset: AnimSequenceBase,SlotNodeName: string,BlendIn: AlphaBlendArgs,BlendOut: AlphaBlendArgs,InPlayRate: number,LoopCount: number,BlendOutTriggerTime: number,InTimeToStartMontageAt: number): AnimMontage;
	PlaySlotAnimationAsDynamicMontage(Asset: AnimSequenceBase,SlotNodeName: string,BlendInTime: number,BlendOutTime: number,InPlayRate: number,LoopCount: number,BlendOutTriggerTime: number,InTimeToStartMontageAt: number): AnimMontage;
	MontageSync_StopFollowing(MontageFollower: AnimMontage): void;
	MontageSync_Follow(MontageFollower: AnimMontage,OtherAnimInstance: AnimInstance,MontageLeader: AnimMontage): void;
	Montage_StopWithBlendSettings(BlendOutSettings: MontageBlendSettings,Montage: AnimMontage): void;
	Montage_StopWithBlendOut(BlendOut: AlphaBlendArgs,Montage: AnimMontage): void;
	Montage_StopGroupByName(InBlendOutTime: number,GroupName: string): void;
	Montage_Stop(InBlendOutTime: number,Montage: AnimMontage): void;
	Montage_SetPosition(Montage: AnimMontage,NewPosition: number): void;
	Montage_SetPlayRate(Montage: AnimMontage,NewPlayRate: number): void;
	Montage_SetNextSection(SectionNameToChange: string,NextSection: string,Montage: AnimMontage): void;
	Montage_Resume(Montage: AnimMontage): void;
	Montage_PlayWithBlendSettings(MontageToPlay: AnimMontage,BlendInSettings: MontageBlendSettings,InPlayRate: number,ReturnValueType: EMontagePlayReturnType,InTimeToStartMontageAt: number,bStopAllMontages: boolean): number;
	Montage_PlayWithBlendIn(MontageToPlay: AnimMontage,BlendIn: AlphaBlendArgs,InPlayRate: number,ReturnValueType: EMontagePlayReturnType,InTimeToStartMontageAt: number,bStopAllMontages: boolean): number;
	Montage_Play(MontageToPlay: AnimMontage,InPlayRate: number,ReturnValueType: EMontagePlayReturnType,InTimeToStartMontageAt: number,bStopAllMontages: boolean): number;
	Montage_Pause(Montage: AnimMontage): void;
	Montage_JumpToSectionsEnd(SectionName: string,Montage: AnimMontage): void;
	Montage_JumpToSection(SectionName: string,Montage: AnimMontage): void;
	Montage_IsPlaying(Montage: AnimMontage): boolean;
	Montage_IsActive(Montage: AnimMontage): boolean;
	Montage_GetPosition(Montage: AnimMontage): number;
	Montage_GetPlayRate(Montage: AnimMontage): number;
	Montage_GetIsStopped(Montage: AnimMontage): boolean;
	Montage_GetCurrentSection(Montage: AnimMontage): string;
	Montage_GetBlendTime(Montage: AnimMontage): number;
	LockAIResources(bLockMovement: boolean,LockAILogic: boolean): void;
	LinkAnimGraphByTag(InTag: string,InClass: UnrealEngineClass): void;
	LinkAnimClassLayers(InClass: UnrealEngineClass): void;
	IsUsingMainInstanceMontageEvaluationData(): boolean;
	IsSyncGroupBetweenMarkers(InSyncGroupName: string,PreviousMarker: string,NextMarker: string,bRespectMarkerOrder: boolean): boolean;
	IsPlayingSlotAnimation(Asset: AnimSequenceBase,SlotNodeName: string): boolean;
	IsAnyMontagePlaying(): boolean;
	HasMarkerBeenHitThisFrame(SyncGroup: string,MarkerName: string): boolean;
	GetTimeToClosestMarker(SyncGroup: string,MarkerName: string,OutMarkerTime?: number): {OutMarkerTime: number, $: boolean};
	GetSyncGroupPosition(InSyncGroupName: string): MarkerSyncAnimPosition;
	GetRelevantAnimTimeRemainingFraction(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimTimeRemaining(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimTimeFraction(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimTime(MachineIndex: number,StateIndex: number): number;
	GetRelevantAnimLength(MachineIndex: number,StateIndex: number): number;
	GetReceiveNotifiesFromLinkedInstances(): boolean;
	GetPropagateNotifiesToLinkedInstances(): boolean;
	GetOwningComponent(): SkeletalMeshComponent;
	GetOwningActor(): Actor;
	GetLinkedAnimLayerInstancesByGroup(InGroup: string,OutLinkedInstances?: AnimInstance[]): {OutLinkedInstances: AnimInstance[]};
	GetLinkedAnimLayerInstanceByGroupAndClass(InGroup: string,InClass: UnrealEngineClass): AnimInstance;
	GetLinkedAnimLayerInstanceByGroup(InGroup: string): AnimInstance;
	GetLinkedAnimLayerInstanceByClass(InClass: UnrealEngineClass): AnimInstance;
	GetLinkedAnimGraphInstancesByTag(InTag: string,OutLinkedInstances?: AnimInstance[]): {OutLinkedInstances: AnimInstance[]};
	GetLinkedAnimGraphInstanceByTag(InTag: string): AnimInstance;
	GetInstanceTransitionTimeElapsedFraction(MachineIndex: number,TransitionIndex: number): number;
	GetInstanceTransitionTimeElapsed(MachineIndex: number,TransitionIndex: number): number;
	GetInstanceTransitionCrossfadeDuration(MachineIndex: number,TransitionIndex: number): number;
	GetInstanceStateWeight(MachineIndex: number,StateIndex: number): number;
	GetInstanceMachineWeight(MachineIndex: number): number;
	GetInstanceCurrentStateElapsedTime(MachineIndex: number): number;
	GetInstanceAssetPlayerTimeFromEndFraction(AssetPlayerIndex: number): number;
	GetInstanceAssetPlayerTimeFromEnd(AssetPlayerIndex: number): number;
	GetInstanceAssetPlayerTimeFraction(AssetPlayerIndex: number): number;
	GetInstanceAssetPlayerTime(AssetPlayerIndex: number): number;
	GetInstanceAssetPlayerLength(AssetPlayerIndex: number): number;
	GetDeltaSeconds(): number;
	GetCurveValue(CurveName: string): number;
	GetCurrentStateName(MachineIndex: number): string;
	GetCurrentActiveMontage(): AnimMontage;
	GetAllCurveNames(OutNames?: string[]): {OutNames: string[]};
	GetActiveCurveNames(CurveType: EAnimCurveType,OutNames?: string[]): {OutNames: string[]};
	ClearMorphTargets(): void;
	CalculateDirection(Velocity: Vector,BaseRotation: Rotator): number;
	BlueprintUpdateAnimation(DeltaTimeX: number): void;
	BlueprintThreadSafeUpdateAnimation(DeltaTime: number): void;
	BlueprintPostEvaluateAnimation(): void;
	BlueprintLinkedAnimationLayersInitialized(): void;
	BlueprintInitializeAnimation(): void;
	BlueprintBeginPlay(): void;
	static C(Other: UObject | any): AnimInstance;
	StateMachine_GetGlobalWeight(CachedAnimStateData: CachedAnimStateData): number;
	StateMachine_GetLocalWeight(CachedAnimStateData: CachedAnimStateData): number;
	StateMachine_IsStateRelevant(CachedAnimStateData: CachedAnimStateData): boolean;
	GetAnimNodeReference(index: number): AnimNodeReference;
	LockAIResourcesWithAnimation(bLockMovement: boolean,LockAILogic: boolean): void;
	UnlockAIResourcesWithAnimation(bUnlockMovement: boolean,UnlockAILogic: boolean): void;
	static StateMachine_GetGlobalWeight(InAnimInstance: AnimInstance,CachedAnimStateData: CachedAnimStateData): number;
	static StateMachine_GetLocalWeight(InAnimInstance: AnimInstance,CachedAnimStateData: CachedAnimStateData): number;
	static StateMachine_IsStateRelevant(InAnimInstance: AnimInstance,CachedAnimStateData: CachedAnimStateData): boolean;
	static GetAnimNodeReference(Instance: AnimInstance,index: number): AnimNodeReference;
	static LockAIResourcesWithAnimation(AnimInstance: AnimInstance,bLockMovement: boolean,LockAILogic: boolean): void;
	static UnlockAIResourcesWithAnimation(AnimInstance: AnimInstance,bUnlockMovement: boolean,UnlockAILogic: boolean): void;
}

declare class ClothingAssetBase extends UObject { 
	ImportedFilePath: string;
	AssetGuid: Guid;
	static Load(ResourceName: string): ClothingAssetBase;
	static Find(Outer: UObject, ResourceName: string): ClothingAssetBase;
	static GetDefaultObject(): ClothingAssetBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingAssetBase;
	static C(Other: UObject | any): ClothingAssetBase;
}

declare class SkeletalMeshSamplingRegionMaterialFilter { 
	MaterialName: string;
	clone() : SkeletalMeshSamplingRegionMaterialFilter;
	static C(Other: UObject | any): SkeletalMeshSamplingRegionMaterialFilter;
}

declare class SkeletalMeshSamplingRegionBoneFilter { 
	BoneName: string;
	bIncludeOrExclude: boolean;
	bApplyToChildren: boolean;
	clone() : SkeletalMeshSamplingRegionBoneFilter;
	static C(Other: UObject | any): SkeletalMeshSamplingRegionBoneFilter;
}

declare class SkeletalMeshSamplingRegion { 
	Name: string;
	LODIndex: number;
	bSupportUniformlyDistributedSampling: boolean;
	MaterialFilters: SkeletalMeshSamplingRegionMaterialFilter[];
	BoneFilters: SkeletalMeshSamplingRegionBoneFilter[];
	clone() : SkeletalMeshSamplingRegion;
	static C(Other: UObject | any): SkeletalMeshSamplingRegion;
}

declare class SkeletalMeshSamplingLODBuiltData { 
	clone() : SkeletalMeshSamplingLODBuiltData;
	static C(Other: UObject | any): SkeletalMeshSamplingLODBuiltData;
}

declare class SkeletalMeshSamplingRegionBuiltData { 
	clone() : SkeletalMeshSamplingRegionBuiltData;
	static C(Other: UObject | any): SkeletalMeshSamplingRegionBuiltData;
}

declare class SkeletalMeshSamplingBuiltData { 
	WholeMeshBuiltData: SkeletalMeshSamplingLODBuiltData[];
	RegionBuiltData: SkeletalMeshSamplingRegionBuiltData[];
	clone() : SkeletalMeshSamplingBuiltData;
	static C(Other: UObject | any): SkeletalMeshSamplingBuiltData;
}

declare class SkeletalMeshSamplingInfo { 
	Regions: SkeletalMeshSamplingRegion[];
	BuiltData: SkeletalMeshSamplingBuiltData;
	clone() : SkeletalMeshSamplingInfo;
	static C(Other: UObject | any): SkeletalMeshSamplingInfo;
}

declare class SkinWeightProfileInfo { 
	Name: string;
	DefaultProfile: PerPlatformBool;
	DefaultProfileFromLODIndex: PerPlatformInt;
	PerLODSourceFiles: any;
	clone() : SkinWeightProfileInfo;
	static C(Other: UObject | any): SkinWeightProfileInfo;
}

declare class SkeletalMesh extends StreamableRenderAsset { 
	MeshEditorDataObject: SkeletalMeshEditorData;
	Skeleton: Skeleton;
	ImportedBounds: BoxSphereBounds;
	ExtendedBounds: BoxSphereBounds;
	PositiveBoundsExtension: Vector;
	NegativeBoundsExtension: Vector;
	Materials: SkeletalMaterial[];
	SkelMirrorTable: BoneMirrorInfo[];
	LODInfo: SkeletalMeshLODInfo[];
	MinLOD: PerPlatformInt;
	DisableBelowMinLodStripping: PerPlatformBool;
	bOverrideLODStreamingSettings: boolean;
	bSupportLODStreaming: PerPlatformBool;
	MaxNumStreamedLODs: PerPlatformInt;
	MaxNumOptionalLODs: PerPlatformInt;
	LODSettings: SkeletalMeshLODSettings;
	DefaultAnimatingRig: UObject;
	SkelMirrorAxis: EAxis;
	SkelMirrorFlipAxis: EAxis;
	bUseFullPrecisionUVs: boolean;
	bUseHighPrecisionTangentBasis: boolean;
	bHasBeenSimplified: boolean;
	bHasVertexColors: boolean;
	bEnablePerPolyCollision: boolean;
	VertexColorGuid: Guid;
	BodySetup: BodySetup;
	PhysicsAsset: PhysicsAsset;
	ShadowPhysicsAsset: PhysicsAsset;
	NodeMappingData: NodeMappingContainer[];
	AssetImportData: AssetImportData;
	SourceFilePath: string;
	SourceFileTimestamp: string;
	ThumbnailInfo: ThumbnailInfo;
	bHasCustomDefaultEditorCamera: boolean;
	DefaultEditorCameraLocation: Vector;
	DefaultEditorCameraRotation: Rotator;
	DefaultEditorCameraLookAt: Vector;
	DefaultEditorCameraOrthoZoom: number;
	PreviewAttachedAssetContainer: PreviewAssetAttachContainer;
	bSupportRayTracing: boolean;
	RayTracingMinLOD: number;
	ClothLODBiasMode: EClothLODBiasMode;
	MorphTargets: MorphTarget[];
	FloorOffset: number;
	RetargetBasePose: Transform[];
	ClothingAssets: ClothingAssetData_Legacy[];
	PostProcessAnimBlueprint: UnrealEngineClass;
	MeshClothingAssets: ClothingAssetBase[];
	SamplingInfo: SkeletalMeshSamplingInfo;
	AssetUserData: AssetUserData[];
	Sockets: SkeletalMeshSocket[];
	SkinWeightProfiles: SkinWeightProfileInfo[];
	static Load(ResourceName: string): SkeletalMesh;
	static Find(Outer: UObject, ResourceName: string): SkeletalMesh;
	static GetDefaultObject(): SkeletalMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMesh;
	SetSkeleton(InSkeleton: Skeleton): void;
	SetMorphTargets(InMorphTargets: MorphTarget[]): void;
	SetMeshClothingAssets(InMeshClothingAssets: ClothingAssetBase[]): void;
	SetMaterials(InMaterials: SkeletalMaterial[]): void;
	SetLODSettings(InLODSettings: SkeletalMeshLODSettings): void;
	SetDefaultAnimatingRig(InAnimatingRig: UObject): void;
	NumSockets(): number;
	K2_GetAllMorphTargetNames(): string[];
	IsSectionUsingCloth(InSectionIndex: number,bCheckCorrespondingSections: boolean): boolean;
	GetSocketByIndex(index: number): SkeletalMeshSocket;
	GetSkeleton(): Skeleton;
	GetShadowPhysicsAsset(): PhysicsAsset;
	GetPhysicsAsset(): PhysicsAsset;
	GetNodeMappingData(): NodeMappingContainer[];
	GetNodeMappingContainer(SourceAsset: Blueprint): NodeMappingContainer;
	GetMorphTargets(): MorphTarget[];
	GetMeshClothingAssets(): ClothingAssetBase[];
	GetMaterials(): SkeletalMaterial[];
	GetLODSettings(): SkeletalMeshLODSettings;
	GetImportedBounds(): BoxSphereBounds;
	GetDefaultAnimatingRig(): UObject;
	GetBounds(): BoxSphereBounds;
	FindSocketInfo(InSocketName: string,OutTransform?: Transform,OutBoneIndex?: number,OutIndex?: number): {OutTransform: Transform, OutBoneIndex: number, OutIndex: number, $: SkeletalMeshSocket};
	FindSocketAndIndex(InSocketName: string,OutIndex?: number): {OutIndex: number, $: SkeletalMeshSocket};
	FindSocket(InSocketName: string): SkeletalMeshSocket;
	static C(Other: UObject | any): SkeletalMesh;
	GetPhysicsBodySetupFromMesh(InName: string): BodySetup;
	CreatePhysicsAsset(): PhysicsAsset;
	GetLodBuildSettings(LODIndex: number,OutBuildOptions?: SkeletalMeshBuildSettings): {OutBuildOptions: SkeletalMeshBuildSettings};
	GetLODCount(): number;
	GetNumVerts(LODIndex: number): number;
	ImportLOD(LODIndex: number,SourceFilename: string): number;
	RegenerateLOD(NewLODCount: number,bRegenerateEvenIfImported: boolean,bGenerateBaseLOD: boolean): boolean;
	ReimportAllCustomLODs(): boolean;
	RemoveLODs(ToRemoveLODs: number[]): boolean;
	RenameSocket(OldName: string,NewName: string): boolean;
	SetLodBuildSettings(LODIndex: number,BuildOptions: SkeletalMeshBuildSettings): void;
	StripLODGeometry(LODIndex: number,TextureMask: Texture2D,Threshold: number): boolean;
	static GetPhysicsBodySetupFromMesh(InSkeletalMesh: SkeletalMesh,InName: string): BodySetup;
	static CreatePhysicsAsset(SkeletalMesh: SkeletalMesh): PhysicsAsset;
	static GetLodBuildSettings(SkeletalMesh: SkeletalMesh,LODIndex: number,OutBuildOptions?: SkeletalMeshBuildSettings): {OutBuildOptions: SkeletalMeshBuildSettings};
	static GetLODCount(SkeletalMesh: SkeletalMesh): number;
	static GetNumVerts(SkeletalMesh: SkeletalMesh,LODIndex: number): number;
	static ImportLOD(BaseMesh: SkeletalMesh,LODIndex: number,SourceFilename: string): number;
	static RegenerateLOD(SkeletalMesh: SkeletalMesh,NewLODCount: number,bRegenerateEvenIfImported: boolean,bGenerateBaseLOD: boolean): boolean;
	static ReimportAllCustomLODs(SkeletalMesh: SkeletalMesh): boolean;
	static RemoveLODs(SkeletalMesh: SkeletalMesh,ToRemoveLODs: number[]): boolean;
	static RenameSocket(SkeletalMesh: SkeletalMesh,OldName: string,NewName: string): boolean;
	static SetLodBuildSettings(SkeletalMesh: SkeletalMesh,LODIndex: number,BuildOptions: SkeletalMeshBuildSettings): void;
	static StripLODGeometry(SkeletalMesh: SkeletalMesh,LODIndex: number,TextureMask: Texture2D,Threshold: number): boolean;
}

declare class MeshDeformer extends UObject { 
	static Load(ResourceName: string): MeshDeformer;
	static Find(Outer: UObject, ResourceName: string): MeshDeformer;
	static GetDefaultObject(): MeshDeformer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshDeformer;
	static C(Other: UObject | any): MeshDeformer;
}

declare class MeshDeformerInstance extends UObject { 
	static Load(ResourceName: string): MeshDeformerInstance;
	static Find(Outer: UObject, ResourceName: string): MeshDeformerInstance;
	static GetDefaultObject(): MeshDeformerInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshDeformerInstance;
	static C(Other: UObject | any): MeshDeformerInstance;
}

declare class SkelMeshComponentLODInfo { 
	HiddenMaterials: boolean[];
	clone() : SkelMeshComponentLODInfo;
	static C(Other: UObject | any): SkelMeshComponentLODInfo;
}

declare type EVisibilityBasedAnimTickOption = 'AlwaysTickPoseAndRefreshBones' | 'AlwaysTickPose' | 'OnlyTickMontagesWhenNotRendered' | 'OnlyTickPoseWhenRendered' | 'EVisibilityBasedAnimTickOption_MAX';
declare var EVisibilityBasedAnimTickOption : { AlwaysTickPoseAndRefreshBones:'AlwaysTickPoseAndRefreshBones',AlwaysTickPose:'AlwaysTickPose',OnlyTickMontagesWhenNotRendered:'OnlyTickMontagesWhenNotRendered',OnlyTickPoseWhenRendered:'OnlyTickPoseWhenRendered',EVisibilityBasedAnimTickOption_MAX:'EVisibilityBasedAnimTickOption_MAX', };
declare class SkelMeshSkinWeightInfo { 
	Bones: number;
	Weights: number;
	clone() : SkelMeshSkinWeightInfo;
	static C(Other: UObject | any): SkelMeshSkinWeightInfo;
	BreakSkinWeightInfo(Bone0?: number,Weight0?: number,Bone1?: number,Weight1?: number,Bone2?: number,Weight2?: number,Bone3?: number,Weight3?: number): {Bone0: number, Weight0: number, Bone1: number, Weight1: number, Bone2: number, Weight2: number, Bone3: number, Weight3: number};
	static BreakSkinWeightInfo(InWeight: SkelMeshSkinWeightInfo,Bone0?: number,Weight0?: number,Bone1?: number,Weight1?: number,Bone2?: number,Weight2?: number,Bone3?: number,Weight3?: number): {Bone0: number, Weight0: number, Bone1: number, Weight1: number, Bone2: number, Weight2: number, Bone3: number, Weight3: number};
	static MakeSkinWeightInfo(Bone0: number,Weight0: number,Bone1: number,Weight1: number,Bone2: number,Weight2: number,Bone3: number,Weight3: number): SkelMeshSkinWeightInfo;
}

declare type EPhysBodyOp = 'PBO_None' | 'PBO_Term' | 'PBO_MAX';
declare var EPhysBodyOp : { PBO_None:'PBO_None',PBO_Term:'PBO_Term',PBO_MAX:'PBO_MAX', };
declare class SkinnedMeshComponent extends MeshComponent { 
	SkeletalMesh: SkeletalMesh;
	MasterPoseComponent: any;
	SkinCacheUsage: ESkinCacheUsage[];
	MeshDeformer: MeshDeformer;
	MeshDeformerInstance: MeshDeformerInstance;
	WireframeColor: Color;
	PhysicsAssetOverride: PhysicsAsset;
	ForcedLodModel: number;
	MinLodModel: number;
	StreamingDistanceMultiplier: number;
	LODInfo: SkelMeshComponentLODInfo[];
	VisibilityBasedAnimTickOption: EVisibilityBasedAnimTickOption;
	bOverrideMinLOD: boolean;
	bUseBoundsFromMasterPoseComponent: boolean;
	bForceWireframe: boolean;
	bDisplayBones: boolean;
	bDisableMorphTarget: boolean;
	bHideSkin: boolean;
	bPerBoneMotionBlur: boolean;
	bComponentUseFixedSkelBounds: boolean;
	bConsiderAllBodiesForBounds: boolean;
	bSyncAttachParentLOD: boolean;
	bCanHighlightSelectedSections: boolean;
	bRecentlyRendered: boolean;
	bCastCapsuleDirectShadow: boolean;
	bCastCapsuleIndirectShadow: boolean;
	bCPUSkinning: boolean;
	bEnableUpdateRateOptimizations: boolean;
	bDisplayDebugUpdateRateOptimizations: boolean;
	bRenderStatic: boolean;
	bIgnoreMasterPoseComponentLOD: boolean;
	bCachedLocalBoundsUpToDate: boolean;
	bCachedWorldSpaceBoundsUpToDate: boolean;
	bForceMeshObjectUpdate: boolean;
	CapsuleIndirectShadowMinVisibility: number;
	CachedWorldOrLocalSpaceBounds: BoxSphereBounds;
	CachedWorldToLocalTransform: Matrix;
	static Load(ResourceName: string): SkinnedMeshComponent;
	static Find(Outer: UObject, ResourceName: string): SkinnedMeshComponent;
	static GetDefaultObject(): SkinnedMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkinnedMeshComponent;
	UnloadSkinWeightProfile(InProfileName: string): void;
	UnHideBoneByName(BoneName: string): void;
	TransformToBoneSpace(BoneName: string,InPosition: Vector,InRotation: Rotator,OutPosition?: Vector,OutRotation?: Rotator): {OutPosition: Vector, OutRotation: Rotator};
	TransformFromBoneSpace(BoneName: string,InPosition: Vector,InRotation: Rotator,OutPosition?: Vector,OutRotation?: Rotator): {OutPosition: Vector, OutRotation: Rotator};
	ShowMaterialSection(MaterialID: number,SectionIndex: number,bShow: boolean,LODIndex: number): void;
	ShowAllMaterialSections(LODIndex: number): void;
	SetVertexOffsetUsage(LODIndex: number,Usage: number): void;
	SetVertexColorOverride_LinearColor(LODIndex: number,VertexColors: LinearColor[]): void;
	SetSkinWeightProfile(InProfileName: string): boolean;
	SetSkinWeightOverride(LODIndex: number,SkinWeights: SkelMeshSkinWeightInfo[]): void;
	SetSkeletalMesh(NewMesh: SkeletalMesh,bReinitPose: boolean): void;
	SetRenderStatic(bNewValue: boolean): void;
	SetPreSkinningOffsets(LODIndex: number,Offsets: Vector[]): void;
	SetPostSkinningOffsets(LODIndex: number,Offsets: Vector[]): void;
	SetPhysicsAsset(NewPhysicsAsset: PhysicsAsset,bForceReInit: boolean): void;
	SetMinLOD(InNewMinLOD: number): void;
	SetMeshDeformer(InMeshDeformer: MeshDeformer): void;
	SetMasterPoseComponent(NewMasterBoneComponent: SkinnedMeshComponent,bForceUpdate: boolean): void;
	SetForcedLOD(InNewForcedLOD: number): void;
	SetCastCapsuleIndirectShadow(bNewValue: boolean): void;
	SetCastCapsuleDirectShadow(bNewValue: boolean): void;
	SetCapsuleIndirectShadowMinVisibility(NewValue: number): void;
	IsUsingSkinWeightProfile(): boolean;
	IsMaterialSectionShown(MaterialID: number,LODIndex: number): boolean;
	IsBoneHiddenByName(BoneName: string): boolean;
	HideBoneByName(BoneName: string,PhysBodyOption: EPhysBodyOp): void;
	GetVertexOffsetUsage(LODIndex: number): number;
	GetTwistAndSwingAngleOfDeltaRotationFromRefPose(BoneName: string,OutTwistAngle?: number,OutSwingAngle?: number): {OutTwistAngle: number, OutSwingAngle: number, $: boolean};
	GetSocketBoneName(InSocketName: string): string;
	GetRefPoseTransform(BoneIndex: number): Transform;
	GetRefPosePosition(BoneIndex: number): Vector;
	GetParentBone(BoneName: string): string;
	GetNumLODs(): number;
	GetNumBones(): number;
	GetForcedLOD(): number;
	GetDeltaTransformFromRefPose(BoneName: string,BaseName: string): Transform;
	GetCurrentSkinWeightProfileName(): string;
	GetBoneName(BoneIndex: number): string;
	GetBoneIndex(BoneName: string): number;
	FindClosestBone_K2(TestLocation: Vector,BoneLocation?: Vector,IgnoreScale?: number,bRequirePhysicsAsset?: boolean): {BoneLocation: Vector, $: string};
	ClearVertexColorOverride(LODIndex: number): void;
	ClearSkinWeightProfile(): void;
	ClearSkinWeightOverride(LODIndex: number): void;
	BoneIsChildOf(BoneName: string,ParentBoneName: string): boolean;
	static C(Other: UObject | any): SkinnedMeshComponent;
}

declare class AnimGroupInfo { 
	Name: string;
	Color: LinearColor;
	clone() : AnimGroupInfo;
	static C(Other: UObject | any): AnimGroupInfo;
}

declare class AnimParentNodeAssetOverride { 
	NewAsset: AnimationAsset;
	ParentNodeGuid: Guid;
	clone() : AnimParentNodeAssetOverride;
	static C(Other: UObject | any): AnimParentNodeAssetOverride;
}

declare class PoseWatchFolder extends UObject { 
	Label: string;
	Parent: any;
	bIsVisible: boolean;
	bIsExpanded: boolean;
	static Load(ResourceName: string): PoseWatchFolder;
	static Find(Outer: UObject, ResourceName: string): PoseWatchFolder;
	static GetDefaultObject(): PoseWatchFolder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PoseWatchFolder;
	static C(Other: UObject | any): PoseWatchFolder;
}

declare class PoseWatch extends UObject { 
	UNode: any;
	bDeleteOnDeselection: boolean;
	bIsVisible: boolean;
	bIsEnabled: boolean;
	Color: Color;
	Label: string;
	Parent: any;
	static Load(ResourceName: string): PoseWatch;
	static Find(Outer: UObject, ResourceName: string): PoseWatch;
	static GetDefaultObject(): PoseWatch;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PoseWatch;
	static C(Other: UObject | any): PoseWatch;
}

declare type EPreviewAnimationBlueprintApplicationMethod = 'LinkedLayers' | 'LinkedAnimGraph' | 'EPreviewAnimationBlueprintApplicationMethod_MAX';
declare var EPreviewAnimationBlueprintApplicationMethod : { LinkedLayers:'LinkedLayers',LinkedAnimGraph:'LinkedAnimGraph',EPreviewAnimationBlueprintApplicationMethod_MAX:'EPreviewAnimationBlueprintApplicationMethod_MAX', };
declare class AnimGraphBlendOptions { 
	BlendInTime: number;
	BlendOutTime: number;
	clone() : AnimGraphBlendOptions;
	static C(Other: UObject | any): AnimGraphBlendOptions;
}

declare class K2Node extends EdGraphNode { 
	static Load(ResourceName: string): K2Node;
	static Find(Outer: UObject, ResourceName: string): K2Node;
	static GetDefaultObject(): K2Node;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node;
	static C(Other: UObject | any): K2Node;
}

declare class OptionalPinFromProperty { 
	PropertyName: string;
	PropertyFriendlyName: string;
	PropertyTooltip: string;
	CategoryName: string;
	bShowPin: boolean;
	bCanToggleVisibility: boolean;
	bPropertyIsCustomized: boolean;
	bHasOverridePin: boolean;
	bIsMarkedForAdvancedDisplay: boolean;
	bIsOverrideEnabled: boolean;
	bIsSetValuePinVisible: boolean;
	bIsOverridePinVisible: boolean;
	clone() : OptionalPinFromProperty;
	static C(Other: UObject | any): OptionalPinFromProperty;
}

declare type EBlueprintUsage = 'NoProperties' | 'DoesNotUseBlueprint' | 'UsesBlueprint' | 'EBlueprintUsage_MAX';
declare var EBlueprintUsage : { NoProperties:'NoProperties',DoesNotUseBlueprint:'DoesNotUseBlueprint',UsesBlueprint:'UsesBlueprint',EBlueprintUsage_MAX:'EBlueprintUsage_MAX', };
declare class MemberReference { 
	MemberParent: UObject;
	MemberScope: string;
	MemberName: string;
	MemberGuid: Guid;
	bSelfContext: boolean;
	bWasDeprecated: boolean;
	clone() : MemberReference;
	static C(Other: UObject | any): MemberReference;
}

declare class AnimGraphNode_Base extends K2Node { 
	ShowPinForProperties: OptionalPinFromProperty[];
	PropertyBindings: any;
	AlwaysDynamicProperties: any;
	BlueprintUsage: EBlueprintUsage;
	InitialUpdateFunction: MemberReference;
	BecomeRelevantFunction: MemberReference;
	UpdateFunction: MemberReference;
	Tag: string;
	static Load(ResourceName: string): AnimGraphNode_Base;
	static Find(Outer: UObject, ResourceName: string): AnimGraphNode_Base;
	static GetDefaultObject(): AnimGraphNode_Base;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimGraphNode_Base;
	static C(Other: UObject | any): AnimGraphNode_Base;
}

declare class AnimationGraph extends EdGraph { 
	BlendOptions: AnimGraphBlendOptions;
	static Load(ResourceName: string): AnimationGraph;
	static Find(Outer: UObject, ResourceName: string): AnimationGraph;
	static GetDefaultObject(): AnimationGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationGraph;
	GetGraphNodesOfClass(NodeClass: UnrealEngineClass,GraphNodes?: AnimGraphNode_Base[],bIncludeChildClasses?: boolean): {GraphNodes: AnimGraphNode_Base[]};
	static C(Other: UObject | any): AnimationGraph;
}

declare class AnimBlueprint extends Blueprint { 
	TargetSkeleton: Skeleton;
	Groups: AnimGroupInfo[];
	bIsTemplate: boolean;
	bUseMultiThreadedAnimationUpdate: boolean;
	bWarnAboutBlueprintUsage: boolean;
	ParentAssetOverrides: AnimParentNodeAssetOverride[];
	PoseWatchFolders: PoseWatchFolder[];
	PoseWatches: PoseWatch[];
	PreviewSkeletalMesh: SkeletalMesh;
	PreviewAnimationBlueprint: AnimBlueprint;
	PreviewAnimationBlueprintApplicationMethod: EPreviewAnimationBlueprintApplicationMethod;
	PreviewAnimationBlueprintTag: string;
	static Load(ResourceName: string): AnimBlueprint;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprint;
	static GetDefaultObject(): AnimBlueprint;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprint;
	static C(Other: UObject | any): AnimBlueprint;
	GetAnimationGraphs(AnimationGraphs?: AnimationGraph[]): {AnimationGraphs: AnimationGraph[]};
	GetNodesOfClass(NodeClass: UnrealEngineClass,GraphNodes?: AnimGraphNode_Base[],bIncludeChildClasses?: boolean): {GraphNodes: AnimGraphNode_Base[]};
	static GetAnimationGraphs(AnimationBlueprint: AnimBlueprint,AnimationGraphs?: AnimationGraph[]): {AnimationGraphs: AnimationGraph[]};
	static GetNodesOfClass(AnimationBlueprint: AnimBlueprint,NodeClass: UnrealEngineClass,GraphNodes?: AnimGraphNode_Base[],bIncludeChildClasses?: boolean): {GraphNodes: AnimGraphNode_Base[]};
}

declare class SingleAnimationPlayData { 
	AnimToPlay: AnimationAsset;
	bSavedLooping: boolean;
	bSavedPlaying: boolean;
	SavedPosition: number;
	SavedPlayRate: number;
	clone() : SingleAnimationPlayData;
	static C(Other: UObject | any): SingleAnimationPlayData;
}

declare type EKinematicBonesUpdateToPhysics = 'SkipSimulatingBones' | 'SkipAllBones' | 'EKinematicBonesUpdateToPhysics_MAX';
declare var EKinematicBonesUpdateToPhysics : { SkipSimulatingBones:'SkipSimulatingBones',SkipAllBones:'SkipAllBones',EKinematicBonesUpdateToPhysics_MAX:'EKinematicBonesUpdateToPhysics_MAX', };
declare type EPhysicsTransformUpdateMode = 'SimulationUpatesComponentTransform' | 'ComponentTransformIsKinematic' | 'EPhysicsTransformUpdateMode_MAX';
declare var EPhysicsTransformUpdateMode : { SimulationUpatesComponentTransform:'SimulationUpatesComponentTransform',ComponentTransformIsKinematic:'ComponentTransformIsKinematic',EPhysicsTransformUpdateMode_MAX:'EPhysicsTransformUpdateMode_MAX', };
declare type EAnimationMode = 'AnimationBlueprint' | 'AnimationSingleNode' | 'AnimationCustomMode' | 'EAnimationMode_MAX';
declare var EAnimationMode : { AnimationBlueprint:'AnimationBlueprint',AnimationSingleNode:'AnimationSingleNode',AnimationCustomMode:'AnimationCustomMode',EAnimationMode_MAX:'EAnimationMode_MAX', };
declare class ClothingSimulationFactory extends UObject { 
	static Load(ResourceName: string): ClothingSimulationFactory;
	static Find(Outer: UObject, ResourceName: string): ClothingSimulationFactory;
	static GetDefaultObject(): ClothingSimulationFactory;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingSimulationFactory;
	static C(Other: UObject | any): ClothingSimulationFactory;
}

declare class ClothingInteractor extends UObject { 
	static Load(ResourceName: string): ClothingInteractor;
	static Find(Outer: UObject, ResourceName: string): ClothingInteractor;
	static GetDefaultObject(): ClothingInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingInteractor;
	static C(Other: UObject | any): ClothingInteractor;
}

declare class ClothingSimulationInteractor extends UObject { 
	ClothingInteractors: any;
	static Load(ResourceName: string): ClothingSimulationInteractor;
	static Find(Outer: UObject, ResourceName: string): ClothingSimulationInteractor;
	static GetDefaultObject(): ClothingSimulationInteractor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ClothingSimulationInteractor;
	SetNumSubsteps(NumSubsteps: number): void;
	SetNumIterations(NumIterations: number): void;
	SetMaxNumIterations(MaxNumIterations: number): void;
	SetAnimDriveSpringStiffness(InStiffness: number): void;
	PhysicsAssetUpdated(): void;
	GetSimulationTime(): number;
	GetNumSubsteps(): number;
	GetNumKinematicParticles(): number;
	GetNumIterations(): number;
	GetNumDynamicParticles(): number;
	GetNumCloths(): number;
	GetClothingInteractor(ClothingAssetName: string): ClothingInteractor;
	EnableGravityOverride(InVector: Vector): void;
	DisableGravityOverride(): void;
	ClothConfigUpdated(): void;
	static C(Other: UObject | any): ClothingSimulationInteractor;
}

declare type ECustomBoneAttributeLookup = 'BoneOnly' | 'ImmediateParent' | 'ParentHierarchy' | 'ECustomBoneAttributeLookup_MAX';
declare var ECustomBoneAttributeLookup : { BoneOnly:'BoneOnly',ImmediateParent:'ImmediateParent',ParentHierarchy:'ParentHierarchy',ECustomBoneAttributeLookup_MAX:'ECustomBoneAttributeLookup_MAX', };
declare type ERelativeTransformSpace = 'RTS_World' | 'RTS_Actor' | 'RTS_Component' | 'RTS_ParentBoneSpace' | 'RTS_MAX';
declare var ERelativeTransformSpace : { RTS_World:'RTS_World',RTS_Actor:'RTS_Actor',RTS_Component:'RTS_Component',RTS_ParentBoneSpace:'RTS_ParentBoneSpace',RTS_MAX:'RTS_MAX', };
declare class SkeletalMeshComponent extends SkinnedMeshComponent { 
	AnimationBlueprint: AnimBlueprint;
	AnimBlueprintGeneratedClass: UnrealEngineClass;
	AnimClass: UnrealEngineClass;
	AnimScriptInstance: AnimInstance;
	SubInstances: AnimInstance[];
	PostProcessAnimInstance: AnimInstance;
	AnimationData: SingleAnimationPlayData;
	RootBoneTranslation: Vector;
	LineCheckBoundsScale: Vector;
	LinkedInstances: AnimInstance[];
	CachedBoneSpaceTransforms: Transform[];
	CachedComponentSpaceTransforms: Transform[];
	GlobalAnimRateScale: number;
	KinematicBonesUpdateType: EKinematicBonesUpdateToPhysics;
	PhysicsTransformUpdateMode: EPhysicsTransformUpdateMode;
	AnimationMode: EAnimationMode;
	bDisablePostProcessBlueprint: boolean;
	bUpdateOverlapsOnAnimationFinalize: boolean;
	bHasValidBodies: boolean;
	bBlendPhysics: boolean;
	bEnablePhysicsOnDedicatedServer: boolean;
	bUpdateJointsFromAnimation: boolean;
	bAllowClothActors: boolean;
	bDisableClothSimulation: boolean;
	bDisableRigidBodyAnimNode: boolean;
	bAllowAnimCurveEvaluation: boolean;
	bDisableAnimCurves: boolean;
	bCollideWithEnvironment: boolean;
	bCollideWithAttachedChildren: boolean;
	bForceCollisionUpdate: boolean;
	bLocalSpaceSimulation: boolean;
	bResetAfterTeleport: boolean;
	bDeferKinematicBoneUpdate: boolean;
	bNoSkeletonUpdate: boolean;
	bPauseAnims: boolean;
	bUseRefPoseOnInitAnim: boolean;
	bEnablePerPolyCollision: boolean;
	bForceRefpose: boolean;
	bOnlyAllowAutonomousTickPose: boolean;
	bIsAutonomousTickPose: boolean;
	bOldForceRefPose: boolean;
	bShowPrePhysBones: boolean;
	bRequiredBonesUpToDate: boolean;
	bAnimTreeInitialised: boolean;
	bIncludeComponentLocationIntoBounds: boolean;
	bEnableLineCheckWithBounds: boolean;
	bPropagateCurvesToSlaves: boolean;
	bSkipKinematicUpdateWhenInterpolating: boolean;
	bSkipBoundsUpdateWhenInterpolating: boolean;
	bUpdateAnimationInEditor: boolean;
	bUpdateClothInEditor: boolean;
	bOverrideDefaultAnimatingRig: boolean;
	bNeedsQueuedAnimEventsDispatched: boolean;
	CachedAnimCurveUidVersion: any;
	ClothBlendWeight: number;
	bWaitForParallelClothTask: boolean;
	DisallowedAnimCurves: string[];
	BodySetup: BodySetup;
	ClothMaxDistanceScale: number;
	OnConstraintBroken: UnrealEngineMulticastDelegate<(ConstraintIndex: number) => void>;
	OnPlasticDeformation: UnrealEngineMulticastDelegate<(ConstraintIndex: number) => void>;
	ClothingSimulationFactory: UnrealEngineClass;
	TeleportDistanceThreshold: number;
	TeleportRotationThreshold: number;
	LastPoseTickFrame: any;
	ClothingInteractor: ClothingSimulationInteractor;
	OnAnimInitialized: UnrealEngineMulticastDelegate<() => void>;
	SequenceToPlay: AnimSequence;
	AnimToPlay: AnimationAsset;
	bDefaultLooping: boolean;
	bDefaultPlaying: boolean;
	DefaultPosition: number;
	DefaultPlayRate: number;
	DefaultAnimatingRigOverride: UObject;
	static Load(ResourceName: string): SkeletalMeshComponent;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshComponent;
	static GetDefaultObject(): SkeletalMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshComponent;
	UnlinkAnimClassLayers(InClass: UnrealEngineClass): void;
	UnbindClothFromMasterPoseComponent(bRestoreSimulationSpace: boolean): void;
	ToggleDisablePostProcessBlueprint(): void;
	TermBodiesBelow(ParentBoneName: string): void;
	SuspendClothingSimulation(): void;
	Stop(): void;
	SnapshotPose(Snapshot?: PoseSnapshot): {Snapshot: PoseSnapshot};
	SetUpdateClothInEditor(NewUpdateState: boolean): void;
	SetUpdateAnimationInEditor(NewUpdateState: boolean): void;
	SetTeleportRotationThreshold(Threshold: number): void;
	SetTeleportDistanceThreshold(Threshold: number): void;
	SetPosition(InPos: number,bFireNotifies: boolean): void;
	SetPlayRate(Rate: number): void;
	SetPhysicsBlendWeight(PhysicsBlendWeight: number): void;
	SetNotifyRigidBodyCollisionBelow(bNewNotifyRigidBodyCollision: boolean,BoneName: string,bIncludeSelf: boolean): void;
	SetMorphTarget(MorphTargetName: string,Value: number,bRemoveZeroWeight: boolean): void;
	SetEnablePhysicsBlending(bNewBlendPhysics: boolean): void;
	SetEnableGravityOnAllBodiesBelow(bEnableGravity: boolean,BoneName: string,bIncludeSelf: boolean): void;
	SetEnableBodyGravity(bEnableGravity: boolean,BoneName: string): void;
	SetDisablePostProcessBlueprint(bInDisablePostProcess: boolean): void;
	SetDisableAnimCurves(bInDisableAnimCurves: boolean): void;
	SetDefaultAnimatingRigOverride(InAnimatingRig: UObject): void;
	SetConstraintProfileForAll(ProfileName: string,bDefaultIfNotFound: boolean): void;
	SetConstraintProfile(JointName: string,ProfileName: string,bDefaultIfNotFound: boolean): void;
	SetClothMaxDistanceScale(Scale: number): void;
	SetBodyNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean,BoneName: string): void;
	SetAnimClass(NewClass: UnrealEngineClass): void;
	SetAnimationMode(InAnimationMode: EAnimationMode): void;
	SetAnimation(NewAnimToPlay: AnimationAsset): void;
	SetAngularLimits(InBoneName: string,Swing1LimitAngle: number,TwistLimitAngle: number,Swing2LimitAngle: number): void;
	SetAllowRigidBodyAnimNode(bInAllow: boolean,bReinitAnim: boolean): void;
	SetAllowedAnimCurvesEvaluation(List: string[],bAllow: boolean): void;
	SetAllowClothActors(bInAllow: boolean): void;
	SetAllowAnimCurveEvaluation(bInAllow: boolean): void;
	SetAllMotorsAngularVelocityDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean,bSkipCustomPhysicsType: boolean): void;
	SetAllMotorsAngularPositionDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean,bSkipCustomPhysicsType: boolean): void;
	SetAllMotorsAngularDriveParams(InSpring: number,InDamping: number,InForceLimit: number,bSkipCustomPhysicsType: boolean): void;
	SetAllBodiesSimulatePhysics(bNewSimulate: boolean): void;
	SetAllBodiesPhysicsBlendWeight(PhysicsBlendWeight: number,bSkipCustomPhysicsType: boolean): void;
	SetAllBodiesBelowSimulatePhysics(InBoneName: string,bNewSimulate: boolean,bIncludeSelf: boolean): void;
	SetAllBodiesBelowPhysicsDisabled(InBoneName: string,bDisabled: boolean,bIncludeSelf: boolean): void;
	SetAllBodiesBelowPhysicsBlendWeight(InBoneName: string,PhysicsBlendWeight: number,bSkipCustomPhysicsType: boolean,bIncludeSelf: boolean): void;
	SetAllBodiesBelowLinearVelocity(InBoneName: string,LinearVelocity: Vector,bIncludeSelf: boolean): void;
	ResumeClothingSimulation(): void;
	ResetClothTeleportMode(): void;
	ResetAnimInstanceDynamics(InTeleportType: ETeleportType): void;
	ResetAllowedAnimCurveEvaluation(): void;
	ResetAllBodiesSimulatePhysics(): void;
	PlayAnimation(NewAnimToPlay: AnimationAsset,bLooping: boolean): void;
	Play(bLooping: boolean): void;
	OverrideAnimationData(InAnimToPlay: AnimationAsset,bIsLooping: boolean,bIsPlaying: boolean,position: number,PlayRate: number): void;
	LinkAnimGraphByTag(InTag: string,InClass: UnrealEngineClass): void;
	LinkAnimClassLayers(InClass: UnrealEngineClass): void;
	K2_GetClosestPointOnPhysicsAsset(WorldPosition: Vector,ClosestWorldPosition?: Vector,Normal?: Vector,BoneName?: string,Distance?: number): {ClosestWorldPosition: Vector, Normal: Vector, BoneName: string, Distance: number, $: boolean};
	IsPlaying(): boolean;
	IsClothingSimulationSuspended(): boolean;
	IsBodyGravityEnabled(BoneName: string): boolean;
	HasValidAnimationInstance(): boolean;
	GetTransformAttribute_Ref(BoneName: string,AttributeName: string,OutValue?: Transform,LookupType?: ECustomBoneAttributeLookup): {OutValue: Transform, $: boolean};
	GetTransformAttribute(BoneName: string,AttributeName: string,DefaultValue: Transform,OutValue?: Transform,LookupType?: ECustomBoneAttributeLookup): {OutValue: Transform, $: boolean};
	GetTeleportRotationThreshold(): number;
	GetTeleportDistanceThreshold(): number;
	GetStringAttribute_Ref(BoneName: string,AttributeName: string,OutValue?: string,LookupType?: ECustomBoneAttributeLookup): {OutValue: string, $: boolean};
	GetStringAttribute(BoneName: string,AttributeName: string,DefaultValue: string,OutValue?: string,LookupType?: ECustomBoneAttributeLookup): {OutValue: string, $: boolean};
	GetSkeletalCenterOfMass(): Vector;
	GetPostProcessInstance(): AnimInstance;
	GetPosition(): number;
	GetPlayRate(): number;
	GetMorphTarget(MorphTargetName: string): number;
	GetLinkedAnimLayerInstanceByGroup(InGroup: string): AnimInstance;
	GetLinkedAnimLayerInstanceByClass(InClass: UnrealEngineClass): AnimInstance;
	GetLinkedAnimGraphInstancesByTag(InTag: string,OutLinkedInstances?: AnimInstance[]): {OutLinkedInstances: AnimInstance[]};
	GetLinkedAnimGraphInstanceByTag(InTag: string): AnimInstance;
	GetIntegerAttribute_Ref(BoneName: string,AttributeName: string,OutValue?: number,LookupType?: ECustomBoneAttributeLookup): {OutValue: number, $: boolean};
	GetIntegerAttribute(BoneName: string,AttributeName: string,DefaultValue: number,OutValue?: number,LookupType?: ECustomBoneAttributeLookup): {OutValue: number, $: boolean};
	GetFloatAttribute_Ref(BoneName: string,AttributeName: string,OutValue?: number,LookupType?: ECustomBoneAttributeLookup): {OutValue: number, $: boolean};
	GetFloatAttribute(BoneName: string,AttributeName: string,DefaultValue: number,OutValue?: number,LookupType?: ECustomBoneAttributeLookup): {OutValue: number, $: boolean};
	GetDisablePostProcessBlueprint(): boolean;
	GetDisableAnimCurves(): boolean;
	GetDefaultAnimatingRigOverride(): UObject;
	GetDefaultAnimatingRig(): UObject;
	GetCurrentJointAngles(InBoneName: string,Swing1Angle?: number,TwistAngle?: number,Swing2Angle?: number): {Swing1Angle: number, TwistAngle: number, Swing2Angle: number};
	GetConstraintsFromBody(BodyName: string,bParentConstraints: boolean,bChildConstraints: boolean,bIncludesTerminated: boolean,OutConstraints?: ConstraintInstanceAccessor[]): {OutConstraints: ConstraintInstanceAccessor[]};
	GetConstraints(bIncludesTerminated: boolean,OutConstraints?: ConstraintInstanceAccessor[]): {OutConstraints: ConstraintInstanceAccessor[]};
	GetConstraintByName(ConstraintName: string,bIncludesTerminated: boolean): ConstraintInstanceAccessor;
	GetClothMaxDistanceScale(): number;
	GetClothingSimulationInteractor(): ClothingSimulationInteractor;
	GetBoneMass(BoneName: string,bScaleMass: boolean): number;
	GetBoneLinearVelocity(InBoneName: string): Vector;
	GetAnimInstance(): AnimInstance;
	GetAnimClass(): UnrealEngineClass;
	GetAnimationMode(): EAnimationMode;
	GetAllowRigidBodyAnimNode(): boolean;
	GetAllowedAnimCurveEvaluate(): boolean;
	GetAllowClothActors(): boolean;
	ForceClothNextUpdateTeleportAndReset(): void;
	ForceClothNextUpdateTeleport(): void;
	FindConstraintBoneName(ConstraintIndex: number): string;
	ClearMorphTargets(): void;
	BreakConstraint(Impulse: Vector,HitLocation: Vector,InBoneName: string): void;
	BindClothToMasterPoseComponent(): void;
	AllowAnimCurveEvaluation(NameOfCurve: string,bAllow: boolean): void;
	AddImpulseToAllBodiesBelow(Impulse: Vector,BoneName: string,bVelChange: boolean,bIncludeSelf: boolean): void;
	AddForceToAllBodiesBelow(Force: Vector,BoneName: string,bAccelChange: boolean,bIncludeSelf: boolean): void;
	AccumulateAllBodiesBelowPhysicsBlendWeight(InBoneName: string,AddPhysicsBlendWeight: number,bSkipCustomPhysicsType: boolean): void;
	static C(Other: UObject | any): SkeletalMeshComponent;
	GetPhysicsBodySetup(InName: string): BodySetup;
	K2_DirectionBetweenSockets(SocketOrBoneNameFrom: string,SocketOrBoneNameTo: string): Vector;
	K2_DistanceBetweenTwoSocketsAndMapRange(SocketOrBoneNameA: string,SocketSpaceA: ERelativeTransformSpace,SocketOrBoneNameB: string,SocketSpaceB: ERelativeTransformSpace,bRemapRange: boolean,InRangeMin: number,InRangeMax: number,OutRangeMin: number,OutRangeMax: number): number;
	static GetPhysicsBodySetup(InSkeletalMeshComp: SkeletalMeshComponent,InName: string): BodySetup;
	static K2_DirectionBetweenSockets(Component: SkeletalMeshComponent,SocketOrBoneNameFrom: string,SocketOrBoneNameTo: string): Vector;
	static K2_DistanceBetweenTwoSocketsAndMapRange(Component: SkeletalMeshComponent,SocketOrBoneNameA: string,SocketSpaceA: ERelativeTransformSpace,SocketOrBoneNameB: string,SocketSpaceB: ERelativeTransformSpace,bRemapRange: boolean,InRangeMin: number,InRangeMax: number,OutRangeMin: number,OutRangeMax: number): number;
}

declare class SkeletalMeshSocket extends UObject { 
	SocketName: string;
	BoneName: string;
	RelativeLocation: Vector;
	RelativeRotation: Rotator;
	RelativeScale: Vector;
	bForceAlwaysAnimated: boolean;
	static Load(ResourceName: string): SkeletalMeshSocket;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshSocket;
	static GetDefaultObject(): SkeletalMeshSocket;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshSocket;
	InitializeSocketFromLocation(SkelComp: SkeletalMeshComponent,WorldLocation: Vector,WorldNormal: Vector): void;
	GetSocketLocation(SkelComp: SkeletalMeshComponent): Vector;
	static C(Other: UObject | any): SkeletalMeshSocket;
}

declare class SmartNameContainer { 
	clone() : SmartNameContainer;
	static C(Other: UObject | any): SmartNameContainer;
}

declare class AnimSlotGroup { 
	GroupName: string;
	SlotNames: string[];
	clone() : AnimSlotGroup;
	static C(Other: UObject | any): AnimSlotGroup;
}

declare type EConstraintTransform = 'Absolute' | 'Relative' | 'EConstraintTransform_MAX';
declare var EConstraintTransform : { Absolute:'Absolute',Relative:'Relative',EConstraintTransform_MAX:'EConstraintTransform_MAX', };
declare class RigTransformConstraint { 
	TranformType: EConstraintTransform;
	ParentSpace: string;
	Weight: number;
	clone() : RigTransformConstraint;
	static C(Other: UObject | any): RigTransformConstraint;
}

declare class TransformBaseConstraint { 
	TransformConstraints: RigTransformConstraint[];
	clone() : TransformBaseConstraint;
	static C(Other: UObject | any): TransformBaseConstraint;
}

declare class TransformBase { 
	UNode: string;
	Constraints: TransformBaseConstraint;
	clone() : TransformBase;
	static C(Other: UObject | any): TransformBase;
}

declare class UNode { 
	Name: string;
	ParentName: string;
	Transform: Transform;
	DisplayName: string;
	bAdvanced: boolean;
	clone() : UNode;
	static C(Other: UObject | any): UNode;
}

declare class Rig extends UObject { 
	TransformBases: TransformBase[];
	Nodes: UNode[];
	static Load(ResourceName: string): Rig;
	static Find(Outer: UObject, ResourceName: string): Rig;
	static GetDefaultObject(): Rig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Rig;
	static C(Other: UObject | any): Rig;
}

declare class NameMapping { 
	NodeName: string;
	BoneName: string;
	clone() : NameMapping;
	static C(Other: UObject | any): NameMapping;
}

declare class RigConfiguration { 
	Rig: Rig;
	BoneMappingTable: NameMapping[];
	clone() : RigConfiguration;
	static C(Other: UObject | any): RigConfiguration;
}

declare type ETransformCurveChannel = 'Position' | 'Rotation' | 'Scale' | 'Invalid' | 'ETransformCurveChannel_MAX';
declare var ETransformCurveChannel : { Position:'Position',Rotation:'Rotation',Scale:'Scale',Invalid:'Invalid',ETransformCurveChannel_MAX:'ETransformCurveChannel_MAX', };
declare type EVectorCurveChannel = 'X' | 'Y' | 'Z' | 'Invalid' | 'EVectorCurveChannel_MAX';
declare var EVectorCurveChannel : { X:'X',Y:'Y',Z:'Z',Invalid:'Invalid',EVectorCurveChannel_MAX:'EVectorCurveChannel_MAX', };
declare class AnimationCurveIdentifier { 
	clone() : AnimationCurveIdentifier;
	static C(Other: UObject | any): AnimationCurveIdentifier;
	GetName(): {Identifier: AnimationCurveIdentifier, $: string};
	GetTransformChildCurveIdentifier(Channel?: ETransformCurveChannel,Axis?: EVectorCurveChannel): {InOutIdentifier: AnimationCurveIdentifier, $: boolean};
	GetType(): {Identifier: AnimationCurveIdentifier, $: ERawCurveTrackTypes};
	IsValid(): {Identifier: AnimationCurveIdentifier, $: boolean};
	static GetName(Identifier?: AnimationCurveIdentifier): {Identifier: AnimationCurveIdentifier, $: string};
	static GetTransformChildCurveIdentifier(InOutIdentifier?: AnimationCurveIdentifier,Channel?: ETransformCurveChannel,Axis?: EVectorCurveChannel): {InOutIdentifier: AnimationCurveIdentifier, $: boolean};
	static GetType(Identifier?: AnimationCurveIdentifier): {Identifier: AnimationCurveIdentifier, $: ERawCurveTrackTypes};
	static IsValid(Identifier?: AnimationCurveIdentifier): {Identifier: AnimationCurveIdentifier, $: boolean};
}

declare type EAnimPoseSpaces = 'Local' | 'World' | 'EAnimPoseSpaces_MAX';
declare var EAnimPoseSpaces : { Local:'Local',World:'World',EAnimPoseSpaces_MAX:'EAnimPoseSpaces_MAX', };
declare class AnimPose { 
	BoneNames: string[];
	BoneIndices: number[];
	ParentBoneIndices: number[];
	LocalSpacePoses: Transform[];
	WorldSpacePoses: Transform[];
	RefLocalSpacePoses: Transform[];
	RefWorldSpacePoses: Transform[];
	clone() : AnimPose;
	static C(Other: UObject | any): AnimPose;
	EvaluateAnimationBlueprintWithInputPose(TargetSkeletalMesh: SkeletalMesh,AnimationBlueprint: AnimBlueprint,OutPose?: AnimPose): {OutPose: AnimPose};
	GetBoneNames(Bones?: string[]): {Bones: string[]};
	GetBonePose(BoneName: string,Space: EAnimPoseSpaces): Transform;
	GetRefBonePose(BoneName: string,Space: EAnimPoseSpaces): Transform;
	GetRefPoseRelativeTransform(FromBoneName: string,ToBoneName: string,Space: EAnimPoseSpaces): Transform;
	GetRelativeToRefPoseTransform(BoneName: string,Space: EAnimPoseSpaces): Transform;
	GetRelativeTransform(FromBoneName: string,ToBoneName: string,Space: EAnimPoseSpaces): Transform;
	IsValid(): boolean;
	SetBonePose(Transform?: Transform,BoneName?: string,Space?: EAnimPoseSpaces): {Pose: AnimPose};
	static EvaluateAnimationBlueprintWithInputPose(InputPose: AnimPose,TargetSkeletalMesh: SkeletalMesh,AnimationBlueprint: AnimBlueprint,OutPose?: AnimPose): {OutPose: AnimPose};
	static GetBoneNames(Pose: AnimPose,Bones?: string[]): {Bones: string[]};
	static GetBonePose(Pose: AnimPose,BoneName: string,Space: EAnimPoseSpaces): Transform;
	static GetRefBonePose(Pose: AnimPose,BoneName: string,Space: EAnimPoseSpaces): Transform;
	static GetRefPoseRelativeTransform(Pose: AnimPose,FromBoneName: string,ToBoneName: string,Space: EAnimPoseSpaces): Transform;
	static GetRelativeToRefPoseTransform(Pose: AnimPose,BoneName: string,Space: EAnimPoseSpaces): Transform;
	static GetRelativeTransform(Pose: AnimPose,FromBoneName: string,ToBoneName: string,Space: EAnimPoseSpaces): Transform;
	static IsValid(Pose: AnimPose): boolean;
	static SetBonePose(Pose?: AnimPose,Transform?: Transform,BoneName?: string,Space?: EAnimPoseSpaces): {Pose: AnimPose};
}

declare class Skeleton extends UObject { 
	BoneTree: BoneNode[];
	RefLocalPoses: Transform[];
	VirtualBoneGuid: Guid;
	VirtualBones: VirtualBone[];
	CompatibleSkeletons: Skeleton[];
	Sockets: SkeletalMeshSocket[];
	SmartNames: SmartNameContainer;
	BlendProfiles: BlendProfile[];
	SlotGroups: AnimSlotGroup[];
	PreviewSkeletalMesh: SkeletalMesh;
	AdditionalPreviewSkeletalMeshes: DataAsset;
	RigConfig: RigConfiguration;
	AnimationNotifies: string[];
	PreviewAttachedAssetContainer: PreviewAssetAttachContainer;
	AssetUserData: AssetUserData[];
	static Load(ResourceName: string): Skeleton;
	static Find(Outer: UObject, ResourceName: string): Skeleton;
	static GetDefaultObject(): Skeleton;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Skeleton;
	GetBlendProfile(InProfileName: string): BlendProfile;
	AddCompatibleSkeleton(SourceSkeleton: Skeleton): void;
	static C(Other: UObject | any): Skeleton;
	FindCurveIdentifier(Name: string,CurveType: ERawCurveTrackTypes): AnimationCurveIdentifier;
	GetCurveIdentifier(Name: string,CurveType: ERawCurveTrackTypes): AnimationCurveIdentifier;
	GetCurveIdentifiers(CurveType: ERawCurveTrackTypes): AnimationCurveIdentifier[];
	GetReferencePose(OutPose?: AnimPose): {OutPose: AnimPose};
	CopyAnimationCurveNamesToSkeleton(NewSkeleton: Skeleton,SequenceBase: AnimSequenceBase,CurveType: ERawCurveTrackTypes): void;
	static FindCurveIdentifier(InSkeleton: Skeleton,Name: string,CurveType: ERawCurveTrackTypes): AnimationCurveIdentifier;
	static GetCurveIdentifier(InSkeleton: Skeleton,Name: string,CurveType: ERawCurveTrackTypes): AnimationCurveIdentifier;
	static GetCurveIdentifiers(InSkeleton: Skeleton,CurveType: ERawCurveTrackTypes): AnimationCurveIdentifier[];
	static GetReferencePose(Skeleton: Skeleton,OutPose?: AnimPose): {OutPose: AnimPose};
	static CopyAnimationCurveNamesToSkeleton(OldSkeleton: Skeleton,NewSkeleton: Skeleton,SequenceBase: AnimSequenceBase,CurveType: ERawCurveTrackTypes): void;
}

declare class AnimMetaData extends UObject { 
	static Load(ResourceName: string): AnimMetaData;
	static Find(Outer: UObject, ResourceName: string): AnimMetaData;
	static GetDefaultObject(): AnimMetaData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimMetaData;
	static C(Other: UObject | any): AnimMetaData;
}

declare class AssetMapping { 
	SourceAsset: AnimationAsset;
	TargetAsset: AnimationAsset;
	clone() : AssetMapping;
	static C(Other: UObject | any): AssetMapping;
}

declare class AssetMappingTable extends UObject { 
	MappedAssets: AssetMapping[];
	static Load(ResourceName: string): AssetMappingTable;
	static Find(Outer: UObject, ResourceName: string): AssetMappingTable;
	static GetDefaultObject(): AssetMappingTable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetMappingTable;
	static C(Other: UObject | any): AssetMappingTable;
}

declare class SmartName { 
	DisplayName: string;
	clone() : SmartName;
	static C(Other: UObject | any): SmartName;
}

declare class PoseAssetInfluence { 
	PoseIndex: number;
	BoneTransformIndex: number;
	clone() : PoseAssetInfluence;
	static C(Other: UObject | any): PoseAssetInfluence;
}

declare class PoseAssetInfluences { 
	Influences: PoseAssetInfluence[];
	clone() : PoseAssetInfluences;
	static C(Other: UObject | any): PoseAssetInfluences;
}

declare class PoseData { 
	SourceLocalSpacePose: Transform[];
	SourceCurveData: number[];
	LocalSpacePose: Transform[];
	CurveData: number[];
	clone() : PoseData;
	static C(Other: UObject | any): PoseData;
}

declare class AnimCurveBase { 
	LastObservedName: string;
	Name: SmartName;
	Color: LinearColor;
	CurveTypeFlags: number;
	clone() : AnimCurveBase;
	static C(Other: UObject | any): AnimCurveBase;
}

declare class PoseDataContainer { 
	PoseNames: SmartName[];
	Tracks: string[];
	TrackBoneIndices: number[];
	TrackPoseInfluenceIndices: PoseAssetInfluences[];
	Poses: PoseData[];
	Curves: AnimCurveBase[];
	clone() : PoseDataContainer;
	static C(Other: UObject | any): PoseDataContainer;
}

declare class PoseAsset extends AnimationAsset { 
	PoseContainer: PoseDataContainer;
	bAdditivePose: boolean;
	BasePoseIndex: number;
	RetargetSource: string;
	RetargetSourceAsset: SkeletalMesh;
	RetargetSourceAssetReferencePose: Transform[];
	SourceAnimation: AnimSequence;
	SourceAnimationRawDataGUID: Guid;
	static Load(ResourceName: string): PoseAsset;
	static Find(Outer: UObject, ResourceName: string): PoseAsset;
	static GetDefaultObject(): PoseAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PoseAsset;
	UpdatePoseFromAnimation(AnimSequence: AnimSequence): void;
	RenamePose(OriginalPoseName: string,NewPoseName: string): void;
	GetPoseNames(PoseNames?: string[]): {PoseNames: string[]};
	static C(Other: UObject | any): PoseAsset;
}

declare class AnimationAttributeIdentifier { 
	Name: string;
	BoneName: string;
	BoneIndex: number;
	ScriptStruct: ScriptStruct;
	ScriptStructPath: SoftObjectPath;
	clone() : AnimationAttributeIdentifier;
	static C(Other: UObject | any): AnimationAttributeIdentifier;
	IsValid(): {Identifier: AnimationAttributeIdentifier, $: boolean};
	static IsValid(Identifier?: AnimationAttributeIdentifier): {Identifier: AnimationAttributeIdentifier, $: boolean};
}

declare class AnimationAsset extends UObject { 
	Skeleton: Skeleton;
	MetaData: AnimMetaData[];
	ParentAsset: AnimationAsset;
	ChildrenAssets: AnimationAsset[];
	AssetMappingTable: AssetMappingTable;
	AssetUserData: AssetUserData[];
	ThumbnailInfo: ThumbnailInfo;
	PreviewPoseAsset: PoseAsset;
	PreviewSkeletalMesh: SkeletalMesh;
	static Load(ResourceName: string): AnimationAsset;
	static Find(Outer: UObject, ResourceName: string): AnimationAsset;
	static GetDefaultObject(): AnimationAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationAsset;
	SetPreviewSkeletalMesh(PreviewMesh: SkeletalMesh): void;
	GetPlayLength(): number;
	static C(Other: UObject | any): AnimationAsset;
	CreateAttributeIdentifier(AttributeName: string,BoneName: string,AttributeType: ScriptStruct,bValidateExistsOnAsset: boolean): AnimationAttributeIdentifier;
	GetSkeleton(): Skeleton;
	AddMetaData(MetaDataClass: UnrealEngineClass,MetaDataInstance?: AnimMetaData): {MetaDataInstance: AnimMetaData};
	AddMetaDataObject(MetaDataObject: AnimMetaData): void;
	ContainsMetaDataOfClass(MetaDataClass: UnrealEngineClass): boolean;
	GetMetaData(MetaData?: AnimMetaData[]): {MetaData: AnimMetaData[]};
	GetMetaDataOfClass(MetaDataClass: UnrealEngineClass,MetaDataOfClass?: AnimMetaData[]): {MetaDataOfClass: AnimMetaData[]};
	RemoveAllMetaData(): void;
	RemoveMetaData(MetaDataObject: AnimMetaData): void;
	RemoveMetaDataOfClass(MetaDataClass: UnrealEngineClass): void;
	static CreateAttributeIdentifier(AnimationAsset: AnimationAsset,AttributeName: string,BoneName: string,AttributeType: ScriptStruct,bValidateExistsOnAsset: boolean): AnimationAttributeIdentifier;
	static GetSkeleton(InAsset: AnimationAsset): Skeleton;
	static AddMetaData(AnimationAsset: AnimationAsset,MetaDataClass: UnrealEngineClass,MetaDataInstance?: AnimMetaData): {MetaDataInstance: AnimMetaData};
	static AddMetaDataObject(AnimationAsset: AnimationAsset,MetaDataObject: AnimMetaData): void;
	static ContainsMetaDataOfClass(AnimationAsset: AnimationAsset,MetaDataClass: UnrealEngineClass): boolean;
	static GetMetaData(AnimationAsset: AnimationAsset,MetaData?: AnimMetaData[]): {MetaData: AnimMetaData[]};
	static GetMetaDataOfClass(AnimationAsset: AnimationAsset,MetaDataClass: UnrealEngineClass,MetaDataOfClass?: AnimMetaData[]): {MetaDataOfClass: AnimMetaData[]};
	static RemoveAllMetaData(AnimationAsset: AnimationAsset): void;
	static RemoveMetaData(AnimationAsset: AnimationAsset,MetaDataObject: AnimMetaData): void;
	static RemoveMetaDataOfClass(AnimationAsset: AnimationAsset,MetaDataClass: UnrealEngineClass): void;
}

declare class FloatCurve extends AnimCurveBase { 
	FloatCurve: RichCurve;
	clone() : FloatCurve;
	static C(Other: UObject | any): FloatCurve;
}

declare class VectorCurve extends AnimCurveBase { 
	FloatCurves: RichCurve;
	clone() : VectorCurve;
	static C(Other: UObject | any): VectorCurve;
}

declare class TransformCurve extends AnimCurveBase { 
	TranslationCurve: VectorCurve;
	RotationCurve: VectorCurve;
	ScaleCurve: VectorCurve;
	clone() : TransformCurve;
	static C(Other: UObject | any): TransformCurve;
}

declare class RawCurveTracks { 
	FloatCurves: FloatCurve[];
	VectorCurves: VectorCurve[];
	TransformCurves: TransformCurve[];
	clone() : RawCurveTracks;
	static C(Other: UObject | any): RawCurveTracks;
}

declare class AnimNotifyTrack { 
	TrackName: string;
	TrackColor: LinearColor;
	clone() : AnimNotifyTrack;
	static C(Other: UObject | any): AnimNotifyTrack;
}

declare type EAnimDataModelNotifyType = 'BracketOpened' | 'BracketClosed' | 'TrackAdded' | 'TrackChanged' | 'TrackRemoved' | 'SequenceLengthChanged' | 'FrameRateChanged' | 'CurveAdded' | 'CurveChanged' | 'CurveRemoved' | 'CurveFlagsChanged' | 'CurveRenamed' | 'CurveScaled' | 'CurveColorChanged' | 'AttributeAdded' | 'AttributeRemoved' | 'AttributeChanged' | 'Populated' | 'Reset' | 'Invalid' | 'EAnimDataModelNotifyType_MAX';
declare var EAnimDataModelNotifyType : { BracketOpened:'BracketOpened',BracketClosed:'BracketClosed',TrackAdded:'TrackAdded',TrackChanged:'TrackChanged',TrackRemoved:'TrackRemoved',SequenceLengthChanged:'SequenceLengthChanged',FrameRateChanged:'FrameRateChanged',CurveAdded:'CurveAdded',CurveChanged:'CurveChanged',CurveRemoved:'CurveRemoved',CurveFlagsChanged:'CurveFlagsChanged',CurveRenamed:'CurveRenamed',CurveScaled:'CurveScaled',CurveColorChanged:'CurveColorChanged',AttributeAdded:'AttributeAdded',AttributeRemoved:'AttributeRemoved',AttributeChanged:'AttributeChanged',Populated:'Populated',Reset:'Reset',Invalid:'Invalid',EAnimDataModelNotifyType_MAX:'EAnimDataModelNotifyType_MAX', };
declare class EmptyPayload { 
	clone() : EmptyPayload;
	static C(Other: UObject | any): EmptyPayload;
}

declare class AnimDataModelNotifPayload { 
	clone() : AnimDataModelNotifPayload;
	static C(Other: UObject | any): AnimDataModelNotifPayload;
	CopyPayload(ExpectedStruct: ScriptStruct,OutPayload?: EmptyPayload): {OutPayload: EmptyPayload};
	GetPayload(): EmptyPayload;
	static CopyPayload(Payload: AnimDataModelNotifPayload,ExpectedStruct: ScriptStruct,OutPayload?: EmptyPayload): {OutPayload: EmptyPayload};
	static GetPayload(Payload: AnimDataModelNotifPayload): EmptyPayload;
}

declare class AnimationCurveData { 
	FloatCurves: FloatCurve[];
	TransformCurves: TransformCurve[];
	clone() : AnimationCurveData;
	static C(Other: UObject | any): AnimationCurveData;
}

declare class AttributeKey { 
	Time: number;
	clone() : AttributeKey;
	static C(Other: UObject | any): AttributeKey;
}

declare class AttributeCurve extends IndexedCurve { 
	Keys: AttributeKey[];
	ScriptStructPath: SoftObjectPath;
	ScriptStruct: ScriptStruct;
	bShouldInterpolate: boolean;
	clone() : AttributeCurve;
	static C(Other: UObject | any): AttributeCurve;
}

declare class AnimatedBoneAttribute { 
	Identifier: AnimationAttributeIdentifier;
	Curve: AttributeCurve;
	clone() : AnimatedBoneAttribute;
	static C(Other: UObject | any): AnimatedBoneAttribute;
}

declare class AnimDataModel extends UObject { 
	BracketCounter: number;
	ModifiedEventDynamic: UnrealEngineMulticastDelegate<(NotifType: EAnimDataModelNotifyType, Model: AnimDataModel, Payload: AnimDataModelNotifPayload) => void>;
	BoneAnimationTracks: BoneAnimationTrack[];
	PlayLength: number;
	FrameRate: FrameRate;
	NumberOfFrames: number;
	NumberOfKeys: number;
	CurveData: AnimationCurveData;
	AnimatedBoneAttributes: AnimatedBoneAttribute[];
	RawAnimationTracks: RawAnimSequenceTrack[];
	RawAnimationTrackNames: string[];
	RawAnimationTrackSkeletonMappings: TrackToSkeletonMap[];
	RawCurveTracks: RawCurveTracks;
	static Load(ResourceName: string): AnimDataModel;
	static Find(Outer: UObject, ResourceName: string): AnimDataModel;
	static GetDefaultObject(): AnimDataModel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimDataModel;
	IsValidBoneTrackIndex(TrackIndex: number): boolean;
	GetPlayLength(): number;
	GetNumBoneTracks(): number;
	GetNumberOfTransformCurves(): number;
	GetNumberOfKeys(): number;
	GetNumberOfFrames(): number;
	GetNumberOfFloatCurves(): number;
	GetFrameRate(): FrameRate;
	GetBoneTrackNames(OutNames?: string[]): {OutNames: string[]};
	GetBoneTrackIndexByName(TrackName: string): number;
	GetBoneTrackIndex(Track: BoneAnimationTrack): number;
	GetBoneTrackByName(TrackName: string): BoneAnimationTrack;
	GetBoneTrackByIndex(TrackIndex: number): BoneAnimationTrack;
	GetBoneAnimationTracks(): BoneAnimationTrack[];
	GetAnimationSequence(): AnimSequence;
	static C(Other: UObject | any): AnimDataModel;
}

declare type EAnimDataEvalType = 'Source' | 'Raw' | 'Compressed' | 'EAnimDataEvalType_MAX';
declare var EAnimDataEvalType : { Source:'Source',Raw:'Raw',Compressed:'Compressed',EAnimDataEvalType_MAX:'EAnimDataEvalType_MAX', };
declare class AnimPoseEvaluationOptions { 
	EvaluationType: EAnimDataEvalType;
	bShouldRetarget: boolean;
	bExtractRootMotion: boolean;
	OptionalSkeletalMesh: SkeletalMesh;
	clone() : AnimPoseEvaluationOptions;
	static C(Other: UObject | any): AnimPoseEvaluationOptions;
}

declare class FrameNumber { 
	Value: number;
	clone() : FrameNumber;
	static C(Other: UObject | any): FrameNumber;
	MakeQualifiedFrameTime(FrameRate: FrameRate,SubFrame: number): QualifiedFrameTime;
	Add_FrameNumberFrameNumber(B: FrameNumber): FrameNumber;
	Add_FrameNumberInteger(B: number): FrameNumber;
	Conv_FrameNumberToInteger(): number;
	Divide_FrameNumberInteger(B: number): FrameNumber;
	Multiply_FrameNumberInteger(B: number): FrameNumber;
	Subtract_FrameNumberFrameNumber(B: FrameNumber): FrameNumber;
	Subtract_FrameNumberInteger(B: number): FrameNumber;
	static MakeQualifiedFrameTime(Frame: FrameNumber,FrameRate: FrameRate,SubFrame: number): QualifiedFrameTime;
	static Add_FrameNumberFrameNumber(A: FrameNumber,B: FrameNumber): FrameNumber;
	static Add_FrameNumberInteger(A: FrameNumber,B: number): FrameNumber;
	static Conv_FrameNumberToInteger(InFrameNumber: FrameNumber): number;
	static Divide_FrameNumberInteger(A: FrameNumber,B: number): FrameNumber;
	static Multiply_FrameNumberInteger(A: FrameNumber,B: number): FrameNumber;
	static Subtract_FrameNumberFrameNumber(A: FrameNumber,B: FrameNumber): FrameNumber;
	static Subtract_FrameNumberInteger(A: FrameNumber,B: number): FrameNumber;
}

declare class FrameTime { 
	FrameNumber: FrameNumber;
	SubFrame: number;
	clone() : FrameTime;
	static C(Other: UObject | any): FrameTime;
	SnapFrameTimeToRate(SourceRate: FrameRate,SnapToRate: FrameRate): FrameTime;
	TransformTime(SourceRate: FrameRate,DestinationRate: FrameRate): FrameTime;
	static SnapFrameTimeToRate(SourceTime: FrameTime,SourceRate: FrameRate,SnapToRate: FrameRate): FrameTime;
	static TransformTime(SourceTime: FrameTime,SourceRate: FrameRate,DestinationRate: FrameRate): FrameTime;
	static Multiply_SecondsFrameRate(TimeInSeconds: number,FrameRate: FrameRate): FrameTime;
}

declare class QualifiedFrameTime { 
	Time: FrameTime;
	Rate: FrameRate;
	clone() : QualifiedFrameTime;
	static C(Other: UObject | any): QualifiedFrameTime;
	BreakQualifiedFrameTime(Frame?: FrameNumber,FrameRate?: FrameRate,SubFrame?: number): {Frame: FrameNumber, FrameRate: FrameRate, SubFrame: number};
	Conv_QualifiedFrameTimeToSeconds(): number;
	static BreakQualifiedFrameTime(InFrameTime: QualifiedFrameTime,Frame?: FrameNumber,FrameRate?: FrameRate,SubFrame?: number): {Frame: FrameNumber, FrameRate: FrameRate, SubFrame: number};
	static Conv_QualifiedFrameTimeToSeconds(InFrameTime: QualifiedFrameTime): number;
}

declare class AnimSequenceBase extends AnimationAsset { 
	Notifies: AnimNotifyEvent[];
	SequenceLength: number;
	RateScale: number;
	RawCurveData: RawCurveTracks;
	AnimNotifyTracks: AnimNotifyTrack[];
	DataModel: AnimDataModel;
	Controller: any;
	static Load(ResourceName: string): AnimSequenceBase;
	static Find(Outer: UObject, ResourceName: string): AnimSequenceBase;
	static GetDefaultObject(): AnimSequenceBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequenceBase;
	static C(Other: UObject | any): AnimSequenceBase;
	ReplaceAnimNotifyClass(NotifyName: string,NewNotifyName: string,NewNotifyClass: UObject): number;
	AddTransformAttribute(AttributeName: string,BoneName: string,Keys: number[],Values: Transform[]): boolean;
	GetAnimPoseAtFrame(FrameIndex: number,EvaluationOptions: AnimPoseEvaluationOptions,Pose?: AnimPose): {Pose: AnimPose};
	GetAnimPoseAtTime(Time: number,EvaluationOptions: AnimPoseEvaluationOptions,Pose?: AnimPose): {Pose: AnimPose};
	AddAnimationNotifyEvent(NotifyTrackName: string,StartTime: number,NotifyClass: UnrealEngineClass): AnimNotify;
	AddAnimationNotifyEventObject(StartTime: number,Notify: AnimNotify,NotifyTrackName: string): void;
	AddAnimationNotifyStateEvent(NotifyTrackName: string,StartTime: number,Duration: number,NotifyStateClass: UnrealEngineClass): AnimNotifyState;
	AddAnimationNotifyStateEventObject(StartTime: number,Duration: number,NotifyState: AnimNotifyState,NotifyTrackName: string): void;
	AddAnimationNotifyTrack(NotifyTrackName: string,TrackColor: LinearColor): void;
	CopyAnimNotifiesFromSequence(DestinationAnimationSequenceBase: AnimSequenceBase,bDeleteExistingNotifies: boolean): void;
	EvaluateRootBoneTimecodeAttributesAtTime(EvalTime: number,OutQualifiedFrameTime?: QualifiedFrameTime): {OutQualifiedFrameTime: QualifiedFrameTime, $: boolean};
	FindBonePathToRoot(BoneName: string,BonePath?: string[]): {BonePath: string[]};
	GetAnimationNotifyEventNames(EventNames?: string[]): {EventNames: string[]};
	GetAnimationNotifyEvents(NotifyEvents?: AnimNotifyEvent[]): {NotifyEvents: AnimNotifyEvent[]};
	GetAnimationNotifyEventsForTrack(NotifyTrackName: string,Events?: AnimNotifyEvent[]): {Events: AnimNotifyEvent[]};
	GetAnimationNotifyTrackNames(TrackNames?: string[]): {TrackNames: string[]};
	GetAnimationTrackNames(TrackNames?: string[]): {TrackNames: string[]};
	GetBonePoseForFrame(BoneName: string,Frame: number,bExtractRootMotion: boolean,Pose?: Transform): {Pose: Transform};
	GetBonePoseForTime(BoneName: string,Time: number,bExtractRootMotion: boolean,Pose?: Transform): {Pose: Transform};
	GetBonePosesForFrame(BoneNames: string[],Frame: number,bExtractRootMotion: boolean,Poses?: Transform[],PreviewMesh?: SkeletalMesh): {Poses: Transform[]};
	GetBonePosesForTime(BoneNames: string[],Time: number,bExtractRootMotion: boolean,Poses?: Transform[],PreviewMesh?: SkeletalMesh): {Poses: Transform[]};
	GetFrameAtTime(Time: number,Frame?: number): {Frame: number};
	GetNumFrames(NumFrames?: number): {NumFrames: number};
	GetNumKeys(NumKeys?: number): {NumKeys: number};
	GetRateScale(RateScale?: number): {RateScale: number};
	GetRawTrackData(TrackName: string,PositionKeys?: Vector[],RotationKeys?: Quat[],ScalingKeys?: Vector[]): {PositionKeys: Vector[], RotationKeys: Quat[], ScalingKeys: Vector[]};
	GetRawTrackPositionData(TrackName: string,PositionData?: Vector[]): {PositionData: Vector[]};
	GetRawTrackRotationData(TrackName: string,RotationData?: Quat[]): {RotationData: Quat[]};
	GetRawTrackScaleData(TrackName: string,ScaleData?: Vector[]): {ScaleData: Vector[]};
	GetSequenceLength(Length?: number): {Length: number};
	GetTimeAtFrame(Frame: number,Time?: number): {Time: number};
	IsValidAnimNotifyTrackName(NotifyTrackName: string): boolean;
	IsValidRawAnimationTrackName(TrackName: string): boolean;
	IsValidTime(Time: number,IsValid?: boolean): {IsValid: boolean};
	RemoveAllAnimationNotifyTracks(): void;
	RemoveAnimationNotifyEventsByName(NotifyName: string): number;
	RemoveAnimationNotifyEventsByTrack(NotifyTrackName: string): number;
	RemoveAnimationNotifyTrack(NotifyTrackName: string): void;
	ReplaceAnimNotifies(OldNotifyClass: UnrealEngineClass,NewNotifyClass: UnrealEngineClass,OnNotifyReplaced: UnrealEngineDelegate<(OldNotify: AnimNotify, NewNotify: AnimNotify) => void>): void;
	ReplaceAnimNotifyStates(OldNotifyClass: UnrealEngineClass,NewNotifyClass: UnrealEngineClass,OnNotifyStateReplaced: UnrealEngineDelegate<(OldNotifyState: AnimNotifyState, NewNotifyState: AnimNotifyState) => void>): void;
	SetRateScale(RateScale: number): void;
	static ReplaceAnimNotifyClass(Sequence: AnimSequenceBase,NotifyName: string,NewNotifyName: string,NewNotifyClass: UObject): number;
	static AddTransformAttribute(AnimSequenceBase: AnimSequenceBase,AttributeName: string,BoneName: string,Keys: number[],Values: Transform[]): boolean;
	static GetAnimPoseAtFrame(AnimationSequenceBase: AnimSequenceBase,FrameIndex: number,EvaluationOptions: AnimPoseEvaluationOptions,Pose?: AnimPose): {Pose: AnimPose};
	static GetAnimPoseAtTime(AnimationSequenceBase: AnimSequenceBase,Time: number,EvaluationOptions: AnimPoseEvaluationOptions,Pose?: AnimPose): {Pose: AnimPose};
	static AddAnimationNotifyEvent(AnimationSequenceBase: AnimSequenceBase,NotifyTrackName: string,StartTime: number,NotifyClass: UnrealEngineClass): AnimNotify;
	static AddAnimationNotifyEventObject(AnimationSequenceBase: AnimSequenceBase,StartTime: number,Notify: AnimNotify,NotifyTrackName: string): void;
	static AddAnimationNotifyStateEvent(AnimationSequenceBase: AnimSequenceBase,NotifyTrackName: string,StartTime: number,Duration: number,NotifyStateClass: UnrealEngineClass): AnimNotifyState;
	static AddAnimationNotifyStateEventObject(AnimationSequenceBase: AnimSequenceBase,StartTime: number,Duration: number,NotifyState: AnimNotifyState,NotifyTrackName: string): void;
	static AddAnimationNotifyTrack(AnimationSequenceBase: AnimSequenceBase,NotifyTrackName: string,TrackColor: LinearColor): void;
	static CopyAnimNotifiesFromSequence(SourceAnimationSequenceBase: AnimSequenceBase,DestinationAnimationSequenceBase: AnimSequenceBase,bDeleteExistingNotifies: boolean): void;
	static EvaluateRootBoneTimecodeAttributesAtTime(AnimationSequenceBase: AnimSequenceBase,EvalTime: number,OutQualifiedFrameTime?: QualifiedFrameTime): {OutQualifiedFrameTime: QualifiedFrameTime, $: boolean};
	static FindBonePathToRoot(AnimationSequenceBase: AnimSequenceBase,BoneName: string,BonePath?: string[]): {BonePath: string[]};
	static GetAnimationNotifyEventNames(AnimationSequenceBase: AnimSequenceBase,EventNames?: string[]): {EventNames: string[]};
	static GetAnimationNotifyEvents(AnimationSequenceBase: AnimSequenceBase,NotifyEvents?: AnimNotifyEvent[]): {NotifyEvents: AnimNotifyEvent[]};
	static GetAnimationNotifyEventsForTrack(AnimationSequenceBase: AnimSequenceBase,NotifyTrackName: string,Events?: AnimNotifyEvent[]): {Events: AnimNotifyEvent[]};
	static GetAnimationNotifyTrackNames(AnimationSequenceBase: AnimSequenceBase,TrackNames?: string[]): {TrackNames: string[]};
	static GetAnimationTrackNames(AnimationSequenceBase: AnimSequenceBase,TrackNames?: string[]): {TrackNames: string[]};
	static GetBonePoseForFrame(AnimationSequenceBase: AnimSequenceBase,BoneName: string,Frame: number,bExtractRootMotion: boolean,Pose?: Transform): {Pose: Transform};
	static GetBonePoseForTime(AnimationSequenceBase: AnimSequenceBase,BoneName: string,Time: number,bExtractRootMotion: boolean,Pose?: Transform): {Pose: Transform};
	static GetBonePosesForFrame(AnimationSequenceBase: AnimSequenceBase,BoneNames: string[],Frame: number,bExtractRootMotion: boolean,Poses?: Transform[],PreviewMesh?: SkeletalMesh): {Poses: Transform[]};
	static GetBonePosesForTime(AnimationSequenceBase: AnimSequenceBase,BoneNames: string[],Time: number,bExtractRootMotion: boolean,Poses?: Transform[],PreviewMesh?: SkeletalMesh): {Poses: Transform[]};
	static GetFrameAtTime(AnimationSequenceBase: AnimSequenceBase,Time: number,Frame?: number): {Frame: number};
	static GetNumFrames(AnimationSequenceBase: AnimSequenceBase,NumFrames?: number): {NumFrames: number};
	static GetNumKeys(AnimationSequenceBase: AnimSequenceBase,NumKeys?: number): {NumKeys: number};
	static GetRateScale(AnimationSequenceBase: AnimSequenceBase,RateScale?: number): {RateScale: number};
	static GetRawTrackData(AnimationSequenceBase: AnimSequenceBase,TrackName: string,PositionKeys?: Vector[],RotationKeys?: Quat[],ScalingKeys?: Vector[]): {PositionKeys: Vector[], RotationKeys: Quat[], ScalingKeys: Vector[]};
	static GetRawTrackPositionData(AnimationSequenceBase: AnimSequenceBase,TrackName: string,PositionData?: Vector[]): {PositionData: Vector[]};
	static GetRawTrackRotationData(AnimationSequenceBase: AnimSequenceBase,TrackName: string,RotationData?: Quat[]): {RotationData: Quat[]};
	static GetRawTrackScaleData(AnimationSequenceBase: AnimSequenceBase,TrackName: string,ScaleData?: Vector[]): {ScaleData: Vector[]};
	static GetSequenceLength(AnimationSequenceBase: AnimSequenceBase,Length?: number): {Length: number};
	static GetTimeAtFrame(AnimationSequenceBase: AnimSequenceBase,Frame: number,Time?: number): {Time: number};
	static IsValidAnimNotifyTrackName(AnimationSequenceBase: AnimSequenceBase,NotifyTrackName: string): boolean;
	static IsValidRawAnimationTrackName(AnimationSequenceBase: AnimSequenceBase,TrackName: string): boolean;
	static IsValidTime(AnimationSequenceBase: AnimSequenceBase,Time: number,IsValid?: boolean): {IsValid: boolean};
	static RemoveAllAnimationNotifyTracks(AnimationSequenceBase: AnimSequenceBase): void;
	static RemoveAnimationNotifyEventsByName(AnimationSequenceBase: AnimSequenceBase,NotifyName: string): number;
	static RemoveAnimationNotifyEventsByTrack(AnimationSequenceBase: AnimSequenceBase,NotifyTrackName: string): number;
	static RemoveAnimationNotifyTrack(AnimationSequenceBase: AnimSequenceBase,NotifyTrackName: string): void;
	static ReplaceAnimNotifies(AnimationSequenceBase: AnimSequenceBase,OldNotifyClass: UnrealEngineClass,NewNotifyClass: UnrealEngineClass,OnNotifyReplaced: UnrealEngineDelegate<(OldNotify: AnimNotify, NewNotify: AnimNotify) => void>): void;
	static ReplaceAnimNotifyStates(AnimationSequenceBase: AnimSequenceBase,OldNotifyClass: UnrealEngineClass,NewNotifyClass: UnrealEngineClass,OnNotifyStateReplaced: UnrealEngineDelegate<(OldNotifyState: AnimNotifyState, NewNotifyState: AnimNotifyState) => void>): void;
	static SetRateScale(AnimationSequenceBase: AnimSequenceBase,RateScale: number): void;
}

declare class AnimCompositeBase extends AnimSequenceBase { 
	static Load(ResourceName: string): AnimCompositeBase;
	static Find(Outer: UObject, ResourceName: string): AnimCompositeBase;
	static GetDefaultObject(): AnimCompositeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompositeBase;
	static C(Other: UObject | any): AnimCompositeBase;
}

declare class AlphaBlend { 
	CustomCurve: CurveFloat;
	BlendTime: number;
	BlendOption: EAlphaBlendOption;
	clone() : AlphaBlend;
	static C(Other: UObject | any): AlphaBlend;
}

declare class MarkerSyncData { 
	AuthoredSyncMarkers: AnimSyncMarker[];
	clone() : MarkerSyncData;
	static C(Other: UObject | any): MarkerSyncData;
}

declare class CompositeSection extends AnimLinkableElement { 
	SectionName: string;
	StartTime: number;
	NextSectionName: string;
	MetaData: AnimMetaData[];
	clone() : CompositeSection;
	static C(Other: UObject | any): CompositeSection;
}

declare class AnimSegment { 
	AnimReference: AnimSequenceBase;
	StartPos: number;
	AnimStartTime: number;
	AnimEndTime: number;
	AnimPlayRate: number;
	LoopingCount: number;
	clone() : AnimSegment;
	static C(Other: UObject | any): AnimSegment;
}

declare class AnimTrack { 
	AnimSegments: AnimSegment[];
	clone() : AnimTrack;
	static C(Other: UObject | any): AnimTrack;
}

declare class SlotAnimationTrack { 
	SlotName: string;
	AnimTrack: AnimTrack;
	clone() : SlotAnimationTrack;
	static C(Other: UObject | any): SlotAnimationTrack;
}

declare class BranchingPoint extends AnimLinkableElement { 
	EventName: string;
	DisplayTime: number;
	TriggerTimeOffset: number;
	clone() : BranchingPoint;
	static C(Other: UObject | any): BranchingPoint;
}

declare type EAnimNotifyEventType = 'Begin' | 'End' | 'EAnimNotifyEventType_MAX';
declare var EAnimNotifyEventType : { Begin:'Begin',End:'End',EAnimNotifyEventType_MAX:'EAnimNotifyEventType_MAX', };
declare class BranchingPointMarker { 
	NotifyIndex: number;
	TriggerTime: number;
	NotifyEventType: EAnimNotifyEventType;
	clone() : BranchingPointMarker;
	static C(Other: UObject | any): BranchingPointMarker;
}

declare class TimeStretchCurveMarker { 
	Time: number;
	Alpha: number;
	clone() : TimeStretchCurveMarker;
	static C(Other: UObject | any): TimeStretchCurveMarker;
}

declare class TimeStretchCurve { 
	SamplingRate: number;
	CurveValueMinPrecision: number;
	Markers: TimeStretchCurveMarker[];
	Sum_dT_i_by_C_i: number;
	clone() : TimeStretchCurve;
	static C(Other: UObject | any): TimeStretchCurve;
}

declare class AnimMontage extends AnimCompositeBase { 
	BlendModeIn: EMontageBlendMode;
	BlendModeOut: EMontageBlendMode;
	BlendIn: AlphaBlend;
	BlendInTime: number;
	BlendOut: AlphaBlend;
	BlendOutTime: number;
	BlendOutTriggerTime: number;
	SyncGroup: string;
	SyncSlotIndex: number;
	MarkerData: MarkerSyncData;
	CompositeSections: CompositeSection[];
	SlotAnimTracks: SlotAnimationTrack[];
	BranchingPoints: BranchingPoint[];
	bEnableRootMotionTranslation: boolean;
	bEnableRootMotionRotation: boolean;
	bEnableAutoBlendOut: boolean;
	BlendProfileIn: BlendProfile;
	BlendProfileOut: BlendProfile;
	RootMotionRootLock: ERootMotionRootLock;
	PreviewBasePose: AnimSequence;
	BranchingPointMarkers: BranchingPointMarker[];
	BranchingPointStateNotifyIndices: number[];
	TimeStretchCurve: TimeStretchCurve;
	TimeStretchCurveName: string;
	static Load(ResourceName: string): AnimMontage;
	static Find(Outer: UObject, ResourceName: string): AnimMontage;
	static GetDefaultObject(): AnimMontage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimMontage;
	IsValidSectionName(InSectionName: string): boolean;
	GetDefaultBlendOutTime(): number;
	GetDefaultBlendInTime(): number;
	GetBlendOutArgs(): AlphaBlendArgs;
	GetBlendInArgs(): AlphaBlendArgs;
	static CreateSlotAnimationAsDynamicMontage_WithBlendSettings(Asset: AnimSequenceBase,SlotNodeName: string,BlendInSettings: MontageBlendSettings,BlendOutSettings: MontageBlendSettings,InPlayRate: number,LoopCount: number,InBlendOutTriggerTime: number): AnimMontage;
	static C(Other: UObject | any): AnimMontage;
}

declare type EGameplayAbilityTargetingLocationType = 'LiteralTransform' | 'ActorTransform' | 'SocketTransform' | 'EGameplayAbilityTargetingLocationType_MAX';
declare var EGameplayAbilityTargetingLocationType : { LiteralTransform:'LiteralTransform',ActorTransform:'ActorTransform',SocketTransform:'SocketTransform',EGameplayAbilityTargetingLocationType_MAX:'EGameplayAbilityTargetingLocationType_MAX', };
declare class GameplayAbilityTargetingLocationInfo { 
	LocationType: EGameplayAbilityTargetingLocationType;
	LiteralTransform: Transform;
	SourceActor: Actor;
	SourceComponent: MeshComponent;
	SourceAbility: GameplayAbility;
	SourceSocketName: string;
	clone() : GameplayAbilityTargetingLocationInfo;
	static C(Other: UObject | any): GameplayAbilityTargetingLocationInfo;
	AbilityTargetDataFromLocations(TargetLocation: GameplayAbilityTargetingLocationInfo): GameplayAbilityTargetDataHandle;
	static AbilityTargetDataFromLocations(SourceLocation: GameplayAbilityTargetingLocationInfo,TargetLocation: GameplayAbilityTargetingLocationInfo): GameplayAbilityTargetDataHandle;
}

declare class GameplayEffectSpecHandle { 
	clone() : GameplayEffectSpecHandle;
	static C(Other: UObject | any): GameplayEffectSpecHandle;
	AddAssetTag(NewGameplayTag: GameplayTag): GameplayEffectSpecHandle;
	AddAssetTags(NewGameplayTags: GameplayTagContainer): GameplayEffectSpecHandle;
	AddGrantedTag(NewGameplayTag: GameplayTag): GameplayEffectSpecHandle;
	AddGrantedTags(NewGameplayTags: GameplayTagContainer): GameplayEffectSpecHandle;
	AddLinkedGameplayEffect(LinkedGameplayEffect: UnrealEngineClass): GameplayEffectSpecHandle;
	AddLinkedGameplayEffectSpec(LinkedGameplayEffectSpec: GameplayEffectSpecHandle): GameplayEffectSpecHandle;
	AssignSetByCallerMagnitude(DataName: string,Magnitude: number): GameplayEffectSpecHandle;
	AssignTagSetByCallerMagnitude(DataTag: GameplayTag,Magnitude: number): GameplayEffectSpecHandle;
	GetAllLinkedGameplayEffectSpecHandles(): GameplayEffectSpecHandle[];
	GetEffectContext(): GameplayEffectContextHandle;
	GetModifiedAttributeMagnitude(Attribute: GameplayAttribute): number;
	SetDuration(Duration: number): GameplayEffectSpecHandle;
	SetStackCount(StackCount: number): GameplayEffectSpecHandle;
	SetStackCountToMax(): GameplayEffectSpecHandle;
	static AddAssetTag(SpecHandle: GameplayEffectSpecHandle,NewGameplayTag: GameplayTag): GameplayEffectSpecHandle;
	static AddAssetTags(SpecHandle: GameplayEffectSpecHandle,NewGameplayTags: GameplayTagContainer): GameplayEffectSpecHandle;
	static AddGrantedTag(SpecHandle: GameplayEffectSpecHandle,NewGameplayTag: GameplayTag): GameplayEffectSpecHandle;
	static AddGrantedTags(SpecHandle: GameplayEffectSpecHandle,NewGameplayTags: GameplayTagContainer): GameplayEffectSpecHandle;
	static AddLinkedGameplayEffect(SpecHandle: GameplayEffectSpecHandle,LinkedGameplayEffect: UnrealEngineClass): GameplayEffectSpecHandle;
	static AddLinkedGameplayEffectSpec(SpecHandle: GameplayEffectSpecHandle,LinkedGameplayEffectSpec: GameplayEffectSpecHandle): GameplayEffectSpecHandle;
	static AssignSetByCallerMagnitude(SpecHandle: GameplayEffectSpecHandle,DataName: string,Magnitude: number): GameplayEffectSpecHandle;
	static AssignTagSetByCallerMagnitude(SpecHandle: GameplayEffectSpecHandle,DataTag: GameplayTag,Magnitude: number): GameplayEffectSpecHandle;
	static GetAllLinkedGameplayEffectSpecHandles(SpecHandle: GameplayEffectSpecHandle): GameplayEffectSpecHandle[];
	static GetEffectContext(SpecHandle: GameplayEffectSpecHandle): GameplayEffectContextHandle;
	static GetModifiedAttributeMagnitude(SpecHandle: GameplayEffectSpecHandle,Attribute: GameplayAttribute): number;
	static SetDuration(SpecHandle: GameplayEffectSpecHandle,Duration: number): GameplayEffectSpecHandle;
	static SetStackCount(SpecHandle: GameplayEffectSpecHandle,StackCount: number): GameplayEffectSpecHandle;
	static SetStackCountToMax(SpecHandle: GameplayEffectSpecHandle): GameplayEffectSpecHandle;
}

declare class GameplayAbilityActorInfo { 
	OwnerActor: any;
	AvatarActor: any;
	PlayerController: any;
	AbilitySystemComponent: any;
	SkeletalMeshComponent: any;
	AnimInstance: any;
	MovementComponent: any;
	AffectedAnimInstanceTag: string;
	clone() : GameplayAbilityActorInfo;
	static C(Other: UObject | any): GameplayAbilityActorInfo;
}

declare class GameplayAbilitySpecHandle { 
	Handle: number;
	clone() : GameplayAbilitySpecHandle;
	static C(Other: UObject | any): GameplayAbilitySpecHandle;
	EqualEqual_GameplayAbilitySpecHandle(B: GameplayAbilitySpecHandle): boolean;
	NotEqual_GameplayAbilitySpecHandle(B: GameplayAbilitySpecHandle): boolean;
	static EqualEqual_GameplayAbilitySpecHandle(A: GameplayAbilitySpecHandle,B: GameplayAbilitySpecHandle): boolean;
	static NotEqual_GameplayAbilitySpecHandle(A: GameplayAbilitySpecHandle,B: GameplayAbilitySpecHandle): boolean;
}

declare class ActiveGameplayEffectHandle { 
	Handle: number;
	bPassedFiltersAndWasExecuted: boolean;
	clone() : ActiveGameplayEffectHandle;
	static C(Other: UObject | any): ActiveGameplayEffectHandle;
	EqualEqual_ActiveGameplayEffectHandle(B: ActiveGameplayEffectHandle): boolean;
	GetActiveGameplayEffectDebugString(): string;
	GetActiveGameplayEffectExpectedEndTime(): number;
	GetActiveGameplayEffectStackCount(): number;
	GetActiveGameplayEffectStackLimitCount(): number;
	GetActiveGameplayEffectStartTime(): number;
	GetActiveGameplayEffectTotalDuration(): number;
	GetGameplayEffectFromActiveEffectHandle(): GameplayEffect;
	NotEqual_ActiveGameplayEffectHandle(B: ActiveGameplayEffectHandle): boolean;
	static EqualEqual_ActiveGameplayEffectHandle(A: ActiveGameplayEffectHandle,B: ActiveGameplayEffectHandle): boolean;
	static GetActiveGameplayEffectDebugString(ActiveHandle: ActiveGameplayEffectHandle): string;
	static GetActiveGameplayEffectExpectedEndTime(ActiveHandle: ActiveGameplayEffectHandle): number;
	static GetActiveGameplayEffectStackCount(ActiveHandle: ActiveGameplayEffectHandle): number;
	static GetActiveGameplayEffectStackLimitCount(ActiveHandle: ActiveGameplayEffectHandle): number;
	static GetActiveGameplayEffectStartTime(ActiveHandle: ActiveGameplayEffectHandle): number;
	static GetActiveGameplayEffectTotalDuration(ActiveHandle: ActiveGameplayEffectHandle): number;
	static GetGameplayEffectFromActiveEffectHandle(ActiveHandle: ActiveGameplayEffectHandle): GameplayEffect;
	static NotEqual_ActiveGameplayEffectHandle(A: ActiveGameplayEffectHandle,B: ActiveGameplayEffectHandle): boolean;
}

declare class GameplayResourceSet { 
	clone() : GameplayResourceSet;
	static C(Other: UObject | any): GameplayResourceSet;
}

declare class GameplayTasksComponent extends ActorComponent { 
	bIsNetDirty: boolean;
	SimulatedTasks: GameplayTask[];
	TaskPriorityQueue: GameplayTask[];
	TickingTasks: GameplayTask[];
	KnownTasks: GameplayTask[];
	OnClaimedResourcesChange: UnrealEngineMulticastDelegate<(NewlyClaimed: GameplayResourceSet, FreshlyReleased: GameplayResourceSet) => void>;
	static Load(ResourceName: string): GameplayTasksComponent;
	static Find(Outer: UObject, ResourceName: string): GameplayTasksComponent;
	static GetDefaultObject(): GameplayTasksComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTasksComponent;
	OnRep_SimulatedTasks(): void;
	static C(Other: UObject | any): GameplayTasksComponent;
}

declare class AttributeSet extends UObject { 
	static Load(ResourceName: string): AttributeSet;
	static Find(Outer: UObject, ResourceName: string): AttributeSet;
	static GetDefaultObject(): AttributeSet;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AttributeSet;
	static C(Other: UObject | any): AttributeSet;
}

declare class AttributeDefaults { 
	Attributes: UnrealEngineClass;
	DefaultStartingTable: DataTable;
	clone() : AttributeDefaults;
	static C(Other: UObject | any): AttributeDefaults;
}

declare class Player extends UObject { 
	PlayerController: PlayerController;
	CurrentNetSpeed: number;
	ConfiguredInternetSpeed: number;
	ConfiguredLanSpeed: number;
	static Load(ResourceName: string): Player;
	static Find(Outer: UObject, ResourceName: string): Player;
	static GetDefaultObject(): Player;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Player;
	static C(Other: UObject | any): Player;
}

declare class InterpTrackInst extends UObject { 
	static Load(ResourceName: string): InterpTrackInst;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInst;
	static GetDefaultObject(): InterpTrackInst;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInst;
	static C(Other: UObject | any): InterpTrackInst;
}

declare class InterpTrackInstDirector extends InterpTrackInst { 
	OldViewTarget: Actor;
	static Load(ResourceName: string): InterpTrackInstDirector;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstDirector;
	static GetDefaultObject(): InterpTrackInstDirector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstDirector;
	static C(Other: UObject | any): InterpTrackInstDirector;
}

declare class ReporterBase extends UObject { 
	static Load(ResourceName: string): ReporterBase;
	static Find(Outer: UObject, ResourceName: string): ReporterBase;
	static GetDefaultObject(): ReporterBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReporterBase;
	static C(Other: UObject | any): ReporterBase;
}

declare class ReporterGraph extends ReporterBase { 
	static Load(ResourceName: string): ReporterGraph;
	static Find(Outer: UObject, ResourceName: string): ReporterGraph;
	static GetDefaultObject(): ReporterGraph;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReporterGraph;
	static C(Other: UObject | any): ReporterGraph;
}

declare class CanvasUVTri { 
	V0_Pos: Vector2D;
	V0_UV: Vector2D;
	V0_Color: LinearColor;
	V1_Pos: Vector2D;
	V1_UV: Vector2D;
	V1_Color: LinearColor;
	V2_Pos: Vector2D;
	V2_UV: Vector2D;
	V2_Color: LinearColor;
	clone() : CanvasUVTri;
	static C(Other: UObject | any): CanvasUVTri;
}

declare class Canvas extends UObject { 
	OrgX: number;
	OrgY: number;
	ClipX: number;
	ClipY: number;
	DrawColor: Color;
	bCenterX: boolean;
	bCenterY: boolean;
	bNoSmooth: boolean;
	SizeX: number;
	SizeY: number;
	ColorModulate: Plane;
	DefaultTexture: Texture2D;
	GradientTexture0: Texture2D;
	ReporterGraph: ReporterGraph;
	static Load(ResourceName: string): Canvas;
	static Find(Outer: UObject, ResourceName: string): Canvas;
	static GetDefaultObject(): Canvas;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Canvas;
	K2_TextSize(RenderFont: Font,RenderText: string,Scale: Vector2D): Vector2D;
	K2_StrLen(RenderFont: Font,RenderText: string): Vector2D;
	K2_Project(WorldLocation: Vector): Vector;
	K2_DrawTriangle(RenderTexture: Texture,Triangles: CanvasUVTri[]): void;
	K2_DrawTexture(RenderTexture: Texture,ScreenPosition: Vector2D,ScreenSize: Vector2D,CoordinatePosition: Vector2D,CoordinateSize: Vector2D,RenderColor: LinearColor,BlendMode: EBlendMode,Rotation: number,PivotPoint: Vector2D): void;
	K2_DrawText(RenderFont: Font,RenderText: string,ScreenPosition: Vector2D,Scale: Vector2D,RenderColor: LinearColor,Kerning: number,ShadowColor: LinearColor,ShadowOffset: Vector2D,bCentreX: boolean,bCentreY: boolean,bOutlined: boolean,OutlineColor: LinearColor): void;
	K2_DrawPolygon(RenderTexture: Texture,ScreenPosition: Vector2D,Radius: Vector2D,NumberOfSides: number,RenderColor: LinearColor): void;
	K2_DrawMaterialTriangle(RenderMaterial: MaterialInterface,Triangles: CanvasUVTri[]): void;
	K2_DrawMaterial(RenderMaterial: MaterialInterface,ScreenPosition: Vector2D,ScreenSize: Vector2D,CoordinatePosition: Vector2D,CoordinateSize: Vector2D,Rotation: number,PivotPoint: Vector2D): void;
	K2_DrawLine(ScreenPositionA: Vector2D,ScreenPositionB: Vector2D,Thickness: number,RenderColor: LinearColor): void;
	K2_DrawBox(ScreenPosition: Vector2D,ScreenSize: Vector2D,Thickness: number,RenderColor: LinearColor): void;
	K2_DrawBorder(BorderTexture: Texture,BackgroundTexture: Texture,LeftBorderTexture: Texture,RightBorderTexture: Texture,TopBorderTexture: Texture,BottomBorderTexture: Texture,ScreenPosition: Vector2D,ScreenSize: Vector2D,CoordinatePosition: Vector2D,CoordinateSize: Vector2D,RenderColor: LinearColor,BorderScale: Vector2D,BackgroundScale: Vector2D,Rotation: number,PivotPoint: Vector2D,CornerSize: Vector2D): void;
	K2_Deproject(ScreenPosition: Vector2D,WorldOrigin?: Vector,WorldDirection?: Vector): {WorldOrigin: Vector, WorldDirection: Vector};
	static C(Other: UObject | any): Canvas;
}

declare class DebugTextInfo { 
	SrcActor: Actor;
	SrcActorOffset: Vector;
	SrcActorDesiredOffset: Vector;
	DebugText: string;
	TimeRemaining: number;
	Duration: number;
	TextColor: Color;
	bAbsoluteLocation: boolean;
	bKeepAttachedToActor: boolean;
	bDrawShadow: boolean;
	OrigActorLocation: Vector;
	Font: Font;
	FontScale: number;
	clone() : DebugTextInfo;
	static C(Other: UObject | any): DebugTextInfo;
}

declare class HUD extends Actor { 
	PlayerOwner: PlayerController;
	bLostFocusPaused: boolean;
	bShowHUD: boolean;
	bShowDebugInfo: boolean;
	CurrentTargetIndex: number;
	bShowHitBoxDebugInfo: boolean;
	bShowOverlays: boolean;
	bEnableDebugTextShadow: boolean;
	PostRenderedActors: Actor[];
	DebugDisplay: string[];
	ToggledDebugCategories: string[];
	Canvas: Canvas;
	DebugCanvas: Canvas;
	DebugTextList: DebugTextInfo[];
	ShowDebugTargetDesiredClass: UnrealEngineClass;
	ShowDebugTargetActor: Actor;
	static GetDefaultObject(): HUD;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HUD;
	ShowHUD(): void;
	ShowDebugToggleSubCategory(Category: string): void;
	ShowDebugForReticleTargetToggle(DesiredClass: UnrealEngineClass): void;
	ShowDebug(DebugType: string): void;
	RemoveDebugText(SrcActor: Actor,bLeaveDurationText: boolean): void;
	RemoveAllDebugStrings(): void;
	ReceiveHitBoxRelease(BoxName: string): void;
	ReceiveHitBoxEndCursorOver(BoxName: string): void;
	ReceiveHitBoxClick(BoxName: string): void;
	ReceiveHitBoxBeginCursorOver(BoxName: string): void;
	ReceiveDrawHUD(SizeX: number,SizeY: number): void;
	Project(Location: Vector,bClampToZeroPlane: boolean): Vector;
	PreviousDebugTarget(): void;
	NextDebugTarget(): void;
	GetTextSize(text: string,OutWidth?: number,OutHeight?: number,Font?: Font,Scale?: number): {OutWidth: number, OutHeight: number};
	GetOwningPlayerController(): PlayerController;
	GetOwningPawn(): Pawn;
	GetActorsInSelectionRectangle(ClassFilter: UnrealEngineClass,FirstPoint: Vector2D,SecondPoint: Vector2D,OutActors?: Actor[],bIncludeNonCollidingComponents?: boolean,bActorMustBeFullyEnclosed?: boolean): {OutActors: Actor[]};
	DrawTextureSimple(Texture: Texture,ScreenX: number,ScreenY: number,Scale: number,bScalePosition: boolean): void;
	DrawTexture(Texture: Texture,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number,TextureU: number,TextureV: number,TextureUWidth: number,TextureVHeight: number,TintColor: LinearColor,BlendMode: EBlendMode,Scale: number,bScalePosition: boolean,Rotation: number,RotPivot: Vector2D): void;
	DrawText(text: string,TextColor: LinearColor,ScreenX: number,ScreenY: number,Font: Font,Scale: number,bScalePosition: boolean): void;
	DrawRect(RectColor: LinearColor,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number): void;
	DrawMaterialTriangle(Material: MaterialInterface,V0_Pos: Vector2D,V1_Pos: Vector2D,V2_Pos: Vector2D,V0_UV: Vector2D,V1_UV: Vector2D,V2_UV: Vector2D,V0_Color: LinearColor,V1_Color: LinearColor,V2_Color: LinearColor): void;
	DrawMaterialSimple(Material: MaterialInterface,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number,Scale: number,bScalePosition: boolean): void;
	DrawMaterial(Material: MaterialInterface,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number,MaterialU: number,MaterialV: number,MaterialUWidth: number,MaterialVHeight: number,Scale: number,bScalePosition: boolean,Rotation: number,RotPivot: Vector2D): void;
	DrawLine(StartScreenX: number,StartScreenY: number,EndScreenX: number,EndScreenY: number,LineColor: LinearColor,LineThickness: number): void;
	Deproject(ScreenX: number,ScreenY: number,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector};
	AddHitBox(position: Vector2D,Size: Vector2D,InName: string,bConsumesInput: boolean,Priority: number): void;
	AddDebugText(DebugText: string,SrcActor: Actor,Duration: number,Offset: Vector,DesiredOffset: Vector,TextColor: Color,bSkipOverwriteCheck: boolean,bAbsoluteLocation: boolean,bKeepAttachedToActor: boolean,InFont: Font,FontScale: number,bDrawShadow: boolean): void;
	static C(Other: UObject | any): HUD;
}

declare type ECameraProjectionMode = 'Perspective' | 'Orthographic' | 'ECameraProjectionMode_MAX';
declare var ECameraProjectionMode : { Perspective:'Perspective',Orthographic:'Orthographic',ECameraProjectionMode_MAX:'ECameraProjectionMode_MAX', };
declare type EBloomMethod = 'BM_SOG' | 'BM_FFT' | 'BM_MAX';
declare var EBloomMethod : { BM_SOG:'BM_SOG',BM_FFT:'BM_FFT',BM_MAX:'BM_MAX', };
declare type EAutoExposureMethod = 'AEM_Histogram' | 'AEM_Basic' | 'AEM_Manual' | 'AEM_MAX';
declare var EAutoExposureMethod : { AEM_Histogram:'AEM_Histogram',AEM_Basic:'AEM_Basic',AEM_Manual:'AEM_Manual',AEM_MAX:'AEM_MAX', };
declare type EDepthOfFieldMethod = 'DOFM_BokehDOF' | 'DOFM_Gaussian' | 'DOFM_CircleDOF' | 'DOFM_MAX';
declare var EDepthOfFieldMethod : { DOFM_BokehDOF:'DOFM_BokehDOF',DOFM_Gaussian:'DOFM_Gaussian',DOFM_CircleDOF:'DOFM_CircleDOF',DOFM_MAX:'DOFM_MAX', };
declare type ETemperatureMethod = 'TEMP_WhiteBalance' | 'TEMP_ColorTemperature' | 'TEMP_MAX';
declare var ETemperatureMethod : { TEMP_WhiteBalance:'TEMP_WhiteBalance',TEMP_ColorTemperature:'TEMP_ColorTemperature',TEMP_MAX:'TEMP_MAX', };
declare type EDynamicGlobalIlluminationMethod = 'None' | 'Lumen' | 'ScreenSpace' | 'RayTraced' | 'Plugin' | 'EDynamicGlobalIlluminationMethod_MAX';
declare var EDynamicGlobalIlluminationMethod : { None:'None',Lumen:'Lumen',ScreenSpace:'ScreenSpace',RayTraced:'RayTraced',Plugin:'Plugin',EDynamicGlobalIlluminationMethod_MAX:'EDynamicGlobalIlluminationMethod_MAX', };
declare type ERayTracingGlobalIlluminationType = 'Disabled' | 'BruteForce' | 'FinalGather' | 'ERayTracingGlobalIlluminationType_MAX';
declare var ERayTracingGlobalIlluminationType : { Disabled:'Disabled',BruteForce:'BruteForce',FinalGather:'FinalGather',ERayTracingGlobalIlluminationType_MAX:'ERayTracingGlobalIlluminationType_MAX', };
declare type EReflectionMethod = 'None' | 'Lumen' | 'ScreenSpace' | 'RayTraced' | 'EReflectionMethod_MAX';
declare var EReflectionMethod : { None:'None',Lumen:'Lumen',ScreenSpace:'ScreenSpace',RayTraced:'RayTraced',EReflectionMethod_MAX:'EReflectionMethod_MAX', };
declare type EReflectionsType = 'ScreenSpace' | 'RayTracing' | 'EReflectionsType_MAX';
declare var EReflectionsType : { ScreenSpace:'ScreenSpace',RayTracing:'RayTracing',EReflectionsType_MAX:'EReflectionsType_MAX', };
declare type ELumenRayLightingModeOverride = 'Default' | 'SurfaceCache' | 'HitLighting' | 'ELumenRayLightingModeOverride_MAX';
declare var ELumenRayLightingModeOverride : { Default:'Default',SurfaceCache:'SurfaceCache',HitLighting:'HitLighting',ELumenRayLightingModeOverride_MAX:'ELumenRayLightingModeOverride_MAX', };
declare type EReflectedAndRefractedRayTracedShadows = 'Disabled' | 'Hard_shadows' | 'Area_shadows' | 'EReflectedAndRefractedRayTracedShadows_MAX';
declare var EReflectedAndRefractedRayTracedShadows : { Disabled:'Disabled',Hard_shadows:'Hard_shadows',Area_shadows:'Area_shadows',EReflectedAndRefractedRayTracedShadows_MAX:'EReflectedAndRefractedRayTracedShadows_MAX', };
declare class TextureCube extends Texture { 
	static Load(ResourceName: string): TextureCube;
	static Find(Outer: UObject, ResourceName: string): TextureCube;
	static GetDefaultObject(): TextureCube;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureCube;
	static C(Other: UObject | any): TextureCube;
}

declare type ETranslucencyType = 'Raster' | 'RayTracing' | 'ETranslucencyType_MAX';
declare var ETranslucencyType : { Raster:'Raster',RayTracing:'RayTracing',ETranslucencyType_MAX:'ETranslucencyType_MAX', };
declare class WeightedBlendable { 
	Weight: number;
	UObject: UObject;
	clone() : WeightedBlendable;
	static C(Other: UObject | any): WeightedBlendable;
}

declare class WeightedBlendables { 
	Array: WeightedBlendable[];
	clone() : WeightedBlendables;
	static C(Other: UObject | any): WeightedBlendables;
}

declare class PostProcessSettings { 
	bOverride_TemperatureType: boolean;
	bOverride_WhiteTemp: boolean;
	bOverride_WhiteTint: boolean;
	bOverride_ColorSaturation: boolean;
	bOverride_ColorContrast: boolean;
	bOverride_ColorGamma: boolean;
	bOverride_ColorGain: boolean;
	bOverride_ColorOffset: boolean;
	bOverride_ColorSaturationShadows: boolean;
	bOverride_ColorContrastShadows: boolean;
	bOverride_ColorGammaShadows: boolean;
	bOverride_ColorGainShadows: boolean;
	bOverride_ColorOffsetShadows: boolean;
	bOverride_ColorSaturationMidtones: boolean;
	bOverride_ColorContrastMidtones: boolean;
	bOverride_ColorGammaMidtones: boolean;
	bOverride_ColorGainMidtones: boolean;
	bOverride_ColorOffsetMidtones: boolean;
	bOverride_ColorSaturationHighlights: boolean;
	bOverride_ColorContrastHighlights: boolean;
	bOverride_ColorGammaHighlights: boolean;
	bOverride_ColorGainHighlights: boolean;
	bOverride_ColorOffsetHighlights: boolean;
	bOverride_ColorCorrectionShadowsMax: boolean;
	bOverride_ColorCorrectionHighlightsMin: boolean;
	bOverride_ColorCorrectionHighlightsMax: boolean;
	bOverride_BlueCorrection: boolean;
	bOverride_ExpandGamut: boolean;
	bOverride_ToneCurveAmount: boolean;
	bOverride_FilmSlope: boolean;
	bOverride_FilmToe: boolean;
	bOverride_FilmShoulder: boolean;
	bOverride_FilmBlackClip: boolean;
	bOverride_FilmWhiteClip: boolean;
	bOverride_SceneColorTint: boolean;
	bOverride_SceneFringeIntensity: boolean;
	bOverride_ChromaticAberrationStartOffset: boolean;
	bOverride_AmbientCubemapTint: boolean;
	bOverride_AmbientCubemapIntensity: boolean;
	bOverride_BloomMethod: boolean;
	bOverride_BloomIntensity: boolean;
	bOverride_BloomThreshold: boolean;
	bOverride_Bloom1Tint: boolean;
	bOverride_Bloom1Size: boolean;
	bOverride_Bloom2Size: boolean;
	bOverride_Bloom2Tint: boolean;
	bOverride_Bloom3Tint: boolean;
	bOverride_Bloom3Size: boolean;
	bOverride_Bloom4Tint: boolean;
	bOverride_Bloom4Size: boolean;
	bOverride_Bloom5Tint: boolean;
	bOverride_Bloom5Size: boolean;
	bOverride_Bloom6Tint: boolean;
	bOverride_Bloom6Size: boolean;
	bOverride_BloomSizeScale: boolean;
	bOverride_BloomConvolutionTexture: boolean;
	bOverride_BloomConvolutionScatterDispersion: boolean;
	bOverride_BloomConvolutionSize: boolean;
	bOverride_BloomConvolutionCenterUV: boolean;
	bOverride_BloomConvolutionPreFilter: boolean;
	bOverride_BloomConvolutionPreFilterMin: boolean;
	bOverride_BloomConvolutionPreFilterMax: boolean;
	bOverride_BloomConvolutionPreFilterMult: boolean;
	bOverride_BloomConvolutionBufferScale: boolean;
	bOverride_BloomDirtMaskIntensity: boolean;
	bOverride_BloomDirtMaskTint: boolean;
	bOverride_BloomDirtMask: boolean;
	bOverride_CameraShutterSpeed: boolean;
	bOverride_CameraISO: boolean;
	bOverride_AutoExposureMethod: boolean;
	bOverride_AutoExposureLowPercent: boolean;
	bOverride_AutoExposureHighPercent: boolean;
	bOverride_AutoExposureMinBrightness: boolean;
	bOverride_AutoExposureMaxBrightness: boolean;
	bOverride_AutoExposureCalibrationConstant: boolean;
	bOverride_AutoExposureSpeedUp: boolean;
	bOverride_AutoExposureSpeedDown: boolean;
	bOverride_AutoExposureBias: boolean;
	bOverride_AutoExposureBiasCurve: boolean;
	bOverride_AutoExposureMeterMask: boolean;
	bOverride_AutoExposureApplyPhysicalCameraExposure: boolean;
	bOverride_HistogramLogMin: boolean;
	bOverride_HistogramLogMax: boolean;
	bOverride_LocalExposureContrastScale: boolean;
	bOverride_LocalExposureDetailStrength: boolean;
	bOverride_LocalExposureBlurredLuminanceBlend: boolean;
	bOverride_LocalExposureBlurredLuminanceKernelSizePercent: boolean;
	bOverride_LocalExposureMiddleGreyBias: boolean;
	bOverride_LensFlareIntensity: boolean;
	bOverride_LensFlareTint: boolean;
	bOverride_LensFlareTints: boolean;
	bOverride_LensFlareBokehSize: boolean;
	bOverride_LensFlareBokehShape: boolean;
	bOverride_LensFlareThreshold: boolean;
	bOverride_VignetteIntensity: boolean;
	bOverride_GrainIntensity: boolean;
	bOverride_GrainJitter: boolean;
	bOverride_FilmGrainIntensity: boolean;
	bOverride_FilmGrainIntensityShadows: boolean;
	bOverride_FilmGrainIntensityMidtones: boolean;
	bOverride_FilmGrainIntensityHighlights: boolean;
	bOverride_FilmGrainShadowsMax: boolean;
	bOverride_FilmGrainHighlightsMin: boolean;
	bOverride_FilmGrainHighlightsMax: boolean;
	bOverride_FilmGrainTexelSize: boolean;
	bOverride_FilmGrainTexture: boolean;
	bOverride_AmbientOcclusionIntensity: boolean;
	bOverride_AmbientOcclusionStaticFraction: boolean;
	bOverride_AmbientOcclusionRadius: boolean;
	bOverride_AmbientOcclusionFadeDistance: boolean;
	bOverride_AmbientOcclusionFadeRadius: boolean;
	bOverride_AmbientOcclusionDistance: boolean;
	bOverride_AmbientOcclusionRadiusInWS: boolean;
	bOverride_AmbientOcclusionPower: boolean;
	bOverride_AmbientOcclusionBias: boolean;
	bOverride_AmbientOcclusionQuality: boolean;
	bOverride_AmbientOcclusionMipBlend: boolean;
	bOverride_AmbientOcclusionMipScale: boolean;
	bOverride_AmbientOcclusionMipThreshold: boolean;
	bOverride_AmbientOcclusionTemporalBlendWeight: boolean;
	bOverride_RayTracingAO: boolean;
	bOverride_RayTracingAOSamplesPerPixel: boolean;
	bOverride_RayTracingAOIntensity: boolean;
	bOverride_RayTracingAORadius: boolean;
	bOverride_LPVIntensity: boolean;
	bOverride_LPVDirectionalOcclusionIntensity: boolean;
	bOverride_LPVDirectionalOcclusionRadius: boolean;
	bOverride_LPVDiffuseOcclusionExponent: boolean;
	bOverride_LPVSpecularOcclusionExponent: boolean;
	bOverride_LPVDiffuseOcclusionIntensity: boolean;
	bOverride_LPVSpecularOcclusionIntensity: boolean;
	bOverride_LPVSize: boolean;
	bOverride_LPVSecondaryOcclusionIntensity: boolean;
	bOverride_LPVSecondaryBounceIntensity: boolean;
	bOverride_LPVGeometryVolumeBias: boolean;
	bOverride_LPVVplInjectionBias: boolean;
	bOverride_LPVEmissiveInjectionIntensity: boolean;
	bOverride_LPVFadeRange: boolean;
	bOverride_LPVDirectionalOcclusionFadeRange: boolean;
	bOverride_IndirectLightingColor: boolean;
	bOverride_IndirectLightingIntensity: boolean;
	bOverride_ColorGradingIntensity: boolean;
	bOverride_ColorGradingLUT: boolean;
	bOverride_DepthOfFieldFocalDistance: boolean;
	bOverride_DepthOfFieldFstop: boolean;
	bOverride_DepthOfFieldMinFstop: boolean;
	bOverride_DepthOfFieldBladeCount: boolean;
	bOverride_DepthOfFieldSensorWidth: boolean;
	bOverride_DepthOfFieldDepthBlurRadius: boolean;
	bOverride_DepthOfFieldDepthBlurAmount: boolean;
	bOverride_DepthOfFieldFocalRegion: boolean;
	bOverride_DepthOfFieldNearTransitionRegion: boolean;
	bOverride_DepthOfFieldFarTransitionRegion: boolean;
	bOverride_DepthOfFieldScale: boolean;
	bOverride_DepthOfFieldNearBlurSize: boolean;
	bOverride_DepthOfFieldFarBlurSize: boolean;
	bOverride_MobileHQGaussian: boolean;
	bOverride_DepthOfFieldOcclusion: boolean;
	bOverride_DepthOfFieldSkyFocusDistance: boolean;
	bOverride_DepthOfFieldVignetteSize: boolean;
	bOverride_MotionBlurAmount: boolean;
	bOverride_MotionBlurMax: boolean;
	bOverride_MotionBlurTargetFPS: boolean;
	bOverride_MotionBlurPerObjectSize: boolean;
	bOverride_ScreenPercentage: boolean;
	bOverride_ReflectionMethod: boolean;
	bOverride_LumenReflectionQuality: boolean;
	bOverride_ScreenSpaceReflectionIntensity: boolean;
	bOverride_ScreenSpaceReflectionQuality: boolean;
	bOverride_ScreenSpaceReflectionMaxRoughness: boolean;
	bOverride_ScreenSpaceReflectionRoughnessScale: boolean;
	bOverride_ReflectionsType: boolean;
	bOverride_RayTracingReflectionsMaxRoughness: boolean;
	bOverride_RayTracingReflectionsMaxBounces: boolean;
	bOverride_RayTracingReflectionsSamplesPerPixel: boolean;
	bOverride_RayTracingReflectionsShadows: boolean;
	bOverride_RayTracingReflectionsTranslucency: boolean;
	bOverride_TranslucencyType: boolean;
	bOverride_RayTracingTranslucencyMaxRoughness: boolean;
	bOverride_RayTracingTranslucencyRefractionRays: boolean;
	bOverride_RayTracingTranslucencySamplesPerPixel: boolean;
	bOverride_RayTracingTranslucencyShadows: boolean;
	bOverride_RayTracingTranslucencyRefraction: boolean;
	bOverride_DynamicGlobalIlluminationMethod: boolean;
	bOverride_LumenSceneLightingQuality: boolean;
	bOverride_LumenSceneDetail: boolean;
	bOverride_LumenSceneViewDistance: boolean;
	bOverride_LumenSceneLightingUpdateSpeed: boolean;
	bOverride_LumenFinalGatherQuality: boolean;
	bOverride_LumenFinalGatherLightingUpdateSpeed: boolean;
	bOverride_LumenMaxTraceDistance: boolean;
	bOverride_LumenRayLightingMode: boolean;
	bOverride_RayTracingGI: boolean;
	bOverride_RayTracingGIMaxBounces: boolean;
	bOverride_RayTracingGISamplesPerPixel: boolean;
	bOverride_PathTracingMaxBounces: boolean;
	bOverride_PathTracingSamplesPerPixel: boolean;
	bOverride_PathTracingFilterWidth: boolean;
	bOverride_PathTracingEnableEmissive: boolean;
	bOverride_PathTracingMaxPathExposure: boolean;
	bOverride_PathTracingEnableReferenceDOF: boolean;
	bOverride_PathTracingEnableDenoiser: boolean;
	bMobileHQGaussian: boolean;
	BloomMethod: EBloomMethod;
	AutoExposureMethod: EAutoExposureMethod;
	DepthOfFieldMethod: EDepthOfFieldMethod;
	TemperatureType: ETemperatureMethod;
	WhiteTemp: number;
	WhiteTint: number;
	ColorSaturation: Vector4;
	ColorContrast: Vector4;
	ColorGamma: Vector4;
	ColorGain: Vector4;
	ColorOffset: Vector4;
	ColorSaturationShadows: Vector4;
	ColorContrastShadows: Vector4;
	ColorGammaShadows: Vector4;
	ColorGainShadows: Vector4;
	ColorOffsetShadows: Vector4;
	ColorSaturationMidtones: Vector4;
	ColorContrastMidtones: Vector4;
	ColorGammaMidtones: Vector4;
	ColorGainMidtones: Vector4;
	ColorOffsetMidtones: Vector4;
	ColorSaturationHighlights: Vector4;
	ColorContrastHighlights: Vector4;
	ColorGammaHighlights: Vector4;
	ColorGainHighlights: Vector4;
	ColorOffsetHighlights: Vector4;
	ColorCorrectionHighlightsMin: number;
	ColorCorrectionHighlightsMax: number;
	ColorCorrectionShadowsMax: number;
	BlueCorrection: number;
	ExpandGamut: number;
	ToneCurveAmount: number;
	FilmSlope: number;
	FilmToe: number;
	FilmShoulder: number;
	FilmBlackClip: number;
	FilmWhiteClip: number;
	SceneColorTint: LinearColor;
	SceneFringeIntensity: number;
	ChromaticAberrationStartOffset: number;
	BloomIntensity: number;
	BloomThreshold: number;
	BloomSizeScale: number;
	Bloom1Size: number;
	Bloom2Size: number;
	Bloom3Size: number;
	Bloom4Size: number;
	Bloom5Size: number;
	Bloom6Size: number;
	Bloom1Tint: LinearColor;
	Bloom2Tint: LinearColor;
	Bloom3Tint: LinearColor;
	Bloom4Tint: LinearColor;
	Bloom5Tint: LinearColor;
	Bloom6Tint: LinearColor;
	BloomConvolutionScatterDispersion: number;
	BloomConvolutionSize: number;
	BloomConvolutionTexture: Texture2D;
	BloomConvolutionCenterUV: Vector2D;
	BloomConvolutionPreFilter: Vector3f;
	BloomConvolutionPreFilterMin: number;
	BloomConvolutionPreFilterMax: number;
	BloomConvolutionPreFilterMult: number;
	BloomConvolutionBufferScale: number;
	BloomDirtMask: Texture;
	BloomDirtMaskIntensity: number;
	BloomDirtMaskTint: LinearColor;
	DynamicGlobalIlluminationMethod: EDynamicGlobalIlluminationMethod;
	IndirectLightingColor: LinearColor;
	IndirectLightingIntensity: number;
	RayTracingGI: boolean;
	LumenSceneLightingQuality: number;
	LumenSceneDetail: number;
	LumenSceneViewDistance: number;
	LumenSceneLightingUpdateSpeed: number;
	LumenFinalGatherQuality: number;
	LumenFinalGatherLightingUpdateSpeed: number;
	LumenMaxTraceDistance: number;
	RayTracingGIType: ERayTracingGlobalIlluminationType;
	RayTracingGIMaxBounces: number;
	RayTracingGISamplesPerPixel: number;
	ReflectionMethod: EReflectionMethod;
	ReflectionsType: EReflectionsType;
	LumenReflectionQuality: number;
	LumenRayLightingMode: ELumenRayLightingModeOverride;
	ScreenSpaceReflectionIntensity: number;
	ScreenSpaceReflectionQuality: number;
	ScreenSpaceReflectionMaxRoughness: number;
	RayTracingReflectionsMaxRoughness: number;
	RayTracingReflectionsMaxBounces: number;
	RayTracingReflectionsSamplesPerPixel: number;
	RayTracingReflectionsShadows: EReflectedAndRefractedRayTracedShadows;
	RayTracingReflectionsTranslucency: boolean;
	AmbientCubemapTint: LinearColor;
	AmbientCubemapIntensity: number;
	AmbientCubemap: TextureCube;
	CameraShutterSpeed: number;
	CameraISO: number;
	DepthOfFieldFstop: number;
	DepthOfFieldMinFstop: number;
	DepthOfFieldBladeCount: number;
	AutoExposureBias: number;
	AutoExposureBiasBackup: number;
	bOverride_AutoExposureBiasBackup: boolean;
	AutoExposureApplyPhysicalCameraExposure: boolean;
	AutoExposureBiasCurve: CurveFloat;
	AutoExposureMeterMask: Texture;
	AutoExposureLowPercent: number;
	AutoExposureHighPercent: number;
	AutoExposureMinBrightness: number;
	AutoExposureMaxBrightness: number;
	AutoExposureSpeedUp: number;
	AutoExposureSpeedDown: number;
	HistogramLogMin: number;
	HistogramLogMax: number;
	AutoExposureCalibrationConstant: number;
	LocalExposureContrastScale: number;
	LocalExposureDetailStrength: number;
	LocalExposureBlurredLuminanceBlend: number;
	LocalExposureBlurredLuminanceKernelSizePercent: number;
	LocalExposureMiddleGreyBias: number;
	LensFlareIntensity: number;
	LensFlareTint: LinearColor;
	LensFlareBokehSize: number;
	LensFlareThreshold: number;
	LensFlareBokehShape: Texture;
	LensFlareTints: LinearColor;
	VignetteIntensity: number;
	GrainJitter: number;
	GrainIntensity: number;
	FilmGrainIntensity: number;
	FilmGrainIntensityShadows: number;
	FilmGrainIntensityMidtones: number;
	FilmGrainIntensityHighlights: number;
	FilmGrainShadowsMax: number;
	FilmGrainHighlightsMin: number;
	FilmGrainHighlightsMax: number;
	FilmGrainTexelSize: number;
	FilmGrainTexture: Texture2D;
	AmbientOcclusionIntensity: number;
	AmbientOcclusionStaticFraction: number;
	AmbientOcclusionRadius: number;
	AmbientOcclusionRadiusInWS: boolean;
	AmbientOcclusionFadeDistance: number;
	AmbientOcclusionFadeRadius: number;
	AmbientOcclusionDistance: number;
	AmbientOcclusionPower: number;
	AmbientOcclusionBias: number;
	AmbientOcclusionQuality: number;
	AmbientOcclusionMipBlend: number;
	AmbientOcclusionMipScale: number;
	AmbientOcclusionMipThreshold: number;
	AmbientOcclusionTemporalBlendWeight: number;
	RayTracingAO: boolean;
	RayTracingAOSamplesPerPixel: number;
	RayTracingAOIntensity: number;
	RayTracingAORadius: number;
	ColorGradingIntensity: number;
	ColorGradingLUT: Texture;
	DepthOfFieldSensorWidth: number;
	DepthOfFieldFocalDistance: number;
	DepthOfFieldDepthBlurAmount: number;
	DepthOfFieldDepthBlurRadius: number;
	DepthOfFieldFocalRegion: number;
	DepthOfFieldNearTransitionRegion: number;
	DepthOfFieldFarTransitionRegion: number;
	DepthOfFieldScale: number;
	DepthOfFieldNearBlurSize: number;
	DepthOfFieldFarBlurSize: number;
	DepthOfFieldOcclusion: number;
	DepthOfFieldSkyFocusDistance: number;
	DepthOfFieldVignetteSize: number;
	MotionBlurAmount: number;
	MotionBlurMax: number;
	MotionBlurTargetFPS: number;
	MotionBlurPerObjectSize: number;
	LPVIntensity: number;
	LPVVplInjectionBias: number;
	LPVSize: number;
	LPVSecondaryOcclusionIntensity: number;
	LPVSecondaryBounceIntensity: number;
	LPVGeometryVolumeBias: number;
	LPVEmissiveInjectionIntensity: number;
	LPVDirectionalOcclusionIntensity: number;
	LPVDirectionalOcclusionRadius: number;
	LPVDiffuseOcclusionExponent: number;
	LPVSpecularOcclusionExponent: number;
	LPVDiffuseOcclusionIntensity: number;
	LPVSpecularOcclusionIntensity: number;
	TranslucencyType: ETranslucencyType;
	RayTracingTranslucencyMaxRoughness: number;
	RayTracingTranslucencyRefractionRays: number;
	RayTracingTranslucencySamplesPerPixel: number;
	RayTracingTranslucencyShadows: EReflectedAndRefractedRayTracedShadows;
	RayTracingTranslucencyRefraction: boolean;
	PathTracingMaxBounces: number;
	PathTracingSamplesPerPixel: number;
	PathTracingFilterWidth: number;
	PathTracingEnableEmissive: boolean;
	PathTracingMaxPathExposure: number;
	PathTracingEnableReferenceDOF: boolean;
	PathTracingEnableDenoiser: boolean;
	LPVFadeRange: number;
	LPVDirectionalOcclusionFadeRange: number;
	ScreenPercentage: number;
	WeightedBlendables: WeightedBlendables;
	Blendables: UObject[];
	clone() : PostProcessSettings;
	static C(Other: UObject | any): PostProcessSettings;
}

declare class MinimalViewInfo { 
	Location: Vector;
	Rotation: Rotator;
	FOV: number;
	DesiredFOV: number;
	OrthoWidth: number;
	OrthoNearClipPlane: number;
	OrthoFarClipPlane: number;
	AspectRatio: number;
	bConstrainAspectRatio: boolean;
	bUseFieldOfViewForLOD: boolean;
	ProjectionMode: ECameraProjectionMode;
	PostProcessBlendWeight: number;
	PostProcessSettings: PostProcessSettings;
	OffCenterProjectionOffset: Vector2D;
	clone() : MinimalViewInfo;
	static C(Other: UObject | any): MinimalViewInfo;
	CalculateProjectionMatrix(): Matrix;
	GetViewProjectionMatrix(ViewMatrix?: Matrix,ProjectionMatrix?: Matrix,ViewProjectionMatrix?: Matrix): {ViewMatrix: Matrix, ProjectionMatrix: Matrix, ViewProjectionMatrix: Matrix};
	static CalculateProjectionMatrix(MinimalViewInfo: MinimalViewInfo): Matrix;
	static GetViewProjectionMatrix(DesiredView: MinimalViewInfo,ViewMatrix?: Matrix,ProjectionMatrix?: Matrix,ViewProjectionMatrix?: Matrix): {ViewMatrix: Matrix, ProjectionMatrix: Matrix, ViewProjectionMatrix: Matrix};
}

declare class CameraCacheEntry { 
	Timestamp: number;
	POV: MinimalViewInfo;
	clone() : CameraCacheEntry;
	static C(Other: UObject | any): CameraCacheEntry;
}

declare class TViewTarget { 
	Target: Actor;
	POV: MinimalViewInfo;
	PlayerState: PlayerState;
	clone() : TViewTarget;
	static C(Other: UObject | any): TViewTarget;
}

declare class CameraModifier extends UObject { 
	bDebug: boolean;
	bExclusive: boolean;
	Priority: number;
	CameraOwner: PlayerCameraManager;
	AlphaInTime: number;
	AlphaOutTime: number;
	Alpha: number;
	static Load(ResourceName: string): CameraModifier;
	static Find(Outer: UObject, ResourceName: string): CameraModifier;
	static GetDefaultObject(): CameraModifier;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraModifier;
	OnCameraOwnerDestroyed(InOwner: Actor): void;
	IsDisabled(): boolean;
	GetViewTarget(): Actor;
	EnableModifier(): void;
	DisableModifier(bImmediate: boolean): void;
	BlueprintModifyPostProcess(DeltaTime: number,PostProcessBlendWeight?: number,PostProcessSettings?: PostProcessSettings): {PostProcessBlendWeight: number, PostProcessSettings: PostProcessSettings};
	BlueprintModifyCamera(DeltaTime: number,ViewLocation: Vector,ViewRotation: Rotator,FOV: number,NewViewLocation?: Vector,NewViewRotation?: Rotator,NewFOV?: number): {NewViewLocation: Vector, NewViewRotation: Rotator, NewFOV: number};
	static C(Other: UObject | any): CameraModifier;
}

declare class CameraShakePattern extends UObject { 
	static Load(ResourceName: string): CameraShakePattern;
	static Find(Outer: UObject, ResourceName: string): CameraShakePattern;
	static GetDefaultObject(): CameraShakePattern;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraShakePattern;
	static C(Other: UObject | any): CameraShakePattern;
}

declare type EInitialOscillatorOffset = 'EOO_OffsetRandom' | 'EOO_OffsetZero' | 'EOO_MAX';
declare var EInitialOscillatorOffset : { EOO_OffsetRandom:'EOO_OffsetRandom',EOO_OffsetZero:'EOO_OffsetZero',EOO_MAX:'EOO_MAX', };
declare type EOscillatorWaveform = 'SineWave' | 'PerlinNoise' | 'EOscillatorWaveform_MAX';
declare var EOscillatorWaveform : { SineWave:'SineWave',PerlinNoise:'PerlinNoise',EOscillatorWaveform_MAX:'EOscillatorWaveform_MAX', };
declare class FOscillator { 
	Amplitude: number;
	Frequency: number;
	InitialOffset: EInitialOscillatorOffset;
	Waveform: EOscillatorWaveform;
	clone() : FOscillator;
	static C(Other: UObject | any): FOscillator;
}

declare class ROscillator { 
	Pitch: FOscillator;
	Yaw: FOscillator;
	Roll: FOscillator;
	clone() : ROscillator;
	static C(Other: UObject | any): ROscillator;
}

declare class VOscillator { 
	X: FOscillator;
	Y: FOscillator;
	Z: FOscillator;
	clone() : VOscillator;
	static C(Other: UObject | any): VOscillator;
}

declare class SubTrackGroup { 
	GroupName: string;
	TrackIndices: number[];
	bIsCollapsed: boolean;
	bIsSelected: boolean;
	clone() : SubTrackGroup;
	static C(Other: UObject | any): SubTrackGroup;
}

declare class SupportedSubTrackInfo { 
	SupportedClass: UnrealEngineClass;
	SubTrackName: string;
	GroupIndex: number;
	clone() : SupportedSubTrackInfo;
	static C(Other: UObject | any): SupportedSubTrackInfo;
}

declare type ETrackActiveCondition = 'ETAC_Always' | 'ETAC_GoreEnabled' | 'ETAC_GoreDisabled' | 'ETAC_MAX';
declare var ETrackActiveCondition : { ETAC_Always:'ETAC_Always',ETAC_GoreEnabled:'ETAC_GoreEnabled',ETAC_GoreDisabled:'ETAC_GoreDisabled',ETAC_MAX:'ETAC_MAX', };
declare class InterpTrack extends UObject { 
	SubTracks: InterpTrack[];
	SubTrackGroups: SubTrackGroup[];
	SupportedSubTracks: SupportedSubTrackInfo[];
	TrackInstClass: UnrealEngineClass;
	ActiveCondition: ETrackActiveCondition;
	TrackTitle: string;
	bOnePerGroup: boolean;
	bDirGroupOnly: boolean;
	bDisableTrack: boolean;
	bIsSelected: boolean;
	TrackIcon: Texture2D;
	bIsAnimControlTrack: boolean;
	bSubTrackOnly: boolean;
	bVisible: boolean;
	bIsRecording: boolean;
	bIsCollapsed: boolean;
	static Load(ResourceName: string): InterpTrack;
	static Find(Outer: UObject, ResourceName: string): InterpTrack;
	static GetDefaultObject(): InterpTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrack;
	static C(Other: UObject | any): InterpTrack;
}

declare class InterpGroup extends UObject { 
	InterpTracks: InterpTrack[];
	GroupName: string;
	GroupColor: Color;
	bCollapsed: boolean;
	bVisible: boolean;
	bIsFolder: boolean;
	bIsParented: boolean;
	bIsSelected: boolean;
	static Load(ResourceName: string): InterpGroup;
	static Find(Outer: UObject, ResourceName: string): InterpGroup;
	static GetDefaultObject(): InterpGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroup;
	static C(Other: UObject | any): InterpGroup;
}

declare class CameraAnim extends UObject { 
	CameraInterpGroup: InterpGroup;
	PreviewInterpGroup: InterpGroup;
	AnimLength: number;
	BoundingBox: Box;
	bRelativeToInitialTransform: boolean;
	bRelativeToInitialFOV: boolean;
	BaseFOV: number;
	BasePostProcessSettings: PostProcessSettings;
	BasePostProcessBlendWeight: number;
	static Load(ResourceName: string): CameraAnim;
	static Find(Outer: UObject, ResourceName: string): CameraAnim;
	static GetDefaultObject(): CameraAnim;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnim;
	static C(Other: UObject | any): CameraAnim;
}

declare class MovieSceneSignedObject extends UObject { 
	Signature: Guid;
	static Load(ResourceName: string): MovieSceneSignedObject;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSignedObject;
	static GetDefaultObject(): MovieSceneSignedObject;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSignedObject;
	static C(Other: UObject | any): MovieSceneSignedObject;
}

declare class MovieSceneEvaluationTemplateSerialNumber { 
	Value: any;
	clone() : MovieSceneEvaluationTemplateSerialNumber;
	static C(Other: UObject | any): MovieSceneEvaluationTemplateSerialNumber;
}

declare class MovieSceneTrackIdentifier { 
	Value: any;
	clone() : MovieSceneTrackIdentifier;
	static C(Other: UObject | any): MovieSceneTrackIdentifier;
}

declare class MovieSceneTemplateGenerationLedger { 
	LastTrackIdentifier: MovieSceneTrackIdentifier;
	TrackSignatureToTrackIdentifier: any;
	SubSectionRanges: any;
	clone() : MovieSceneTemplateGenerationLedger;
	static C(Other: UObject | any): MovieSceneTemplateGenerationLedger;
}

declare class MovieSceneEvaluationTemplate { 
	Tracks: any;
	SequenceSignature: Guid;
	TemplateSerialNumber: MovieSceneEvaluationTemplateSerialNumber;
	TemplateLedger: MovieSceneTemplateGenerationLedger;
	clone() : MovieSceneEvaluationTemplate;
	static C(Other: UObject | any): MovieSceneEvaluationTemplate;
}

declare class MovieSceneSequenceID { 
	Value: any;
	clone() : MovieSceneSequenceID;
	static C(Other: UObject | any): MovieSceneSequenceID;
}

declare class MovieSceneSequenceHierarchyNode { 
	ParentID: MovieSceneSequenceID;
	Children: MovieSceneSequenceID[];
	clone() : MovieSceneSequenceHierarchyNode;
	static C(Other: UObject | any): MovieSceneSequenceHierarchyNode;
}

declare class MovieSceneSubSequenceTree { 
	clone() : MovieSceneSubSequenceTree;
	static C(Other: UObject | any): MovieSceneSubSequenceTree;
}

declare class MovieSceneSequenceHierarchy { 
	RootNode: MovieSceneSequenceHierarchyNode;
	Tree: MovieSceneSubSequenceTree;
	SubSequences: any;
	Hierarchy: any;
	clone() : MovieSceneSequenceHierarchy;
	static C(Other: UObject | any): MovieSceneSequenceHierarchy;
}

declare class MovieSceneEvaluationFieldEntityTree { 
	clone() : MovieSceneEvaluationFieldEntityTree;
	static C(Other: UObject | any): MovieSceneEvaluationFieldEntityTree;
}

declare class MovieSceneEvaluationFieldEntityKey { 
	EntityOwner: any;
	EntityID: any;
	clone() : MovieSceneEvaluationFieldEntityKey;
	static C(Other: UObject | any): MovieSceneEvaluationFieldEntityKey;
}

declare class MovieSceneEvaluationFieldEntity { 
	Key: MovieSceneEvaluationFieldEntityKey;
	SharedMetaDataIndex: number;
	clone() : MovieSceneEvaluationFieldEntity;
	static C(Other: UObject | any): MovieSceneEvaluationFieldEntity;
}

declare type ESectionEvaluationFlags = 'None' | 'PreRoll' | 'PostRoll' | 'ESectionEvaluationFlags_MAX';
declare var ESectionEvaluationFlags : { None:'None',PreRoll:'PreRoll',PostRoll:'PostRoll',ESectionEvaluationFlags_MAX:'ESectionEvaluationFlags_MAX', };
declare class MovieSceneEvaluationFieldEntityMetaData { 
	OverrideBoundPropertyPath: string;
	ForcedTime: FrameNumber;
	Flags: ESectionEvaluationFlags;
	bEvaluateInSequencePreRoll: boolean;
	bEvaluateInSequencePostRoll: boolean;
	clone() : MovieSceneEvaluationFieldEntityMetaData;
	static C(Other: UObject | any): MovieSceneEvaluationFieldEntityMetaData;
}

declare class MovieSceneEvaluationFieldSharedEntityMetaData { 
	ObjectBindingID: Guid;
	clone() : MovieSceneEvaluationFieldSharedEntityMetaData;
	static C(Other: UObject | any): MovieSceneEvaluationFieldSharedEntityMetaData;
}

declare class MovieSceneEntityComponentField { 
	PersistentEntityTree: MovieSceneEvaluationFieldEntityTree;
	OneShotEntityTree: MovieSceneEvaluationFieldEntityTree;
	Entities: MovieSceneEvaluationFieldEntity[];
	EntityMetaData: MovieSceneEvaluationFieldEntityMetaData[];
	SharedMetaData: MovieSceneEvaluationFieldSharedEntityMetaData[];
	clone() : MovieSceneEntityComponentField;
	static C(Other: UObject | any): MovieSceneEntityComponentField;
}

declare class MovieSceneFrameRange { 
	clone() : MovieSceneFrameRange;
	static C(Other: UObject | any): MovieSceneFrameRange;
}

declare class MovieSceneEvaluationGroupLUTIndex { 
	NumInitPtrs: number;
	NumEvalPtrs: number;
	clone() : MovieSceneEvaluationGroupLUTIndex;
	static C(Other: UObject | any): MovieSceneEvaluationGroupLUTIndex;
}

declare class MovieSceneEvaluationFieldTrackPtr { 
	SequenceID: MovieSceneSequenceID;
	TrackIdentifier: MovieSceneTrackIdentifier;
	clone() : MovieSceneEvaluationFieldTrackPtr;
	static C(Other: UObject | any): MovieSceneEvaluationFieldTrackPtr;
}

declare class MovieSceneFieldEntry_EvaluationTrack { 
	TrackPtr: MovieSceneEvaluationFieldTrackPtr;
	NumChildren: any;
	clone() : MovieSceneFieldEntry_EvaluationTrack;
	static C(Other: UObject | any): MovieSceneFieldEntry_EvaluationTrack;
}

declare class MovieSceneFieldEntry_ChildTemplate { 
	ChildIndex: any;
	Flags: ESectionEvaluationFlags;
	ForcedTime: FrameNumber;
	clone() : MovieSceneFieldEntry_ChildTemplate;
	static C(Other: UObject | any): MovieSceneFieldEntry_ChildTemplate;
}

declare class MovieSceneEvaluationGroup { 
	LUTIndices: MovieSceneEvaluationGroupLUTIndex[];
	TrackLUT: MovieSceneFieldEntry_EvaluationTrack[];
	SectionLUT: MovieSceneFieldEntry_ChildTemplate[];
	clone() : MovieSceneEvaluationGroup;
	static C(Other: UObject | any): MovieSceneEvaluationGroup;
}

declare class MovieSceneEvaluationKey { 
	SequenceID: MovieSceneSequenceID;
	TrackIdentifier: MovieSceneTrackIdentifier;
	SectionIndex: any;
	clone() : MovieSceneEvaluationKey;
	static C(Other: UObject | any): MovieSceneEvaluationKey;
}

declare class MovieSceneOrderedEvaluationKey { 
	Key: MovieSceneEvaluationKey;
	SetupIndex: any;
	TearDownIndex: any;
	clone() : MovieSceneOrderedEvaluationKey;
	static C(Other: UObject | any): MovieSceneOrderedEvaluationKey;
}

declare class MovieSceneEvaluationMetaData { 
	ActiveSequences: MovieSceneSequenceID[];
	ActiveEntities: MovieSceneOrderedEvaluationKey[];
	clone() : MovieSceneEvaluationMetaData;
	static C(Other: UObject | any): MovieSceneEvaluationMetaData;
}

declare class MovieSceneEvaluationField { 
	Signature: Guid;
	Ranges: MovieSceneFrameRange[];
	Groups: MovieSceneEvaluationGroup[];
	MetaData: MovieSceneEvaluationMetaData[];
	clone() : MovieSceneEvaluationField;
	static C(Other: UObject | any): MovieSceneEvaluationField;
}

declare class MovieSceneSequenceCompilerMaskStruct { 
	bHierarchy: boolean;
	bEvaluationTemplate: boolean;
	bEvaluationTemplateField: boolean;
	bEntityComponentField: boolean;
	clone() : MovieSceneSequenceCompilerMaskStruct;
	static C(Other: UObject | any): MovieSceneSequenceCompilerMaskStruct;
}

declare type EMovieSceneSequenceFlags = 'None' | 'Volatile' | 'BlockingEvaluation' | 'InheritedFlags' | 'EMovieSceneSequenceFlags_MAX';
declare var EMovieSceneSequenceFlags : { None:'None',Volatile:'Volatile',BlockingEvaluation:'BlockingEvaluation',InheritedFlags:'InheritedFlags',EMovieSceneSequenceFlags_MAX:'EMovieSceneSequenceFlags_MAX', };
declare class MovieSceneCompiledData extends UObject { 
	EvaluationTemplate: MovieSceneEvaluationTemplate;
	Hierarchy: MovieSceneSequenceHierarchy;
	EntityComponentField: MovieSceneEntityComponentField;
	TrackTemplateField: MovieSceneEvaluationField;
	DeterminismFences: FrameTime[];
	CompiledSignature: Guid;
	CompilerVersion: Guid;
	AccumulatedMask: MovieSceneSequenceCompilerMaskStruct;
	AllocatedMask: MovieSceneSequenceCompilerMaskStruct;
	AccumulatedFlags: EMovieSceneSequenceFlags;
	static Load(ResourceName: string): MovieSceneCompiledData;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCompiledData;
	static GetDefaultObject(): MovieSceneCompiledData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCompiledData;
	static C(Other: UObject | any): MovieSceneCompiledData;
}

declare type EMovieSceneCompletionMode = 'KeepState' | 'RestoreState' | 'ProjectDefault' | 'EMovieSceneCompletionMode_MAX';
declare var EMovieSceneCompletionMode : { KeepState:'KeepState',RestoreState:'RestoreState',ProjectDefault:'ProjectDefault',EMovieSceneCompletionMode_MAX:'EMovieSceneCompletionMode_MAX', };
declare class Timecode { 
	Hours: number;
	Minutes: number;
	Seconds: number;
	Frames: number;
	bDropFrameFormat: boolean;
	clone() : Timecode;
	static C(Other: UObject | any): Timecode;
	Conv_TimecodeToString(bForceSignDisplay: boolean): string;
	static Conv_TimecodeToString(InTimecode: Timecode,bForceSignDisplay: boolean): string;
	static GetTimecode(): Timecode;
}

declare class MovieSceneTimecodeSource { 
	Timecode: Timecode;
	clone() : MovieSceneTimecodeSource;
	static C(Other: UObject | any): MovieSceneTimecodeSource;
}

declare type EMovieSceneObjectBindingSpace = 'Local' | 'Root' | 'Unused' | 'EMovieSceneObjectBindingSpace_MAX';
declare var EMovieSceneObjectBindingSpace : { Local:'Local',Root:'Root',Unused:'Unused',EMovieSceneObjectBindingSpace_MAX:'EMovieSceneObjectBindingSpace_MAX', };
declare class MovieSceneObjectBindingID { 
	Guid: Guid;
	SequenceID: number;
	ResolveParentIndex: number;
	Space: EMovieSceneObjectBindingSpace;
	clone() : MovieSceneObjectBindingID;
	static C(Other: UObject | any): MovieSceneObjectBindingID;
}

declare class MovieSceneSectionEvalOptions { 
	bCanEditCompletionMode: boolean;
	CompletionMode: EMovieSceneCompletionMode;
	clone() : MovieSceneSectionEvalOptions;
	static C(Other: UObject | any): MovieSceneSectionEvalOptions;
}

declare class MovieSceneEasingSettings { 
	AutoEaseInDuration: number;
	AutoEaseOutDuration: number;
	EaseIn: any;
	bManualEaseIn: boolean;
	ManualEaseInDuration: number;
	EaseOut: any;
	bManualEaseOut: boolean;
	ManualEaseOutDuration: number;
	AutoEaseInTime: number;
	AutoEaseOutTime: number;
	ManualEaseInTime: number;
	ManualEaseOutTime: number;
	clone() : MovieSceneEasingSettings;
	static C(Other: UObject | any): MovieSceneEasingSettings;
}

declare type EMovieSceneBlendType = 'Invalid' | 'Absolute' | 'Additive' | 'Relative' | 'AdditiveFromBase' | 'EMovieSceneBlendType_MAX';
declare var EMovieSceneBlendType : { Invalid:'Invalid',Absolute:'Absolute',Additive:'Additive',Relative:'Relative',AdditiveFromBase:'AdditiveFromBase',EMovieSceneBlendType_MAX:'EMovieSceneBlendType_MAX', };
declare class OptionalMovieSceneBlendType { 
	BlendType: EMovieSceneBlendType;
	bIsValid: boolean;
	clone() : OptionalMovieSceneBlendType;
	static C(Other: UObject | any): OptionalMovieSceneBlendType;
}

declare class MovieSceneScriptingChannel extends UObject { 
	ChannelName: string;
	static Load(ResourceName: string): MovieSceneScriptingChannel;
	static Find(Outer: UObject, ResourceName: string): MovieSceneScriptingChannel;
	static GetDefaultObject(): MovieSceneScriptingChannel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneScriptingChannel;
	static C(Other: UObject | any): MovieSceneScriptingChannel;
}

declare class MovieSceneSection extends MovieSceneSignedObject { 
	EvalOptions: MovieSceneSectionEvalOptions;
	Easing: MovieSceneEasingSettings;
	SectionRange: MovieSceneFrameRange;
	TimecodeSource: MovieSceneTimecodeSource;
	PreRollFrames: FrameNumber;
	PostRollFrames: FrameNumber;
	RowIndex: number;
	OverlapPriority: number;
	bIsActive: boolean;
	bIsLocked: boolean;
	StartTime: number;
	EndTime: number;
	PrerollTime: number;
	PostrollTime: number;
	bIsInfinite: boolean;
	bSupportsInfiniteRange: boolean;
	BlendType: OptionalMovieSceneBlendType;
	static Load(ResourceName: string): MovieSceneSection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSection;
	static GetDefaultObject(): MovieSceneSection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSection;
	SetRowIndex(NewRowIndex: number): void;
	SetPreRollFrames(InPreRollFrames: number): void;
	SetPostRollFrames(InPostRollFrames: number): void;
	SetOverlapPriority(NewPriority: number): void;
	SetIsLocked(bInIsLocked: boolean): void;
	SetIsActive(bInIsActive: boolean): void;
	SetCompletionMode(InCompletionMode: EMovieSceneCompletionMode): void;
	SetBlendType(InBlendType: EMovieSceneBlendType): void;
	IsLocked(): boolean;
	IsActive(): boolean;
	GetRowIndex(): number;
	GetPreRollFrames(): number;
	GetPostRollFrames(): number;
	GetOverlapPriority(): number;
	GetCompletionMode(): EMovieSceneCompletionMode;
	GetBlendType(): OptionalMovieSceneBlendType;
	static C(Other: UObject | any): MovieSceneSection;
	FindChannelsByType(ChannelType: UnrealEngineClass): MovieSceneScriptingChannel[];
	GetAllChannels(): MovieSceneScriptingChannel[];
	GetChannels(): MovieSceneScriptingChannel[];
	GetChannelsByType(ChannelType: UnrealEngineClass): MovieSceneScriptingChannel[];
	GetEndFrame(): number;
	GetEndFrameSeconds(): number;
	GetStartFrame(): number;
	GetStartFrameSeconds(): number;
	HasEndFrame(): boolean;
	HasStartFrame(): boolean;
	SetEndFrame(EndFrame: number): void;
	SetEndFrameBounded(bIsBounded: boolean): void;
	SetEndFrameSeconds(EndTime: number): void;
	SetRange(StartFrame: number,EndFrame: number): void;
	SetRangeSeconds(StartTime: number,EndTime: number): void;
	SetStartFrame(StartFrame: number): void;
	SetStartFrameBounded(bIsBounded: boolean): void;
	SetStartFrameSeconds(StartTime: number): void;
	static FindChannelsByType(Section: MovieSceneSection,ChannelType: UnrealEngineClass): MovieSceneScriptingChannel[];
	static GetAllChannels(Section: MovieSceneSection): MovieSceneScriptingChannel[];
	static GetChannels(Section: MovieSceneSection): MovieSceneScriptingChannel[];
	static GetChannelsByType(Section: MovieSceneSection,ChannelType: UnrealEngineClass): MovieSceneScriptingChannel[];
	static GetEndFrame(Section: MovieSceneSection): number;
	static GetEndFrameSeconds(Section: MovieSceneSection): number;
	static GetStartFrame(Section: MovieSceneSection): number;
	static GetStartFrameSeconds(Section: MovieSceneSection): number;
	static HasEndFrame(Section: MovieSceneSection): boolean;
	static HasStartFrame(Section: MovieSceneSection): boolean;
	static SetEndFrame(Section: MovieSceneSection,EndFrame: number): void;
	static SetEndFrameBounded(Section: MovieSceneSection,bIsBounded: boolean): void;
	static SetEndFrameSeconds(Section: MovieSceneSection,EndTime: number): void;
	static SetRange(Section: MovieSceneSection,StartFrame: number,EndFrame: number): void;
	static SetRangeSeconds(Section: MovieSceneSection,StartTime: number,EndTime: number): void;
	static SetStartFrame(Section: MovieSceneSection,StartFrame: number): void;
	static SetStartFrameBounded(Section: MovieSceneSection,bIsBounded: boolean): void;
	static SetStartFrameSeconds(Section: MovieSceneSection,StartTime: number): void;
}

declare class MovieSceneEventSectionBase extends MovieSceneSection { 
	static Load(ResourceName: string): MovieSceneEventSectionBase;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEventSectionBase;
	static GetDefaultObject(): MovieSceneEventSectionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEventSectionBase;
	static C(Other: UObject | any): MovieSceneEventSectionBase;
}

declare class K2Node_EditablePinBase extends K2Node { 
	bIsEditable: boolean;
	static Load(ResourceName: string): K2Node_EditablePinBase;
	static Find(Outer: UObject, ResourceName: string): K2Node_EditablePinBase;
	static GetDefaultObject(): K2Node_EditablePinBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_EditablePinBase;
	static C(Other: UObject | any): K2Node_EditablePinBase;
}

declare class K2Node_Event extends K2Node_EditablePinBase { 
	EventSignatureName: string;
	EventSignatureClass: UnrealEngineClass;
	EventReference: MemberReference;
	bOverrideFunction: boolean;
	bInternalEvent: boolean;
	CustomFunctionName: string;
	FunctionFlags: any;
	static Load(ResourceName: string): K2Node_Event;
	static Find(Outer: UObject, ResourceName: string): K2Node_Event;
	static GetDefaultObject(): K2Node_Event;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_Event;
	static C(Other: UObject | any): K2Node_Event;
}

declare class KismetUserDeclaredFunctionMetadata { 
	Tooltip: string;
	Category: string;
	Keywords: string;
	CompactNodeTitle: string;
	InstanceTitleColor: LinearColor;
	DeprecationMessage: string;
	bIsDeprecated: boolean;
	bCallInEditor: boolean;
	bThreadSafe: boolean;
	HasLatentFunctions: any;
	clone() : KismetUserDeclaredFunctionMetadata;
	static C(Other: UObject | any): KismetUserDeclaredFunctionMetadata;
}

declare class K2Node_CustomEvent extends K2Node_Event { 
	DeprecationMessage: string;
	bIsDeprecated: boolean;
	bCallInEditor: boolean;
	MetaData: KismetUserDeclaredFunctionMetadata;
	static Load(ResourceName: string): K2Node_CustomEvent;
	static Find(Outer: UObject, ResourceName: string): K2Node_CustomEvent;
	static GetDefaultObject(): K2Node_CustomEvent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CustomEvent;
	static C(Other: UObject | any): K2Node_CustomEvent;
}

declare class SequencerQuickBindingResult { 
	EventEndpoint: K2Node_CustomEvent;
	PayloadNames: string[];
	clone() : SequencerQuickBindingResult;
	static C(Other: UObject | any): SequencerQuickBindingResult;
	IsEventEndpointValid(): boolean;
	static IsEventEndpointValid(InEndpoint: SequencerQuickBindingResult): boolean;
}

declare class UFunction extends Struct { 
	static Load(ResourceName: string): UFunction;
	static Find(Outer: UObject, ResourceName: string): UFunction;
	static GetDefaultObject(): UFunction;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UFunction;
	static C(Other: UObject | any): UFunction;
	GetFunctionParmsSize(): number;
	static GetFunctionParmsSize(UFunction: UFunction): number;
}

declare class MovieSceneEventPtrs { 
	UFunction: UFunction;
	BoundObjectProperty: any;
	clone() : MovieSceneEventPtrs;
	static C(Other: UObject | any): MovieSceneEventPtrs;
}

declare class MovieSceneEvent { 
	Ptrs: MovieSceneEventPtrs;
	PayloadVariables: any;
	CompiledFunctionName: string;
	BoundObjectPinName: string;
	WeakEndpoint: any;
	GraphGuid: Guid;
	NodeGuid: Guid;
	FunctionEntry: any;
	clone() : MovieSceneEvent;
	static C(Other: UObject | any): MovieSceneEvent;
	GetBoundObjectPropertyClass(): UnrealEngineClass;
	static GetBoundObjectPropertyClass(EventKey: MovieSceneEvent): UnrealEngineClass;
}

declare class MovieSceneMarkedFrame { 
	FrameNumber: FrameNumber;
	Label: string;
	Color: LinearColor;
	bIsDeterminismFence: boolean;
	clone() : MovieSceneMarkedFrame;
	static C(Other: UObject | any): MovieSceneMarkedFrame;
}

declare class MovieSceneTrackEvalOptions { 
	bCanEvaluateNearestSection: boolean;
	bEvalNearestSection: boolean;
	bEvaluateInPreroll: boolean;
	bEvaluateInPostroll: boolean;
	bEvaluateNearestSection: boolean;
	clone() : MovieSceneTrackEvalOptions;
	static C(Other: UObject | any): MovieSceneTrackEvalOptions;
}

declare class MovieSceneTrackDisplayOptions { 
	bShowVerticalFrames: boolean;
	clone() : MovieSceneTrackDisplayOptions;
	static C(Other: UObject | any): MovieSceneTrackDisplayOptions;
}

declare class FrameNumberRangeBound { 
	Type: ERangeBoundTypes;
	Value: FrameNumber;
	clone() : FrameNumberRangeBound;
	static C(Other: UObject | any): FrameNumberRangeBound;
}

declare class FrameNumberRange { 
	LowerBound: FrameNumberRangeBound;
	UpperBound: FrameNumberRangeBound;
	clone() : FrameNumberRange;
	static C(Other: UObject | any): FrameNumberRange;
}

declare class MovieSceneTrackEvaluationFieldEntry { 
	Section: MovieSceneSection;
	Range: FrameNumberRange;
	ForcedTime: FrameNumber;
	Flags: ESectionEvaluationFlags;
	LegacySortOrder: any;
	clone() : MovieSceneTrackEvaluationFieldEntry;
	static C(Other: UObject | any): MovieSceneTrackEvaluationFieldEntry;
}

declare class MovieSceneTrackEvaluationField { 
	Entries: MovieSceneTrackEvaluationFieldEntry[];
	clone() : MovieSceneTrackEvaluationField;
	static C(Other: UObject | any): MovieSceneTrackEvaluationField;
}

declare class MovieSceneTrack extends MovieSceneSignedObject { 
	EvalOptions: MovieSceneTrackEvalOptions;
	DisplayOptions: MovieSceneTrackDisplayOptions;
	bIsEvalDisabled: boolean;
	RowsDisabled: number[];
	EvaluationFieldGuid: Guid;
	EvaluationFieldVersion: any;
	EvaluationField: MovieSceneTrackEvaluationField;
	ObjectBindingID: Guid;
	TrackTint: Color;
	SortingOrder: number;
	bSupportsDefaultSections: boolean;
	static Load(ResourceName: string): MovieSceneTrack;
	static Find(Outer: UObject, ResourceName: string): MovieSceneTrack;
	static GetDefaultObject(): MovieSceneTrack;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneTrack;
	static C(Other: UObject | any): MovieSceneTrack;
	AddSection(): MovieSceneSection;
	GetColorTint(): Color;
	GetDisplayName(): string;
	GetSections(): MovieSceneSection[];
	GetSectionToKey(): MovieSceneSection;
	GetSortingOrder(): number;
	GetTrackRowDisplayName(RowIndex: number): string;
	RemoveSection(Section: MovieSceneSection): void;
	SetColorTint(ColorTint: Color): void;
	SetDisplayName(InName: string): void;
	SetSectionToKey(Section: MovieSceneSection): void;
	SetSortingOrder(SortingOrder: number): void;
	SetTrackRowDisplayName(InName: string,RowIndex: number): void;
	static AddSection(Track: MovieSceneTrack): MovieSceneSection;
	static GetColorTint(Track: MovieSceneTrack): Color;
	static GetDisplayName(Track: MovieSceneTrack): string;
	static GetSections(Track: MovieSceneTrack): MovieSceneSection[];
	static GetSectionToKey(Track: MovieSceneTrack): MovieSceneSection;
	static GetSortingOrder(Track: MovieSceneTrack): number;
	static GetTrackRowDisplayName(Track: MovieSceneTrack,RowIndex: number): string;
	static RemoveSection(Track: MovieSceneTrack,Section: MovieSceneSection): void;
	static SetColorTint(Track: MovieSceneTrack,ColorTint: Color): void;
	static SetDisplayName(Track: MovieSceneTrack,InName: string): void;
	static SetSectionToKey(Track: MovieSceneTrack,Section: MovieSceneSection): void;
	static SetSortingOrder(Track: MovieSceneTrack,SortingOrder: number): void;
	static SetTrackRowDisplayName(Track: MovieSceneTrack,InName: string,RowIndex: number): void;
}

declare class SequencerBindingProxy { 
	BindingID: Guid;
	Sequence: MovieSceneSequence;
	clone() : SequencerBindingProxy;
	static C(Other: UObject | any): SequencerBindingProxy;
	GetBindingID(): MovieSceneObjectBindingID;
	AddTrack(TrackType: UnrealEngineClass): MovieSceneTrack;
	FindTracksByExactType(TrackType: UnrealEngineClass): MovieSceneTrack[];
	FindTracksByType(TrackType: UnrealEngineClass): MovieSceneTrack[];
	GetChildPossessables(): SequencerBindingProxy[];
	GetDisplayName(): string;
	GetId(): Guid;
	GetName(): string;
	GetObjectTemplate(): UObject;
	GetParent(): SequencerBindingProxy;
	GetPossessedObjectClass(): UnrealEngineClass;
	GetTracks(): MovieSceneTrack[];
	IsValid(): boolean;
	MoveBindingContents(DestinationBindingId: SequencerBindingProxy): void;
	Remove(): void;
	RemoveTrack(TrackToRemove: MovieSceneTrack): void;
	SetDisplayName(InDisplayName: string): void;
	SetName(InName: string): void;
	SetParent(InParentBinding: SequencerBindingProxy): void;
	static GetBindingID(InBinding: SequencerBindingProxy): MovieSceneObjectBindingID;
	static AddTrack(InBinding: SequencerBindingProxy,TrackType: UnrealEngineClass): MovieSceneTrack;
	static FindTracksByExactType(InBinding: SequencerBindingProxy,TrackType: UnrealEngineClass): MovieSceneTrack[];
	static FindTracksByType(InBinding: SequencerBindingProxy,TrackType: UnrealEngineClass): MovieSceneTrack[];
	static GetChildPossessables(InBinding: SequencerBindingProxy): SequencerBindingProxy[];
	static GetDisplayName(InBinding: SequencerBindingProxy): string;
	static GetId(InBinding: SequencerBindingProxy): Guid;
	static GetName(InBinding: SequencerBindingProxy): string;
	static GetObjectTemplate(InBinding: SequencerBindingProxy): UObject;
	static GetParent(InBinding: SequencerBindingProxy): SequencerBindingProxy;
	static GetPossessedObjectClass(InBinding: SequencerBindingProxy): UnrealEngineClass;
	static GetTracks(InBinding: SequencerBindingProxy): MovieSceneTrack[];
	static IsValid(InBinding: SequencerBindingProxy): boolean;
	static MoveBindingContents(SourceBindingId: SequencerBindingProxy,DestinationBindingId: SequencerBindingProxy): void;
	static Remove(InBinding: SequencerBindingProxy): void;
	static RemoveTrack(InBinding: SequencerBindingProxy,TrackToRemove: MovieSceneTrack): void;
	static SetDisplayName(InBinding: SequencerBindingProxy,InDisplayName: string): void;
	static SetName(InBinding: SequencerBindingProxy,InName: string): void;
	static SetParent(InBinding: SequencerBindingProxy,InParentBinding: SequencerBindingProxy): void;
}

declare class MovieSceneFolder extends UObject { 
	FolderName: string;
	ChildFolders: MovieSceneFolder[];
	ChildMasterTracks: MovieSceneTrack[];
	ChildObjectBindingStrings: string[];
	FolderColor: Color;
	SortingOrder: number;
	static Load(ResourceName: string): MovieSceneFolder;
	static Find(Outer: UObject, ResourceName: string): MovieSceneFolder;
	static GetDefaultObject(): MovieSceneFolder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneFolder;
	static C(Other: UObject | any): MovieSceneFolder;
	AddChildFolder(FolderToAdd: MovieSceneFolder): boolean;
	AddChildMasterTrack(InMasterTrack: MovieSceneTrack): boolean;
	AddChildObjectBinding(InObjectBinding: SequencerBindingProxy): boolean;
	GetChildFolders(): MovieSceneFolder[];
	GetChildMasterTracks(): MovieSceneTrack[];
	GetChildObjectBindings(): SequencerBindingProxy[];
	GetFolderColor(): Color;
	GetFolderName(): string;
	RemoveChildFolder(FolderToRemove: MovieSceneFolder): boolean;
	RemoveChildMasterTrack(InMasterTrack: MovieSceneTrack): boolean;
	RemoveChildObjectBinding(InObjectBinding: SequencerBindingProxy): boolean;
	SetFolderColor(InFolderColor: Color): boolean;
	SetFolderName(InFolderName: string): boolean;
	static AddChildFolder(TargetFolder: MovieSceneFolder,FolderToAdd: MovieSceneFolder): boolean;
	static AddChildMasterTrack(Folder: MovieSceneFolder,InMasterTrack: MovieSceneTrack): boolean;
	static AddChildObjectBinding(Folder: MovieSceneFolder,InObjectBinding: SequencerBindingProxy): boolean;
	static GetChildFolders(Folder: MovieSceneFolder): MovieSceneFolder[];
	static GetChildMasterTracks(Folder: MovieSceneFolder): MovieSceneTrack[];
	static GetChildObjectBindings(Folder: MovieSceneFolder): SequencerBindingProxy[];
	static GetFolderColor(Folder: MovieSceneFolder): Color;
	static GetFolderName(Folder: MovieSceneFolder): string;
	static RemoveChildFolder(TargetFolder: MovieSceneFolder,FolderToRemove: MovieSceneFolder): boolean;
	static RemoveChildMasterTrack(Folder: MovieSceneFolder,InMasterTrack: MovieSceneTrack): boolean;
	static RemoveChildObjectBinding(Folder: MovieSceneFolder,InObjectBinding: SequencerBindingProxy): boolean;
	static SetFolderColor(Folder: MovieSceneFolder,InFolderColor: Color): boolean;
	static SetFolderName(Folder: MovieSceneFolder,InFolderName: string): boolean;
}

declare type EUpdateClockSource = 'Tick' | 'Platform' | 'Audio' | 'RelativeTimecode' | 'Timecode' | 'PlayEveryFrame' | 'Custom' | 'EUpdateClockSource_MAX';
declare var EUpdateClockSource : { Tick:'Tick',Platform:'Platform',Audio:'Audio',RelativeTimecode:'RelativeTimecode',Timecode:'Timecode',PlayEveryFrame:'PlayEveryFrame',Custom:'Custom',EUpdateClockSource_MAX:'EUpdateClockSource_MAX', };
declare type EMovieSceneEvaluationType = 'FrameLocked' | 'WithSubFrames' | 'EMovieSceneEvaluationType_MAX';
declare var EMovieSceneEvaluationType : { FrameLocked:'FrameLocked',WithSubFrames:'WithSubFrames',EMovieSceneEvaluationType_MAX:'EMovieSceneEvaluationType_MAX', };
declare type ESpawnOwnership = 'InnerSequence' | 'MasterSequence' | 'External' | 'ESpawnOwnership_MAX';
declare var ESpawnOwnership : { InnerSequence:'InnerSequence',MasterSequence:'MasterSequence',External:'External',ESpawnOwnership_MAX:'ESpawnOwnership_MAX', };
declare class MovieSceneSpawnable { 
	SpawnTransform: Transform;
	Tags: string[];
	bContinuouslyRespawn: boolean;
	bNetAddressableName: boolean;
	bEvaluateTracksWhenNotSpawned: boolean;
	Guid: Guid;
	Name: string;
	ObjectTemplate: UObject;
	ChildPossessables: Guid[];
	Ownership: ESpawnOwnership;
	GeneratedClass: UnrealEngineClass;
	LevelName: string;
	clone() : MovieSceneSpawnable;
	static C(Other: UObject | any): MovieSceneSpawnable;
}

declare class MovieScenePossessable { 
	Tags: string[];
	Guid: Guid;
	Name: string;
	PossessedObjectClass: Class;
	ParentGuid: Guid;
	SpawnableObjectBindingID: MovieSceneObjectBindingID;
	clone() : MovieScenePossessable;
	static C(Other: UObject | any): MovieScenePossessable;
}

declare class MovieSceneBinding { 
	ObjectGuid: Guid;
	BindingName: string;
	Tracks: MovieSceneTrack[];
	SortingOrder: number;
	clone() : MovieSceneBinding;
	static C(Other: UObject | any): MovieSceneBinding;
}

declare class FloatRangeBound { 
	Type: ERangeBoundTypes;
	Value: number;
	clone() : FloatRangeBound;
	static C(Other: UObject | any): FloatRangeBound;
}

declare class FloatRange { 
	LowerBound: FloatRangeBound;
	UpperBound: FloatRangeBound;
	clone() : FloatRange;
	static C(Other: UObject | any): FloatRange;
}

declare class MovieSceneEditorData { 
	ExpansionStates: any;
	PinnedNodes: string[];
	ViewStart: any;
	ViewEnd: any;
	WorkStart: any;
	WorkEnd: any;
	MarkedFrames: any;
	WorkingRange: FloatRange;
	ViewRange: FloatRange;
	clone() : MovieSceneEditorData;
	static C(Other: UObject | any): MovieSceneEditorData;
}

declare class MovieSceneSectionGroup { 
	Sections: any[];
	clone() : MovieSceneSectionGroup;
	static C(Other: UObject | any): MovieSceneSectionGroup;
}

declare class MovieSceneNodeGroup extends UObject { 
	Name: string;
	Nodes: string[];
	static Load(ResourceName: string): MovieSceneNodeGroup;
	static Find(Outer: UObject, ResourceName: string): MovieSceneNodeGroup;
	static GetDefaultObject(): MovieSceneNodeGroup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneNodeGroup;
	static C(Other: UObject | any): MovieSceneNodeGroup;
}

declare class MovieSceneNodeGroupCollection extends UObject { 
	NodeGroups: MovieSceneNodeGroup[];
	static Load(ResourceName: string): MovieSceneNodeGroupCollection;
	static Find(Outer: UObject, ResourceName: string): MovieSceneNodeGroupCollection;
	static GetDefaultObject(): MovieSceneNodeGroupCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneNodeGroupCollection;
	static C(Other: UObject | any): MovieSceneNodeGroupCollection;
}

declare class MovieScene extends MovieSceneSignedObject { 
	Spawnables: MovieSceneSpawnable[];
	Possessables: MovieScenePossessable[];
	ObjectBindings: MovieSceneBinding[];
	BindingGroups: any;
	MasterTracks: MovieSceneTrack[];
	CameraCutTrack: MovieSceneTrack;
	SelectionRange: MovieSceneFrameRange;
	PlaybackRange: MovieSceneFrameRange;
	TickResolution: FrameRate;
	DisplayRate: FrameRate;
	EvaluationType: EMovieSceneEvaluationType;
	ClockSource: EUpdateClockSource;
	CustomClockSourcePath: SoftObjectPath;
	MarkedFrames: MovieSceneMarkedFrame[];
	bReadOnly: boolean;
	bPlaybackRangeLocked: boolean;
	ObjectsToDisplayNames: any;
	ObjectsToLabels: any;
	EditorData: MovieSceneEditorData;
	RootFolders: MovieSceneFolder[];
	SoloNodes: string[];
	MuteNodes: string[];
	SectionGroups: MovieSceneSectionGroup[];
	NodeGroupCollection: MovieSceneNodeGroupCollection;
	InTime: number;
	OutTime: number;
	StartTime: number;
	EndTime: number;
	bForceFixedFrameIntervalPlayback: boolean;
	FixedFrameInterval: number;
	static Load(ResourceName: string): MovieScene;
	static Find(Outer: UObject, ResourceName: string): MovieScene;
	static GetDefaultObject(): MovieScene;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene;
	static C(Other: UObject | any): MovieScene;
}

declare class SequencerScriptingRange { 
	bHasStart: boolean;
	bHasEnd: boolean;
	InclusiveStart: number;
	ExclusiveEnd: number;
	InternalRate: FrameRate;
	clone() : SequencerScriptingRange;
	static C(Other: UObject | any): SequencerScriptingRange;
	GetEndFrame(): number;
	GetEndSeconds(): number;
	GetStartFrame(): number;
	GetStartSeconds(): number;
	HasEnd(): boolean;
	HasStart(): boolean;
	RemoveEnd(): {Range: SequencerScriptingRange};
	RemoveStart(): {Range: SequencerScriptingRange};
	SetEndFrame(End?: number): {Range: SequencerScriptingRange};
	SetEndSeconds(End?: number): {Range: SequencerScriptingRange};
	SetStartFrame(Start?: number): {Range: SequencerScriptingRange};
	SetStartSeconds(Start?: number): {Range: SequencerScriptingRange};
	static GetEndFrame(Range: SequencerScriptingRange): number;
	static GetEndSeconds(Range: SequencerScriptingRange): number;
	static GetStartFrame(Range: SequencerScriptingRange): number;
	static GetStartSeconds(Range: SequencerScriptingRange): number;
	static HasEnd(Range: SequencerScriptingRange): boolean;
	static HasStart(Range: SequencerScriptingRange): boolean;
	static RemoveEnd(Range?: SequencerScriptingRange): {Range: SequencerScriptingRange};
	static RemoveStart(Range?: SequencerScriptingRange): {Range: SequencerScriptingRange};
	static SetEndFrame(Range?: SequencerScriptingRange,End?: number): {Range: SequencerScriptingRange};
	static SetEndSeconds(Range?: SequencerScriptingRange,End?: number): {Range: SequencerScriptingRange};
	static SetStartFrame(Range?: SequencerScriptingRange,Start?: number): {Range: SequencerScriptingRange};
	static SetStartSeconds(Range?: SequencerScriptingRange,Start?: number): {Range: SequencerScriptingRange};
}

declare class MovieSceneSequence extends MovieSceneSignedObject { 
	CompiledData: MovieSceneCompiledData;
	DefaultCompletionMode: EMovieSceneCompletionMode;
	bParentContextsAreSignificant: boolean;
	bPlayableDirectly: boolean;
	SequenceFlags: EMovieSceneSequenceFlags;
	static Load(ResourceName: string): MovieSceneSequence;
	static Find(Outer: UObject, ResourceName: string): MovieSceneSequence;
	static GetDefaultObject(): MovieSceneSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneSequence;
	GetEarliestTimecodeSource(): MovieSceneTimecodeSource;
	FindBindingsByTag(InBindingName: string): MovieSceneObjectBindingID[];
	FindBindingByTag(InBindingName: string): MovieSceneObjectBindingID;
	static C(Other: UObject | any): MovieSceneSequence;
	CreateEvent(InSection: MovieSceneEventSectionBase,InEndpoint: SequencerQuickBindingResult,InPayload: string[]): MovieSceneEvent;
	CreateQuickBinding(InObject: UObject,InFunctionName: string,bCallInEditor: boolean): SequencerQuickBindingResult;
	AddMarkedFrame(InMarkedFrame: MovieSceneMarkedFrame): number;
	AddMasterTrack(TrackType: UnrealEngineClass): MovieSceneTrack;
	AddPossessable(ObjectToPossess: UObject): SequencerBindingProxy;
	AddRootFolderToSequence(NewFolderName: string): MovieSceneFolder;
	AddSpawnableFromClass(ClassToSpawn: UnrealEngineClass): SequencerBindingProxy;
	AddSpawnableFromInstance(ObjectToSpawn: UObject): SequencerBindingProxy;
	DeleteMarkedFrame(DeleteIndex: number): void;
	DeleteMarkedFrames(): void;
	FindBindingById(BindingID: Guid): SequencerBindingProxy;
	FindBindingByName(Name: string): SequencerBindingProxy;
	FindMarkedFrameByFrameNumber(InFrameNumber: FrameNumber): number;
	FindMarkedFrameByLabel(InLabel: string): number;
	FindMasterTracksByExactType(TrackType: UnrealEngineClass): MovieSceneTrack[];
	FindMasterTracksByType(TrackType: UnrealEngineClass): MovieSceneTrack[];
	FindNextMarkedFrame(InFrameNumber: FrameNumber,bForward: boolean): number;
	GetBindings(): SequencerBindingProxy[];
	GetClockSource(): EUpdateClockSource;
	GetDisplayRate(): FrameRate;
	GetEvaluationType(): EMovieSceneEvaluationType;
	GetMarkedFrames(): MovieSceneMarkedFrame[];
	GetMasterTracks(): MovieSceneTrack[];
	GetMovieScene(): MovieScene;
	GetPlaybackEnd(): number;
	GetPlaybackEndSeconds(): number;
	GetPlaybackRange(): SequencerScriptingRange;
	GetPlaybackStart(): number;
	GetPlaybackStartSeconds(): number;
	GetPortableBindingID(DestinationSequence: MovieSceneSequence,InBinding: SequencerBindingProxy): MovieSceneObjectBindingID;
	GetPossessables(): SequencerBindingProxy[];
	GetRootFoldersInSequence(): MovieSceneFolder[];
	GetSpawnables(): SequencerBindingProxy[];
	GetTickResolution(): FrameRate;
	GetTimecodeSource(): Timecode;
	GetViewRangeEnd(): number;
	GetViewRangeStart(): number;
	GetWorkRangeEnd(): number;
	GetWorkRangeStart(): number;
	IsReadOnly(): boolean;
	LocateBoundObjects(InBinding: SequencerBindingProxy,Context: UObject): UObject[];
	MakeBindingID(InBinding: SequencerBindingProxy,Space: EMovieSceneObjectBindingSpace): MovieSceneObjectBindingID;
	MakeRange(StartFrame: number,Duration: number): SequencerScriptingRange;
	MakeRangeSeconds(StartTime: number,Duration: number): SequencerScriptingRange;
	RemoveMasterTrack(MasterTrack: MovieSceneTrack): boolean;
	ResolveBindingID(InObjectBindingID: MovieSceneObjectBindingID): SequencerBindingProxy;
	SetClockSource(InClockSource: EUpdateClockSource): void;
	SetDisplayRate(DisplayRate: FrameRate): void;
	SetEvaluationType(InEvaluationType: EMovieSceneEvaluationType): void;
	SetMarkedFrame(InMarkIndex: number,InFrameNumber: FrameNumber): void;
	SetPlaybackEnd(EndFrame: number): void;
	SetPlaybackEndSeconds(EndTime: number): void;
	SetPlaybackStart(StartFrame: number): void;
	SetPlaybackStartSeconds(StartTime: number): void;
	SetReadOnly(bInReadOnly: boolean): void;
	SetTickResolution(TickResolution: FrameRate): void;
	SetTickResolutionDirectly(TickResolution: FrameRate): void;
	SetViewRangeEnd(EndTimeInSeconds: number): void;
	SetViewRangeStart(StartTimeInSeconds: number): void;
	SetWorkRangeEnd(EndTimeInSeconds: number): void;
	SetWorkRangeStart(StartTimeInSeconds: number): void;
	SortMarkedFrames(): void;
	static CreateEvent(InSequence: MovieSceneSequence,InSection: MovieSceneEventSectionBase,InEndpoint: SequencerQuickBindingResult,InPayload: string[]): MovieSceneEvent;
	static CreateQuickBinding(InSequence: MovieSceneSequence,InObject: UObject,InFunctionName: string,bCallInEditor: boolean): SequencerQuickBindingResult;
	static AddMarkedFrame(Sequence: MovieSceneSequence,InMarkedFrame: MovieSceneMarkedFrame): number;
	static AddMasterTrack(Sequence: MovieSceneSequence,TrackType: UnrealEngineClass): MovieSceneTrack;
	static AddPossessable(Sequence: MovieSceneSequence,ObjectToPossess: UObject): SequencerBindingProxy;
	static AddRootFolderToSequence(Sequence: MovieSceneSequence,NewFolderName: string): MovieSceneFolder;
	static AddSpawnableFromClass(Sequence: MovieSceneSequence,ClassToSpawn: UnrealEngineClass): SequencerBindingProxy;
	static AddSpawnableFromInstance(Sequence: MovieSceneSequence,ObjectToSpawn: UObject): SequencerBindingProxy;
	static DeleteMarkedFrame(Sequence: MovieSceneSequence,DeleteIndex: number): void;
	static DeleteMarkedFrames(Sequence: MovieSceneSequence): void;
	static FindBindingById(Sequence: MovieSceneSequence,BindingID: Guid): SequencerBindingProxy;
	static FindBindingByName(Sequence: MovieSceneSequence,Name: string): SequencerBindingProxy;
	static FindMarkedFrameByFrameNumber(Sequence: MovieSceneSequence,InFrameNumber: FrameNumber): number;
	static FindMarkedFrameByLabel(Sequence: MovieSceneSequence,InLabel: string): number;
	static FindMasterTracksByExactType(Sequence: MovieSceneSequence,TrackType: UnrealEngineClass): MovieSceneTrack[];
	static FindMasterTracksByType(Sequence: MovieSceneSequence,TrackType: UnrealEngineClass): MovieSceneTrack[];
	static FindNextMarkedFrame(Sequence: MovieSceneSequence,InFrameNumber: FrameNumber,bForward: boolean): number;
	static GetBindings(Sequence: MovieSceneSequence): SequencerBindingProxy[];
	static GetClockSource(InSequence: MovieSceneSequence): EUpdateClockSource;
	static GetDisplayRate(Sequence: MovieSceneSequence): FrameRate;
	static GetEvaluationType(InSequence: MovieSceneSequence): EMovieSceneEvaluationType;
	static GetMarkedFrames(Sequence: MovieSceneSequence): MovieSceneMarkedFrame[];
	static GetMasterTracks(Sequence: MovieSceneSequence): MovieSceneTrack[];
	static GetMovieScene(Sequence: MovieSceneSequence): MovieScene;
	static GetPlaybackEnd(Sequence: MovieSceneSequence): number;
	static GetPlaybackEndSeconds(Sequence: MovieSceneSequence): number;
	static GetPlaybackRange(Sequence: MovieSceneSequence): SequencerScriptingRange;
	static GetPlaybackStart(Sequence: MovieSceneSequence): number;
	static GetPlaybackStartSeconds(Sequence: MovieSceneSequence): number;
	static GetPortableBindingID(MasterSequence: MovieSceneSequence,DestinationSequence: MovieSceneSequence,InBinding: SequencerBindingProxy): MovieSceneObjectBindingID;
	static GetPossessables(Sequence: MovieSceneSequence): SequencerBindingProxy[];
	static GetRootFoldersInSequence(Sequence: MovieSceneSequence): MovieSceneFolder[];
	static GetSpawnables(Sequence: MovieSceneSequence): SequencerBindingProxy[];
	static GetTickResolution(Sequence: MovieSceneSequence): FrameRate;
	static GetTimecodeSource(Sequence: MovieSceneSequence): Timecode;
	static GetViewRangeEnd(InSequence: MovieSceneSequence): number;
	static GetViewRangeStart(InSequence: MovieSceneSequence): number;
	static GetWorkRangeEnd(InSequence: MovieSceneSequence): number;
	static GetWorkRangeStart(InSequence: MovieSceneSequence): number;
	static IsReadOnly(Sequence: MovieSceneSequence): boolean;
	static LocateBoundObjects(Sequence: MovieSceneSequence,InBinding: SequencerBindingProxy,Context: UObject): UObject[];
	static MakeBindingID(MasterSequence: MovieSceneSequence,InBinding: SequencerBindingProxy,Space: EMovieSceneObjectBindingSpace): MovieSceneObjectBindingID;
	static MakeRange(Sequence: MovieSceneSequence,StartFrame: number,Duration: number): SequencerScriptingRange;
	static MakeRangeSeconds(Sequence: MovieSceneSequence,StartTime: number,Duration: number): SequencerScriptingRange;
	static RemoveMasterTrack(Sequence: MovieSceneSequence,MasterTrack: MovieSceneTrack): boolean;
	static ResolveBindingID(MasterSequence: MovieSceneSequence,InObjectBindingID: MovieSceneObjectBindingID): SequencerBindingProxy;
	static SetClockSource(InSequence: MovieSceneSequence,InClockSource: EUpdateClockSource): void;
	static SetDisplayRate(Sequence: MovieSceneSequence,DisplayRate: FrameRate): void;
	static SetEvaluationType(InSequence: MovieSceneSequence,InEvaluationType: EMovieSceneEvaluationType): void;
	static SetMarkedFrame(Sequence: MovieSceneSequence,InMarkIndex: number,InFrameNumber: FrameNumber): void;
	static SetPlaybackEnd(Sequence: MovieSceneSequence,EndFrame: number): void;
	static SetPlaybackEndSeconds(Sequence: MovieSceneSequence,EndTime: number): void;
	static SetPlaybackStart(Sequence: MovieSceneSequence,StartFrame: number): void;
	static SetPlaybackStartSeconds(Sequence: MovieSceneSequence,StartTime: number): void;
	static SetReadOnly(Sequence: MovieSceneSequence,bInReadOnly: boolean): void;
	static SetTickResolution(Sequence: MovieSceneSequence,TickResolution: FrameRate): void;
	static SetTickResolutionDirectly(Sequence: MovieSceneSequence,TickResolution: FrameRate): void;
	static SetViewRangeEnd(InSequence: MovieSceneSequence,EndTimeInSeconds: number): void;
	static SetViewRangeStart(InSequence: MovieSceneSequence,StartTimeInSeconds: number): void;
	static SetWorkRangeEnd(InSequence: MovieSceneSequence,EndTimeInSeconds: number): void;
	static SetWorkRangeStart(InSequence: MovieSceneSequence,StartTimeInSeconds: number): void;
	static SortMarkedFrames(Sequence: MovieSceneSequence): void;
}

declare class TemplateSequence extends MovieSceneSequence { 
	MovieScene: MovieScene;
	BoundActorClass: Class;
	BoundPreviewActor: Actor;
	BoundActorComponents: any;
	static Load(ResourceName: string): TemplateSequence;
	static Find(Outer: UObject, ResourceName: string): TemplateSequence;
	static GetDefaultObject(): TemplateSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TemplateSequence;
	static C(Other: UObject | any): TemplateSequence;
}

declare class CameraAnimationSequence extends TemplateSequence { 
	static Load(ResourceName: string): CameraAnimationSequence;
	static Find(Outer: UObject, ResourceName: string): CameraAnimationSequence;
	static GetDefaultObject(): CameraAnimationSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnimationSequence;
	static C(Other: UObject | any): CameraAnimationSequence;
}

declare class InterpGroupInst extends UObject { 
	Group: InterpGroup;
	GroupActor: Actor;
	TrackInst: InterpTrackInst[];
	static Load(ResourceName: string): InterpGroupInst;
	static Find(Outer: UObject, ResourceName: string): InterpGroupInst;
	static GetDefaultObject(): InterpGroupInst;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroupInst;
	static C(Other: UObject | any): InterpGroupInst;
}

declare type EInterpCurveMode = 'CIM_Linear' | 'CIM_CurveAuto' | 'CIM_Constant' | 'CIM_CurveUser' | 'CIM_CurveBreak' | 'CIM_CurveAutoClamped' | 'CIM_MAX';
declare var EInterpCurveMode : { CIM_Linear:'CIM_Linear',CIM_CurveAuto:'CIM_CurveAuto',CIM_Constant:'CIM_Constant',CIM_CurveUser:'CIM_CurveUser',CIM_CurveBreak:'CIM_CurveBreak',CIM_CurveAutoClamped:'CIM_CurveAutoClamped',CIM_MAX:'CIM_MAX', };
declare class InterpCurvePointVector { 
	InVal: number;
	OutVal: Vector;
	ArriveTangent: Vector;
	LeaveTangent: Vector;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointVector;
	static C(Other: UObject | any): InterpCurvePointVector;
}

declare class InterpCurveVector { 
	Points: InterpCurvePointVector[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveVector;
	static C(Other: UObject | any): InterpCurveVector;
}

declare class InterpLookupPoint { 
	GroupName: string;
	Time: number;
	clone() : InterpLookupPoint;
	static C(Other: UObject | any): InterpLookupPoint;
}

declare class InterpLookupTrack { 
	Points: InterpLookupPoint[];
	clone() : InterpLookupTrack;
	static C(Other: UObject | any): InterpLookupTrack;
}

declare type EInterpTrackMoveRotMode = 'IMR_Keyframed' | 'IMR_LookAtGroup' | 'IMR_Ignore' | 'IMR_MAX';
declare var EInterpTrackMoveRotMode : { IMR_Keyframed:'IMR_Keyframed',IMR_LookAtGroup:'IMR_LookAtGroup',IMR_Ignore:'IMR_Ignore',IMR_MAX:'IMR_MAX', };
declare class InterpTrackMove extends InterpTrack { 
	PosTrack: InterpCurveVector;
	EulerTrack: InterpCurveVector;
	LookupTrack: InterpLookupTrack;
	LookAtGroupName: string;
	LinCurveTension: number;
	AngCurveTension: number;
	bUseQuatInterpolation: boolean;
	bShowArrowAtKeys: boolean;
	bDisableMovement: boolean;
	bShowTranslationOnCurveEd: boolean;
	bShowRotationOnCurveEd: boolean;
	bHide3DTrack: boolean;
	RotMode: EInterpTrackMoveRotMode;
	static Load(ResourceName: string): InterpTrackMove;
	static Find(Outer: UObject, ResourceName: string): InterpTrackMove;
	static GetDefaultObject(): InterpTrackMove;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackMove;
	static C(Other: UObject | any): InterpTrackMove;
}

declare class InterpTrackInstMove extends InterpTrackInst { 
	ResetLocation: Vector;
	ResetRotation: Rotator;
	static Load(ResourceName: string): InterpTrackInstMove;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstMove;
	static GetDefaultObject(): InterpTrackInstMove;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstMove;
	static C(Other: UObject | any): InterpTrackInstMove;
}

declare type ECameraShakePlaySpace = 'CameraLocal' | 'World' | 'UserDefined' | 'ECameraShakePlaySpace_MAX';
declare var ECameraShakePlaySpace : { CameraLocal:'CameraLocal',World:'World',UserDefined:'UserDefined',ECameraShakePlaySpace_MAX:'ECameraShakePlaySpace_MAX', };
declare class CameraAnimInst extends UObject { 
	CamAnim: CameraAnim;
	InterpGroupInst: InterpGroupInst;
	PlayRate: number;
	MoveTrack: InterpTrackMove;
	MoveInst: InterpTrackInstMove;
	PlaySpace: ECameraShakePlaySpace;
	static Load(ResourceName: string): CameraAnimInst;
	static Find(Outer: UObject, ResourceName: string): CameraAnimInst;
	static GetDefaultObject(): CameraAnimInst;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnimInst;
	Stop(bImmediate: boolean): void;
	SetScale(NewDuration: number): void;
	SetDuration(NewDuration: number): void;
	static C(Other: UObject | any): CameraAnimInst;
}

declare class MovieSceneCompiledDataManager extends UObject { 
	Hierarchies: any;
	TrackTemplates: any;
	TrackTemplateFields: any;
	EntityComponentFields: any;
	static Load(ResourceName: string): MovieSceneCompiledDataManager;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCompiledDataManager;
	static GetDefaultObject(): MovieSceneCompiledDataManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCompiledDataManager;
	static C(Other: UObject | any): MovieSceneCompiledDataManager;
}

declare class MovieSceneEntitySystemGraphNodes { 
	clone() : MovieSceneEntitySystemGraphNodes;
	static C(Other: UObject | any): MovieSceneEntitySystemGraphNodes;
}

declare class MovieSceneEntitySystemGraph { 
	Nodes: MovieSceneEntitySystemGraphNodes;
	clone() : MovieSceneEntitySystemGraph;
	static C(Other: UObject | any): MovieSceneEntitySystemGraph;
}

declare class MovieSceneEntitySystemLinker extends UObject { 
	SystemGraph: MovieSceneEntitySystemGraph;
	static Load(ResourceName: string): MovieSceneEntitySystemLinker;
	static Find(Outer: UObject, ResourceName: string): MovieSceneEntitySystemLinker;
	static GetDefaultObject(): MovieSceneEntitySystemLinker;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneEntitySystemLinker;
	static C(Other: UObject | any): MovieSceneEntitySystemLinker;
}

declare class MovieSceneRootEvaluationTemplateInstance { 
	WeakRootSequence: any;
	CompiledDataManager: MovieSceneCompiledDataManager;
	EntitySystemLinker: MovieSceneEntitySystemLinker;
	DirectorInstances: any;
	clone() : MovieSceneRootEvaluationTemplateInstance;
	static C(Other: UObject | any): MovieSceneRootEvaluationTemplateInstance;
}

declare class CameraAnimationSequencePlayer extends UObject { 
	BoundObjectOverride: UObject;
	Sequence: MovieSceneSequence;
	RootTemplateInstance: MovieSceneRootEvaluationTemplateInstance;
	static Load(ResourceName: string): CameraAnimationSequencePlayer;
	static Find(Outer: UObject, ResourceName: string): CameraAnimationSequencePlayer;
	static GetDefaultObject(): CameraAnimationSequencePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnimationSequencePlayer;
	static C(Other: UObject | any): CameraAnimationSequencePlayer;
}

declare class CameraFilmbackSettings { 
	SensorWidth: number;
	SensorHeight: number;
	SensorAspectRatio: number;
	clone() : CameraFilmbackSettings;
	static C(Other: UObject | any): CameraFilmbackSettings;
}

declare class CameraLensSettings { 
	MinFocalLength: number;
	MaxFocalLength: number;
	MinFStop: number;
	MaxFStop: number;
	MinimumFocusDistance: number;
	DiaphragmBladeCount: number;
	clone() : CameraLensSettings;
	static C(Other: UObject | any): CameraLensSettings;
}

declare type ECameraFocusMethod = 'DoNotOverride' | 'Manual' | 'Tracking' | 'Disable' | 'MAX';
declare var ECameraFocusMethod : { DoNotOverride:'DoNotOverride',Manual:'Manual',Tracking:'Tracking',Disable:'Disable',MAX:'MAX', };
declare class CameraTrackingFocusSettings { 
	ActorToTrack: Actor;
	RelativeOffset: Vector;
	bDrawDebugTrackingFocusPoint: boolean;
	clone() : CameraTrackingFocusSettings;
	static C(Other: UObject | any): CameraTrackingFocusSettings;
}

declare class CameraFocusSettings { 
	FocusMethod: ECameraFocusMethod;
	ManualFocusDistance: number;
	TrackingFocusSettings: CameraTrackingFocusSettings;
	bDrawDebugFocusPlane: boolean;
	DebugFocusPlaneColor: Color;
	bSmoothFocusChanges: boolean;
	FocusSmoothingInterpSpeed: number;
	FocusOffset: number;
	clone() : CameraFocusSettings;
	static C(Other: UObject | any): CameraFocusSettings;
}

declare class CameraAnimationSequenceCameraStandIn extends UObject { 
	FieldOfView: number;
	bConstrainAspectRatio: boolean;
	AspectRatio: number;
	PostProcessSettings: PostProcessSettings;
	PostProcessBlendWeight: number;
	Filmback: CameraFilmbackSettings;
	LensSettings: CameraLensSettings;
	FocusSettings: CameraFocusSettings;
	CurrentFocalLength: number;
	CurrentAperture: number;
	CurrentFocusDistance: number;
	static Load(ResourceName: string): CameraAnimationSequenceCameraStandIn;
	static Find(Outer: UObject, ResourceName: string): CameraAnimationSequenceCameraStandIn;
	static GetDefaultObject(): CameraAnimationSequenceCameraStandIn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnimationSequenceCameraStandIn;
	static C(Other: UObject | any): CameraAnimationSequenceCameraStandIn;
}

declare class SequenceCameraShakePattern extends CameraShakePattern { 
	Sequence: CameraAnimationSequence;
	PlayRate: number;
	Scale: number;
	BlendInTime: number;
	BlendOutTime: number;
	RandomSegmentDuration: number;
	bRandomSegment: boolean;
	Player: CameraAnimationSequencePlayer;
	CameraStandIn: CameraAnimationSequenceCameraStandIn;
	static Load(ResourceName: string): SequenceCameraShakePattern;
	static Find(Outer: UObject, ResourceName: string): SequenceCameraShakePattern;
	static GetDefaultObject(): SequenceCameraShakePattern;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceCameraShakePattern;
	static C(Other: UObject | any): SequenceCameraShakePattern;
}

declare type ECameraShakeAttenuation = 'Linear' | 'Quadratic' | 'ECameraShakeAttenuation_MAX';
declare var ECameraShakeAttenuation : { Linear:'Linear',Quadratic:'Quadratic',ECameraShakeAttenuation_MAX:'ECameraShakeAttenuation_MAX', };
declare class CameraShakeSourceComponent extends SceneComponent { 
	Attenuation: ECameraShakeAttenuation;
	InnerAttenuationRadius: number;
	OuterAttenuationRadius: number;
	CameraShake: UnrealEngineClass;
	bAutoStart: boolean;
	EditorSpriteTexture: Texture2D;
	EditorSpriteTextureScale: number;
	static Load(ResourceName: string): CameraShakeSourceComponent;
	static Find(Outer: UObject, ResourceName: string): CameraShakeSourceComponent;
	static GetDefaultObject(): CameraShakeSourceComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraShakeSourceComponent;
	StopAllCameraShakesOfType(InCameraShake: UnrealEngineClass,bImmediately: boolean): void;
	StopAllCameraShakes(bImmediately: boolean): void;
	StartCameraShake(InCameraShake: UnrealEngineClass,Scale: number,PlaySpace: ECameraShakePlaySpace,UserPlaySpaceRot: Rotator): void;
	Start(): void;
	GetAttenuationFactor(Location: Vector): number;
	static C(Other: UObject | any): CameraShakeSourceComponent;
}

declare class MatineeCameraShake extends CameraShakeBase { 
	OscillationDuration: number;
	OscillationBlendInTime: number;
	OscillationBlendOutTime: number;
	RotOscillation: ROscillator;
	LocOscillation: VOscillator;
	FOVOscillation: FOscillator;
	AnimPlayRate: number;
	AnimScale: number;
	AnimBlendInTime: number;
	AnimBlendOutTime: number;
	RandomAnimSegmentDuration: number;
	Anim: CameraAnim;
	AnimSequence: CameraAnimationSequence;
	bRandomAnimSegment: boolean;
	OscillatorTimeRemaining: number;
	AnimInst: CameraAnimInst;
	SequenceShakePattern: SequenceCameraShakePattern;
	static Load(ResourceName: string): MatineeCameraShake;
	static Find(Outer: UObject, ResourceName: string): MatineeCameraShake;
	static GetDefaultObject(): MatineeCameraShake;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeCameraShake;
	static StartMatineeCameraShakeFromSource(PlayerCameraManager: PlayerCameraManager,ShakeClass: UnrealEngineClass,SourceComponent: CameraShakeSourceComponent,Scale: number,PlaySpace: ECameraShakePlaySpace,UserPlaySpaceRot: Rotator): MatineeCameraShake;
	static StartMatineeCameraShake(PlayerCameraManager: PlayerCameraManager,ShakeClass: UnrealEngineClass,Scale: number,PlaySpace: ECameraShakePlaySpace,UserPlaySpaceRot: Rotator): MatineeCameraShake;
	ReceiveStopShake(bImmediately: boolean): void;
	ReceivePlayShake(Scale: number): void;
	ReceiveIsFinished(): boolean;
	BlueprintUpdateCameraShake(DeltaTime: number,Alpha: number,POV: MinimalViewInfo,ModifiedPOV?: MinimalViewInfo): {ModifiedPOV: MinimalViewInfo};
	static C(Other: UObject | any): MatineeCameraShake;
}

declare class CameraShakeBase extends UObject { 
	bSingleInstance: boolean;
	ShakeScale: number;
	RootShakePattern: CameraShakePattern;
	CameraManager: PlayerCameraManager;
	static Load(ResourceName: string): CameraShakeBase;
	static Find(Outer: UObject, ResourceName: string): CameraShakeBase;
	static GetDefaultObject(): CameraShakeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraShakeBase;
	SetRootShakePattern(InPattern: CameraShakePattern): void;
	GetRootShakePattern(): CameraShakePattern;
	static C(Other: UObject | any): CameraShakeBase;
	Conv_MatineeCameraShake(): MatineeCameraShake;
	static Conv_MatineeCameraShake(CameraShake: CameraShakeBase): MatineeCameraShake;
}

declare class ActiveCameraShakeInfo { 
	ShakeInstance: CameraShakeBase;
	ShakeSource: any;
	bIsCustomInitialized: boolean;
	clone() : ActiveCameraShakeInfo;
	static C(Other: UObject | any): ActiveCameraShakeInfo;
}

declare class CameraModifier_CameraShake extends CameraModifier { 
	ActiveShakes: ActiveCameraShakeInfo[];
	ExpiredPooledShakesMap: any;
	SplitScreenShakeScale: number;
	static Load(ResourceName: string): CameraModifier_CameraShake;
	static Find(Outer: UObject, ResourceName: string): CameraModifier_CameraShake;
	static GetDefaultObject(): CameraModifier_CameraShake;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraModifier_CameraShake;
	static C(Other: UObject | any): CameraModifier_CameraShake;
}

declare class ElementID { 
	IDValue: number;
	clone() : ElementID;
	static C(Other: UObject | any): ElementID;
}

declare class VertexID extends ElementID { 
	clone() : VertexID;
	static C(Other: UObject | any): VertexID;
}

declare class PolygonID extends ElementID { 
	clone() : PolygonID;
	static C(Other: UObject | any): PolygonID;
}

declare class VertexInstanceID extends ElementID { 
	clone() : VertexInstanceID;
	static C(Other: UObject | any): VertexInstanceID;
}

declare class PolygonGroupID extends ElementID { 
	clone() : PolygonGroupID;
	static C(Other: UObject | any): PolygonGroupID;
}

declare class TriangleID extends ElementID { 
	clone() : TriangleID;
	static C(Other: UObject | any): TriangleID;
}

declare class EdgeID extends ElementID { 
	clone() : EdgeID;
	static C(Other: UObject | any): EdgeID;
}

declare class MeshDescriptionBase extends UObject { 
	static Load(ResourceName: string): MeshDescriptionBase;
	static Find(Outer: UObject, ResourceName: string): MeshDescriptionBase;
	static GetDefaultObject(): MeshDescriptionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshDescriptionBase;
	SetVertexPosition(VertexID: VertexID,position: Vector): void;
	SetPolygonVertexInstances(PolygonID: PolygonID,VertexInstanceIDs: VertexInstanceID[]): void;
	SetPolygonPolygonGroup(PolygonID: PolygonID,PolygonGroupID: PolygonGroupID): void;
	ReversePolygonFacing(PolygonID: PolygonID): void;
	ReserveNewVertices(NumberOfNewVertices: number): void;
	ReserveNewVertexInstances(NumberOfNewVertexInstances: number): void;
	ReserveNewTriangles(NumberOfNewTriangles: number): void;
	ReserveNewPolygons(NumberOfNewPolygons: number): void;
	ReserveNewPolygonGroups(NumberOfNewPolygonGroups: number): void;
	ReserveNewEdges(NumberOfNewEdges: number): void;
	IsVertexValid(VertexID: VertexID): boolean;
	IsVertexOrphaned(VertexID: VertexID): boolean;
	IsVertexInstanceValid(VertexInstanceID: VertexInstanceID): boolean;
	IsTriangleValid(TriangleID: TriangleID): boolean;
	IsTrianglePartOfNgon(TriangleID: TriangleID): boolean;
	IsPolygonValid(PolygonID: PolygonID): boolean;
	IsPolygonGroupValid(PolygonGroupID: PolygonGroupID): boolean;
	IsEmpty(): boolean;
	IsEdgeValid(EdgeID: EdgeID): boolean;
	IsEdgeInternalToPolygon(EdgeID: EdgeID,PolygonID: PolygonID): boolean;
	IsEdgeInternal(EdgeID: EdgeID): boolean;
	GetVertexVertexInstances(VertexID: VertexID,OutVertexInstanceIDs?: VertexInstanceID[]): {OutVertexInstanceIDs: VertexInstanceID[]};
	GetVertexPosition(VertexID: VertexID): Vector;
	GetVertexPairEdge(VertexID0: VertexID,VertexID1: VertexID): EdgeID;
	GetVertexInstanceVertex(VertexInstanceID: VertexInstanceID): VertexID;
	GetVertexInstancePairEdge(VertexInstanceID0: VertexInstanceID,VertexInstanceID1: VertexInstanceID): EdgeID;
	GetVertexInstanceForTriangleVertex(TriangleID: TriangleID,VertexID: VertexID): VertexInstanceID;
	GetVertexInstanceForPolygonVertex(PolygonID: PolygonID,VertexID: VertexID): VertexInstanceID;
	GetVertexInstanceCount(): number;
	GetVertexInstanceConnectedTriangles(VertexInstanceID: VertexInstanceID,OutConnectedTriangleIDs?: TriangleID[]): {OutConnectedTriangleIDs: TriangleID[]};
	GetVertexInstanceConnectedPolygons(VertexInstanceID: VertexInstanceID,OutConnectedPolygonIDs?: PolygonID[]): {OutConnectedPolygonIDs: PolygonID[]};
	GetVertexCount(): number;
	GetVertexConnectedTriangles(VertexID: VertexID,OutConnectedTriangleIDs?: TriangleID[]): {OutConnectedTriangleIDs: TriangleID[]};
	GetVertexConnectedPolygons(VertexID: VertexID,OutConnectedPolygonIDs?: PolygonID[]): {OutConnectedPolygonIDs: PolygonID[]};
	GetVertexConnectedEdges(VertexID: VertexID,OutEdgeIDs?: EdgeID[]): {OutEdgeIDs: EdgeID[]};
	GetVertexAdjacentVertices(VertexID: VertexID,OutAdjacentVertexIDs?: VertexID[]): {OutAdjacentVertexIDs: VertexID[]};
	GetTriangleVertices(TriangleID: TriangleID,OutVertexIDs?: VertexID[]): {OutVertexIDs: VertexID[]};
	GetTriangleVertexInstances(TriangleID: TriangleID,OutVertexInstanceIDs?: VertexInstanceID[]): {OutVertexInstanceIDs: VertexInstanceID[]};
	GetTriangleVertexInstance(TriangleID: TriangleID,index: number): VertexInstanceID;
	GetTrianglePolygonGroup(TriangleID: TriangleID): PolygonGroupID;
	GetTrianglePolygon(TriangleID: TriangleID): PolygonID;
	GetTriangleEdges(TriangleID: TriangleID,OutEdgeIDs?: EdgeID[]): {OutEdgeIDs: EdgeID[]};
	GetTriangleCount(): number;
	GetTriangleAdjacentTriangles(TriangleID: TriangleID,OutTriangleIDs?: TriangleID[]): {OutTriangleIDs: TriangleID[]};
	GetPolygonVertices(PolygonID: PolygonID,OutVertexIDs?: VertexID[]): {OutVertexIDs: VertexID[]};
	GetPolygonVertexInstances(PolygonID: PolygonID,OutVertexInstanceIDs?: VertexInstanceID[]): {OutVertexInstanceIDs: VertexInstanceID[]};
	GetPolygonTriangles(PolygonID: PolygonID,OutTriangleIDs?: TriangleID[]): {OutTriangleIDs: TriangleID[]};
	GetPolygonPolygonGroup(PolygonID: PolygonID): PolygonGroupID;
	GetPolygonPerimeterEdges(PolygonID: PolygonID,OutEdgeIDs?: EdgeID[]): {OutEdgeIDs: EdgeID[]};
	GetPolygonInternalEdges(PolygonID: PolygonID,OutEdgeIDs?: EdgeID[]): {OutEdgeIDs: EdgeID[]};
	GetPolygonGroupPolygons(PolygonGroupID: PolygonGroupID,OutPolygonIDs?: PolygonID[]): {OutPolygonIDs: PolygonID[]};
	GetPolygonGroupCount(): number;
	GetPolygonCount(): number;
	GetPolygonAdjacentPolygons(PolygonID: PolygonID,OutPolygonIDs?: PolygonID[]): {OutPolygonIDs: PolygonID[]};
	GetNumVertexVertexInstances(VertexID: VertexID): number;
	GetNumVertexInstanceConnectedTriangles(VertexInstanceID: VertexInstanceID): number;
	GetNumVertexInstanceConnectedPolygons(VertexInstanceID: VertexInstanceID): number;
	GetNumVertexConnectedTriangles(VertexID: VertexID): number;
	GetNumVertexConnectedPolygons(VertexID: VertexID): number;
	GetNumVertexConnectedEdges(VertexID: VertexID): number;
	GetNumPolygonVertices(PolygonID: PolygonID): number;
	GetNumPolygonTriangles(PolygonID: PolygonID): number;
	GetNumPolygonInternalEdges(PolygonID: PolygonID): number;
	GetNumPolygonGroupPolygons(PolygonGroupID: PolygonGroupID): number;
	GetNumEdgeConnectedTriangles(EdgeID: EdgeID): number;
	GetNumEdgeConnectedPolygons(EdgeID: EdgeID): number;
	GetEdgeVertices(EdgeID: EdgeID,OutVertexIDs?: VertexID[]): {OutVertexIDs: VertexID[]};
	GetEdgeVertex(EdgeID: EdgeID,VertexNumber: number): VertexID;
	GetEdgeCount(): number;
	GetEdgeConnectedTriangles(EdgeID: EdgeID,OutConnectedTriangleIDs?: TriangleID[]): {OutConnectedTriangleIDs: TriangleID[]};
	GetEdgeConnectedPolygons(EdgeID: EdgeID,OutConnectedPolygonIDs?: PolygonID[]): {OutConnectedPolygonIDs: PolygonID[]};
	Empty(): void;
	DeleteVertexInstance(VertexInstanceID: VertexInstanceID,OrphanedVertices?: VertexID[]): {OrphanedVertices: VertexID[]};
	DeleteVertex(VertexID: VertexID): void;
	DeleteTriangle(TriangleID: TriangleID,OrphanedEdges?: EdgeID[],OrphanedVertexInstances?: VertexInstanceID[],OrphanedPolygonGroupsPtr?: PolygonGroupID[]): {OrphanedEdges: EdgeID[], OrphanedVertexInstances: VertexInstanceID[], OrphanedPolygonGroupsPtr: PolygonGroupID[]};
	DeletePolygonGroup(PolygonGroupID: PolygonGroupID): void;
	DeletePolygon(PolygonID: PolygonID,OrphanedEdges?: EdgeID[],OrphanedVertexInstances?: VertexInstanceID[],OrphanedPolygonGroups?: PolygonGroupID[]): {OrphanedEdges: EdgeID[], OrphanedVertexInstances: VertexInstanceID[], OrphanedPolygonGroups: PolygonGroupID[]};
	DeleteEdge(EdgeID: EdgeID,OrphanedVertices?: VertexID[]): {OrphanedVertices: VertexID[]};
	CreateVertexWithID(VertexID: VertexID): void;
	CreateVertexInstanceWithID(VertexInstanceID: VertexInstanceID,VertexID: VertexID): void;
	CreateVertexInstance(VertexID: VertexID): VertexInstanceID;
	CreateVertex(): VertexID;
	CreateTriangleWithID(TriangleID: TriangleID,PolygonGroupID: PolygonGroupID,VertexInstanceIDs: VertexInstanceID[],NewEdgeIDs?: EdgeID[]): {NewEdgeIDs: EdgeID[]};
	CreateTriangle(PolygonGroupID: PolygonGroupID,VertexInstanceIDs: VertexInstanceID[],NewEdgeIDs?: EdgeID[]): {NewEdgeIDs: EdgeID[], $: TriangleID};
	CreatePolygonWithID(PolygonID: PolygonID,PolygonGroupID: PolygonGroupID,VertexInstanceIDs?: VertexInstanceID[],NewEdgeIDs?: EdgeID[]): {VertexInstanceIDs: VertexInstanceID[], NewEdgeIDs: EdgeID[]};
	CreatePolygonGroupWithID(PolygonGroupID: PolygonGroupID): void;
	CreatePolygonGroup(): PolygonGroupID;
	CreatePolygon(PolygonGroupID: PolygonGroupID,VertexInstanceIDs?: VertexInstanceID[],NewEdgeIDs?: EdgeID[]): {VertexInstanceIDs: VertexInstanceID[], NewEdgeIDs: EdgeID[], $: PolygonID};
	CreateEdgeWithID(EdgeID: EdgeID,VertexID0: VertexID,VertexID1: VertexID): void;
	CreateEdge(VertexID0: VertexID,VertexID1: VertexID): EdgeID;
	ComputePolygonTriangulation(PolygonID: PolygonID): void;
	static C(Other: UObject | any): MeshDescriptionBase;
}

declare class MeshDescriptionBaseBulkData extends UObject { 
	PreallocatedMeshDescription: MeshDescriptionBase;
	MeshDescription: MeshDescriptionBase;
	static Load(ResourceName: string): MeshDescriptionBaseBulkData;
	static Find(Outer: UObject, ResourceName: string): MeshDescriptionBaseBulkData;
	static GetDefaultObject(): MeshDescriptionBaseBulkData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshDescriptionBaseBulkData;
	static C(Other: UObject | any): MeshDescriptionBaseBulkData;
}

declare class StaticMeshDescriptionBulkData extends MeshDescriptionBaseBulkData { 
	static Load(ResourceName: string): StaticMeshDescriptionBulkData;
	static Find(Outer: UObject, ResourceName: string): StaticMeshDescriptionBulkData;
	static GetDefaultObject(): StaticMeshDescriptionBulkData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshDescriptionBulkData;
	static C(Other: UObject | any): StaticMeshDescriptionBulkData;
}

declare class MeshBuildSettings { 
	bUseMikkTSpace: boolean;
	bRecomputeNormals: boolean;
	bRecomputeTangents: boolean;
	bComputeWeightedNormals: boolean;
	bRemoveDegenerates: boolean;
	bBuildReversedIndexBuffer: boolean;
	bUseHighPrecisionTangentBasis: boolean;
	bUseFullPrecisionUVs: boolean;
	bUseBackwardsCompatibleF16TruncUVs: boolean;
	bGenerateLightmapUVs: boolean;
	bGenerateDistanceFieldAsIfTwoSided: boolean;
	bSupportFaceRemap: boolean;
	MinLightmapResolution: number;
	SrcLightmapIndex: number;
	DstLightmapIndex: number;
	BuildScale: number;
	BuildScale3D: Vector;
	DistanceFieldResolutionScale: number;
	DistanceFieldBias: number;
	DistanceFieldReplacementMesh: StaticMesh;
	MaxLumenMeshCards: number;
	clone() : MeshBuildSettings;
	static C(Other: UObject | any): MeshBuildSettings;
}

declare type EMeshFeatureImportance = 'Off' | 'Lowest' | 'Low' | 'Normal' | 'High' | 'Highest' | 'EMeshFeatureImportance_MAX';
declare var EMeshFeatureImportance : { Off:'Off',Lowest:'Lowest',Low:'Low',Normal:'Normal',High:'High',Highest:'Highest',EMeshFeatureImportance_MAX:'EMeshFeatureImportance_MAX', };
declare type EStaticMeshReductionTerimationCriterion = 'Triangles' | 'Vertices' | 'Any' | 'EStaticMeshReductionTerimationCriterion_MAX';
declare var EStaticMeshReductionTerimationCriterion : { Triangles:'Triangles',Vertices:'Vertices',Any:'Any',EStaticMeshReductionTerimationCriterion_MAX:'EStaticMeshReductionTerimationCriterion_MAX', };
declare class MeshReductionSettings { 
	PercentTriangles: number;
	PercentVertices: number;
	MaxDeviation: number;
	PixelError: number;
	WeldingThreshold: number;
	HardAngleThreshold: number;
	BaseLODModel: number;
	SilhouetteImportance: EMeshFeatureImportance;
	TextureImportance: EMeshFeatureImportance;
	ShadingImportance: EMeshFeatureImportance;
	bRecalculateNormals: boolean;
	bGenerateUniqueLightmapUVs: boolean;
	bKeepSymmetry: boolean;
	bVisibilityAided: boolean;
	bCullOccluded: boolean;
	TerminationCriterion: EStaticMeshReductionTerimationCriterion;
	VisibilityAggressiveness: EMeshFeatureImportance;
	VertexColorImportance: EMeshFeatureImportance;
	clone() : MeshReductionSettings;
	static C(Other: UObject | any): MeshReductionSettings;
}

declare class StaticMeshSourceModel { 
	StaticMeshDescriptionBulkData: StaticMeshDescriptionBulkData;
	BuildSettings: MeshBuildSettings;
	ReductionSettings: MeshReductionSettings;
	LODDistance: number;
	ScreenSize: PerPlatformFloat;
	SourceImportFilename: string;
	bImportWithBaseMesh: boolean;
	clone() : StaticMeshSourceModel;
	static C(Other: UObject | any): StaticMeshSourceModel;
}

declare class MeshSectionInfoMap { 
	Map: any;
	clone() : MeshSectionInfoMap;
	static C(Other: UObject | any): MeshSectionInfoMap;
}

declare class MaterialRemapIndex { 
	ImportVersionKey: any;
	MaterialRemap: number[];
	clone() : MaterialRemapIndex;
	static C(Other: UObject | any): MaterialRemapIndex;
}

declare class MeshNaniteSettings { 
	bEnabled: boolean;
	PositionPrecision: number;
	TargetMinimumResidencyInKB: any;
	KeepPercentTriangles: number;
	TrimRelativeError: number;
	FallbackPercentTriangles: number;
	FallbackRelativeError: number;
	clone() : MeshNaniteSettings;
	static C(Other: UObject | any): MeshNaniteSettings;
}

declare class StaticMaterial { 
	MaterialInterface: MaterialInterface;
	MaterialSlotName: string;
	ImportedMaterialSlotName: string;
	UVChannelData: MeshUVChannelInfo;
	clone() : StaticMaterial;
	static C(Other: UObject | any): StaticMaterial;
}

declare class AssetEditorOrbitCameraPosition { 
	bIsSet: boolean;
	CamOrbitPoint: Vector;
	CamOrbitZoom: Vector;
	CamOrbitRotation: Rotator;
	clone() : AssetEditorOrbitCameraPosition;
	static C(Other: UObject | any): AssetEditorOrbitCameraPosition;
}

declare class StaticMeshSocket extends UObject { 
	SocketName: string;
	RelativeLocation: Vector;
	RelativeRotation: Rotator;
	RelativeScale: Vector;
	Tag: string;
	PreviewStaticMesh: StaticMesh;
	bSocketCreatedAtImport: boolean;
	static Load(ResourceName: string): StaticMeshSocket;
	static Find(Outer: UObject, ResourceName: string): StaticMeshSocket;
	static GetDefaultObject(): StaticMeshSocket;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshSocket;
	static C(Other: UObject | any): StaticMeshSocket;
}

declare class NavCollisionBase extends UObject { 
	bIsDynamicObstacle: boolean;
	static Load(ResourceName: string): NavCollisionBase;
	static Find(Outer: UObject, ResourceName: string): NavCollisionBase;
	static GetDefaultObject(): NavCollisionBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavCollisionBase;
	static C(Other: UObject | any): NavCollisionBase;
}

declare class StaticMeshDescription extends MeshDescriptionBase { 
	static Load(ResourceName: string): StaticMeshDescription;
	static Find(Outer: UObject, ResourceName: string): StaticMeshDescription;
	static GetDefaultObject(): StaticMeshDescription;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshDescription;
	SetVertexInstanceUV(VertexInstanceID: VertexInstanceID,UV: Vector2D,UVIndex: number): void;
	SetPolygonGroupMaterialSlotName(PolygonGroupID: PolygonGroupID,SlotName: string): void;
	GetVertexInstanceUV(VertexInstanceID: VertexInstanceID,UVIndex: number): Vector2D;
	CreateCube(Center: Vector,HalfExtents: Vector,PolygonGroup: PolygonGroupID,PolygonID_PlusX?: PolygonID,PolygonID_MinusX?: PolygonID,PolygonID_PlusY?: PolygonID,PolygonID_MinusY?: PolygonID,PolygonID_PlusZ?: PolygonID,PolygonID_MinusZ?: PolygonID): {PolygonID_PlusX: PolygonID, PolygonID_MinusX: PolygonID, PolygonID_PlusY: PolygonID, PolygonID_MinusY: PolygonID, PolygonID_PlusZ: PolygonID, PolygonID_MinusZ: PolygonID};
	static C(Other: UObject | any): StaticMeshDescription;
}

declare class MeshSectionInfo { 
	MaterialIndex: number;
	bEnableCollision: boolean;
	bCastShadow: boolean;
	bVisibleInRayTracing: boolean;
	bForceOpaque: boolean;
	clone() : MeshSectionInfo;
	static C(Other: UObject | any): MeshSectionInfo;
}

declare class JavascriptRawMesh { 
	FaceMaterialIndices: number[];
	FaceSmoothingMasks: any[];
	VertexPositions: Vector[];
	WedgeIndices: any[];
	WedgeTangentX: Vector[];
	WedgeTangentY: Vector[];
	WedgeTangentZ: Vector[];
	WedgeTexCoords_0: Vector2D[];
	WedgeTexCoords_1: Vector2D[];
	WedgeTexCoords_2: Vector2D[];
	WedgeTexCoords_3: Vector2D[];
	WedgeTexCoords_4: Vector2D[];
	WedgeTexCoords_5: Vector2D[];
	WedgeTexCoords_6: Vector2D[];
	WedgeTexCoords_7: Vector2D[];
	WedgeColors: Color[];
	MaterialIndexToImportIndex: number[];
	clone() : JavascriptRawMesh;
	static C(Other: UObject | any): JavascriptRawMesh;
	CompactMaterialIndices(): {RawMesh: JavascriptRawMesh};
	Empty(): {RawMesh: JavascriptRawMesh};
	GetWedgePosition(WedgeIndex: number): Vector;
	IsValid(): boolean;
	IsValidOrFixable(): boolean;
	static CompactMaterialIndices(RawMesh?: JavascriptRawMesh): {RawMesh: JavascriptRawMesh};
	static Empty(RawMesh?: JavascriptRawMesh): {RawMesh: JavascriptRawMesh};
	static GetWedgePosition(RawMesh: JavascriptRawMesh,WedgeIndex: number): Vector;
	static IsValid(RawMesh: JavascriptRawMesh): boolean;
	static IsValidOrFixable(RawMesh: JavascriptRawMesh): boolean;
}

declare class ProcMeshTangent { 
	TangentX: Vector;
	bFlipTangentY: boolean;
	clone() : ProcMeshTangent;
	static C(Other: UObject | any): ProcMeshTangent;
}

declare class DynamicMeshGenerator extends UObject { 
	static Load(ResourceName: string): DynamicMeshGenerator;
	static Find(Outer: UObject, ResourceName: string): DynamicMeshGenerator;
	static GetDefaultObject(): DynamicMeshGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicMeshGenerator;
	static C(Other: UObject | any): DynamicMeshGenerator;
}

declare class GeometryScriptGroupLayer { 
	bDefaultLayer: boolean;
	ExtendedLayerIndex: number;
	clone() : GeometryScriptGroupLayer;
	static C(Other: UObject | any): GeometryScriptGroupLayer;
}

declare type EGeometryScriptDebugMessageType = 'ErrorMessage' | 'WarningMessage' | 'EGeometryScriptDebugMessageType_MAX';
declare var EGeometryScriptDebugMessageType : { ErrorMessage:'ErrorMessage',WarningMessage:'WarningMessage',EGeometryScriptDebugMessageType_MAX:'EGeometryScriptDebugMessageType_MAX', };
declare type EGeometryScriptErrorType = 'NoError' | 'UnknownError' | 'InvalidInputs' | 'OperationFailed' | 'EGeometryScriptErrorType_MAX';
declare var EGeometryScriptErrorType : { NoError:'NoError',UnknownError:'UnknownError',InvalidInputs:'InvalidInputs',OperationFailed:'OperationFailed',EGeometryScriptErrorType_MAX:'EGeometryScriptErrorType_MAX', };
declare class GeometryScriptDebugMessage { 
	MessageType: EGeometryScriptDebugMessageType;
	ErrorType: EGeometryScriptErrorType;
	Message: string;
	clone() : GeometryScriptDebugMessage;
	static C(Other: UObject | any): GeometryScriptDebugMessage;
}

declare class GeometryScriptDebug extends UObject { 
	Messages: GeometryScriptDebugMessage[];
	static Load(ResourceName: string): GeometryScriptDebug;
	static Find(Outer: UObject, ResourceName: string): GeometryScriptDebug;
	static GetDefaultObject(): GeometryScriptDebug;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryScriptDebug;
	static C(Other: UObject | any): GeometryScriptDebug;
}

declare class GeometryScriptCreateNewStaticMeshAssetOptions { 
	bEnableRecomputeNormals: boolean;
	bEnableRecomputeTangents: boolean;
	bEnableNanite: boolean;
	NaniteProxyTrianglePercent: number;
	bEnableCollision: boolean;
	CollisionMode: ECollisionTraceFlag;
	clone() : GeometryScriptCreateNewStaticMeshAssetOptions;
	static C(Other: UObject | any): GeometryScriptCreateNewStaticMeshAssetOptions;
}

declare type EGeometryScriptOutcomePins = 'Failure' | 'Success' | 'EGeometryScriptOutcomePins_MAX';
declare var EGeometryScriptOutcomePins : { Failure:'Failure',Success:'Success',EGeometryScriptOutcomePins_MAX:'EGeometryScriptOutcomePins_MAX', };
declare type EBrushType = 'Brush_Default' | 'Brush_Add' | 'Brush_Subtract' | 'Brush_MAX';
declare var EBrushType : { Brush_Default:'Brush_Default',Brush_Add:'Brush_Add',Brush_Subtract:'Brush_Subtract',Brush_MAX:'Brush_MAX', };
declare class BrushComponent extends PrimitiveComponent { 
	Brush: Model;
	BrushBodySetup: BodySetup;
	PrePivot: Vector;
	static Load(ResourceName: string): BrushComponent;
	static Find(Outer: UObject, ResourceName: string): BrushComponent;
	static GetDefaultObject(): BrushComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushComponent;
	static C(Other: UObject | any): BrushComponent;
}

declare class BuilderPoly { 
	VertexIndices: number[];
	Direction: number;
	ItemName: string;
	PolyFlags: number;
	clone() : BuilderPoly;
	static C(Other: UObject | any): BuilderPoly;
}

declare class BrushBuilder extends UObject { 
	BitmapFilename: string;
	Tooltip: string;
	NotifyBadParams: boolean;
	Vertices: Vector[];
	Polys: BuilderPoly[];
	Layer: string;
	MergeCoplanars: boolean;
	static Load(ResourceName: string): BrushBuilder;
	static Find(Outer: UObject, ResourceName: string): BrushBuilder;
	static GetDefaultObject(): BrushBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBuilder;
	static C(Other: UObject | any): BrushBuilder;
	Build(InWorld: World,InBrush: Brush): boolean;
	static Build(Builder: BrushBuilder,InWorld: World,InBrush: Brush): boolean;
}

declare class GeomSelection { 
	Type: number;
	index: number;
	SelectionIndex: number;
	clone() : GeomSelection;
	static C(Other: UObject | any): GeomSelection;
}

declare class Brush extends Actor { 
	BrushType: EBrushType;
	BrushColor: Color;
	PolyFlags: number;
	bColored: boolean;
	bSolidWhenSelected: boolean;
	bPlaceableFromClassBrowser: boolean;
	bNotForClientOrServer: boolean;
	Brush: Model;
	BrushComponent: BrushComponent;
	BrushBuilder: BrushBuilder;
	bDisplayShadedVolume: boolean;
	ShadedVolumeOpacityValue: number;
	bInManipulation: boolean;
	SavedSelections: GeomSelection[];
	static GetDefaultObject(): Brush;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Brush;
	static C(Other: UObject | any): Brush;
	csgAdd(PolyFlags: number,BrushType: EBrushType): Brush;
	GetSurfaces(Surfaces?: number[]): {Surfaces: number[]};
	static csgAdd(DefaultBrush: Brush,PolyFlags: number,BrushType: EBrushType): Brush;
	static GetSurfaces(Brush: Brush,Surfaces?: number[]): {Surfaces: number[]};
}

declare class Volume extends Brush { 
	static GetDefaultObject(): Volume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Volume;
	static C(Other: UObject | any): Volume;
	CreateBrushForVolumeActor(BrushBuilder: BrushBuilder): void;
	static CreateBrushForVolumeActor(NewActor: Volume,BrushBuilder: BrushBuilder): void;
}

declare class GeometryScriptCreateNewVolumeFromMeshOptions { 
	VolumeType: UnrealEngineClass;
	bAutoSimplify: boolean;
	MaxTriangles: number;
	clone() : GeometryScriptCreateNewVolumeFromMeshOptions;
	static C(Other: UObject | any): GeometryScriptCreateNewVolumeFromMeshOptions;
}

declare type EGeometryScriptGridSizingMethod = 'GridCellSize' | 'GridResolution' | 'EGeometryScriptGridSizingMethod_MAX';
declare var EGeometryScriptGridSizingMethod : { GridCellSize:'GridCellSize',GridResolution:'GridResolution',EGeometryScriptGridSizingMethod_MAX:'EGeometryScriptGridSizingMethod_MAX', };
declare class GeometryScript3DGridParameters { 
	SizeMethod: EGeometryScriptGridSizingMethod;
	GridCellSize: number;
	GridResolution: number;
	clone() : GeometryScript3DGridParameters;
	static C(Other: UObject | any): GeometryScript3DGridParameters;
}

declare type EGeometryScriptMorphologicalOpType = 'Dilate' | 'Contract' | 'Close' | 'Open' | 'EGeometryScriptMorphologicalOpType_MAX';
declare var EGeometryScriptMorphologicalOpType : { Dilate:'Dilate',Contract:'Contract',Close:'Close',Open:'Open',EGeometryScriptMorphologicalOpType_MAX:'EGeometryScriptMorphologicalOpType_MAX', };
declare class GeometryScriptMorphologyOptions { 
	SDFGridParameters: GeometryScript3DGridParameters;
	bUseSeparateMeshGrid: boolean;
	MeshGridParameters: GeometryScript3DGridParameters;
	Operation: EGeometryScriptMorphologicalOpType;
	Distance: number;
	clone() : GeometryScriptMorphologyOptions;
	static C(Other: UObject | any): GeometryScriptMorphologyOptions;
}

declare class GeometryScriptSolidifyOptions { 
	GridParameters: GeometryScript3DGridParameters;
	WindingThreshold: number;
	bSolidAtBoundaries: boolean;
	ExtendBounds: number;
	SurfaceSearchSteps: number;
	clone() : GeometryScriptSolidifyOptions;
	static C(Other: UObject | any): GeometryScriptSolidifyOptions;
}

declare class GeometryScriptColorFlags { 
	bRed: boolean;
	bGreen: boolean;
	bBlue: boolean;
	bAlpha: boolean;
	clone() : GeometryScriptColorFlags;
	static C(Other: UObject | any): GeometryScriptColorFlags;
}

declare class GeometryScriptColorList { 
	clone() : GeometryScriptColorList;
	static C(Other: UObject | any): GeometryScriptColorList;
	ConvertColorListToArray(ColorArray?: LinearColor[]): {ColorArray: LinearColor[]};
	GetColorListItem(index: number,bIsValidIndex?: boolean): {bIsValidIndex: boolean, $: LinearColor};
	GetColorListLastIndex(): number;
	GetColorListLength(): number;
	static ConvertColorListToArray(ColorList: GeometryScriptColorList,ColorArray?: LinearColor[]): {ColorArray: LinearColor[]};
	static GetColorListItem(ColorList: GeometryScriptColorList,index: number,bIsValidIndex?: boolean): {bIsValidIndex: boolean, $: LinearColor};
	static GetColorListLastIndex(ColorList: GeometryScriptColorList): number;
	static GetColorListLength(ColorList: GeometryScriptColorList): number;
}

declare class GeometryScriptExpMapUVOptions { 
	NormalSmoothingRounds: number;
	NormalSmoothingAlpha: number;
	clone() : GeometryScriptExpMapUVOptions;
	static C(Other: UObject | any): GeometryScriptExpMapUVOptions;
}

declare class GeometryScriptRepackUVsOptions { 
	TargetImageWidth: number;
	bOptimizeIslandRotation: boolean;
	clone() : GeometryScriptRepackUVsOptions;
	static C(Other: UObject | any): GeometryScriptRepackUVsOptions;
}

declare class GeometryScriptPatchBuilderOptions { 
	InitialPatchCount: number;
	MinPatchSize: number;
	PatchCurvatureAlignmentWeight: number;
	PatchMergingMetricThresh: number;
	PatchMergingAngleThresh: number;
	ExpMapOptions: GeometryScriptExpMapUVOptions;
	bRespectInputGroups: boolean;
	GroupLayer: GeometryScriptGroupLayer;
	bAutoPack: boolean;
	PackingOptions: GeometryScriptRepackUVsOptions;
	clone() : GeometryScriptPatchBuilderOptions;
	static C(Other: UObject | any): GeometryScriptPatchBuilderOptions;
}

declare class GeometryScriptXAtlasOptions { 
	MaxIterations: number;
	clone() : GeometryScriptXAtlasOptions;
	static C(Other: UObject | any): GeometryScriptXAtlasOptions;
}

declare type EGeometryScriptUVFlattenMethod = 'ExpMap' | 'Conformal' | 'EGeometryScriptUVFlattenMethod_MAX';
declare var EGeometryScriptUVFlattenMethod : { ExpMap:'ExpMap',Conformal:'Conformal',EGeometryScriptUVFlattenMethod_MAX:'EGeometryScriptUVFlattenMethod_MAX', };
declare type EGeometryScriptUVIslandSource = 'PolyGroups' | 'UVIslands' | 'EGeometryScriptUVIslandSource_MAX';
declare var EGeometryScriptUVIslandSource : { PolyGroups:'PolyGroups',UVIslands:'UVIslands',EGeometryScriptUVIslandSource_MAX:'EGeometryScriptUVIslandSource_MAX', };
declare class GeometryScriptRecomputeUVsOptions { 
	Method: EGeometryScriptUVFlattenMethod;
	IslandSource: EGeometryScriptUVIslandSource;
	ExpMapOptions: GeometryScriptExpMapUVOptions;
	GroupLayer: GeometryScriptGroupLayer;
	bAutoAlignIslandsWithAxes: boolean;
	clone() : GeometryScriptRecomputeUVsOptions;
	static C(Other: UObject | any): GeometryScriptRecomputeUVsOptions;
}

declare class GeometryScriptUVTriangle { 
	UV0: Vector2D;
	UV1: Vector2D;
	UV2: Vector2D;
	clone() : GeometryScriptUVTriangle;
	static C(Other: UObject | any): GeometryScriptUVTriangle;
}

declare class GeometryScriptPNTessellateOptions { 
	bRecomputeNormals: boolean;
	clone() : GeometryScriptPNTessellateOptions;
	static C(Other: UObject | any): GeometryScriptPNTessellateOptions;
}

declare class GeometryScriptDynamicMeshBVH { 
	clone() : GeometryScriptDynamicMeshBVH;
	static C(Other: UObject | any): GeometryScriptDynamicMeshBVH;
	ResetBVH(): {ResetBVH: GeometryScriptDynamicMeshBVH};
	static ResetBVH(ResetBVH?: GeometryScriptDynamicMeshBVH): {ResetBVH: GeometryScriptDynamicMeshBVH};
}

declare class GeometryScriptSpatialQueryOptions { 
	MaxDistance: number;
	bAllowUnsafeModifiedQueries: boolean;
	WindingIsoThreshold: number;
	clone() : GeometryScriptSpatialQueryOptions;
	static C(Other: UObject | any): GeometryScriptSpatialQueryOptions;
}

declare class GeometryScriptTrianglePoint { 
	bValid: boolean;
	TriangleID: number;
	position: Vector;
	BaryCoords: Vector;
	clone() : GeometryScriptTrianglePoint;
	static C(Other: UObject | any): GeometryScriptTrianglePoint;
}

declare type EGeometryScriptSearchOutcomePins = 'Found' | 'NotFound' | 'EGeometryScriptSearchOutcomePins_MAX';
declare var EGeometryScriptSearchOutcomePins : { Found:'Found',NotFound:'NotFound',EGeometryScriptSearchOutcomePins_MAX:'EGeometryScriptSearchOutcomePins_MAX', };
declare class GeometryScriptRayHitResult { 
	bHit: boolean;
	RayParameter: number;
	HitTriangleID: number;
	HitPosition: Vector;
	HitBaryCoords: Vector;
	clone() : GeometryScriptRayHitResult;
	static C(Other: UObject | any): GeometryScriptRayHitResult;
}

declare type EGeometryScriptContainmentOutcomePins = 'Inside' | 'Outside' | 'EGeometryScriptContainmentOutcomePins_MAX';
declare var EGeometryScriptContainmentOutcomePins : { Inside:'Inside',Outside:'Outside',EGeometryScriptContainmentOutcomePins_MAX:'EGeometryScriptContainmentOutcomePins_MAX', };
declare class GeometryScriptPlanarSimplifyOptions { 
	AngleThreshold: number;
	clone() : GeometryScriptPlanarSimplifyOptions;
	static C(Other: UObject | any): GeometryScriptPlanarSimplifyOptions;
}

declare class GeometryScriptPolygroupSimplifyOptions { 
	AngleThreshold: number;
	clone() : GeometryScriptPolygroupSimplifyOptions;
	static C(Other: UObject | any): GeometryScriptPolygroupSimplifyOptions;
}

declare type EGeometryScriptRemoveMeshSimplificationType = 'StandardQEM' | 'VolumePreserving' | 'AttributeAware' | 'EGeometryScriptRemoveMeshSimplificationType_MAX';
declare var EGeometryScriptRemoveMeshSimplificationType : { StandardQEM:'StandardQEM',VolumePreserving:'VolumePreserving',AttributeAware:'AttributeAware',EGeometryScriptRemoveMeshSimplificationType_MAX:'EGeometryScriptRemoveMeshSimplificationType_MAX', };
declare class GeometryScriptSimplifyMeshOptions { 
	Method: EGeometryScriptRemoveMeshSimplificationType;
	bAllowSeamCollapse: boolean;
	bAllowSeamSmoothing: boolean;
	bAllowSeamSplits: boolean;
	bPreserveVertexPositions: boolean;
	bRetainQuadricMemory: boolean;
	clone() : GeometryScriptSimplifyMeshOptions;
	static C(Other: UObject | any): GeometryScriptSimplifyMeshOptions;
}

declare type EGeometryScriptFillHolesMethod = 'Automatic' | 'MinimalFill' | 'PolygonTriangulation' | 'TriangleFan' | 'PlanarProjection' | 'EGeometryScriptFillHolesMethod_MAX';
declare var EGeometryScriptFillHolesMethod : { Automatic:'Automatic',MinimalFill:'MinimalFill',PolygonTriangulation:'PolygonTriangulation',TriangleFan:'TriangleFan',PlanarProjection:'PlanarProjection',EGeometryScriptFillHolesMethod_MAX:'EGeometryScriptFillHolesMethod_MAX', };
declare class GeometryScriptFillHolesOptions { 
	FillMethod: EGeometryScriptFillHolesMethod;
	clone() : GeometryScriptFillHolesOptions;
	static C(Other: UObject | any): GeometryScriptFillHolesOptions;
}

declare type EGeometryScriptRemoveHiddenTrianglesMethod = 'FastWindingNumber' | 'RaycastOcclusionTest' | 'EGeometryScriptRemoveHiddenTrianglesMethod_MAX';
declare var EGeometryScriptRemoveHiddenTrianglesMethod : { FastWindingNumber:'FastWindingNumber',RaycastOcclusionTest:'RaycastOcclusionTest',EGeometryScriptRemoveHiddenTrianglesMethod_MAX:'EGeometryScriptRemoveHiddenTrianglesMethod_MAX', };
declare class GeometryScriptRemoveHiddenTrianglesOptions { 
	Method: EGeometryScriptRemoveHiddenTrianglesMethod;
	SamplesPerTriangle: number;
	ShrinkSelection: number;
	WindingIsoValue: number;
	RaysPerSample: number;
	NormalOffset: number;
	bCompactResult: boolean;
	clone() : GeometryScriptRemoveHiddenTrianglesOptions;
	static C(Other: UObject | any): GeometryScriptRemoveHiddenTrianglesOptions;
}

declare class GeometryScriptRemoveSmallComponentOptions { 
	MinVolume: number;
	MinArea: number;
	MinTriangleCount: number;
	clone() : GeometryScriptRemoveSmallComponentOptions;
	static C(Other: UObject | any): GeometryScriptRemoveSmallComponentOptions;
}

declare class GeometryScriptWeldEdgesOptions { 
	Tolerance: number;
	bOnlyUniquePairs: boolean;
	clone() : GeometryScriptWeldEdgesOptions;
	static C(Other: UObject | any): GeometryScriptWeldEdgesOptions;
}

declare type EGeometryScriptIndexType = 'Any' | 'Triangle' | 'Vertex' | 'MaterialID' | 'PolygroupID' | 'EGeometryScriptIndexType_MAX';
declare var EGeometryScriptIndexType : { Any:'Any',Triangle:'Triangle',Vertex:'Vertex',MaterialID:'MaterialID',PolygroupID:'PolygroupID',EGeometryScriptIndexType_MAX:'EGeometryScriptIndexType_MAX', };
declare class GeometryScriptIndexList { 
	IndexType: EGeometryScriptIndexType;
	clone() : GeometryScriptIndexList;
	static C(Other: UObject | any): GeometryScriptIndexList;
	ConvertIndexListToArray(IndexArray?: number[]): {IndexArray: number[]};
	GetIndexListItem(index: number,bIsValidIndex?: boolean): {bIsValidIndex: boolean, $: number};
	GetIndexListLastIndex(): number;
	GetIndexListLength(): number;
	static ConvertIndexListToArray(IndexList: GeometryScriptIndexList,IndexArray?: number[]): {IndexArray: number[]};
	static GetIndexListItem(IndexList: GeometryScriptIndexList,index: number,bIsValidIndex?: boolean): {bIsValidIndex: boolean, $: number};
	static GetIndexListLastIndex(IndexList: GeometryScriptIndexList): number;
	static GetIndexListLength(IndexList: GeometryScriptIndexList): number;
}

declare class GeometryScriptTriangleList { 
	clone() : GeometryScriptTriangleList;
	static C(Other: UObject | any): GeometryScriptTriangleList;
	ConvertTriangleListToArray(TriangleArray?: IntVector[]): {TriangleArray: IntVector[]};
	GetTriangleListItem(Triangle: number,bIsValidTriangle?: boolean): {bIsValidTriangle: boolean, $: IntVector};
	GetTriangleListLastTriangle(): number;
	GetTriangleListLength(): number;
	static ConvertTriangleListToArray(TriangleList: GeometryScriptTriangleList,TriangleArray?: IntVector[]): {TriangleArray: IntVector[]};
	static GetTriangleListItem(TriangleList: GeometryScriptTriangleList,Triangle: number,bIsValidTriangle?: boolean): {bIsValidTriangle: boolean, $: IntVector};
	static GetTriangleListLastTriangle(TriangleList: GeometryScriptTriangleList): number;
	static GetTriangleListLength(TriangleList: GeometryScriptTriangleList): number;
}

declare class GeometryScriptVectorList { 
	clone() : GeometryScriptVectorList;
	static C(Other: UObject | any): GeometryScriptVectorList;
	ConvertVectorListToArray(VectorArray?: Vector[]): {VectorArray: Vector[]};
	GetVectorListItem(index: number,bIsValidIndex?: boolean): {bIsValidIndex: boolean, $: Vector};
	GetVectorListLastIndex(): number;
	GetVectorListLength(): number;
	static ConvertVectorListToArray(VectorList: GeometryScriptVectorList,VectorArray?: Vector[]): {VectorArray: Vector[]};
	static GetVectorListItem(VectorList: GeometryScriptVectorList,index: number,bIsValidIndex?: boolean): {bIsValidIndex: boolean, $: Vector};
	static GetVectorListLastIndex(VectorList: GeometryScriptVectorList): number;
	static GetVectorListLength(VectorList: GeometryScriptVectorList): number;
}

declare type EGeometryScriptPrimitivePolygroupMode = 'SingleGroup' | 'PerFace' | 'PerQuad' | 'EGeometryScriptPrimitivePolygroupMode_MAX';
declare var EGeometryScriptPrimitivePolygroupMode : { SingleGroup:'SingleGroup',PerFace:'PerFace',PerQuad:'PerQuad',EGeometryScriptPrimitivePolygroupMode_MAX:'EGeometryScriptPrimitivePolygroupMode_MAX', };
declare type EGeometryScriptPrimitiveUVMode = 'Uniform' | 'ScaleToFill' | 'EGeometryScriptPrimitiveUVMode_MAX';
declare var EGeometryScriptPrimitiveUVMode : { Uniform:'Uniform',ScaleToFill:'ScaleToFill',EGeometryScriptPrimitiveUVMode_MAX:'EGeometryScriptPrimitiveUVMode_MAX', };
declare class GeometryScriptPrimitiveOptions { 
	PolygroupMode: EGeometryScriptPrimitivePolygroupMode;
	bFlipOrientation: boolean;
	UVMode: EGeometryScriptPrimitiveUVMode;
	clone() : GeometryScriptPrimitiveOptions;
	static C(Other: UObject | any): GeometryScriptPrimitiveOptions;
}

declare type EGeometryScriptPrimitiveOriginMode = 'Center' | 'Base' | 'EGeometryScriptPrimitiveOriginMode_MAX';
declare var EGeometryScriptPrimitiveOriginMode : { Center:'Center',Base:'Base',EGeometryScriptPrimitiveOriginMode_MAX:'EGeometryScriptPrimitiveOriginMode_MAX', };
declare class GeometryScriptRevolveOptions { 
	RevolveDegrees: number;
	DegreeOffset: number;
	bReverseDirection: boolean;
	bHardNormals: boolean;
	HardNormalAngle: number;
	bProfileAtMidpoint: boolean;
	bFillPartialRevolveEndcaps: boolean;
	clone() : GeometryScriptRevolveOptions;
	static C(Other: UObject | any): GeometryScriptRevolveOptions;
}

declare class GeometryScriptSplitNormalsOptions { 
	bSplitByOpeningAngle: boolean;
	OpeningAngleDeg: number;
	bSplitByFaceGroup: boolean;
	GroupLayer: GeometryScriptGroupLayer;
	clone() : GeometryScriptSplitNormalsOptions;
	static C(Other: UObject | any): GeometryScriptSplitNormalsOptions;
}

declare class GeometryScriptCalculateNormalsOptions { 
	bAngleWeighted: boolean;
	bAreaWeighted: boolean;
	clone() : GeometryScriptCalculateNormalsOptions;
	static C(Other: UObject | any): GeometryScriptCalculateNormalsOptions;
}

declare type EGeometryScriptTangentTypes = 'FastMikkT' | 'PerTriangle' | 'EGeometryScriptTangentTypes_MAX';
declare var EGeometryScriptTangentTypes : { FastMikkT:'FastMikkT',PerTriangle:'PerTriangle',EGeometryScriptTangentTypes_MAX:'EGeometryScriptTangentTypes_MAX', };
declare class GeometryScriptTangentsOptions { 
	Type: EGeometryScriptTangentTypes;
	UVLayer: number;
	clone() : GeometryScriptTangentsOptions;
	static C(Other: UObject | any): GeometryScriptTangentsOptions;
}

declare class GeometryScriptTriangle { 
	Vector0: Vector;
	Vector1: Vector;
	Vector2: Vector;
	clone() : GeometryScriptTriangle;
	static C(Other: UObject | any): GeometryScriptTriangle;
}

declare class GeometryScriptMeshExtrudeOptions { 
	ExtrudeDistance: number;
	ExtrudeDirection: Vector;
	UVScale: number;
	bSolidsToShells: boolean;
	clone() : GeometryScriptMeshExtrudeOptions;
	static C(Other: UObject | any): GeometryScriptMeshExtrudeOptions;
}

declare class GeometryScriptMeshOffsetOptions { 
	OffsetDistance: number;
	bFixedBoundary: boolean;
	SolveSteps: number;
	SmoothAlpha: number;
	bReprojectDuringSmoothing: boolean;
	BoundaryAlpha: number;
	clone() : GeometryScriptMeshOffsetOptions;
	static C(Other: UObject | any): GeometryScriptMeshOffsetOptions;
}

declare class GeometryScriptMeshBevelOptions { 
	BevelDistance: number;
	bInferMaterialID: boolean;
	SetMaterialID: number;
	bApplyFilterBox: boolean;
	FilterBox: Box;
	FilterBoxTransform: Transform;
	bFullyContained: boolean;
	clone() : GeometryScriptMeshBevelOptions;
	static C(Other: UObject | any): GeometryScriptMeshBevelOptions;
}

declare class GeometryScriptBendWarpOptions { 
	bSymmetricExtents: boolean;
	LowerExtent: number;
	bBidirectional: boolean;
	clone() : GeometryScriptBendWarpOptions;
	static C(Other: UObject | any): GeometryScriptBendWarpOptions;
}

declare class GeometryScriptDisplaceFromTextureOptions { 
	Magnitude: number;
	UVScale: Vector2D;
	UVOffset: Vector2D;
	Center: number;
	ImageChannel: number;
	clone() : GeometryScriptDisplaceFromTextureOptions;
	static C(Other: UObject | any): GeometryScriptDisplaceFromTextureOptions;
}

declare type EGeometryScriptFlareType = 'SinMode' | 'SinSquaredMode' | 'TriangleMode' | 'EGeometryScriptFlareType_MAX';
declare var EGeometryScriptFlareType : { SinMode:'SinMode',SinSquaredMode:'SinSquaredMode',TriangleMode:'TriangleMode',EGeometryScriptFlareType_MAX:'EGeometryScriptFlareType_MAX', };
declare class GeometryScriptFlareWarpOptions { 
	bSymmetricExtents: boolean;
	LowerExtent: number;
	FlareType: EGeometryScriptFlareType;
	clone() : GeometryScriptFlareWarpOptions;
	static C(Other: UObject | any): GeometryScriptFlareWarpOptions;
}

declare class GeometryScriptIterativeMeshSmoothingOptions { 
	NumIterations: number;
	Alpha: number;
	clone() : GeometryScriptIterativeMeshSmoothingOptions;
	static C(Other: UObject | any): GeometryScriptIterativeMeshSmoothingOptions;
}

declare type EGeometryScriptMathWarpType = 'SinWave1D' | 'SinWave2D' | 'SinWave3D' | 'EGeometryScriptMathWarpType_MAX';
declare var EGeometryScriptMathWarpType : { SinWave1D:'SinWave1D',SinWave2D:'SinWave2D',SinWave3D:'SinWave3D',EGeometryScriptMathWarpType_MAX:'EGeometryScriptMathWarpType_MAX', };
declare class GeometryScriptMathWarpOptions { 
	Magnitude: number;
	Frequency: number;
	FrequencyShift: number;
	clone() : GeometryScriptMathWarpOptions;
	static C(Other: UObject | any): GeometryScriptMathWarpOptions;
}

declare class GeometryScriptPerlinNoiseLayerOptions { 
	Magnitude: number;
	Frequency: number;
	FrequencyShift: Vector;
	RandomSeed: number;
	clone() : GeometryScriptPerlinNoiseLayerOptions;
	static C(Other: UObject | any): GeometryScriptPerlinNoiseLayerOptions;
}

declare class GeometryScriptPerlinNoiseOptions { 
	BaseLayer: GeometryScriptPerlinNoiseLayerOptions;
	bApplyAlongNormal: boolean;
	clone() : GeometryScriptPerlinNoiseOptions;
	static C(Other: UObject | any): GeometryScriptPerlinNoiseOptions;
}

declare class GeometryScriptTwistWarpOptions { 
	bSymmetricExtents: boolean;
	LowerExtent: number;
	bBidirectional: boolean;
	clone() : GeometryScriptTwistWarpOptions;
	static C(Other: UObject | any): GeometryScriptTwistWarpOptions;
}

declare class DynamicMeshPool extends UObject { 
	CachedMeshes: DynamicMesh[];
	AllCreatedMeshes: DynamicMesh[];
	static Load(ResourceName: string): DynamicMeshPool;
	static Find(Outer: UObject, ResourceName: string): DynamicMeshPool;
	static GetDefaultObject(): DynamicMeshPool;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicMeshPool;
	ReturnMesh(Mesh: DynamicMesh): void;
	ReturnAllMeshes(): void;
	RequestMesh(): DynamicMesh;
	FreeAllMeshes(): void;
	static C(Other: UObject | any): DynamicMeshPool;
}

declare class GeometryScriptIsSameMeshOptions { 
	bCheckConnectivity: boolean;
	bCheckEdgeIDs: boolean;
	bCheckNormals: boolean;
	bCheckColors: boolean;
	bCheckUVs: boolean;
	bCheckGroups: boolean;
	bCheckAttributes: boolean;
	Epsilon: number;
	clone() : GeometryScriptIsSameMeshOptions;
	static C(Other: UObject | any): GeometryScriptIsSameMeshOptions;
}

declare class GeometryScriptMeasureMeshDistanceOptions { 
	bSymmetric: boolean;
	clone() : GeometryScriptMeasureMeshDistanceOptions;
	static C(Other: UObject | any): GeometryScriptMeasureMeshDistanceOptions;
}

declare type EGeometryScriptBooleanOperation = 'Union' | 'Intersection' | 'Subtract' | 'EGeometryScriptBooleanOperation_MAX';
declare var EGeometryScriptBooleanOperation : { Union:'Union',Intersection:'Intersection',Subtract:'Subtract',EGeometryScriptBooleanOperation_MAX:'EGeometryScriptBooleanOperation_MAX', };
declare class GeometryScriptMeshBooleanOptions { 
	bFillHoles: boolean;
	bSimplifyOutput: boolean;
	SimplifyPlanarTolerance: number;
	clone() : GeometryScriptMeshBooleanOptions;
	static C(Other: UObject | any): GeometryScriptMeshBooleanOptions;
}

declare class GeometryScriptMeshMirrorOptions { 
	bApplyPlaneCut: boolean;
	bFlipCutSide: boolean;
	bWeldAlongPlane: boolean;
	clone() : GeometryScriptMeshMirrorOptions;
	static C(Other: UObject | any): GeometryScriptMeshMirrorOptions;
}

declare class GeometryScriptMeshPlaneCutOptions { 
	bFillHoles: boolean;
	bFillSpans: boolean;
	bFlipCutSide: boolean;
	UVWorldDimension: number;
	clone() : GeometryScriptMeshPlaneCutOptions;
	static C(Other: UObject | any): GeometryScriptMeshPlaneCutOptions;
}

declare class GeometryScriptMeshPlaneSliceOptions { 
	bFillHoles: boolean;
	bFillSpans: boolean;
	GapWidth: number;
	UVWorldDimension: number;
	clone() : GeometryScriptMeshPlaneSliceOptions;
	static C(Other: UObject | any): GeometryScriptMeshPlaneSliceOptions;
}

declare class GeometryScriptMeshSelfUnionOptions { 
	bFillHoles: boolean;
	bTrimFlaps: boolean;
	bSimplifyOutput: boolean;
	SimplifyPlanarTolerance: number;
	WindingThreshold: number;
	clone() : GeometryScriptMeshSelfUnionOptions;
	static C(Other: UObject | any): GeometryScriptMeshSelfUnionOptions;
}

declare class GeometryScriptSimpleMeshBuffers { 
	Vertices: Vector[];
	Normals: Vector[];
	UV0: Vector2D[];
	UV1: Vector2D[];
	UV2: Vector2D[];
	UV3: Vector2D[];
	UV4: Vector2D[];
	UV5: Vector2D[];
	UV6: Vector2D[];
	UV7: Vector2D[];
	VertexColors: LinearColor[];
	Triangles: IntVector[];
	TriGroupIDs: number[];
	clone() : GeometryScriptSimpleMeshBuffers;
	static C(Other: UObject | any): GeometryScriptSimpleMeshBuffers;
}

declare class GeometryScriptNaniteOptions { 
	bEnabled: boolean;
	FallbackPercentTriangles: number;
	FallbackRelativeError: number;
	clone() : GeometryScriptNaniteOptions;
	static C(Other: UObject | any): GeometryScriptNaniteOptions;
}

declare class GeometryScriptCopyMeshToAssetOptions { 
	bEnableRecomputeNormals: boolean;
	bEnableRecomputeTangents: boolean;
	bEnableRemoveDegenerates: boolean;
	bReplaceMaterials: boolean;
	NewMaterials: MaterialInterface[];
	NewMaterialSlotNames: string[];
	bApplyNaniteSettings: boolean;
	NaniteSettings: GeometryScriptNaniteOptions;
	bEmitTransaction: boolean;
	bDeferMeshPostEditChange: boolean;
	clone() : GeometryScriptCopyMeshToAssetOptions;
	static C(Other: UObject | any): GeometryScriptCopyMeshToAssetOptions;
}

declare class GeometryScriptMeshWriteLOD { 
	bWriteHiResSource: boolean;
	LODIndex: number;
	clone() : GeometryScriptMeshWriteLOD;
	static C(Other: UObject | any): GeometryScriptMeshWriteLOD;
}

declare class GeometryScriptConvexHullOptions { 
	bPrefilterVertices: boolean;
	PrefilterGridResolution: number;
	SimplifyToFaceCount: number;
	clone() : GeometryScriptConvexHullOptions;
	static C(Other: UObject | any): GeometryScriptConvexHullOptions;
}

declare class GeometryScriptSweptHullOptions { 
	bPrefilterVertices: boolean;
	PrefilterGridResolution: number;
	MinThickness: number;
	bSimplify: boolean;
	MinEdgeLength: number;
	SimplifyTolerance: number;
	clone() : GeometryScriptSweptHullOptions;
	static C(Other: UObject | any): GeometryScriptSweptHullOptions;
}

declare class BaseDynamicMeshComponent extends MeshComponent { 
	bExplicitShowWireframe: boolean;
	bEnableViewModeOverrides: boolean;
	OverrideRenderMaterial: MaterialInterface;
	SecondaryRenderMaterial: MaterialInterface;
	bEnableRayTracing: boolean;
	BaseMaterials: MaterialInterface[];
	static Load(ResourceName: string): BaseDynamicMeshComponent;
	static Find(Outer: UObject, ResourceName: string): BaseDynamicMeshComponent;
	static GetDefaultObject(): BaseDynamicMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BaseDynamicMeshComponent;
	SetViewModeOverridesEnabled(bEnabled: boolean): void;
	SetShadowsEnabled(bEnabled: boolean): void;
	SetSecondaryRenderMaterial(Material: MaterialInterface): void;
	SetSecondaryBuffersVisibility(bSetVisible: boolean): void;
	SetOverrideRenderMaterial(Material: MaterialInterface): void;
	SetEnableWireframeRenderPass(bEnable: boolean): void;
	SetEnableRaytracing(bSetEnabled: boolean): void;
	HasOverrideRenderMaterial(K: number): boolean;
	GetViewModeOverridesEnabled(): boolean;
	GetShadowsEnabled(): boolean;
	GetSecondaryRenderMaterial(): MaterialInterface;
	GetSecondaryBuffersVisibility(): boolean;
	GetOverrideRenderMaterial(MaterialIndex: number): MaterialInterface;
	GetEnableWireframeRenderPass(): boolean;
	GetEnableRaytracing(): boolean;
	GetDynamicMesh(): DynamicMesh;
	ClearSecondaryRenderMaterial(): void;
	ClearOverrideRenderMaterial(): void;
	static C(Other: UObject | any): BaseDynamicMeshComponent;
}

declare type EDynamicMeshComponentTangentsMode = 'NoTangents' | 'AutoCalculated' | 'ExternallyProvided' | 'EDynamicMeshComponentTangentsMode_MAX';
declare var EDynamicMeshComponentTangentsMode : { NoTangents:'NoTangents',AutoCalculated:'AutoCalculated',ExternallyProvided:'ExternallyProvided',EDynamicMeshComponentTangentsMode_MAX:'EDynamicMeshComponentTangentsMode_MAX', };
declare class DynamicMeshComponent extends BaseDynamicMeshComponent { 
	MeshObject: DynamicMesh;
	TangentsType: EDynamicMeshComponentTangentsMode;
	CollisionType: ECollisionTraceFlag;
	bEnableComplexCollision: boolean;
	bDeferCollisionUpdates: boolean;
	MeshBodySetup: BodySetup;
	static Load(ResourceName: string): DynamicMeshComponent;
	static Find(Outer: UObject, ResourceName: string): DynamicMeshComponent;
	static GetDefaultObject(): DynamicMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicMeshComponent;
	ValidateMaterialSlots(bCreateIfMissing: boolean,bDeleteExtraSlots: boolean): boolean;
	UpdateCollision(bOnlyIfPending: boolean): void;
	SetTangentsType(NewTangentsType: EDynamicMeshComponentTangentsMode): void;
	SetDynamicMesh(NewMesh: DynamicMesh): void;
	SetDeferredCollisionUpdatesEnabled(bEnabled: boolean,bImmediateUpdate: boolean): void;
	SetComplexAsSimpleCollisionEnabled(bEnabled: boolean,bImmediateUpdate: boolean): void;
	GetTangentsType(): EDynamicMeshComponentTangentsMode;
	EnableComplexAsSimpleCollision(): void;
	ConfigureMaterialSet(NewMaterialSet: MaterialInterface[]): void;
	static C(Other: UObject | any): DynamicMeshComponent;
	ResetDynamicMeshCollision(bEmitTransaction: boolean,Debug: GeometryScriptDebug): void;
	static ResetDynamicMeshCollision(Component: DynamicMeshComponent,bEmitTransaction: boolean,Debug: GeometryScriptDebug): void;
}

declare type EGeometryScriptCollisionGenerationMethod = 'AlignedBoxes' | 'OrientedBoxes' | 'MinimalSpheres' | 'Capsules' | 'ConvexHulls' | 'SweptHulls' | 'MinVolumeShapes' | 'EGeometryScriptCollisionGenerationMethod_MAX';
declare var EGeometryScriptCollisionGenerationMethod : { AlignedBoxes:'AlignedBoxes',OrientedBoxes:'OrientedBoxes',MinimalSpheres:'MinimalSpheres',Capsules:'Capsules',ConvexHulls:'ConvexHulls',SweptHulls:'SweptHulls',MinVolumeShapes:'MinVolumeShapes',EGeometryScriptCollisionGenerationMethod_MAX:'EGeometryScriptCollisionGenerationMethod_MAX', };
declare type EGeometryScriptSweptHullAxis = 'X' | 'Y' | 'Z' | 'SmallestBoxDimension' | 'SmallestVolume' | 'EGeometryScriptSweptHullAxis_MAX';
declare var EGeometryScriptSweptHullAxis : { X:'X',Y:'Y',Z:'Z',SmallestBoxDimension:'SmallestBoxDimension',SmallestVolume:'SmallestVolume',EGeometryScriptSweptHullAxis_MAX:'EGeometryScriptSweptHullAxis_MAX', };
declare class GeometryScriptCollisionFromMeshOptions { 
	bEmitTransaction: boolean;
	Method: EGeometryScriptCollisionGenerationMethod;
	bAutoDetectSpheres: boolean;
	bAutoDetectBoxes: boolean;
	bAutoDetectCapsules: boolean;
	MinThickness: number;
	bSimplifyHulls: boolean;
	ConvexHullTargetFaceCount: number;
	SweptHullSimplifyTolerance: number;
	SweptHullAxis: EGeometryScriptSweptHullAxis;
	bRemoveFullyContainedShapes: boolean;
	MaxShapeCount: number;
	clone() : GeometryScriptCollisionFromMeshOptions;
	static C(Other: UObject | any): GeometryScriptCollisionFromMeshOptions;
}

declare class DynamicMesh extends UObject { 
	MeshModifiedBPEvent: UnrealEngineMulticastDelegate<(Mesh: DynamicMesh) => void>;
	MeshGenerator: DynamicMeshGenerator;
	bEnableMeshGenerator: boolean;
	static Load(ResourceName: string): DynamicMesh;
	static Find(Outer: UObject, ResourceName: string): DynamicMesh;
	static GetDefaultObject(): DynamicMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicMesh;
	ResetToCube(): DynamicMesh;
	Reset(): DynamicMesh;
	IsEmpty(): boolean;
	GetTriangleCount(): number;
	static C(Other: UObject | any): DynamicMesh;
	ApplyPolygroupCatmullClarkSubD(Subdivisions: number,GroupLayer: GeometryScriptGroupLayer,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyTriangleLoopSubD(Subdivisions: number,Debug: GeometryScriptDebug): DynamicMesh;
	CreateNewStaticMeshAssetFromMesh(AssetPathAndName: string,Options: GeometryScriptCreateNewStaticMeshAssetOptions,Outcome?: EGeometryScriptOutcomePins,Debug?: GeometryScriptDebug): {Outcome: EGeometryScriptOutcomePins, $: StaticMesh};
	CreateNewVolumeFromMesh(CreateInWorld?: World,ActorTransform?: Transform,BaseActorName?: string,Options?: GeometryScriptCreateNewVolumeFromMeshOptions,Outcome?: EGeometryScriptOutcomePins,Debug?: GeometryScriptDebug): {CreateInWorld: World, Outcome: EGeometryScriptOutcomePins, $: Volume};
	ApplyMeshMorphology(Options: GeometryScriptMorphologyOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyMeshSolidify(Options: GeometryScriptSolidifyOptions,Debug: GeometryScriptDebug): DynamicMesh;
	SetMeshConstantVertexColor(Color: LinearColor,Flags: GeometryScriptColorFlags,bClearExisting: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	SetMeshPerVertexColors(VertexColorList: GeometryScriptColorList,Debug: GeometryScriptDebug): DynamicMesh;
	AutoGeneratePatchBuilderMeshUVs(UvSetIndex: number,Options: GeometryScriptPatchBuilderOptions,Debug: GeometryScriptDebug): DynamicMesh;
	AutoGenerateXAtlasMeshUVs(UvSetIndex: number,Options: GeometryScriptXAtlasOptions,Debug: GeometryScriptDebug): DynamicMesh;
	CopyUVSet(FromUVSet: number,ToUVSet: number,Debug: GeometryScriptDebug): DynamicMesh;
	RecomputeMeshUVs(UvSetIndex: number,Options: GeometryScriptRecomputeUVsOptions,Debug: GeometryScriptDebug): DynamicMesh;
	RepackMeshUVs(UvSetIndex: number,RepackOptions: GeometryScriptRepackUVsOptions,Debug: GeometryScriptDebug): DynamicMesh;
	RotateMeshUVs(UvSetIndex: number,RotationAngle: number,RotationOrigin: Vector2D,Debug: GeometryScriptDebug): DynamicMesh;
	ScaleMeshUVs(UvSetIndex: number,Scale: Vector2D,ScaleOrigin: Vector2D,Debug: GeometryScriptDebug): DynamicMesh;
	SetMeshTriangleUVs(UvSetIndex: number,TriangleID: number,UVs: GeometryScriptUVTriangle,bIsValidTriangle?: boolean,bDeferChangeNotifications?: boolean): {bIsValidTriangle: boolean, $: DynamicMesh};
	SetMeshUVsFromBoxProjection(UvSetIndex: number,BoxTransform: Transform,MinIslandTriCount: number,Debug: GeometryScriptDebug): DynamicMesh;
	SetMeshUVsFromCylinderProjection(UvSetIndex: number,CylinderTransform: Transform,SplitAngle: number,Debug: GeometryScriptDebug): DynamicMesh;
	SetMeshUVsFromPlanarProjection(UvSetIndex: number,PlaneTransform: Transform,Debug: GeometryScriptDebug): DynamicMesh;
	SetNumUVSets(NumUVSets: number,Debug: GeometryScriptDebug): DynamicMesh;
	TranslateMeshUVs(UvSetIndex: number,Translation: Vector2D,Debug: GeometryScriptDebug): DynamicMesh;
	ScaleMesh(Scale: Vector,Debug: GeometryScriptDebug): DynamicMesh;
	TransformMesh(Transform: Transform,Debug: GeometryScriptDebug): DynamicMesh;
	TranslateMesh(Translation: Vector,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyPNTessellation(Options: GeometryScriptPNTessellateOptions,TessellationLevel: number,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyRecursivePNTessellation(Options: GeometryScriptPNTessellateOptions,NumIterations: number,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyUniformTessellation(TessellationLevel: number,Debug: GeometryScriptDebug): DynamicMesh;
	BuildBVHForMesh(OutputBVH?: GeometryScriptDynamicMeshBVH,Debug?: GeometryScriptDebug): {OutputBVH: GeometryScriptDynamicMeshBVH, $: DynamicMesh};
	FindNearestPointOnMesh(QueryBVH: GeometryScriptDynamicMeshBVH,QueryPoint: Vector,Options: GeometryScriptSpatialQueryOptions,NearestResult?: GeometryScriptTrianglePoint,Outcome?: EGeometryScriptSearchOutcomePins,Debug?: GeometryScriptDebug): {NearestResult: GeometryScriptTrianglePoint, Outcome: EGeometryScriptSearchOutcomePins, $: DynamicMesh};
	FindNearestRayIntersectionWithMesh(QueryBVH: GeometryScriptDynamicMeshBVH,RayOrigin: Vector,RayDirection: Vector,Options: GeometryScriptSpatialQueryOptions,HitResult?: GeometryScriptRayHitResult,Outcome?: EGeometryScriptSearchOutcomePins,Debug?: GeometryScriptDebug): {HitResult: GeometryScriptRayHitResult, Outcome: EGeometryScriptSearchOutcomePins, $: DynamicMesh};
	IsBVHValidForMesh(TestBVH: GeometryScriptDynamicMeshBVH,bIsValid?: boolean,Debug?: GeometryScriptDebug): {bIsValid: boolean, $: DynamicMesh};
	IsPointInsideMesh(QueryBVH: GeometryScriptDynamicMeshBVH,QueryPoint: Vector,Options: GeometryScriptSpatialQueryOptions,bIsInside?: boolean,Outcome?: EGeometryScriptContainmentOutcomePins,Debug?: GeometryScriptDebug): {bIsInside: boolean, Outcome: EGeometryScriptContainmentOutcomePins, $: DynamicMesh};
	RebuildBVHForMesh(UpdateBVH?: GeometryScriptDynamicMeshBVH,bOnlyIfInvalid?: boolean,Debug?: GeometryScriptDebug): {UpdateBVH: GeometryScriptDynamicMeshBVH, $: DynamicMesh};
	ApplySimplifyToPlanar(Options: GeometryScriptPlanarSimplifyOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplySimplifyToPolygroupTopology(Options: GeometryScriptPolygroupSimplifyOptions,GroupLayer: GeometryScriptGroupLayer,Debug: GeometryScriptDebug): DynamicMesh;
	ApplySimplifyToTolerance(Tolerance: number,Options: GeometryScriptSimplifyMeshOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplySimplifyToTriangleCount(TriangleCount: number,Options: GeometryScriptSimplifyMeshOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplySimplifyToVertexCount(vertexcount: number,Options: GeometryScriptSimplifyMeshOptions,Debug: GeometryScriptDebug): DynamicMesh;
	CompactMesh(Debug: GeometryScriptDebug): DynamicMesh;
	FillAllMeshHoles(FillOptions: GeometryScriptFillHolesOptions,NumFilledHoles?: number,NumFailedHoleFills?: number,Debug?: GeometryScriptDebug): {NumFilledHoles: number, NumFailedHoleFills: number, $: DynamicMesh};
	RemoveHiddenTriangles(Options: GeometryScriptRemoveHiddenTrianglesOptions,Debug: GeometryScriptDebug): DynamicMesh;
	RemoveSmallComponents(Options: GeometryScriptRemoveSmallComponentOptions,Debug: GeometryScriptDebug): DynamicMesh;
	WeldMeshEdges(WeldOptions: GeometryScriptWeldEdgesOptions,Debug: GeometryScriptDebug): DynamicMesh;
	GetAllTriangleIDs(TriangleIDList?: GeometryScriptIndexList,bHasTriangleIDGaps?: boolean): {TriangleIDList: GeometryScriptIndexList, bHasTriangleIDGaps: boolean, $: DynamicMesh};
	GetAllTriangleIndices(TriangleList?: GeometryScriptTriangleList,bSkipGaps?: boolean,bHasTriangleIDGaps?: boolean): {TriangleList: GeometryScriptTriangleList, bHasTriangleIDGaps: boolean, $: DynamicMesh};
	GetAllVertexIDs(VertexIDList?: GeometryScriptIndexList,bHasVertexIDGaps?: boolean): {VertexIDList: GeometryScriptIndexList, bHasVertexIDGaps: boolean, $: DynamicMesh};
	GetAllVertexPositions(PositionList?: GeometryScriptVectorList,bSkipGaps?: boolean,bHasVertexIDGaps?: boolean): {PositionList: GeometryScriptVectorList, bHasVertexIDGaps: boolean, $: DynamicMesh};
	GetHasMaterialIDs(): boolean;
	GetHasPolygroups(): boolean;
	GetHasTriangleIDGaps(): boolean;
	GetHasVertexIDGaps(): boolean;
	GetIsClosedMesh(): boolean;
	GetIsDenseMesh(): boolean;
	GetMeshBoundingBox(): Box;
	GetMeshHasAttributeSet(): boolean;
	GetMeshVolumeArea(SurfaceArea?: number,Volume?: number): {SurfaceArea: number, Volume: number};
	GetNumConnectedComponents(): number;
	GetNumExtendedPolygroupLayers(): number;
	GetNumOpenBorderEdges(): number;
	GetNumOpenBorderLoops(bAmbiguousTopologyFound?: boolean): {bAmbiguousTopologyFound: boolean, $: number};
	GetNumTriangleIDs(): number;
	GetNumUVSets(): number;
	GetNumVertexIDs(): number;
	GetTriangleFaceNormal(TriangleID: number,bIsValidTriangle?: boolean): {bIsValidTriangle: boolean, $: Vector};
	GetTriangleIndices(TriangleID: number,bIsValidTriangle?: boolean): {bIsValidTriangle: boolean, $: IntVector};
	GetTrianglePositions(TriangleID: number,bIsValidTriangle?: boolean,Vertex1?: Vector,Vertex2?: Vector,Vertex3?: Vector): {bIsValidTriangle: boolean, Vertex1: Vector, Vertex2: Vector, Vertex3: Vector};
	GetTriangleUVs(UvSetIndex: number,TriangleID: number,UV1?: Vector2D,UV2?: Vector2D,UV3?: Vector2D,bHaveValidUVs?: boolean): {UV1: Vector2D, UV2: Vector2D, UV3: Vector2D, bHaveValidUVs: boolean};
	GetUVSetBoundingBox(UvSetIndex: number,bIsValidUVSet?: boolean,bUVSetIsEmpty?: boolean): {bIsValidUVSet: boolean, bUVSetIsEmpty: boolean, $: Box2D};
	GetVertexCount(): number;
	GetVertexPosition(VertexID: number,bIsValidVertex?: boolean): {bIsValidVertex: boolean, $: Vector};
	IsValidTriangleID(TriangleID: number): boolean;
	IsValidVertexID(VertexID: number): boolean;
	AppendBox(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,DimensionX: number,DimensionY: number,DimensionZ: number,StepsX: number,StepsY: number,StepsZ: number,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	AppendCapsule(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,Radius: number,LineLength: number,HemisphereSteps: number,CircleSteps: number,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	AppendCone(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,BaseRadius: number,TopRadius: number,Height: number,RadialSteps: number,HeightSteps: number,bCapped: boolean,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	AppendCurvedStairs(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,StepWidth: number,StepHeight: number,InnerRadius: number,CurveAngle: number,NumSteps: number,bFloating: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	AppendCylinder(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,Radius: number,Height: number,RadialSteps: number,HeightSteps: number,bCapped: boolean,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	AppendDisc(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,Radius: number,AngleSteps: number,SpokeSteps: number,StartAngle: number,EndAngle: number,HoleRadius: number,Debug: GeometryScriptDebug): DynamicMesh;
	AppendLinearStairs(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,StepWidth: number,StepHeight: number,StepDepth: number,NumSteps: number,bFloating: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	AppendRectangle_Compatibility_5_0(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,DimensionX: number,DimensionY: number,StepsWidth: number,StepsHeight: number,Debug: GeometryScriptDebug): DynamicMesh;
	AppendRectangleXY(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,DimensionX: number,DimensionY: number,StepsWidth: number,StepsHeight: number,Debug: GeometryScriptDebug): DynamicMesh;
	AppendRevolvePath(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,PathVertices: Vector2D[],RevolveOptions: GeometryScriptRevolveOptions,Steps: number,bCapped: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	AppendRevolvePolygon(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,PolygonVertices: Vector2D[],RevolveOptions: GeometryScriptRevolveOptions,Radius: number,Steps: number,Debug: GeometryScriptDebug): DynamicMesh;
	AppendRoundRectangle_Compatibility_5_0(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,DimensionX: number,DimensionY: number,CornerRadius: number,StepsWidth: number,StepsHeight: number,StepsRound: number,Debug: GeometryScriptDebug): DynamicMesh;
	AppendRoundRectangleXY(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,DimensionX: number,DimensionY: number,CornerRadius: number,StepsWidth: number,StepsHeight: number,StepsRound: number,Debug: GeometryScriptDebug): DynamicMesh;
	AppendSimpleExtrudePolygon(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,PolygonVertices: Vector2D[],Height: number,HeightSteps: number,bCapped: boolean,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	AppendSimpleSweptPolygon(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,PolygonVertices: Vector2D[],SweepPath: Vector[],bLoop: boolean,bCapped: boolean,StartScale: number,EndScale: number,Debug: GeometryScriptDebug): DynamicMesh;
	AppendSphereBox(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,Radius: number,StepsX: number,StepsY: number,StepsZ: number,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	AppendSphereLatLong(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,Radius: number,StepsPhi: number,StepsTheta: number,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	AppendSpiralRevolvePolygon(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,PolygonVertices: Vector2D[],RevolveOptions: GeometryScriptRevolveOptions,Radius: number,Steps: number,RisePerRevolution: number,Debug: GeometryScriptDebug): DynamicMesh;
	AppendTorus(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,RevolveOptions: GeometryScriptRevolveOptions,MajorRadius: number,MinorRadius: number,MajorSteps: number,MinorSteps: number,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	AppendTriangulatedPolygon(PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,PolygonVertices: Vector2D[],bAllowSelfIntersections: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	ClearPolygroups(GroupLayer: GeometryScriptGroupLayer,ClearValue: number,Debug: GeometryScriptDebug): DynamicMesh;
	ComputePolygroupsFromAngleThreshold(GroupLayer: GeometryScriptGroupLayer,CreaseAngle: number,MinGroupSize: number,Debug: GeometryScriptDebug): DynamicMesh;
	ConvertComponentsToPolygroups(GroupLayer: GeometryScriptGroupLayer,Debug: GeometryScriptDebug): DynamicMesh;
	ConvertUVIslandsToPolygroups(GroupLayer: GeometryScriptGroupLayer,UVLayer: number,Debug: GeometryScriptDebug): DynamicMesh;
	CopyPolygroupsLayer(FromGroupLayer: GeometryScriptGroupLayer,ToGroupLayer: GeometryScriptGroupLayer,Debug: GeometryScriptDebug): DynamicMesh;
	DeleteTrianglesInPolygroup(GroupLayer: GeometryScriptGroupLayer,PolygroupID: number,NumDeleted?: number,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {NumDeleted: number, $: DynamicMesh};
	EnablePolygroups(Debug: GeometryScriptDebug): DynamicMesh;
	GetAllTrianglePolygroupIDs(GroupLayer: GeometryScriptGroupLayer,PolygroupIDsOut?: GeometryScriptIndexList): {PolygroupIDsOut: GeometryScriptIndexList, $: DynamicMesh};
	GetPolygroupIDsInMesh(GroupLayer: GeometryScriptGroupLayer,PolygroupIDsOut?: GeometryScriptIndexList): {PolygroupIDsOut: GeometryScriptIndexList, $: DynamicMesh};
	GetTrianglePolygroupID(GroupLayer: GeometryScriptGroupLayer,TriangleID: number,bIsValidTriangle?: boolean): {bIsValidTriangle: boolean, $: number};
	GetTrianglesInPolygroup(GroupLayer: GeometryScriptGroupLayer,PolygroupID: number,TriangleIDsOut?: GeometryScriptIndexList): {TriangleIDsOut: GeometryScriptIndexList, $: DynamicMesh};
	SetNumExtendedPolygroupLayers(NumLayers: number,Debug: GeometryScriptDebug): DynamicMesh;
	AutoRepairNormals(Debug: GeometryScriptDebug): DynamicMesh;
	ComputeSplitNormals(SplitOptions: GeometryScriptSplitNormalsOptions,CalculateOptions: GeometryScriptCalculateNormalsOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ComputeTangents(Options: GeometryScriptTangentsOptions,Debug: GeometryScriptDebug): DynamicMesh;
	FlipNormals(Debug: GeometryScriptDebug): DynamicMesh;
	RecomputeNormals(CalculateOptions: GeometryScriptCalculateNormalsOptions,Debug: GeometryScriptDebug): DynamicMesh;
	SetMeshTriangleNormals(TriangleID: number,Normals: GeometryScriptTriangle,bIsValidTriangle?: boolean,bDeferChangeNotifications?: boolean): {bIsValidTriangle: boolean, $: DynamicMesh};
	SetPerFaceNormals(Debug: GeometryScriptDebug): DynamicMesh;
	SetPerVertexNormals(Debug: GeometryScriptDebug): DynamicMesh;
	ApplyMeshExtrude(Options: GeometryScriptMeshExtrudeOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyMeshOffset(Options: GeometryScriptMeshOffsetOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyMeshPolygroupBevel(Options: GeometryScriptMeshBevelOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyMeshShell(Options: GeometryScriptMeshOffsetOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ClearMaterialIDs(ClearValue: number,Debug: GeometryScriptDebug): DynamicMesh;
	CompactMaterialIDs(SourceMaterialList: MaterialInterface[],CompactedMaterialList?: MaterialInterface[],Debug?: GeometryScriptDebug): {CompactedMaterialList: MaterialInterface[], $: DynamicMesh};
	DeleteTrianglesByMaterialID(MaterialID: number,NumDeleted?: number,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {NumDeleted: number, $: DynamicMesh};
	EnableMaterialIDs(Debug: GeometryScriptDebug): DynamicMesh;
	GetAllTriangleMaterialIDs(MaterialIDList?: GeometryScriptIndexList,bHasMaterialIDs?: boolean): {MaterialIDList: GeometryScriptIndexList, bHasMaterialIDs: boolean, $: DynamicMesh};
	GetMaxMaterialID(bHasMaterialIDs?: boolean): {bHasMaterialIDs: boolean, $: number};
	GetTriangleMaterialID(TriangleID: number,bIsValidTriangle?: boolean): {bIsValidTriangle: boolean, $: number};
	RemapMaterialIDs(FromMaterialID: number,ToMaterialID: number,Debug: GeometryScriptDebug): DynamicMesh;
	SetAllTriangleMaterialIDs(TriangleMaterialIDList?: GeometryScriptIndexList,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {TriangleMaterialIDList: GeometryScriptIndexList, $: DynamicMesh};
	SetPolygroupMaterialID(GroupLayer: GeometryScriptGroupLayer,PolygroupID: number,MaterialID: number,bIsValidPolygroupID?: boolean,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {bIsValidPolygroupID: boolean, $: DynamicMesh};
	SetTriangleMaterialID(TriangleID: number,MaterialID: number,bIsValidTriangle?: boolean,bDeferChangeNotifications?: boolean): {bIsValidTriangle: boolean, $: DynamicMesh};
	ApplyBendWarpToMesh(Options: GeometryScriptBendWarpOptions,BendOrientation: Transform,BendAngle: number,BendExtent: number,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyDisplaceFromTextureMap(Texture: Texture2D,Options: GeometryScriptDisplaceFromTextureOptions,UVLayer: number,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyFlareWarpToMesh(Options: GeometryScriptFlareWarpOptions,FlareOrientation: Transform,FlarePercentX: number,FlarePercentY: number,FlareExtent: number,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyIterativeSmoothingToMesh(Options: GeometryScriptIterativeMeshSmoothingOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyMathWarpToMesh(WarpOrientation: Transform,WarpType: EGeometryScriptMathWarpType,Options: GeometryScriptMathWarpOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyPerlinNoiseToMesh(Options: GeometryScriptPerlinNoiseOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyTwistWarpToMesh(Options: GeometryScriptTwistWarpOptions,TwistOrientation: Transform,TwistAngle: number,TwistExtent: number,Debug: GeometryScriptDebug): DynamicMesh;
	CopyMeshToMesh(CopyToMesh?: DynamicMesh,CopyToMeshOut?: DynamicMesh,Debug?: GeometryScriptDebug): {CopyToMesh: DynamicMesh, CopyToMeshOut: DynamicMesh, $: DynamicMesh};
	GetSubMeshFromMesh(StoreToSubmesh?: DynamicMesh,TriangleList?: GeometryScriptIndexList,StoreToSubmeshOut?: DynamicMesh,Debug?: GeometryScriptDebug): {StoreToSubmesh: DynamicMesh, StoreToSubmeshOut: DynamicMesh, $: DynamicMesh};
	SplitMeshByComponents(ComponentMeshes?: DynamicMesh[],MeshPool?: DynamicMeshPool,Debug?: GeometryScriptDebug): {ComponentMeshes: DynamicMesh[], $: DynamicMesh};
	SplitMeshByMaterialIDs(ComponentMeshes?: DynamicMesh[],ComponentMaterialIDs?: number[],MeshPool?: DynamicMeshPool,Debug?: GeometryScriptDebug): {ComponentMeshes: DynamicMesh[], ComponentMaterialIDs: number[], $: DynamicMesh};
	SplitMeshByPolygroups(GroupLayer: GeometryScriptGroupLayer,ComponentMeshes?: DynamicMesh[],ComponentPolygroups?: number[],MeshPool?: DynamicMeshPool,Debug?: GeometryScriptDebug): {ComponentMeshes: DynamicMesh[], ComponentPolygroups: number[], $: DynamicMesh};
	IsIntersectingMesh(TargetTransform: Transform,OtherMesh: DynamicMesh,OtherTransform: Transform,bIsIntersecting?: boolean,Debug?: GeometryScriptDebug): {bIsIntersecting: boolean, $: DynamicMesh};
	IsSameMeshAs(OtherMesh: DynamicMesh,Options: GeometryScriptIsSameMeshOptions,bIsSameMesh?: boolean,Debug?: GeometryScriptDebug): {bIsSameMesh: boolean, $: DynamicMesh};
	MeasureDistancesBetweenMeshes(OtherMesh: DynamicMesh,Options: GeometryScriptMeasureMeshDistanceOptions,MaxDistance?: any,MinDistance?: any,AverageDistance?: any,RootMeanSqrDeviation?: any,Debug?: GeometryScriptDebug): {MaxDistance: any, MinDistance: any, AverageDistance: any, RootMeanSqrDeviation: any, $: DynamicMesh};
	ApplyMeshBoolean(TargetTransform: Transform,ToolMesh: DynamicMesh,ToolTransform: Transform,Operation: EGeometryScriptBooleanOperation,Options: GeometryScriptMeshBooleanOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyMeshMirror(MirrorFrame: Transform,Options: GeometryScriptMeshMirrorOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyMeshPlaneCut(CutFrame: Transform,Options: GeometryScriptMeshPlaneCutOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyMeshPlaneSlice(CutFrame: Transform,Options: GeometryScriptMeshPlaneSliceOptions,Debug: GeometryScriptDebug): DynamicMesh;
	ApplyMeshSelfUnion(Options: GeometryScriptMeshSelfUnionOptions,Debug: GeometryScriptDebug): DynamicMesh;
	AddTrianglesToMesh(NewTrianglesList: GeometryScriptTriangleList,NewIndicesList?: GeometryScriptIndexList,NewTriangleGroupID?: number,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {NewIndicesList: GeometryScriptIndexList, $: DynamicMesh};
	AddTriangleToMesh(NewTriangle: IntVector,NewTriangleIndex?: number,NewTriangleGroupID?: number,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {NewTriangleIndex: number, $: DynamicMesh};
	AddVertexToMesh(NewPosition: Vector,NewVertexIndex?: number,bDeferChangeNotifications?: boolean): {NewVertexIndex: number, $: DynamicMesh};
	AddVerticesToMesh(NewPositionsList: GeometryScriptVectorList,NewIndicesList?: GeometryScriptIndexList,bDeferChangeNotifications?: boolean): {NewIndicesList: GeometryScriptIndexList, $: DynamicMesh};
	AppendBuffersToMesh(Buffers: GeometryScriptSimpleMeshBuffers,NewTriangleIndicesList?: GeometryScriptIndexList,MaterialID?: number,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {NewTriangleIndicesList: GeometryScriptIndexList, $: DynamicMesh};
	AppendMesh(AppendMesh: DynamicMesh,AppendTransform: Transform,bDeferChangeNotifications: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	AppendMeshRepeated(AppendMesh: DynamicMesh,AppendTransform: Transform,RepeatCount: number,bApplyTransformToFirstInstance: boolean,bDeferChangeNotifications: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	DeleteTriangleFromMesh(TriangleID: number,bWasTriangleDeleted?: boolean,bDeferChangeNotifications?: boolean): {bWasTriangleDeleted: boolean, $: DynamicMesh};
	DeleteTrianglesFromMesh(TriangleList: GeometryScriptIndexList,NumDeleted?: number,bDeferChangeNotifications?: boolean): {NumDeleted: number, $: DynamicMesh};
	DeleteVertexFromMesh(VertexID: number,bWasVertexDeleted?: boolean,bDeferChangeNotifications?: boolean): {bWasVertexDeleted: boolean, $: DynamicMesh};
	DeleteVerticesFromMesh(VertexList: GeometryScriptIndexList,NumDeleted?: number,bDeferChangeNotifications?: boolean): {NumDeleted: number, $: DynamicMesh};
	DiscardMeshAttributes(bDeferChangeNotifications: boolean): DynamicMesh;
	SetVertexPosition(VertexID: number,NewPosition: Vector,bIsValidVertex?: boolean,bDeferChangeNotifications?: boolean): {bIsValidVertex: boolean, $: DynamicMesh};
	CopyMeshToStaticMesh(ToStaticMeshAsset: StaticMesh,Options: GeometryScriptCopyMeshToAssetOptions,TargetLod: GeometryScriptMeshWriteLOD,Outcome?: EGeometryScriptOutcomePins,Debug?: GeometryScriptDebug): {Outcome: EGeometryScriptOutcomePins, $: DynamicMesh};
	ComputeMeshConvexHull(CopyToMesh?: DynamicMesh,CopyToMeshOut?: DynamicMesh,Options?: GeometryScriptConvexHullOptions,Debug?: GeometryScriptDebug): {CopyToMesh: DynamicMesh, CopyToMeshOut: DynamicMesh, $: DynamicMesh};
	ComputeMeshSweptHull(CopyToMesh?: DynamicMesh,CopyToMeshOut?: DynamicMesh,ProjectionFrame?: Transform,Options?: GeometryScriptSweptHullOptions,Debug?: GeometryScriptDebug): {CopyToMesh: DynamicMesh, CopyToMeshOut: DynamicMesh, $: DynamicMesh};
	SetDynamicMeshCollisionFromMesh(ToDynamicMeshComponent: DynamicMeshComponent,Options: GeometryScriptCollisionFromMeshOptions,Debug: GeometryScriptDebug): DynamicMesh;
	SetStaticMeshCollisionFromMesh(ToStaticMeshAsset: StaticMesh,Options: GeometryScriptCollisionFromMeshOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyPolygroupCatmullClarkSubD(FromDynamicMesh: DynamicMesh,Subdivisions: number,GroupLayer: GeometryScriptGroupLayer,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyTriangleLoopSubD(FromDynamicMesh: DynamicMesh,Subdivisions: number,Debug: GeometryScriptDebug): DynamicMesh;
	static CreateNewStaticMeshAssetFromMesh(FromDynamicMesh: DynamicMesh,AssetPathAndName: string,Options: GeometryScriptCreateNewStaticMeshAssetOptions,Outcome?: EGeometryScriptOutcomePins,Debug?: GeometryScriptDebug): {Outcome: EGeometryScriptOutcomePins, $: StaticMesh};
	static CreateNewVolumeFromMesh(FromDynamicMesh: DynamicMesh,CreateInWorld?: World,ActorTransform?: Transform,BaseActorName?: string,Options?: GeometryScriptCreateNewVolumeFromMeshOptions,Outcome?: EGeometryScriptOutcomePins,Debug?: GeometryScriptDebug): {CreateInWorld: World, Outcome: EGeometryScriptOutcomePins, $: Volume};
	static ApplyMeshMorphology(TargetMesh: DynamicMesh,Options: GeometryScriptMorphologyOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyMeshSolidify(TargetMesh: DynamicMesh,Options: GeometryScriptSolidifyOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static SetMeshConstantVertexColor(TargetMesh: DynamicMesh,Color: LinearColor,Flags: GeometryScriptColorFlags,bClearExisting: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	static SetMeshPerVertexColors(TargetMesh: DynamicMesh,VertexColorList: GeometryScriptColorList,Debug: GeometryScriptDebug): DynamicMesh;
	static AutoGeneratePatchBuilderMeshUVs(TargetMesh: DynamicMesh,UvSetIndex: number,Options: GeometryScriptPatchBuilderOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static AutoGenerateXAtlasMeshUVs(TargetMesh: DynamicMesh,UvSetIndex: number,Options: GeometryScriptXAtlasOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static CopyUVSet(TargetMesh: DynamicMesh,FromUVSet: number,ToUVSet: number,Debug: GeometryScriptDebug): DynamicMesh;
	static RecomputeMeshUVs(TargetMesh: DynamicMesh,UvSetIndex: number,Options: GeometryScriptRecomputeUVsOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static RepackMeshUVs(TargetMesh: DynamicMesh,UvSetIndex: number,RepackOptions: GeometryScriptRepackUVsOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static RotateMeshUVs(TargetMesh: DynamicMesh,UvSetIndex: number,RotationAngle: number,RotationOrigin: Vector2D,Debug: GeometryScriptDebug): DynamicMesh;
	static ScaleMeshUVs(TargetMesh: DynamicMesh,UvSetIndex: number,Scale: Vector2D,ScaleOrigin: Vector2D,Debug: GeometryScriptDebug): DynamicMesh;
	static SetMeshTriangleUVs(TargetMesh: DynamicMesh,UvSetIndex: number,TriangleID: number,UVs: GeometryScriptUVTriangle,bIsValidTriangle?: boolean,bDeferChangeNotifications?: boolean): {bIsValidTriangle: boolean, $: DynamicMesh};
	static SetMeshUVsFromBoxProjection(TargetMesh: DynamicMesh,UvSetIndex: number,BoxTransform: Transform,MinIslandTriCount: number,Debug: GeometryScriptDebug): DynamicMesh;
	static SetMeshUVsFromCylinderProjection(TargetMesh: DynamicMesh,UvSetIndex: number,CylinderTransform: Transform,SplitAngle: number,Debug: GeometryScriptDebug): DynamicMesh;
	static SetMeshUVsFromPlanarProjection(TargetMesh: DynamicMesh,UvSetIndex: number,PlaneTransform: Transform,Debug: GeometryScriptDebug): DynamicMesh;
	static SetNumUVSets(TargetMesh: DynamicMesh,NumUVSets: number,Debug: GeometryScriptDebug): DynamicMesh;
	static TranslateMeshUVs(TargetMesh: DynamicMesh,UvSetIndex: number,Translation: Vector2D,Debug: GeometryScriptDebug): DynamicMesh;
	static ScaleMesh(TargetMesh: DynamicMesh,Scale: Vector,Debug: GeometryScriptDebug): DynamicMesh;
	static TransformMesh(TargetMesh: DynamicMesh,Transform: Transform,Debug: GeometryScriptDebug): DynamicMesh;
	static TranslateMesh(TargetMesh: DynamicMesh,Translation: Vector,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyPNTessellation(TargetMesh: DynamicMesh,Options: GeometryScriptPNTessellateOptions,TessellationLevel: number,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyRecursivePNTessellation(TargetMesh: DynamicMesh,Options: GeometryScriptPNTessellateOptions,NumIterations: number,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyUniformTessellation(TargetMesh: DynamicMesh,TessellationLevel: number,Debug: GeometryScriptDebug): DynamicMesh;
	static BuildBVHForMesh(TargetMesh: DynamicMesh,OutputBVH?: GeometryScriptDynamicMeshBVH,Debug?: GeometryScriptDebug): {OutputBVH: GeometryScriptDynamicMeshBVH, $: DynamicMesh};
	static FindNearestPointOnMesh(TargetMesh: DynamicMesh,QueryBVH: GeometryScriptDynamicMeshBVH,QueryPoint: Vector,Options: GeometryScriptSpatialQueryOptions,NearestResult?: GeometryScriptTrianglePoint,Outcome?: EGeometryScriptSearchOutcomePins,Debug?: GeometryScriptDebug): {NearestResult: GeometryScriptTrianglePoint, Outcome: EGeometryScriptSearchOutcomePins, $: DynamicMesh};
	static FindNearestRayIntersectionWithMesh(TargetMesh: DynamicMesh,QueryBVH: GeometryScriptDynamicMeshBVH,RayOrigin: Vector,RayDirection: Vector,Options: GeometryScriptSpatialQueryOptions,HitResult?: GeometryScriptRayHitResult,Outcome?: EGeometryScriptSearchOutcomePins,Debug?: GeometryScriptDebug): {HitResult: GeometryScriptRayHitResult, Outcome: EGeometryScriptSearchOutcomePins, $: DynamicMesh};
	static IsBVHValidForMesh(TargetMesh: DynamicMesh,TestBVH: GeometryScriptDynamicMeshBVH,bIsValid?: boolean,Debug?: GeometryScriptDebug): {bIsValid: boolean, $: DynamicMesh};
	static IsPointInsideMesh(TargetMesh: DynamicMesh,QueryBVH: GeometryScriptDynamicMeshBVH,QueryPoint: Vector,Options: GeometryScriptSpatialQueryOptions,bIsInside?: boolean,Outcome?: EGeometryScriptContainmentOutcomePins,Debug?: GeometryScriptDebug): {bIsInside: boolean, Outcome: EGeometryScriptContainmentOutcomePins, $: DynamicMesh};
	static RebuildBVHForMesh(TargetMesh: DynamicMesh,UpdateBVH?: GeometryScriptDynamicMeshBVH,bOnlyIfInvalid?: boolean,Debug?: GeometryScriptDebug): {UpdateBVH: GeometryScriptDynamicMeshBVH, $: DynamicMesh};
	static ApplySimplifyToPlanar(TargetMesh: DynamicMesh,Options: GeometryScriptPlanarSimplifyOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplySimplifyToPolygroupTopology(TargetMesh: DynamicMesh,Options: GeometryScriptPolygroupSimplifyOptions,GroupLayer: GeometryScriptGroupLayer,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplySimplifyToTolerance(TargetMesh: DynamicMesh,Tolerance: number,Options: GeometryScriptSimplifyMeshOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplySimplifyToTriangleCount(TargetMesh: DynamicMesh,TriangleCount: number,Options: GeometryScriptSimplifyMeshOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplySimplifyToVertexCount(TargetMesh: DynamicMesh,vertexcount: number,Options: GeometryScriptSimplifyMeshOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static CompactMesh(TargetMesh: DynamicMesh,Debug: GeometryScriptDebug): DynamicMesh;
	static FillAllMeshHoles(TargetMesh: DynamicMesh,FillOptions: GeometryScriptFillHolesOptions,NumFilledHoles?: number,NumFailedHoleFills?: number,Debug?: GeometryScriptDebug): {NumFilledHoles: number, NumFailedHoleFills: number, $: DynamicMesh};
	static RemoveHiddenTriangles(TargetMesh: DynamicMesh,Options: GeometryScriptRemoveHiddenTrianglesOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static RemoveSmallComponents(TargetMesh: DynamicMesh,Options: GeometryScriptRemoveSmallComponentOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static WeldMeshEdges(TargetMesh: DynamicMesh,WeldOptions: GeometryScriptWeldEdgesOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static GetAllTriangleIDs(TargetMesh: DynamicMesh,TriangleIDList?: GeometryScriptIndexList,bHasTriangleIDGaps?: boolean): {TriangleIDList: GeometryScriptIndexList, bHasTriangleIDGaps: boolean, $: DynamicMesh};
	static GetAllTriangleIndices(TargetMesh: DynamicMesh,TriangleList?: GeometryScriptTriangleList,bSkipGaps?: boolean,bHasTriangleIDGaps?: boolean): {TriangleList: GeometryScriptTriangleList, bHasTriangleIDGaps: boolean, $: DynamicMesh};
	static GetAllVertexIDs(TargetMesh: DynamicMesh,VertexIDList?: GeometryScriptIndexList,bHasVertexIDGaps?: boolean): {VertexIDList: GeometryScriptIndexList, bHasVertexIDGaps: boolean, $: DynamicMesh};
	static GetAllVertexPositions(TargetMesh: DynamicMesh,PositionList?: GeometryScriptVectorList,bSkipGaps?: boolean,bHasVertexIDGaps?: boolean): {PositionList: GeometryScriptVectorList, bHasVertexIDGaps: boolean, $: DynamicMesh};
	static GetHasMaterialIDs(TargetMesh: DynamicMesh): boolean;
	static GetHasPolygroups(TargetMesh: DynamicMesh): boolean;
	static GetHasTriangleIDGaps(TargetMesh: DynamicMesh): boolean;
	static GetHasVertexIDGaps(TargetMesh: DynamicMesh): boolean;
	static GetIsClosedMesh(TargetMesh: DynamicMesh): boolean;
	static GetIsDenseMesh(TargetMesh: DynamicMesh): boolean;
	static GetMeshBoundingBox(TargetMesh: DynamicMesh): Box;
	static GetMeshHasAttributeSet(TargetMesh: DynamicMesh): boolean;
	static GetMeshVolumeArea(TargetMesh: DynamicMesh,SurfaceArea?: number,Volume?: number): {SurfaceArea: number, Volume: number};
	static GetNumConnectedComponents(TargetMesh: DynamicMesh): number;
	static GetNumExtendedPolygroupLayers(TargetMesh: DynamicMesh): number;
	static GetNumOpenBorderEdges(TargetMesh: DynamicMesh): number;
	static GetNumOpenBorderLoops(TargetMesh: DynamicMesh,bAmbiguousTopologyFound?: boolean): {bAmbiguousTopologyFound: boolean, $: number};
	static GetNumTriangleIDs(TargetMesh: DynamicMesh): number;
	static GetNumUVSets(TargetMesh: DynamicMesh): number;
	static GetNumVertexIDs(TargetMesh: DynamicMesh): number;
	static GetTriangleFaceNormal(TargetMesh: DynamicMesh,TriangleID: number,bIsValidTriangle?: boolean): {bIsValidTriangle: boolean, $: Vector};
	static GetTriangleIndices(TargetMesh: DynamicMesh,TriangleID: number,bIsValidTriangle?: boolean): {bIsValidTriangle: boolean, $: IntVector};
	static GetTrianglePositions(TargetMesh: DynamicMesh,TriangleID: number,bIsValidTriangle?: boolean,Vertex1?: Vector,Vertex2?: Vector,Vertex3?: Vector): {bIsValidTriangle: boolean, Vertex1: Vector, Vertex2: Vector, Vertex3: Vector};
	static GetTriangleUVs(TargetMesh: DynamicMesh,UvSetIndex: number,TriangleID: number,UV1?: Vector2D,UV2?: Vector2D,UV3?: Vector2D,bHaveValidUVs?: boolean): {UV1: Vector2D, UV2: Vector2D, UV3: Vector2D, bHaveValidUVs: boolean};
	static GetUVSetBoundingBox(TargetMesh: DynamicMesh,UvSetIndex: number,bIsValidUVSet?: boolean,bUVSetIsEmpty?: boolean): {bIsValidUVSet: boolean, bUVSetIsEmpty: boolean, $: Box2D};
	static GetVertexCount(TargetMesh: DynamicMesh): number;
	static GetVertexPosition(TargetMesh: DynamicMesh,VertexID: number,bIsValidVertex?: boolean): {bIsValidVertex: boolean, $: Vector};
	static IsValidTriangleID(TargetMesh: DynamicMesh,TriangleID: number): boolean;
	static IsValidVertexID(TargetMesh: DynamicMesh,VertexID: number): boolean;
	static AppendBox(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,DimensionX: number,DimensionY: number,DimensionZ: number,StepsX: number,StepsY: number,StepsZ: number,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendCapsule(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,Radius: number,LineLength: number,HemisphereSteps: number,CircleSteps: number,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendCone(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,BaseRadius: number,TopRadius: number,Height: number,RadialSteps: number,HeightSteps: number,bCapped: boolean,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendCurvedStairs(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,StepWidth: number,StepHeight: number,InnerRadius: number,CurveAngle: number,NumSteps: number,bFloating: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendCylinder(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,Radius: number,Height: number,RadialSteps: number,HeightSteps: number,bCapped: boolean,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendDisc(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,Radius: number,AngleSteps: number,SpokeSteps: number,StartAngle: number,EndAngle: number,HoleRadius: number,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendLinearStairs(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,StepWidth: number,StepHeight: number,StepDepth: number,NumSteps: number,bFloating: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendRectangle_Compatibility_5_0(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,DimensionX: number,DimensionY: number,StepsWidth: number,StepsHeight: number,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendRectangleXY(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,DimensionX: number,DimensionY: number,StepsWidth: number,StepsHeight: number,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendRevolvePath(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,PathVertices: Vector2D[],RevolveOptions: GeometryScriptRevolveOptions,Steps: number,bCapped: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendRevolvePolygon(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,PolygonVertices: Vector2D[],RevolveOptions: GeometryScriptRevolveOptions,Radius: number,Steps: number,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendRoundRectangle_Compatibility_5_0(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,DimensionX: number,DimensionY: number,CornerRadius: number,StepsWidth: number,StepsHeight: number,StepsRound: number,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendRoundRectangleXY(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,DimensionX: number,DimensionY: number,CornerRadius: number,StepsWidth: number,StepsHeight: number,StepsRound: number,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendSimpleExtrudePolygon(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,PolygonVertices: Vector2D[],Height: number,HeightSteps: number,bCapped: boolean,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendSimpleSweptPolygon(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,PolygonVertices: Vector2D[],SweepPath: Vector[],bLoop: boolean,bCapped: boolean,StartScale: number,EndScale: number,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendSphereBox(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,Radius: number,StepsX: number,StepsY: number,StepsZ: number,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendSphereLatLong(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,Radius: number,StepsPhi: number,StepsTheta: number,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendSpiralRevolvePolygon(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,PolygonVertices: Vector2D[],RevolveOptions: GeometryScriptRevolveOptions,Radius: number,Steps: number,RisePerRevolution: number,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendTorus(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,RevolveOptions: GeometryScriptRevolveOptions,MajorRadius: number,MinorRadius: number,MajorSteps: number,MinorSteps: number,Origin: EGeometryScriptPrimitiveOriginMode,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendTriangulatedPolygon(TargetMesh: DynamicMesh,PrimitiveOptions: GeometryScriptPrimitiveOptions,Transform: Transform,PolygonVertices: Vector2D[],bAllowSelfIntersections: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	static ClearPolygroups(TargetMesh: DynamicMesh,GroupLayer: GeometryScriptGroupLayer,ClearValue: number,Debug: GeometryScriptDebug): DynamicMesh;
	static ComputePolygroupsFromAngleThreshold(TargetMesh: DynamicMesh,GroupLayer: GeometryScriptGroupLayer,CreaseAngle: number,MinGroupSize: number,Debug: GeometryScriptDebug): DynamicMesh;
	static ConvertComponentsToPolygroups(TargetMesh: DynamicMesh,GroupLayer: GeometryScriptGroupLayer,Debug: GeometryScriptDebug): DynamicMesh;
	static ConvertUVIslandsToPolygroups(TargetMesh: DynamicMesh,GroupLayer: GeometryScriptGroupLayer,UVLayer: number,Debug: GeometryScriptDebug): DynamicMesh;
	static CopyPolygroupsLayer(TargetMesh: DynamicMesh,FromGroupLayer: GeometryScriptGroupLayer,ToGroupLayer: GeometryScriptGroupLayer,Debug: GeometryScriptDebug): DynamicMesh;
	static DeleteTrianglesInPolygroup(TargetMesh: DynamicMesh,GroupLayer: GeometryScriptGroupLayer,PolygroupID: number,NumDeleted?: number,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {NumDeleted: number, $: DynamicMesh};
	static EnablePolygroups(TargetMesh: DynamicMesh,Debug: GeometryScriptDebug): DynamicMesh;
	static GetAllTrianglePolygroupIDs(TargetMesh: DynamicMesh,GroupLayer: GeometryScriptGroupLayer,PolygroupIDsOut?: GeometryScriptIndexList): {PolygroupIDsOut: GeometryScriptIndexList, $: DynamicMesh};
	static GetPolygroupIDsInMesh(TargetMesh: DynamicMesh,GroupLayer: GeometryScriptGroupLayer,PolygroupIDsOut?: GeometryScriptIndexList): {PolygroupIDsOut: GeometryScriptIndexList, $: DynamicMesh};
	static GetTrianglePolygroupID(TargetMesh: DynamicMesh,GroupLayer: GeometryScriptGroupLayer,TriangleID: number,bIsValidTriangle?: boolean): {bIsValidTriangle: boolean, $: number};
	static GetTrianglesInPolygroup(TargetMesh: DynamicMesh,GroupLayer: GeometryScriptGroupLayer,PolygroupID: number,TriangleIDsOut?: GeometryScriptIndexList): {TriangleIDsOut: GeometryScriptIndexList, $: DynamicMesh};
	static SetNumExtendedPolygroupLayers(TargetMesh: DynamicMesh,NumLayers: number,Debug: GeometryScriptDebug): DynamicMesh;
	static AutoRepairNormals(TargetMesh: DynamicMesh,Debug: GeometryScriptDebug): DynamicMesh;
	static ComputeSplitNormals(TargetMesh: DynamicMesh,SplitOptions: GeometryScriptSplitNormalsOptions,CalculateOptions: GeometryScriptCalculateNormalsOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ComputeTangents(TargetMesh: DynamicMesh,Options: GeometryScriptTangentsOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static FlipNormals(TargetMesh: DynamicMesh,Debug: GeometryScriptDebug): DynamicMesh;
	static RecomputeNormals(TargetMesh: DynamicMesh,CalculateOptions: GeometryScriptCalculateNormalsOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static SetMeshTriangleNormals(TargetMesh: DynamicMesh,TriangleID: number,Normals: GeometryScriptTriangle,bIsValidTriangle?: boolean,bDeferChangeNotifications?: boolean): {bIsValidTriangle: boolean, $: DynamicMesh};
	static SetPerFaceNormals(TargetMesh: DynamicMesh,Debug: GeometryScriptDebug): DynamicMesh;
	static SetPerVertexNormals(TargetMesh: DynamicMesh,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyMeshExtrude(TargetMesh: DynamicMesh,Options: GeometryScriptMeshExtrudeOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyMeshOffset(TargetMesh: DynamicMesh,Options: GeometryScriptMeshOffsetOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyMeshPolygroupBevel(TargetMesh: DynamicMesh,Options: GeometryScriptMeshBevelOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyMeshShell(TargetMesh: DynamicMesh,Options: GeometryScriptMeshOffsetOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ClearMaterialIDs(TargetMesh: DynamicMesh,ClearValue: number,Debug: GeometryScriptDebug): DynamicMesh;
	static CompactMaterialIDs(TargetMesh: DynamicMesh,SourceMaterialList: MaterialInterface[],CompactedMaterialList?: MaterialInterface[],Debug?: GeometryScriptDebug): {CompactedMaterialList: MaterialInterface[], $: DynamicMesh};
	static DeleteTrianglesByMaterialID(TargetMesh: DynamicMesh,MaterialID: number,NumDeleted?: number,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {NumDeleted: number, $: DynamicMesh};
	static EnableMaterialIDs(TargetMesh: DynamicMesh,Debug: GeometryScriptDebug): DynamicMesh;
	static GetAllTriangleMaterialIDs(TargetMesh: DynamicMesh,MaterialIDList?: GeometryScriptIndexList,bHasMaterialIDs?: boolean): {MaterialIDList: GeometryScriptIndexList, bHasMaterialIDs: boolean, $: DynamicMesh};
	static GetMaxMaterialID(TargetMesh: DynamicMesh,bHasMaterialIDs?: boolean): {bHasMaterialIDs: boolean, $: number};
	static GetTriangleMaterialID(TargetMesh: DynamicMesh,TriangleID: number,bIsValidTriangle?: boolean): {bIsValidTriangle: boolean, $: number};
	static RemapMaterialIDs(TargetMesh: DynamicMesh,FromMaterialID: number,ToMaterialID: number,Debug: GeometryScriptDebug): DynamicMesh;
	static SetAllTriangleMaterialIDs(TargetMesh: DynamicMesh,TriangleMaterialIDList?: GeometryScriptIndexList,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {TriangleMaterialIDList: GeometryScriptIndexList, $: DynamicMesh};
	static SetPolygroupMaterialID(TargetMesh: DynamicMesh,GroupLayer: GeometryScriptGroupLayer,PolygroupID: number,MaterialID: number,bIsValidPolygroupID?: boolean,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {bIsValidPolygroupID: boolean, $: DynamicMesh};
	static SetTriangleMaterialID(TargetMesh: DynamicMesh,TriangleID: number,MaterialID: number,bIsValidTriangle?: boolean,bDeferChangeNotifications?: boolean): {bIsValidTriangle: boolean, $: DynamicMesh};
	static ApplyBendWarpToMesh(TargetMesh: DynamicMesh,Options: GeometryScriptBendWarpOptions,BendOrientation: Transform,BendAngle: number,BendExtent: number,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyDisplaceFromTextureMap(TargetMesh: DynamicMesh,Texture: Texture2D,Options: GeometryScriptDisplaceFromTextureOptions,UVLayer: number,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyFlareWarpToMesh(TargetMesh: DynamicMesh,Options: GeometryScriptFlareWarpOptions,FlareOrientation: Transform,FlarePercentX: number,FlarePercentY: number,FlareExtent: number,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyIterativeSmoothingToMesh(TargetMesh: DynamicMesh,Options: GeometryScriptIterativeMeshSmoothingOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyMathWarpToMesh(TargetMesh: DynamicMesh,WarpOrientation: Transform,WarpType: EGeometryScriptMathWarpType,Options: GeometryScriptMathWarpOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyPerlinNoiseToMesh(TargetMesh: DynamicMesh,Options: GeometryScriptPerlinNoiseOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyTwistWarpToMesh(TargetMesh: DynamicMesh,Options: GeometryScriptTwistWarpOptions,TwistOrientation: Transform,TwistAngle: number,TwistExtent: number,Debug: GeometryScriptDebug): DynamicMesh;
	static CopyMeshToMesh(CopyFromMesh: DynamicMesh,CopyToMesh?: DynamicMesh,CopyToMeshOut?: DynamicMesh,Debug?: GeometryScriptDebug): {CopyToMesh: DynamicMesh, CopyToMeshOut: DynamicMesh, $: DynamicMesh};
	static GetSubMeshFromMesh(TargetMesh: DynamicMesh,StoreToSubmesh?: DynamicMesh,TriangleList?: GeometryScriptIndexList,StoreToSubmeshOut?: DynamicMesh,Debug?: GeometryScriptDebug): {StoreToSubmesh: DynamicMesh, StoreToSubmeshOut: DynamicMesh, $: DynamicMesh};
	static SplitMeshByComponents(TargetMesh: DynamicMesh,ComponentMeshes?: DynamicMesh[],MeshPool?: DynamicMeshPool,Debug?: GeometryScriptDebug): {ComponentMeshes: DynamicMesh[], $: DynamicMesh};
	static SplitMeshByMaterialIDs(TargetMesh: DynamicMesh,ComponentMeshes?: DynamicMesh[],ComponentMaterialIDs?: number[],MeshPool?: DynamicMeshPool,Debug?: GeometryScriptDebug): {ComponentMeshes: DynamicMesh[], ComponentMaterialIDs: number[], $: DynamicMesh};
	static SplitMeshByPolygroups(TargetMesh: DynamicMesh,GroupLayer: GeometryScriptGroupLayer,ComponentMeshes?: DynamicMesh[],ComponentPolygroups?: number[],MeshPool?: DynamicMeshPool,Debug?: GeometryScriptDebug): {ComponentMeshes: DynamicMesh[], ComponentPolygroups: number[], $: DynamicMesh};
	static IsIntersectingMesh(TargetMesh: DynamicMesh,TargetTransform: Transform,OtherMesh: DynamicMesh,OtherTransform: Transform,bIsIntersecting?: boolean,Debug?: GeometryScriptDebug): {bIsIntersecting: boolean, $: DynamicMesh};
	static IsSameMeshAs(TargetMesh: DynamicMesh,OtherMesh: DynamicMesh,Options: GeometryScriptIsSameMeshOptions,bIsSameMesh?: boolean,Debug?: GeometryScriptDebug): {bIsSameMesh: boolean, $: DynamicMesh};
	static MeasureDistancesBetweenMeshes(TargetMesh: DynamicMesh,OtherMesh: DynamicMesh,Options: GeometryScriptMeasureMeshDistanceOptions,MaxDistance?: any,MinDistance?: any,AverageDistance?: any,RootMeanSqrDeviation?: any,Debug?: GeometryScriptDebug): {MaxDistance: any, MinDistance: any, AverageDistance: any, RootMeanSqrDeviation: any, $: DynamicMesh};
	static ApplyMeshBoolean(TargetMesh: DynamicMesh,TargetTransform: Transform,ToolMesh: DynamicMesh,ToolTransform: Transform,Operation: EGeometryScriptBooleanOperation,Options: GeometryScriptMeshBooleanOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyMeshMirror(TargetMesh: DynamicMesh,MirrorFrame: Transform,Options: GeometryScriptMeshMirrorOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyMeshPlaneCut(TargetMesh: DynamicMesh,CutFrame: Transform,Options: GeometryScriptMeshPlaneCutOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyMeshPlaneSlice(TargetMesh: DynamicMesh,CutFrame: Transform,Options: GeometryScriptMeshPlaneSliceOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static ApplyMeshSelfUnion(TargetMesh: DynamicMesh,Options: GeometryScriptMeshSelfUnionOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static AddTrianglesToMesh(TargetMesh: DynamicMesh,NewTrianglesList: GeometryScriptTriangleList,NewIndicesList?: GeometryScriptIndexList,NewTriangleGroupID?: number,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {NewIndicesList: GeometryScriptIndexList, $: DynamicMesh};
	static AddTriangleToMesh(TargetMesh: DynamicMesh,NewTriangle: IntVector,NewTriangleIndex?: number,NewTriangleGroupID?: number,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {NewTriangleIndex: number, $: DynamicMesh};
	static AddVertexToMesh(TargetMesh: DynamicMesh,NewPosition: Vector,NewVertexIndex?: number,bDeferChangeNotifications?: boolean): {NewVertexIndex: number, $: DynamicMesh};
	static AddVerticesToMesh(TargetMesh: DynamicMesh,NewPositionsList: GeometryScriptVectorList,NewIndicesList?: GeometryScriptIndexList,bDeferChangeNotifications?: boolean): {NewIndicesList: GeometryScriptIndexList, $: DynamicMesh};
	static AppendBuffersToMesh(TargetMesh: DynamicMesh,Buffers: GeometryScriptSimpleMeshBuffers,NewTriangleIndicesList?: GeometryScriptIndexList,MaterialID?: number,bDeferChangeNotifications?: boolean,Debug?: GeometryScriptDebug): {NewTriangleIndicesList: GeometryScriptIndexList, $: DynamicMesh};
	static AppendMesh(TargetMesh: DynamicMesh,AppendMesh: DynamicMesh,AppendTransform: Transform,bDeferChangeNotifications: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	static AppendMeshRepeated(TargetMesh: DynamicMesh,AppendMesh: DynamicMesh,AppendTransform: Transform,RepeatCount: number,bApplyTransformToFirstInstance: boolean,bDeferChangeNotifications: boolean,Debug: GeometryScriptDebug): DynamicMesh;
	static DeleteTriangleFromMesh(TargetMesh: DynamicMesh,TriangleID: number,bWasTriangleDeleted?: boolean,bDeferChangeNotifications?: boolean): {bWasTriangleDeleted: boolean, $: DynamicMesh};
	static DeleteTrianglesFromMesh(TargetMesh: DynamicMesh,TriangleList: GeometryScriptIndexList,NumDeleted?: number,bDeferChangeNotifications?: boolean): {NumDeleted: number, $: DynamicMesh};
	static DeleteVertexFromMesh(TargetMesh: DynamicMesh,VertexID: number,bWasVertexDeleted?: boolean,bDeferChangeNotifications?: boolean): {bWasVertexDeleted: boolean, $: DynamicMesh};
	static DeleteVerticesFromMesh(TargetMesh: DynamicMesh,VertexList: GeometryScriptIndexList,NumDeleted?: number,bDeferChangeNotifications?: boolean): {NumDeleted: number, $: DynamicMesh};
	static DiscardMeshAttributes(TargetMesh: DynamicMesh,bDeferChangeNotifications: boolean): DynamicMesh;
	static SetVertexPosition(TargetMesh: DynamicMesh,VertexID: number,NewPosition: Vector,bIsValidVertex?: boolean,bDeferChangeNotifications?: boolean): {bIsValidVertex: boolean, $: DynamicMesh};
	static CopyMeshToStaticMesh(FromDynamicMesh: DynamicMesh,ToStaticMeshAsset: StaticMesh,Options: GeometryScriptCopyMeshToAssetOptions,TargetLod: GeometryScriptMeshWriteLOD,Outcome?: EGeometryScriptOutcomePins,Debug?: GeometryScriptDebug): {Outcome: EGeometryScriptOutcomePins, $: DynamicMesh};
	static ComputeMeshConvexHull(TargetMesh: DynamicMesh,CopyToMesh?: DynamicMesh,CopyToMeshOut?: DynamicMesh,Options?: GeometryScriptConvexHullOptions,Debug?: GeometryScriptDebug): {CopyToMesh: DynamicMesh, CopyToMeshOut: DynamicMesh, $: DynamicMesh};
	static ComputeMeshSweptHull(TargetMesh: DynamicMesh,CopyToMesh?: DynamicMesh,CopyToMeshOut?: DynamicMesh,ProjectionFrame?: Transform,Options?: GeometryScriptSweptHullOptions,Debug?: GeometryScriptDebug): {CopyToMesh: DynamicMesh, CopyToMeshOut: DynamicMesh, $: DynamicMesh};
	static SetDynamicMeshCollisionFromMesh(FromDynamicMesh: DynamicMesh,ToDynamicMeshComponent: DynamicMeshComponent,Options: GeometryScriptCollisionFromMeshOptions,Debug: GeometryScriptDebug): DynamicMesh;
	static SetStaticMeshCollisionFromMesh(FromDynamicMesh: DynamicMesh,ToStaticMeshAsset: StaticMesh,Options: GeometryScriptCollisionFromMeshOptions,Debug: GeometryScriptDebug): DynamicMesh;
}

declare class GeometryScriptCopyMeshFromAssetOptions { 
	bApplyBuildSettings: boolean;
	bRequestTangents: boolean;
	bIgnoreRemoveDegenerates: boolean;
	clone() : GeometryScriptCopyMeshFromAssetOptions;
	static C(Other: UObject | any): GeometryScriptCopyMeshFromAssetOptions;
}

declare type EGeometryScriptLODType = 'MaxAvailable' | 'HiResSourceModel' | 'SourceModel' | 'RenderData' | 'EGeometryScriptLODType_MAX';
declare var EGeometryScriptLODType : { MaxAvailable:'MaxAvailable',HiResSourceModel:'HiResSourceModel',SourceModel:'SourceModel',RenderData:'RenderData',EGeometryScriptLODType_MAX:'EGeometryScriptLODType_MAX', };
declare class GeometryScriptMeshReadLOD { 
	LODType: EGeometryScriptLODType;
	LODIndex: number;
	clone() : GeometryScriptMeshReadLOD;
	static C(Other: UObject | any): GeometryScriptMeshReadLOD;
}

declare class GeometryScriptSetSimpleCollisionOptions { 
	bEmitTransaction: boolean;
	clone() : GeometryScriptSetSimpleCollisionOptions;
	static C(Other: UObject | any): GeometryScriptSetSimpleCollisionOptions;
}

declare type EScriptCollisionShapeType = 'Box' | 'Sphere' | 'Capsule' | 'NDOP10_X' | 'NDOP10_Y' | 'NDOP10_Z' | 'NDOP18' | 'NDOP26' | 'EScriptCollisionShapeType_MAX';
declare var EScriptCollisionShapeType : { Box:'Box',Sphere:'Sphere',Capsule:'Capsule',NDOP10_X:'NDOP10_X',NDOP10_Y:'NDOP10_Y',NDOP10_Z:'NDOP10_Z',NDOP18:'NDOP18',NDOP26:'NDOP26',EScriptCollisionShapeType_MAX:'EScriptCollisionShapeType_MAX', };
declare class StaticMeshReductionSettings { 
	PercentTriangles: number;
	ScreenSize: number;
	clone() : StaticMeshReductionSettings;
	static C(Other: UObject | any): StaticMeshReductionSettings;
}

declare class StaticMeshReductionOptions { 
	bAutoComputeLODScreenSize: boolean;
	ReductionSettings: StaticMeshReductionSettings[];
	clone() : StaticMeshReductionOptions;
	static C(Other: UObject | any): StaticMeshReductionOptions;
}

declare class StaticMesh extends StreamableRenderAsset { 
	SourceModels: StaticMeshSourceModel[];
	HiResSourceModel: StaticMeshSourceModel;
	SectionInfoMap: MeshSectionInfoMap;
	OriginalSectionInfoMap: MeshSectionInfoMap;
	LODGroup: string;
	NumStreamedLODs: PerPlatformInt;
	ImportVersion: number;
	MaterialRemapIndexPerImportVersion: MaterialRemapIndex[];
	LightmapUVVersion: number;
	bAutoComputeLODScreenSize: boolean;
	Materials: MaterialInterface[];
	NaniteSettings: MeshNaniteSettings;
	MinQualityLevelLOD: PerQualityLevelInt;
	MinLOD: PerPlatformInt;
	StaticMaterials: StaticMaterial[];
	LightmapUVDensity: number;
	LightMapResolution: number;
	LightMapCoordinateIndex: number;
	DistanceFieldSelfShadowBias: number;
	BodySetup: BodySetup;
	LODForCollision: number;
	bGenerateMeshDistanceField: boolean;
	bStripComplexCollisionForConsole: boolean;
	bHasNavigationData: boolean;
	bSupportUniformlyDistributedSampling: boolean;
	bSupportPhysicalMaterialMasks: boolean;
	bSupportRayTracing: boolean;
	bDoFastBuild: boolean;
	bIsBuiltAtRuntime: boolean;
	bAllowCPUAccess: boolean;
	bSupportGpuUniformlyDistributedSampling: boolean;
	AssetImportData: AssetImportData;
	SourceFilePath: string;
	SourceFileTimestamp: string;
	ThumbnailInfo: ThumbnailInfo;
	EditorCameraPosition: AssetEditorOrbitCameraPosition;
	bCustomizedCollision: boolean;
	Sockets: StaticMeshSocket[];
	PositiveBoundsExtension: Vector;
	NegativeBoundsExtension: Vector;
	ExtendedBounds: BoxSphereBounds;
	ElementToIgnoreForTexFactor: number;
	AssetUserData: AssetUserData[];
	EditableMesh: UObject;
	ComplexCollisionMesh: StaticMesh;
	NavCollision: NavCollisionBase;
	static Load(ResourceName: string): StaticMesh;
	static Find(Outer: UObject, ResourceName: string): StaticMesh;
	static GetDefaultObject(): StaticMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMesh;
	SetStaticMaterials(InStaticMaterials: StaticMaterial[]): void;
	SetNumSourceModels(Num: number): void;
	SetMinimumLODForPlatforms(PlatformMinimumLODs: any): void;
	SetMinimumLODForPlatform(PlatformName: string,InMinLOD: number): void;
	SetMaterial(MaterialIndex: number,NewMaterial: MaterialInterface): void;
	RemoveSocket(Socket: StaticMeshSocket): void;
	GetStaticMeshDescription(LODIndex: number): StaticMeshDescription;
	GetStaticMaterials(): StaticMaterial[];
	GetNumSections(InLOD: number): number;
	GetNumLODs(): number;
	GetMinimumLODForQualityLevels(QualityLevelMinimumLODs?: any): {QualityLevelMinimumLODs: any};
	GetMinimumLODForQualityLevel(QualityLevel: string): number;
	GetMinimumLODForPlatforms(PlatformMinimumLODs?: any): {PlatformMinimumLODs: any};
	GetMinimumLODForPlatform(PlatformName: string): number;
	GetMaterialIndex(MaterialSlotName: string): number;
	GetMaterial(MaterialIndex: number): MaterialInterface;
	GetBounds(): BoxSphereBounds;
	GetBoundingBox(): Box;
	FindSocket(InSocketName: string): StaticMeshSocket;
	static CreateStaticMeshDescription(Outer: UObject): StaticMeshDescription;
	BuildFromStaticMeshDescriptions(StaticMeshDescriptions: StaticMeshDescription[],bBuildSimpleCollision: boolean,bFastBuild: boolean): void;
	AddSocket(Socket: StaticMeshSocket): void;
	AddMaterial(Material: MaterialInterface): string;
	static C(Other: UObject | any): StaticMesh;
	Build(): void;
	GetPhysicsBodySetupFromStaticMesh(): BodySetup;
	GetSectionInfo(LODIndex: number,SectionIndex: number): MeshSectionInfo;
	LoadRawMesh(SourceModelIndex: number,OutMesh?: JavascriptRawMesh): {OutMesh: JavascriptRawMesh};
	SaveRawMesh(SourceModelIndex: number,InMesh?: JavascriptRawMesh): {InMesh: JavascriptRawMesh};
	SetSectionInfo(LODIndex: number,SectionIndex: number,Info: MeshSectionInfo): void;
	GetSectionFromStaticMesh(LODIndex: number,SectionIndex: number,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	CopyMeshFromStaticMesh(ToDynamicMesh: DynamicMesh,AssetOptions: GeometryScriptCopyMeshFromAssetOptions,RequestedLOD: GeometryScriptMeshReadLOD,Outcome?: EGeometryScriptOutcomePins,Debug?: GeometryScriptDebug): {Outcome: EGeometryScriptOutcomePins, $: DynamicMesh};
	GetSectionMaterialListFromStaticMesh(RequestedLOD: GeometryScriptMeshReadLOD,MaterialList?: MaterialInterface[],MaterialIndex?: number[],Outcome?: EGeometryScriptOutcomePins,Debug?: GeometryScriptDebug): {MaterialList: MaterialInterface[], MaterialIndex: number[], Outcome: EGeometryScriptOutcomePins};
	SetStaticMeshCollisionFromComponent(SourceComponent: PrimitiveComponent,Options: GeometryScriptSetSimpleCollisionOptions,Debug: GeometryScriptDebug): void;
	AddSimpleCollisions(ShapeType: EScriptCollisionShapeType): number;
	AddSimpleCollisionsWithNotification(ShapeType: EScriptCollisionShapeType,bApplyChanges: boolean): number;
	AddUVChannel(LODIndex: number): boolean;
	EnableSectionCastShadow(bCastShadow: boolean,LODIndex: number,SectionIndex: number): void;
	EnableSectionCollision(bCollisionEnabled: boolean,LODIndex: number,SectionIndex: number): void;
	GenerateBoxUVChannel(LODIndex: number,UVChannelIndex: number,position: Vector,Orientation: Rotator,Size: Vector): boolean;
	GenerateCylindricalUVChannel(LODIndex: number,UVChannelIndex: number,position: Vector,Orientation: Rotator,Tiling: Vector2D): boolean;
	GeneratePlanarUVChannel(LODIndex: number,UVChannelIndex: number,position: Vector,Orientation: Rotator,Tiling: Vector2D): boolean;
	GetCollisionComplexity(): ECollisionTraceFlag;
	GetConvexCollisionCount(): number;
	GetLodBuildSettings(LODIndex: number,OutBuildOptions?: MeshBuildSettings): {OutBuildOptions: MeshBuildSettings};
	GetLodCount(): number;
	GetLodReductionSettings(LODIndex: number,OutReductionOptions?: MeshReductionSettings): {OutReductionOptions: MeshReductionSettings};
	GetLodScreenSizes(): number[];
	GetNumberMaterials(): number;
	GetNumberVerts(LODIndex: number): number;
	GetNumUVChannels(LODIndex: number): number;
	GetSimpleCollisionCount(): number;
	HasVertexColors(): boolean;
	ImportLOD(LODIndex: number,SourceFilename: string): number;
	InsertUVChannel(LODIndex: number,UVChannelIndex: number): boolean;
	IsSectionCollisionEnabled(LODIndex: number,SectionIndex: number): boolean;
	ReimportAllCustomLODs(): boolean;
	RemoveCollisions(): boolean;
	RemoveCollisionsWithNotification(bApplyChanges: boolean): boolean;
	RemoveLods(): boolean;
	RemoveUVChannel(LODIndex: number,UVChannelIndex: number): boolean;
	SetAllowCPUAccess(bAllowCPUAccess: boolean): void;
	SetConvexDecompositionCollisions(HullCount: number,MaxHullVerts: number,HullPrecision: number): boolean;
	SetConvexDecompositionCollisionsWithNotification(HullCount: number,MaxHullVerts: number,HullPrecision: number,bApplyChanges: boolean): boolean;
	SetGenerateLightmapUVs(bGenerateLightmapUVs: boolean): boolean;
	SetLodBuildSettings(LODIndex: number,BuildOptions: MeshBuildSettings): void;
	SetLodFromStaticMesh(DestinationLodIndex: number,SourceStaticMesh: StaticMesh,SourceLodIndex: number,bReuseExistingMaterialSlots: boolean): number;
	SetLodReductionSettings(LODIndex: number,ReductionOptions: MeshReductionSettings): void;
	SetLods(ReductionOptions: StaticMeshReductionOptions): number;
	SetLodsWithNotification(ReductionOptions: StaticMeshReductionOptions,bApplyChanges: boolean): number;
	static Build(StaticMesh: StaticMesh): void;
	static GetPhysicsBodySetupFromStaticMesh(InStaticMesh: StaticMesh): BodySetup;
	static GetSectionInfo(StaticMesh: StaticMesh,LODIndex: number,SectionIndex: number): MeshSectionInfo;
	static LoadRawMesh(StaticMesh: StaticMesh,SourceModelIndex: number,OutMesh?: JavascriptRawMesh): {OutMesh: JavascriptRawMesh};
	static SaveRawMesh(StaticMesh: StaticMesh,SourceModelIndex: number,InMesh?: JavascriptRawMesh): {InMesh: JavascriptRawMesh};
	static SetSectionInfo(StaticMesh: StaticMesh,LODIndex: number,SectionIndex: number,Info: MeshSectionInfo): void;
	static GetSectionFromStaticMesh(InMesh: StaticMesh,LODIndex: number,SectionIndex: number,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	static CopyMeshFromStaticMesh(FromStaticMeshAsset: StaticMesh,ToDynamicMesh: DynamicMesh,AssetOptions: GeometryScriptCopyMeshFromAssetOptions,RequestedLOD: GeometryScriptMeshReadLOD,Outcome?: EGeometryScriptOutcomePins,Debug?: GeometryScriptDebug): {Outcome: EGeometryScriptOutcomePins, $: DynamicMesh};
	static GetSectionMaterialListFromStaticMesh(FromStaticMeshAsset: StaticMesh,RequestedLOD: GeometryScriptMeshReadLOD,MaterialList?: MaterialInterface[],MaterialIndex?: number[],Outcome?: EGeometryScriptOutcomePins,Debug?: GeometryScriptDebug): {MaterialList: MaterialInterface[], MaterialIndex: number[], Outcome: EGeometryScriptOutcomePins};
	static SetStaticMeshCollisionFromComponent(StaticMeshAsset: StaticMesh,SourceComponent: PrimitiveComponent,Options: GeometryScriptSetSimpleCollisionOptions,Debug: GeometryScriptDebug): void;
	static AddSimpleCollisions(StaticMesh: StaticMesh,ShapeType: EScriptCollisionShapeType): number;
	static AddSimpleCollisionsWithNotification(StaticMesh: StaticMesh,ShapeType: EScriptCollisionShapeType,bApplyChanges: boolean): number;
	static AddUVChannel(StaticMesh: StaticMesh,LODIndex: number): boolean;
	static EnableSectionCastShadow(StaticMesh: StaticMesh,bCastShadow: boolean,LODIndex: number,SectionIndex: number): void;
	static EnableSectionCollision(StaticMesh: StaticMesh,bCollisionEnabled: boolean,LODIndex: number,SectionIndex: number): void;
	static GenerateBoxUVChannel(StaticMesh: StaticMesh,LODIndex: number,UVChannelIndex: number,position: Vector,Orientation: Rotator,Size: Vector): boolean;
	static GenerateCylindricalUVChannel(StaticMesh: StaticMesh,LODIndex: number,UVChannelIndex: number,position: Vector,Orientation: Rotator,Tiling: Vector2D): boolean;
	static GeneratePlanarUVChannel(StaticMesh: StaticMesh,LODIndex: number,UVChannelIndex: number,position: Vector,Orientation: Rotator,Tiling: Vector2D): boolean;
	static GetCollisionComplexity(StaticMesh: StaticMesh): ECollisionTraceFlag;
	static GetConvexCollisionCount(StaticMesh: StaticMesh): number;
	static GetLodBuildSettings(StaticMesh: StaticMesh,LODIndex: number,OutBuildOptions?: MeshBuildSettings): {OutBuildOptions: MeshBuildSettings};
	static GetLodCount(StaticMesh: StaticMesh): number;
	static GetLodReductionSettings(StaticMesh: StaticMesh,LODIndex: number,OutReductionOptions?: MeshReductionSettings): {OutReductionOptions: MeshReductionSettings};
	static GetLodScreenSizes(StaticMesh: StaticMesh): number[];
	static GetNumberMaterials(StaticMesh: StaticMesh): number;
	static GetNumberVerts(StaticMesh: StaticMesh,LODIndex: number): number;
	static GetNumUVChannels(StaticMesh: StaticMesh,LODIndex: number): number;
	static GetSimpleCollisionCount(StaticMesh: StaticMesh): number;
	static HasVertexColors(StaticMesh: StaticMesh): boolean;
	static ImportLOD(BaseStaticMesh: StaticMesh,LODIndex: number,SourceFilename: string): number;
	static InsertUVChannel(StaticMesh: StaticMesh,LODIndex: number,UVChannelIndex: number): boolean;
	static IsSectionCollisionEnabled(StaticMesh: StaticMesh,LODIndex: number,SectionIndex: number): boolean;
	static ReimportAllCustomLODs(StaticMesh: StaticMesh): boolean;
	static RemoveCollisions(StaticMesh: StaticMesh): boolean;
	static RemoveCollisionsWithNotification(StaticMesh: StaticMesh,bApplyChanges: boolean): boolean;
	static RemoveLods(StaticMesh: StaticMesh): boolean;
	static RemoveUVChannel(StaticMesh: StaticMesh,LODIndex: number,UVChannelIndex: number): boolean;
	static SetAllowCPUAccess(StaticMesh: StaticMesh,bAllowCPUAccess: boolean): void;
	static SetConvexDecompositionCollisions(StaticMesh: StaticMesh,HullCount: number,MaxHullVerts: number,HullPrecision: number): boolean;
	static SetConvexDecompositionCollisionsWithNotification(StaticMesh: StaticMesh,HullCount: number,MaxHullVerts: number,HullPrecision: number,bApplyChanges: boolean): boolean;
	static SetGenerateLightmapUVs(StaticMesh: StaticMesh,bGenerateLightmapUVs: boolean): boolean;
	static SetLodBuildSettings(StaticMesh: StaticMesh,LODIndex: number,BuildOptions: MeshBuildSettings): void;
	static SetLodFromStaticMesh(DestinationStaticMesh: StaticMesh,DestinationLodIndex: number,SourceStaticMesh: StaticMesh,SourceLodIndex: number,bReuseExistingMaterialSlots: boolean): number;
	static SetLodReductionSettings(StaticMesh: StaticMesh,LODIndex: number,ReductionOptions: MeshReductionSettings): void;
	static SetLods(StaticMesh: StaticMesh,ReductionOptions: StaticMeshReductionOptions): number;
	static SetLodsWithNotification(StaticMesh: StaticMesh,ReductionOptions: StaticMeshReductionOptions,bApplyChanges: boolean): number;
}

declare class CameraComponent extends SceneComponent { 
	FieldOfView: number;
	OrthoWidth: number;
	OrthoNearClipPlane: number;
	OrthoFarClipPlane: number;
	AspectRatio: number;
	bConstrainAspectRatio: boolean;
	bUseFieldOfViewForLOD: boolean;
	bDrawFrustumAllowed: boolean;
	bCameraMeshHiddenInGame: boolean;
	bLockToHmd: boolean;
	bUsePawnControlRotation: boolean;
	ProjectionMode: ECameraProjectionMode;
	CameraMesh: StaticMesh;
	PostProcessBlendWeight: number;
	PostProcessSettings: PostProcessSettings;
	bUseControllerViewRotation: boolean;
	static Load(ResourceName: string): CameraComponent;
	static Find(Outer: UObject, ResourceName: string): CameraComponent;
	static GetDefaultObject(): CameraComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraComponent;
	SetUseFieldOfViewForLOD(bInUseFieldOfViewForLOD: boolean): void;
	SetProjectionMode(InProjectionMode: ECameraProjectionMode): void;
	SetPostProcessBlendWeight(InPostProcessBlendWeight: number): void;
	SetOrthoWidth(InOrthoWidth: number): void;
	SetOrthoNearClipPlane(InOrthoNearClipPlane: number): void;
	SetOrthoFarClipPlane(InOrthoFarClipPlane: number): void;
	SetFieldOfView(InFieldOfView: number): void;
	SetConstraintAspectRatio(bInConstrainAspectRatio: boolean): void;
	SetAspectRatio(InAspectRatio: number): void;
	OnCameraMeshHiddenChanged(): void;
	GetFilmbackText(): string;
	GetCameraView(DeltaTime: number,DesiredView?: MinimalViewInfo): {DesiredView: MinimalViewInfo};
	static C(Other: UObject | any): CameraComponent;
}

declare class CameraActor extends Actor { 
	AutoActivateForPlayer: EAutoReceiveInput;
	CameraComponent: CameraComponent;
	SceneComponent: SceneComponent;
	bConstrainAspectRatio: boolean;
	AspectRatio: number;
	FOVAngle: number;
	PostProcessBlendWeight: number;
	PostProcessSettings: PostProcessSettings;
	static GetDefaultObject(): CameraActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraActor;
	GetAutoActivatePlayerIndex(): number;
	static C(Other: UObject | any): CameraActor;
	DrawDebugCamera(CameraColor: LinearColor,Duration: number): void;
	static DrawDebugCamera(CameraActor: CameraActor,CameraColor: LinearColor,Duration: number): void;
}

declare type EAttachmentRule = 'KeepRelative' | 'KeepWorld' | 'SnapToTarget' | 'EAttachmentRule_MAX';
declare var EAttachmentRule : { KeepRelative:'KeepRelative',KeepWorld:'KeepWorld',SnapToTarget:'SnapToTarget',EAttachmentRule_MAX:'EAttachmentRule_MAX', };
declare class FXSystemAsset extends UObject { 
	MaxPoolSize: any;
	PoolPrimeSize: any;
	static Load(ResourceName: string): FXSystemAsset;
	static Find(Outer: UObject, ResourceName: string): FXSystemAsset;
	static GetDefaultObject(): FXSystemAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FXSystemAsset;
	static C(Other: UObject | any): FXSystemAsset;
}

declare class FXSystemComponent extends PrimitiveComponent { 
	static Load(ResourceName: string): FXSystemComponent;
	static Find(Outer: UObject, ResourceName: string): FXSystemComponent;
	static GetDefaultObject(): FXSystemComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FXSystemComponent;
	SetVectorParameter(ParameterName: string,Param: Vector): void;
	SetUseAutoManageAttachment(bAutoManage: boolean): void;
	SetIntParameter(ParameterName: string,Param: number): void;
	SetFloatParameter(ParameterName: string,Param: number): void;
	SetEmitterEnable(EmitterName: string,bNewEnableState: boolean): void;
	SetColorParameter(ParameterName: string,Param: LinearColor): void;
	SetBoolParameter(ParameterName: string,Param: boolean): void;
	SetAutoAttachmentParameters(Parent: SceneComponent,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule): void;
	SetActorParameter(ParameterName: string,Param: Actor): void;
	ReleaseToPool(): void;
	GetFXSystemAsset(): FXSystemAsset;
	static C(Other: UObject | any): FXSystemComponent;
}

declare type EEmitterRenderMode = 'ERM_Normal' | 'ERM_Point' | 'ERM_Cross' | 'ERM_LightsOnly' | 'ERM_None' | 'ERM_MAX';
declare var EEmitterRenderMode : { ERM_Normal:'ERM_Normal',ERM_Point:'ERM_Point',ERM_Cross:'ERM_Cross',ERM_LightsOnly:'ERM_LightsOnly',ERM_None:'ERM_None',ERM_MAX:'ERM_MAX', };
declare type EParticleSignificanceLevel = 'Low' | 'Medium' | 'High' | 'Critical' | 'Num' | 'EParticleSignificanceLevel_MAX';
declare var EParticleSignificanceLevel : { Low:'Low',Medium:'Medium',High:'High',Critical:'Critical',Num:'Num',EParticleSignificanceLevel_MAX:'EParticleSignificanceLevel_MAX', };
declare type EDetailMode = 'DM_Low' | 'DM_Medium' | 'DM_High' | 'DM_MAX';
declare var EDetailMode : { DM_Low:'DM_Low',DM_Medium:'DM_Medium',DM_High:'DM_High',DM_MAX:'DM_MAX', };
declare class ParticleModule extends UObject { 
	bSpawnModule: boolean;
	bUpdateModule: boolean;
	bFinalUpdateModule: boolean;
	bUpdateForGPUEmitter: boolean;
	bCurvesAsColor: boolean;
	b3DDrawMode: boolean;
	bSupported3DDrawMode: boolean;
	bEnabled: boolean;
	bEditable: boolean;
	LODDuplicate: boolean;
	bSupportsRandomSeed: boolean;
	bRequiresLoopingNotification: boolean;
	LODValidity: number;
	ModuleEditorColor: Color;
	static Load(ResourceName: string): ParticleModule;
	static Find(Outer: UObject, ResourceName: string): ParticleModule;
	static GetDefaultObject(): ParticleModule;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModule;
	static C(Other: UObject | any): ParticleModule;
}

declare type EParticleScreenAlignment = 'PSA_FacingCameraPosition' | 'PSA_Square' | 'PSA_Rectangle' | 'PSA_Velocity' | 'PSA_AwayFromCenter' | 'PSA_TypeSpecific' | 'PSA_FacingCameraDistanceBlend' | 'PSA_MAX';
declare var EParticleScreenAlignment : { PSA_FacingCameraPosition:'PSA_FacingCameraPosition',PSA_Square:'PSA_Square',PSA_Rectangle:'PSA_Rectangle',PSA_Velocity:'PSA_Velocity',PSA_AwayFromCenter:'PSA_AwayFromCenter',PSA_TypeSpecific:'PSA_TypeSpecific',PSA_FacingCameraDistanceBlend:'PSA_FacingCameraDistanceBlend',PSA_MAX:'PSA_MAX', };
declare type EParticleSortMode = 'PSORTMODE_None' | 'PSORTMODE_ViewProjDepth' | 'PSORTMODE_DistanceToView' | 'PSORTMODE_Age_OldestFirst' | 'PSORTMODE_Age_NewestFirst' | 'PSORTMODE_MAX';
declare var EParticleSortMode : { PSORTMODE_None:'PSORTMODE_None',PSORTMODE_ViewProjDepth:'PSORTMODE_ViewProjDepth',PSORTMODE_DistanceToView:'PSORTMODE_DistanceToView',PSORTMODE_Age_OldestFirst:'PSORTMODE_Age_OldestFirst',PSORTMODE_Age_NewestFirst:'PSORTMODE_Age_NewestFirst',PSORTMODE_MAX:'PSORTMODE_MAX', };
declare class DistributionLookupTable { 
	TimeScale: number;
	TimeBias: number;
	Values: number[];
	Op: number;
	EntryCount: number;
	EntryStride: number;
	SubEntryStride: number;
	LockFlag: number;
	clone() : DistributionLookupTable;
	static C(Other: UObject | any): DistributionLookupTable;
}

declare class RawDistribution { 
	Table: DistributionLookupTable;
	clone() : RawDistribution;
	static C(Other: UObject | any): RawDistribution;
}

declare class Distribution extends UObject { 
	static Load(ResourceName: string): Distribution;
	static Find(Outer: UObject, ResourceName: string): Distribution;
	static GetDefaultObject(): Distribution;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Distribution;
	static C(Other: UObject | any): Distribution;
}

declare class DistributionFloat extends Distribution { 
	bCanBeBaked: boolean;
	bBakedDataSuccesfully: boolean;
	static Load(ResourceName: string): DistributionFloat;
	static Find(Outer: UObject, ResourceName: string): DistributionFloat;
	static GetDefaultObject(): DistributionFloat;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionFloat;
	static C(Other: UObject | any): DistributionFloat;
}

declare class RawDistributionFloat extends RawDistribution { 
	MinValue: number;
	MaxValue: number;
	Distribution: DistributionFloat;
	clone() : RawDistributionFloat;
	static C(Other: UObject | any): RawDistributionFloat;
}

declare class ParticleBurst { 
	Count: number;
	CountLow: number;
	Time: number;
	clone() : ParticleBurst;
	static C(Other: UObject | any): ParticleBurst;
}

declare type EParticleSubUVInterpMethod = 'PSUVIM_None' | 'PSUVIM_Linear' | 'PSUVIM_Linear_Blend' | 'PSUVIM_Random' | 'PSUVIM_Random_Blend' | 'PSUVIM_MAX';
declare var EParticleSubUVInterpMethod : { PSUVIM_None:'PSUVIM_None',PSUVIM_Linear:'PSUVIM_Linear',PSUVIM_Linear_Blend:'PSUVIM_Linear_Blend',PSUVIM_Random:'PSUVIM_Random',PSUVIM_Random_Blend:'PSUVIM_Random_Blend',PSUVIM_MAX:'PSUVIM_MAX', };
declare type EParticleBurstMethod = 'EPBM_Instant' | 'EPBM_Interpolated' | 'EPBM_MAX';
declare var EParticleBurstMethod : { EPBM_Instant:'EPBM_Instant',EPBM_Interpolated:'EPBM_Interpolated',EPBM_MAX:'EPBM_MAX', };
declare type EOpacitySourceMode = 'OSM_Alpha' | 'OSM_ColorBrightness' | 'OSM_RedChannel' | 'OSM_GreenChannel' | 'OSM_BlueChannel' | 'OSM_MAX';
declare var EOpacitySourceMode : { OSM_Alpha:'OSM_Alpha',OSM_ColorBrightness:'OSM_ColorBrightness',OSM_RedChannel:'OSM_RedChannel',OSM_GreenChannel:'OSM_GreenChannel',OSM_BlueChannel:'OSM_BlueChannel',OSM_MAX:'OSM_MAX', };
declare type EEmitterNormalsMode = 'ENM_CameraFacing' | 'ENM_Spherical' | 'ENM_Cylindrical' | 'ENM_MAX';
declare var EEmitterNormalsMode : { ENM_CameraFacing:'ENM_CameraFacing',ENM_Spherical:'ENM_Spherical',ENM_Cylindrical:'ENM_Cylindrical',ENM_MAX:'ENM_MAX', };
declare type EParticleUVFlipMode = 'None' | 'FlipUV' | 'FlipUOnly' | 'FlipVOnly' | 'RandomFlipUV' | 'RandomFlipUOnly' | 'RandomFlipVOnly' | 'RandomFlipUVIndependent' | 'EParticleUVFlipMode_MAX';
declare var EParticleUVFlipMode : { None:'None',FlipUV:'FlipUV',FlipUOnly:'FlipUOnly',FlipVOnly:'FlipVOnly',RandomFlipUV:'RandomFlipUV',RandomFlipUOnly:'RandomFlipUOnly',RandomFlipVOnly:'RandomFlipVOnly',RandomFlipUVIndependent:'RandomFlipUVIndependent',EParticleUVFlipMode_MAX:'EParticleUVFlipMode_MAX', };
declare type ESubUVBoundingVertexCount = 'BVC_FourVertices' | 'BVC_EightVertices' | 'BVC_MAX';
declare var ESubUVBoundingVertexCount : { BVC_FourVertices:'BVC_FourVertices',BVC_EightVertices:'BVC_EightVertices',BVC_MAX:'BVC_MAX', };
declare class ParticleModuleRequired extends ParticleModule { 
	Material: MaterialInterface;
	MinFacingCameraBlendDistance: number;
	MaxFacingCameraBlendDistance: number;
	EmitterOrigin: Vector;
	EmitterRotation: Rotator;
	ScreenAlignment: EParticleScreenAlignment;
	bUseLocalSpace: boolean;
	bKillOnDeactivate: boolean;
	bKillOnCompleted: boolean;
	SortMode: EParticleSortMode;
	bUseLegacyEmitterTime: boolean;
	bRemoveHMDRoll: boolean;
	bSupportLargeWorldCoordinates: boolean;
	bEmitterDurationUseRange: boolean;
	EmitterDuration: number;
	SpawnRate: RawDistributionFloat;
	BurstList: ParticleBurst[];
	EmitterDelay: number;
	EmitterDelayLow: number;
	bDelayFirstLoopOnly: boolean;
	InterpolationMethod: EParticleSubUVInterpMethod;
	bScaleUV: boolean;
	bEmitterDelayUseRange: boolean;
	ParticleBurstMethod: EParticleBurstMethod;
	bOverrideSystemMacroUV: boolean;
	bUseMaxDrawCount: boolean;
	OpacitySourceMode: EOpacitySourceMode;
	EmitterNormalsMode: EEmitterNormalsMode;
	bOrbitModuleAffectsVelocityAlignment: boolean;
	SubImages_Horizontal: number;
	SubImages_Vertical: number;
	RandomImageTime: number;
	RandomImageChanges: number;
	MacroUVPosition: Vector;
	MacroUVRadius: number;
	UVFlippingMode: EParticleUVFlipMode;
	BoundingMode: ESubUVBoundingVertexCount;
	bDurationRecalcEachLoop: boolean;
	NormalsSphereCenter: Vector;
	AlphaThreshold: number;
	EmitterLoops: number;
	CutoutTexture: Texture2D;
	MaxDrawCount: number;
	EmitterDurationLow: number;
	NormalsCylinderDirection: Vector;
	NamedMaterialOverrides: string[];
	static Load(ResourceName: string): ParticleModuleRequired;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRequired;
	static GetDefaultObject(): ParticleModuleRequired;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRequired;
	static C(Other: UObject | any): ParticleModuleRequired;
}

declare class ParticleModuleTypeDataBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleTypeDataBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataBase;
	static GetDefaultObject(): ParticleModuleTypeDataBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataBase;
	static C(Other: UObject | any): ParticleModuleTypeDataBase;
}

declare class ParticleModuleSpawnBase extends ParticleModule { 
	bProcessSpawnRate: boolean;
	bProcessBurstList: boolean;
	static Load(ResourceName: string): ParticleModuleSpawnBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSpawnBase;
	static GetDefaultObject(): ParticleModuleSpawnBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSpawnBase;
	static C(Other: UObject | any): ParticleModuleSpawnBase;
}

declare class ParticleModuleSpawn extends ParticleModuleSpawnBase { 
	Rate: RawDistributionFloat;
	RateScale: RawDistributionFloat;
	ParticleBurstMethod: EParticleBurstMethod;
	BurstList: ParticleBurst[];
	BurstScale: RawDistributionFloat;
	bApplyGlobalSpawnRateScale: boolean;
	static Load(ResourceName: string): ParticleModuleSpawn;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSpawn;
	static GetDefaultObject(): ParticleModuleSpawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSpawn;
	static C(Other: UObject | any): ParticleModuleSpawn;
}

declare class ParticleModuleEventBase extends ParticleModule { 
	static Load(ResourceName: string): ParticleModuleEventBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventBase;
	static GetDefaultObject(): ParticleModuleEventBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventBase;
	static C(Other: UObject | any): ParticleModuleEventBase;
}

declare type EParticleEventType = 'EPET_Any' | 'EPET_Spawn' | 'EPET_Death' | 'EPET_Collision' | 'EPET_Burst' | 'EPET_Blueprint' | 'EPET_MAX';
declare var EParticleEventType : { EPET_Any:'EPET_Any',EPET_Spawn:'EPET_Spawn',EPET_Death:'EPET_Death',EPET_Collision:'EPET_Collision',EPET_Burst:'EPET_Burst',EPET_Blueprint:'EPET_Blueprint',EPET_MAX:'EPET_MAX', };
declare class ParticleModuleEventSendToGame extends UObject { 
	static Load(ResourceName: string): ParticleModuleEventSendToGame;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventSendToGame;
	static GetDefaultObject(): ParticleModuleEventSendToGame;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventSendToGame;
	static C(Other: UObject | any): ParticleModuleEventSendToGame;
}

declare class ParticleEvent_GenerateInfo { 
	Type: EParticleEventType;
	Frequency: number;
	ParticleFrequency: number;
	FirstTimeOnly: boolean;
	LastTimeOnly: boolean;
	UseReflectedImpactVector: boolean;
	bUseOrbitOffset: boolean;
	CustomName: string;
	ParticleModuleEventsToSendToGame: ParticleModuleEventSendToGame[];
	clone() : ParticleEvent_GenerateInfo;
	static C(Other: UObject | any): ParticleEvent_GenerateInfo;
}

declare class ParticleModuleEventGenerator extends ParticleModuleEventBase { 
	Events: ParticleEvent_GenerateInfo[];
	static Load(ResourceName: string): ParticleModuleEventGenerator;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventGenerator;
	static GetDefaultObject(): ParticleModuleEventGenerator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventGenerator;
	static C(Other: UObject | any): ParticleModuleEventGenerator;
}

declare class ParticleModuleOrbitBase extends ParticleModule { 
	bUseEmitterTime: boolean;
	static Load(ResourceName: string): ParticleModuleOrbitBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleOrbitBase;
	static GetDefaultObject(): ParticleModuleOrbitBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrbitBase;
	static C(Other: UObject | any): ParticleModuleOrbitBase;
}

declare type EOrbitChainMode = 'EOChainMode_Add' | 'EOChainMode_Scale' | 'EOChainMode_Link' | 'EOChainMode_MAX';
declare var EOrbitChainMode : { EOChainMode_Add:'EOChainMode_Add',EOChainMode_Scale:'EOChainMode_Scale',EOChainMode_Link:'EOChainMode_Link',EOChainMode_MAX:'EOChainMode_MAX', };
declare class DistributionVector extends Distribution { 
	bCanBeBaked: boolean;
	bIsDirty: boolean;
	bBakedDataSuccesfully: boolean;
	static Load(ResourceName: string): DistributionVector;
	static Find(Outer: UObject, ResourceName: string): DistributionVector;
	static GetDefaultObject(): DistributionVector;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionVector;
	static C(Other: UObject | any): DistributionVector;
}

declare class RawDistributionVector extends RawDistribution { 
	MinValue: number;
	MaxValue: number;
	MinValueVec: Vector;
	MaxValueVec: Vector;
	Distribution: DistributionVector;
	clone() : RawDistributionVector;
	static C(Other: UObject | any): RawDistributionVector;
}

declare class OrbitOptions { 
	bProcessDuringSpawn: boolean;
	bProcessDuringUpdate: boolean;
	bUseEmitterTime: boolean;
	clone() : OrbitOptions;
	static C(Other: UObject | any): OrbitOptions;
}

declare class ParticleModuleOrbit extends ParticleModuleOrbitBase { 
	ChainMode: EOrbitChainMode;
	OffsetAmount: RawDistributionVector;
	OffsetOptions: OrbitOptions;
	RotationAmount: RawDistributionVector;
	RotationOptions: OrbitOptions;
	RotationRateAmount: RawDistributionVector;
	RotationRateOptions: OrbitOptions;
	static Load(ResourceName: string): ParticleModuleOrbit;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleOrbit;
	static GetDefaultObject(): ParticleModuleOrbit;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrbit;
	static C(Other: UObject | any): ParticleModuleOrbit;
}

declare class ParticleModuleEventReceiverBase extends ParticleModuleEventBase { 
	EventGeneratorType: EParticleEventType;
	EventName: string;
	static Load(ResourceName: string): ParticleModuleEventReceiverBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventReceiverBase;
	static GetDefaultObject(): ParticleModuleEventReceiverBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventReceiverBase;
	static C(Other: UObject | any): ParticleModuleEventReceiverBase;
}

declare class ParticleLODLevel extends UObject { 
	Level: number;
	bEnabled: boolean;
	RequiredModule: ParticleModuleRequired;
	Modules: ParticleModule[];
	TypeDataModule: ParticleModuleTypeDataBase;
	SpawnModule: ParticleModuleSpawn;
	EventGenerator: ParticleModuleEventGenerator;
	SpawningModules: ParticleModuleSpawnBase[];
	SpawnModules: ParticleModule[];
	UpdateModules: ParticleModule[];
	OrbitModules: ParticleModuleOrbit[];
	EventReceiverModules: ParticleModuleEventReceiverBase[];
	ConvertedModules: boolean;
	PeakActiveParticles: number;
	static Load(ResourceName: string): ParticleLODLevel;
	static Find(Outer: UObject, ResourceName: string): ParticleLODLevel;
	static GetDefaultObject(): ParticleLODLevel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleLODLevel;
	static C(Other: UObject | any): ParticleLODLevel;
}

declare class ParticleEmitter extends UObject { 
	EmitterName: string;
	SubUVDataOffset: number;
	EmitterRenderMode: EEmitterRenderMode;
	SignificanceLevel: EParticleSignificanceLevel;
	bUseLegacySpawningBehavior: boolean;
	ConvertedModules: boolean;
	bIsSoloing: boolean;
	bCookedOut: boolean;
	bDisabledLODsKeepEmitterAlive: boolean;
	bDisableWhenInsignficant: boolean;
	bCollapsed: boolean;
	DetailMode: EDetailMode;
	EmitterEditorColor: Color;
	LODLevels: ParticleLODLevel[];
	PeakActiveParticles: number;
	InitialAllocationCount: number;
	QualityLevelSpawnRateScale: number;
	DetailModeBitmask: any;
	DetailModeDisplay: string;
	static Load(ResourceName: string): ParticleEmitter;
	static Find(Outer: UObject, ResourceName: string): ParticleEmitter;
	static GetDefaultObject(): ParticleEmitter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleEmitter;
	static C(Other: UObject | any): ParticleEmitter;
}

declare class CurveEdEntry { 
	CurveObject: UObject;
	CurveColor: Color;
	CurveName: string;
	bHideCurve: number;
	bColorCurve: number;
	bFloatingPointColorCurve: number;
	bClamp: number;
	ClampLow: number;
	ClampHigh: number;
	clone() : CurveEdEntry;
	static C(Other: UObject | any): CurveEdEntry;
}

declare class CurveEdTab { 
	TabName: string;
	Curves: CurveEdEntry[];
	ViewStartInput: number;
	ViewEndInput: number;
	ViewStartOutput: number;
	ViewEndOutput: number;
	clone() : CurveEdTab;
	static C(Other: UObject | any): CurveEdTab;
}

declare class InterpCurveEdSetup extends UObject { 
	Tabs: CurveEdTab[];
	ActiveTab: number;
	static Load(ResourceName: string): InterpCurveEdSetup;
	static Find(Outer: UObject, ResourceName: string): InterpCurveEdSetup;
	static GetDefaultObject(): InterpCurveEdSetup;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpCurveEdSetup;
	static C(Other: UObject | any): InterpCurveEdSetup;
}

declare class ParticleSystemLOD { 
	clone() : ParticleSystemLOD;
	static C(Other: UObject | any): ParticleSystemLOD;
}

declare type EParticleSystemUpdateMode = 'EPSUM_RealTime' | 'EPSUM_FixedTime' | 'EPSUM_MAX';
declare var EParticleSystemUpdateMode : { EPSUM_RealTime:'EPSUM_RealTime',EPSUM_FixedTime:'EPSUM_FixedTime',EPSUM_MAX:'EPSUM_MAX', };
declare type ParticleSystemLODMethod = 'PARTICLESYSTEMLODMETHOD_Automatic' | 'PARTICLESYSTEMLODMETHOD_DirectSet' | 'PARTICLESYSTEMLODMETHOD_ActivateAutomatic' | 'PARTICLESYSTEMLODMETHOD_MAX';
declare var ParticleSystemLODMethod : { PARTICLESYSTEMLODMETHOD_Automatic:'PARTICLESYSTEMLODMETHOD_Automatic',PARTICLESYSTEMLODMETHOD_DirectSet:'PARTICLESYSTEMLODMETHOD_DirectSet',PARTICLESYSTEMLODMETHOD_ActivateAutomatic:'PARTICLESYSTEMLODMETHOD_ActivateAutomatic',PARTICLESYSTEMLODMETHOD_MAX:'PARTICLESYSTEMLODMETHOD_MAX', };
declare type EParticleSystemInsignificanceReaction = 'Auto' | 'Complete' | 'DisableTick' | 'DisableTickAndKill' | 'Num' | 'EParticleSystemInsignificanceReaction_MAX';
declare var EParticleSystemInsignificanceReaction : { Auto:'Auto',Complete:'Complete',DisableTick:'DisableTick',DisableTickAndKill:'DisableTickAndKill',Num:'Num',EParticleSystemInsignificanceReaction_MAX:'EParticleSystemInsignificanceReaction_MAX', };
declare type EParticleSystemOcclusionBoundsMethod = 'EPSOBM_None' | 'EPSOBM_ParticleBounds' | 'EPSOBM_CustomBounds' | 'EPSOBM_MAX';
declare var EParticleSystemOcclusionBoundsMethod : { EPSOBM_None:'EPSOBM_None',EPSOBM_ParticleBounds:'EPSOBM_ParticleBounds',EPSOBM_CustomBounds:'EPSOBM_CustomBounds',EPSOBM_MAX:'EPSOBM_MAX', };
declare class LODSoloTrack { 
	SoloEnableSetting: number[];
	clone() : LODSoloTrack;
	static C(Other: UObject | any): LODSoloTrack;
}

declare class NamedEmitterMaterial { 
	Name: string;
	Material: MaterialInterface;
	clone() : NamedEmitterMaterial;
	static C(Other: UObject | any): NamedEmitterMaterial;
}

declare type EPSCPoolMethod = 'None' | 'AutoRelease' | 'ManualRelease' | 'ManualRelease_OnComplete' | 'FreeInPool' | 'EPSCPoolMethod_MAX';
declare var EPSCPoolMethod : { None:'None',AutoRelease:'AutoRelease',ManualRelease:'ManualRelease',ManualRelease_OnComplete:'ManualRelease_OnComplete',FreeInPool:'FreeInPool',EPSCPoolMethod_MAX:'EPSCPoolMethod_MAX', };
declare class ParticleSystem extends FXSystemAsset { 
	UpdateTime_FPS: number;
	UpdateTime_Delta: number;
	WarmupTime: number;
	WarmupTickRate: number;
	Emitters: ParticleEmitter[];
	PreviewComponent: ParticleSystemComponent;
	ThumbnailAngle: Rotator;
	ThumbnailDistance: number;
	ThumbnailWarmup: number;
	CurveEdSetup: InterpCurveEdSetup;
	LODDistanceCheckTime: number;
	MacroUVRadius: number;
	LODDistances: number[];
	EditorLODSetting: number;
	LODSettings: ParticleSystemLOD[];
	FixedRelativeBoundingBox: Box;
	SecondsBeforeInactive: number;
	FloorMesh: string;
	FloorPosition: Vector;
	FloorRotation: Rotator;
	FloorScale: number;
	FloorScale3D: Vector;
	BackgroundColor: Color;
	Delay: number;
	DelayLow: number;
	bOrientZAxisTowardCamera: boolean;
	bUseFixedRelativeBoundingBox: boolean;
	bShouldResetPeakCounts: boolean;
	bHasPhysics: boolean;
	bUseRealtimeThumbnail: boolean;
	ThumbnailImageOutOfDate: boolean;
	ThumbnailImage: Texture2D;
	bUseDelayRange: boolean;
	bAllowManagedTicking: boolean;
	bAutoDeactivate: boolean;
	bRegenerateLODDuplicate: boolean;
	SystemUpdateMode: EParticleSystemUpdateMode;
	LODMethod: ParticleSystemLODMethod;
	InsignificantReaction: EParticleSystemInsignificanceReaction;
	OcclusionBoundsMethod: EParticleSystemOcclusionBoundsMethod;
	MaxSignificanceLevel: EParticleSignificanceLevel;
	MinTimeBetweenTicks: any;
	InsignificanceDelay: number;
	MacroUVPosition: Vector;
	CustomOcclusionBounds: Box;
	SoloTracking: LODSoloTrack[];
	NamedMaterialSlots: NamedEmitterMaterial[];
	static Load(ResourceName: string): ParticleSystem;
	static Find(Outer: UObject, ResourceName: string): ParticleSystem;
	static GetDefaultObject(): ParticleSystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystem;
	ContainsEmitterType(TypeData: UnrealEngineClass): boolean;
	static C(Other: UObject | any): ParticleSystem;
	SpawnEmitterAttached(AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,Scale: Vector,LocationType: EAttachLocation,bAutoDestroy: boolean,PoolingMethod: EPSCPoolMethod,bAutoActivate: boolean): ParticleSystemComponent;
	static SpawnEmitterAttached(EmitterTemplate: ParticleSystem,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,Scale: Vector,LocationType: EAttachLocation,bAutoDestroy: boolean,PoolingMethod: EPSCPoolMethod,bAutoActivate: boolean): ParticleSystemComponent;
}

declare type EParticleSysParamType = 'PSPT_None' | 'PSPT_Scalar' | 'PSPT_ScalarRand' | 'PSPT_Vector' | 'PSPT_VectorRand' | 'PSPT_Color' | 'PSPT_Actor' | 'PSPT_Material' | 'PSPT_VectorUnitRand' | 'PSPT_MAX';
declare var EParticleSysParamType : { PSPT_None:'PSPT_None',PSPT_Scalar:'PSPT_Scalar',PSPT_ScalarRand:'PSPT_ScalarRand',PSPT_Vector:'PSPT_Vector',PSPT_VectorRand:'PSPT_VectorRand',PSPT_Color:'PSPT_Color',PSPT_Actor:'PSPT_Actor',PSPT_Material:'PSPT_Material',PSPT_VectorUnitRand:'PSPT_VectorUnitRand',PSPT_MAX:'PSPT_MAX', };
declare class ParticleSysParam { 
	Name: string;
	ParamType: EParticleSysParamType;
	Scalar: number;
	Scalar_Low: number;
	Vector: Vector;
	Vector_Low: Vector;
	Color: Color;
	Actor: Actor;
	Material: MaterialInterface;
	clone() : ParticleSysParam;
	static C(Other: UObject | any): ParticleSysParam;
}

declare class ParticleSystemReplay extends UObject { 
	ClipIDNumber: number;
	static Load(ResourceName: string): ParticleSystemReplay;
	static Find(Outer: UObject, ResourceName: string): ParticleSystemReplay;
	static GetDefaultObject(): ParticleSystemReplay;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystemReplay;
	static C(Other: UObject | any): ParticleSystemReplay;
}

declare type ETrailWidthMode = 'ETrailWidthMode_FromCentre' | 'ETrailWidthMode_FromFirst' | 'ETrailWidthMode_FromSecond' | 'ETrailWidthMode_MAX';
declare var ETrailWidthMode : { ETrailWidthMode_FromCentre:'ETrailWidthMode_FromCentre',ETrailWidthMode_FromFirst:'ETrailWidthMode_FromFirst',ETrailWidthMode_FromSecond:'ETrailWidthMode_FromSecond',ETrailWidthMode_MAX:'ETrailWidthMode_MAX', };
declare class ParticleSystemComponent extends FXSystemComponent { 
	Template: ParticleSystem;
	EmitterMaterials: MaterialInterface[];
	SkelMeshComponents: SkeletalMeshComponent[];
	bResetOnDetach: boolean;
	bUpdateOnDedicatedServer: boolean;
	bAllowRecycling: boolean;
	bAutoManageAttachment: boolean;
	bAutoAttachWeldSimulatedBodies: boolean;
	bWarmingUp: boolean;
	bOverrideLODMethod: boolean;
	bSkipUpdateDynamicDataDuringTick: boolean;
	LODMethod: ParticleSystemLODMethod;
	RequiredSignificance: EParticleSignificanceLevel;
	InstanceParameters: ParticleSysParam[];
	OnParticleSpawn: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, Location: Vector, Velocity: Vector) => void>;
	OnParticleBurst: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
	OnParticleDeath: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector) => void>;
	OnParticleCollide: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector, Normal: Vector, BoneName: string, PhysMat: PhysicalMaterial) => void>;
	bOldPositionValid: boolean;
	OldPosition: Vector;
	PartSysVelocity: Vector;
	WarmupTime: number;
	WarmupTickRate: number;
	SecondsBeforeInactive: number;
	MaxTimeBeforeForceUpdateTransform: number;
	EditorLODLevel: number;
	EditorDetailMode: number;
	ReplayClips: ParticleSystemReplay[];
	CustomTimeDilation: number;
	AutoAttachParent: any;
	AutoAttachSocketName: string;
	AutoAttachLocationType: EAttachLocation;
	AutoAttachLocationRule: EAttachmentRule;
	AutoAttachRotationRule: EAttachmentRule;
	AutoAttachScaleRule: EAttachmentRule;
	OnSystemFinished: UnrealEngineMulticastDelegate<(PSystem: ParticleSystemComponent) => void>;
	static Load(ResourceName: string): ParticleSystemComponent;
	static Find(Outer: UObject, ResourceName: string): ParticleSystemComponent;
	static GetDefaultObject(): ParticleSystemComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystemComponent;
	SetTrailSourceData(InFirstSocketName: string,InSecondSocketName: string,InWidthMode: ETrailWidthMode,InWidth: number): void;
	SetTemplate(NewTemplate: ParticleSystem): void;
	SetMaterialParameter(ParameterName: string,Param: MaterialInterface): void;
	SetBeamTargetTangent(EmitterIndex: number,NewTangentPoint: Vector,TargetIndex: number): void;
	SetBeamTargetStrength(EmitterIndex: number,NewTargetStrength: number,TargetIndex: number): void;
	SetBeamTargetPoint(EmitterIndex: number,NewTargetPoint: Vector,TargetIndex: number): void;
	SetBeamSourceTangent(EmitterIndex: number,NewTangentPoint: Vector,SourceIndex: number): void;
	SetBeamSourceStrength(EmitterIndex: number,NewSourceStrength: number,SourceIndex: number): void;
	SetBeamSourcePoint(EmitterIndex: number,NewSourcePoint: Vector,SourceIndex: number): void;
	SetBeamEndPoint(EmitterIndex: number,NewEndPoint: Vector): void;
	SetAutoAttachParams(Parent: SceneComponent,SocketName: string,LocationType: EAttachLocation): void;
	GetNumActiveParticles(): number;
	GetNamedMaterial(InName: string): MaterialInterface;
	GetBeamTargetTangent(EmitterIndex: number,TargetIndex: number,OutTangentPoint?: Vector): {OutTangentPoint: Vector, $: boolean};
	GetBeamTargetStrength(EmitterIndex: number,TargetIndex: number,OutTargetStrength?: number): {OutTargetStrength: number, $: boolean};
	GetBeamTargetPoint(EmitterIndex: number,TargetIndex: number,OutTargetPoint?: Vector): {OutTargetPoint: Vector, $: boolean};
	GetBeamSourceTangent(EmitterIndex: number,SourceIndex: number,OutTangentPoint?: Vector): {OutTangentPoint: Vector, $: boolean};
	GetBeamSourceStrength(EmitterIndex: number,SourceIndex: number,OutSourceStrength?: number): {OutSourceStrength: number, $: boolean};
	GetBeamSourcePoint(EmitterIndex: number,SourceIndex: number,OutSourcePoint?: Vector): {OutSourcePoint: Vector, $: boolean};
	GetBeamEndPoint(EmitterIndex: number,OutEndPoint?: Vector): {OutEndPoint: Vector, $: boolean};
	GenerateParticleEvent(InEventName: string,InEmitterTime: number,InLocation: Vector,InDirection: Vector,InVelocity: Vector): void;
	EndTrails(): void;
	CreateNamedDynamicMaterialInstance(InName: string,SourceMaterial: MaterialInterface): MaterialInstanceDynamic;
	BeginTrails(InFirstSocketName: string,InSecondSocketName: string,InWidthMode: ETrailWidthMode,InWidth: number): void;
	static C(Other: UObject | any): ParticleSystemComponent;
}

declare class ArrowComponent extends PrimitiveComponent { 
	ArrowColor: Color;
	ArrowSize: number;
	ArrowLength: number;
	ScreenSize: number;
	bIsScreenSizeScaled: boolean;
	bTreatAsASprite: boolean;
	SpriteCategoryName: string;
	SpriteInfo: SpriteCategoryInfo;
	bLightAttachment: boolean;
	bUseInEditorScaling: boolean;
	static Load(ResourceName: string): ArrowComponent;
	static Find(Outer: UObject, ResourceName: string): ArrowComponent;
	static GetDefaultObject(): ArrowComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArrowComponent;
	SetArrowColor(NewColor: LinearColor): void;
	static C(Other: UObject | any): ArrowComponent;
}

declare class Emitter extends Actor { 
	ParticleSystemComponent: ParticleSystemComponent;
	bDestroyOnSystemFinish: boolean;
	bPostUpdateTickGroup: boolean;
	bCurrentlyActive: boolean;
	OnParticleSpawn: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, Location: Vector, Velocity: Vector) => void>;
	OnParticleBurst: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
	OnParticleDeath: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector) => void>;
	OnParticleCollide: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector, Normal: Vector, BoneName: string, PhysMat: PhysicalMaterial) => void>;
	SpriteComponent: BillboardComponent;
	ArrowComponent: ArrowComponent;
	static GetDefaultObject(): Emitter;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Emitter;
	ToggleActive(): void;
	SetVectorParameter(ParameterName: string,Param: Vector): void;
	SetTemplate(NewTemplate: ParticleSystem): void;
	SetMaterialParameter(ParameterName: string,Param: MaterialInterface): void;
	SetFloatParameter(ParameterName: string,Param: number): void;
	SetColorParameter(ParameterName: string,Param: LinearColor): void;
	SetActorParameter(ParameterName: string,Param: Actor): void;
	OnRep_bCurrentlyActive(): void;
	OnParticleSystemFinished(FinishedComponent: ParticleSystemComponent): void;
	IsActive(): boolean;
	Deactivate(): void;
	Activate(): void;
	static C(Other: UObject | any): Emitter;
}

declare class EmitterCameraLensEffectBase extends Emitter { 
	PS_CameraEffect: ParticleSystem;
	BaseCamera: PlayerCameraManager;
	RelativeTransform: Transform;
	BaseFOV: number;
	bAllowMultipleInstances: boolean;
	bResetWhenRetriggered: boolean;
	EmittersToTreatAsSame: UnrealEngineClass[];
	DistFromCamera: number;
	static GetDefaultObject(): EmitterCameraLensEffectBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EmitterCameraLensEffectBase;
	static C(Other: UObject | any): EmitterCameraLensEffectBase;
}

declare class PlayerCameraManager extends Actor { 
	PCOwner: PlayerController;
	TransformComponent: SceneComponent;
	DefaultFOV: number;
	DefaultOrthoWidth: number;
	DefaultAspectRatio: number;
	CameraCache: CameraCacheEntry;
	LastFrameCameraCache: CameraCacheEntry;
	ViewTarget: TViewTarget;
	PendingViewTarget: TViewTarget;
	CameraCachePrivate: CameraCacheEntry;
	LastFrameCameraCachePrivate: CameraCacheEntry;
	ModifierList: CameraModifier[];
	DefaultModifiers: UnrealEngineClass[];
	FreeCamDistance: number;
	FreeCamOffset: Vector;
	ViewTargetOffset: Vector;
	OnAudioFadeChangeEvent: UnrealEngineMulticastDelegate<(bFadeOut: boolean, FadeTime: number) => void>;
	CameraLensEffects: any[];
	CachedCameraShakeMod: CameraModifier_CameraShake;
	AnimInstPool: CameraAnimInst;
	PostProcessBlendCache: PostProcessSettings[];
	ActiveAnims: CameraAnimInst[];
	FreeAnims: CameraAnimInst[];
	AnimCameraActor: CameraActor;
	bIsOrthographic: boolean;
	bDefaultConstrainAspectRatio: boolean;
	bClientSimulatingViewTarget: boolean;
	bUseClientSideCameraUpdates: boolean;
	bGameCameraCutThisFrame: boolean;
	ViewPitchMin: number;
	ViewPitchMax: number;
	ViewYawMin: number;
	ViewYawMax: number;
	ViewRollMin: number;
	ViewRollMax: number;
	ServerUpdateCameraTimeout: number;
	static GetDefaultObject(): PlayerCameraManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerCameraManager;
	SwapPendingViewTargetWhenUsingClientSideCameraUpdates(): void;
	StopCameraShake(ShakeInstance: CameraShakeBase,bImmediately: boolean): void;
	StopCameraFade(): void;
	StopCameraAnimInst(AnimInst: CameraAnimInst,bImmediate: boolean): void;
	StopAllInstancesOfCameraShakeFromSource(Shake: UnrealEngineClass,SourceComponent: CameraShakeSourceComponent,bImmediately: boolean): void;
	StopAllInstancesOfCameraShake(Shake: UnrealEngineClass,bImmediately: boolean): void;
	StopAllInstancesOfCameraAnim(Anim: CameraAnim,bImmediate: boolean): void;
	StopAllCameraShakesFromSource(SourceComponent: CameraShakeSourceComponent,bImmediately: boolean): void;
	StopAllCameraShakes(bImmediately: boolean): void;
	StopAllCameraAnims(bImmediate: boolean): void;
	StartCameraShakeFromSource(ShakeClass: UnrealEngineClass,SourceComponent: CameraShakeSourceComponent,Scale: number,PlaySpace: ECameraShakePlaySpace,UserPlaySpaceRot: Rotator): CameraShakeBase;
	StartCameraShake(ShakeClass: UnrealEngineClass,Scale: number,PlaySpace: ECameraShakePlaySpace,UserPlaySpaceRot: Rotator): CameraShakeBase;
	StartCameraFade(FromAlpha: number,ToAlpha: number,Duration: number,Color: LinearColor,bShouldFadeAudio: boolean,bHoldWhenFinished: boolean): void;
	SetManualCameraFade(InFadeAmount: number,Color: LinearColor,bInFadeAudio: boolean): void;
	SetGameCameraCutThisFrame(): void;
	RemoveCameraModifier(ModifierToRemove: CameraModifier): boolean;
	RemoveCameraLensEffect(Emitter: EmitterCameraLensEffectBase): void;
	PlayCameraAnim(Anim: CameraAnim,Rate: number,Scale: number,BlendInTime: number,BlendOutTime: number,bLoop: boolean,bRandomStartTime: boolean,Duration: number,PlaySpace: ECameraShakePlaySpace,UserPlaySpaceRot: Rotator): CameraAnimInst;
	PhotographyCameraModify(NewCameraLocation: Vector,PreviousCameraLocation: Vector,OriginalCameraLocation: Vector,ResultCameraLocation?: Vector): {ResultCameraLocation: Vector};
	OnPhotographySessionStart(): void;
	OnPhotographySessionEnd(): void;
	OnPhotographyMultiPartCaptureStart(): void;
	OnPhotographyMultiPartCaptureEnd(): void;
	GetOwningPlayerController(): PlayerController;
	GetFOVAngle(): number;
	GetCameraRotation(): Rotator;
	GetCameraLocation(): Vector;
	FindCameraModifierByClass(ModifierClass: UnrealEngineClass): CameraModifier;
	ClearCameraLensEffects(): void;
	BlueprintUpdateCamera(CameraTarget: Actor,NewCameraLocation?: Vector,NewCameraRotation?: Rotator,NewCameraFOV?: number): {NewCameraLocation: Vector, NewCameraRotation: Rotator, NewCameraFOV: number, $: boolean};
	AddNewCameraModifier(ModifierClass: UnrealEngineClass): CameraModifier;
	AddCameraLensEffect(LensEffectEmitterClass: UnrealEngineClass): EmitterCameraLensEffectBase;
	static C(Other: UObject | any): PlayerCameraManager;
}

declare class DrawFrustumComponent extends PrimitiveComponent { 
	bFrustumEnabled: boolean;
	FrustumColor: Color;
	FrustumAngle: number;
	FrustumAspectRatio: number;
	FrustumStartDist: number;
	FrustumEndDist: number;
	Texture: Texture;
	static Load(ResourceName: string): DrawFrustumComponent;
	static Find(Outer: UObject, ResourceName: string): DrawFrustumComponent;
	static GetDefaultObject(): DrawFrustumComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DrawFrustumComponent;
	static C(Other: UObject | any): DrawFrustumComponent;
}

declare class DebugCameraController extends PlayerController { 
	bShowSelectedInfo: boolean;
	bIsFrozenRendering: boolean;
	bIsOrbitingSelectedActor: boolean;
	bOrbitPivotUseCenter: boolean;
	bEnableBufferVisualization: boolean;
	bEnableBufferVisualizationFullMode: boolean;
	bIsBufferVisualizationInputSetup: boolean;
	bLastDisplayEnabled: boolean;
	DrawFrustum: DrawFrustumComponent;
	SelectedActor: Actor;
	SelectedComponent: PrimitiveComponent;
	SelectedHitPoint: HitResult;
	OriginalControllerRef: PlayerController;
	OriginalPlayer: Player;
	SpeedScale: number;
	InitialMaxSpeed: number;
	InitialAccel: number;
	InitialDecel: number;
	static GetDefaultObject(): DebugCameraController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DebugCameraController;
	ToggleDisplay(): void;
	ShowDebugSelectedInfo(): void;
	SetPawnMovementSpeedScale(NewSpeedScale: number): void;
	ReceiveOnDeactivate(RestoredPC: PlayerController): void;
	ReceiveOnActorSelected(NewSelectedActor: Actor,SelectHitLocation: Vector,SelectHitNormal: Vector,Hit: HitResult): void;
	ReceiveOnActivate(OriginalPC: PlayerController): void;
	GetSelectedActor(): Actor;
	static C(Other: UObject | any): DebugCameraController;
}

declare class CheatManagerExtension extends UObject { 
	static Load(ResourceName: string): CheatManagerExtension;
	static Find(Outer: UObject, ResourceName: string): CheatManagerExtension;
	static GetDefaultObject(): CheatManagerExtension;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheatManagerExtension;
	GetPlayerController(): PlayerController;
	static C(Other: UObject | any): CheatManagerExtension;
}

declare class CheatManager extends UObject { 
	DebugCameraControllerRef: DebugCameraController;
	DebugCameraControllerClass: UnrealEngineClass;
	CheatManagerExtensions: CheatManagerExtension[];
	static Load(ResourceName: string): CheatManager;
	static Find(Outer: UObject, ResourceName: string): CheatManager;
	static GetDefaultObject(): CheatManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheatManager;
	Walk(): void;
	ViewSelf(): void;
	ViewPlayer(S: string): void;
	ViewClass(DesiredClass: UnrealEngineClass): void;
	ViewActor(ActorName: string): void;
	UpdateSafeArea(): void;
	ToggleServerStatReplicatorUpdateStatNet(): void;
	ToggleServerStatReplicatorClientOverwrite(): void;
	ToggleDebugCamera(): void;
	ToggleAILogging(): void;
	TestCollisionDistance(): void;
	Teleport(): void;
	Summon(ClassName: string): void;
	StreamLevelOut(PackageName: string): void;
	StreamLevelIn(PackageName: string): void;
	SpawnServerStatReplicator(): void;
	Slomo(NewTimeDilation: number): void;
	SetWorldOrigin(): void;
	SetMouseSensitivityToDefault(): void;
	ServerToggleAILogging(): void;
	ReceiveInitCheatManager(): void;
	ReceiveEndPlay(): void;
	PlayersOnly(): void;
	OnPlayerEndPlayed(Player: Actor,EndPlayReason: EEndPlayReason): void;
	OnlyLoadLevel(PackageName: string): void;
	LogLoc(): void;
	InvertMouse(): void;
	God(): void;
	Ghost(): void;
	GetPlayerController(): PlayerController;
	FreezeFrame(Delay: number): void;
	Fly(): void;
	FlushLog(): void;
	EnableDebugCamera(): void;
	DumpVoiceMutingState(): void;
	DumpPartyState(): void;
	DumpOnlineSessionState(): void;
	DumpChatState(): void;
	DisableDebugCamera(): void;
	DestroyTarget(): void;
	DestroyServerStatReplicator(): void;
	DestroyPawns(aClass: UnrealEngineClass): void;
	DestroyAllPawnsExceptTarget(): void;
	DestroyAll(aClass: UnrealEngineClass): void;
	DebugCapsuleSweepSize(HalfHeight: number,Radius: number): void;
	DebugCapsuleSweepPawn(): void;
	DebugCapsuleSweepComplex(bTraceComplex: boolean): void;
	DebugCapsuleSweepClear(): void;
	DebugCapsuleSweepChannel(Channel: ECollisionChannel): void;
	DebugCapsuleSweepCapture(): void;
	DebugCapsuleSweep(): void;
	DamageTarget(DamageAmount: number): void;
	CheatScript(ScriptName: string): void;
	ChangeSize(F: number): void;
	BugItStringCreator(ViewLocation: Vector,ViewRotation: Rotator,GoString?: string,LocString?: string): {GoString: string, LocString: string};
	BugItGo(X: number,Y: number,Z: number,Pitch: number,Yaw: number,Roll: number): void;
	BugIt(ScreenShotDescription: string): void;
	static C(Other: UObject | any): CheatManager;
}

declare class RuntimeFloatCurve { 
	EditorCurveData: RichCurve;
	ExternalCurve: CurveFloat;
	clone() : RuntimeFloatCurve;
	static C(Other: UObject | any): RuntimeFloatCurve;
}

declare class ForceFeedbackChannelDetails { 
	bAffectsLeftLarge: boolean;
	bAffectsLeftSmall: boolean;
	bAffectsRightLarge: boolean;
	bAffectsRightSmall: boolean;
	Curve: RuntimeFloatCurve;
	clone() : ForceFeedbackChannelDetails;
	static C(Other: UObject | any): ForceFeedbackChannelDetails;
}

declare type EAttenuationDistanceModel = 'Linear' | 'Logarithmic' | 'Inverse' | 'LogReverse' | 'NaturalSound' | 'Custom' | 'EAttenuationDistanceModel_MAX';
declare var EAttenuationDistanceModel : { Linear:'Linear',Logarithmic:'Logarithmic',Inverse:'Inverse',LogReverse:'LogReverse',NaturalSound:'NaturalSound',Custom:'Custom',EAttenuationDistanceModel_MAX:'EAttenuationDistanceModel_MAX', };
declare type EAttenuationShape = 'Sphere' | 'Capsule' | 'Box' | 'Cone' | 'EAttenuationShape_MAX';
declare var EAttenuationShape : { Sphere:'Sphere',Capsule:'Capsule',Box:'Box',Cone:'Cone',EAttenuationShape_MAX:'EAttenuationShape_MAX', };
declare type ENaturalSoundFalloffMode = 'Continues' | 'Silent' | 'Hold' | 'ENaturalSoundFalloffMode_MAX';
declare var ENaturalSoundFalloffMode : { Continues:'Continues',Silent:'Silent',Hold:'Hold',ENaturalSoundFalloffMode_MAX:'ENaturalSoundFalloffMode_MAX', };
declare class BaseAttenuationSettings { 
	DistanceAlgorithm: EAttenuationDistanceModel;
	AttenuationShape: EAttenuationShape;
	dBAttenuationAtMax: number;
	FalloffMode: ENaturalSoundFalloffMode;
	AttenuationShapeExtents: Vector;
	ConeOffset: number;
	FalloffDistance: number;
	ConeSphereRadius: number;
	ConeSphereFalloffDistance: number;
	CustomAttenuationCurve: RuntimeFloatCurve;
	clone() : BaseAttenuationSettings;
	static C(Other: UObject | any): BaseAttenuationSettings;
}

declare class ForceFeedbackAttenuationSettings extends BaseAttenuationSettings { 
	clone() : ForceFeedbackAttenuationSettings;
	static C(Other: UObject | any): ForceFeedbackAttenuationSettings;
}

declare class ForceFeedbackAttenuation extends UObject { 
	Attenuation: ForceFeedbackAttenuationSettings;
	static Load(ResourceName: string): ForceFeedbackAttenuation;
	static Find(Outer: UObject, ResourceName: string): ForceFeedbackAttenuation;
	static GetDefaultObject(): ForceFeedbackAttenuation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ForceFeedbackAttenuation;
	static C(Other: UObject | any): ForceFeedbackAttenuation;
}

declare class ForceFeedbackComponent extends SceneComponent { 
	ForceFeedbackEffect: ForceFeedbackEffect;
	bAutoDestroy: boolean;
	bStopWhenOwnerDestroyed: boolean;
	bLooping: boolean;
	bIgnoreTimeDilation: boolean;
	bOverrideAttenuation: boolean;
	IntensityMultiplier: number;
	AttenuationSettings: ForceFeedbackAttenuation;
	AttenuationOverrides: ForceFeedbackAttenuationSettings;
	OnForceFeedbackFinished: UnrealEngineMulticastDelegate<(ForceFeedbackComponent: ForceFeedbackComponent) => void>;
	static Load(ResourceName: string): ForceFeedbackComponent;
	static Find(Outer: UObject, ResourceName: string): ForceFeedbackComponent;
	static GetDefaultObject(): ForceFeedbackComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ForceFeedbackComponent;
	Stop(): void;
	SetIntensityMultiplier(NewIntensityMultiplier: number): void;
	SetForceFeedbackEffect(NewForceFeedbackEffect: ForceFeedbackEffect): void;
	Play(StartTime: number): void;
	BP_GetAttenuationSettingsToApply(OutAttenuationSettings?: ForceFeedbackAttenuationSettings): {OutAttenuationSettings: ForceFeedbackAttenuationSettings, $: boolean};
	AdjustAttenuation(InAttenuationSettings: ForceFeedbackAttenuationSettings): void;
	static C(Other: UObject | any): ForceFeedbackComponent;
}

declare class ForceFeedbackEffect extends UObject { 
	ChannelDetails: ForceFeedbackChannelDetails[];
	Duration: number;
	static Load(ResourceName: string): ForceFeedbackEffect;
	static Find(Outer: UObject, ResourceName: string): ForceFeedbackEffect;
	static GetDefaultObject(): ForceFeedbackEffect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ForceFeedbackEffect;
	static C(Other: UObject | any): ForceFeedbackEffect;
	SpawnForceFeedbackAttached(AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,bLooping: boolean,IntensityMultiplier: number,StartTime: number,AttenuationSettings: ForceFeedbackAttenuation,bAutoDestroy: boolean): ForceFeedbackComponent;
	static SpawnForceFeedbackAttached(ForceFeedbackEffect: ForceFeedbackEffect,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,bLooping: boolean,IntensityMultiplier: number,StartTime: number,AttenuationSettings: ForceFeedbackAttenuation,bAutoDestroy: boolean): ForceFeedbackComponent;
}

declare class ActiveForceFeedbackEffect { 
	ForceFeedbackEffect: ForceFeedbackEffect;
	clone() : ActiveForceFeedbackEffect;
	static C(Other: UObject | any): ActiveForceFeedbackEffect;
}

declare class ChildConnection extends NetConnection { 
	Parent: NetConnection;
	static Load(ResourceName: string): ChildConnection;
	static Find(Outer: UObject, ResourceName: string): ChildConnection;
	static GetDefaultObject(): ChildConnection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChildConnection;
	static C(Other: UObject | any): ChildConnection;
}

declare class Package extends UObject { 
	static Load(ResourceName: string): Package;
	static Find(Outer: UObject, ResourceName: string): Package;
	static GetDefaultObject(): Package;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Package;
	static C(Other: UObject | any): Package;
	DeletePackage(): boolean;
	FindWorldInPackage(): World;
	SavePackage(Filename: string): boolean;
	GetLongPackagePath(): string;
	HasAnyPackageFlags(Flags: number): boolean;
	LoadPackage(PackageName: string): Package;
	static DeletePackage(Package: Package): boolean;
	static FindWorldInPackage(Package: Package): World;
	static SavePackage(Package: Package,Filename: string): boolean;
	static GetLongPackagePath(InPackage: Package): string;
	static HasAnyPackageFlags(Package: Package,Flags: number): boolean;
	static LoadPackage(InOuter: Package,PackageName: string): Package;
}

declare class ChannelDefinition { 
	ChannelName: string;
	ClassName: string;
	ChannelClass: UnrealEngineClass;
	StaticChannelIndex: number;
	bTickOnCreate: boolean;
	bServerOpen: boolean;
	bClientOpen: boolean;
	bInitialServer: boolean;
	bInitialClient: boolean;
	clone() : ChannelDefinition;
	static C(Other: UObject | any): ChannelDefinition;
}

declare class Channel extends UObject { 
	Connection: NetConnection;
	static Load(ResourceName: string): Channel;
	static Find(Outer: UObject, ResourceName: string): Channel;
	static GetDefaultObject(): Channel;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Channel;
	static C(Other: UObject | any): Channel;
}

declare class ReplicationDriver extends UObject { 
	static Load(ResourceName: string): ReplicationDriver;
	static Find(Outer: UObject, ResourceName: string): ReplicationDriver;
	static GetDefaultObject(): ReplicationDriver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReplicationDriver;
	static C(Other: UObject | any): ReplicationDriver;
}

declare class NetDriver extends UObject { 
	NetConnectionClassName: string;
	ReplicationDriverClassName: string;
	MaxDownloadSize: number;
	bClampListenServerTickRate: boolean;
	NetServerMaxTickRate: number;
	MaxNetTickRate: number;
	MaxInternetClientRate: number;
	MaxClientRate: number;
	ServerTravelPause: number;
	SpawnPrioritySeconds: number;
	RelevantTimeout: number;
	KeepAliveTime: number;
	InitialConnectTimeout: number;
	ConnectionTimeout: number;
	TimeoutMultiplierForUnoptimizedBuilds: number;
	bNoTimeouts: boolean;
	bNeverApplyNetworkEmulationSettings: boolean;
	ServerConnection: NetConnection;
	ClientConnections: NetConnection[];
	RecentlyDisconnectedTrackingTime: number;
	World: World;
	WorldPackage: Package;
	NetConnectionClass: UnrealEngineClass;
	ReplicationDriverClass: UnrealEngineClass;
	NetDriverName: string;
	ChannelDefinitions: ChannelDefinition[];
	ChannelDefinitionMap: any;
	ActorChannelPool: Channel[];
	ReplicationDriver: ReplicationDriver;
	static Load(ResourceName: string): NetDriver;
	static Find(Outer: UObject, ResourceName: string): NetDriver;
	static GetDefaultObject(): NetDriver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetDriver;
	static C(Other: UObject | any): NetDriver;
}

declare class UniqueNetIdWrapper { 
	clone() : UniqueNetIdWrapper;
	static C(Other: UObject | any): UniqueNetIdWrapper;
}

declare class UniqueNetIdRepl extends UniqueNetIdWrapper { 
	ReplicationBytes: number[];
	clone() : UniqueNetIdRepl;
	static C(Other: UObject | any): UniqueNetIdRepl;
}

declare class NetConnection extends Player { 
	Children: ChildConnection[];
	Driver: NetDriver;
	PackageMapClass: UnrealEngineClass;
	PackageMap: PackageMap;
	OpenChannels: Channel[];
	SentTemporaries: Actor[];
	ViewTarget: Actor;
	OwningActor: Actor;
	MaxPacket: number;
	InternalAck: boolean;
	PlayerId: UniqueNetIdRepl;
	LastReceiveTime: any;
	ChannelsToTick: Channel[];
	static Load(ResourceName: string): NetConnection;
	static Find(Outer: UObject, ResourceName: string): NetConnection;
	static GetDefaultObject(): NetConnection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetConnection;
	static C(Other: UObject | any): NetConnection;
}

declare type EMouseCursor = 'None' | 'Default' | 'TextEditBeam' | 'ResizeLeftRight' | 'ResizeUpDown' | 'ResizeSouthEast' | 'ResizeSouthWest' | 'CardinalCross' | 'Crosshairs' | 'Hand' | 'GrabHand' | 'GrabHandClosed' | 'SlashedCircle' | 'EyeDropper' | 'EMouseCursor_MAX';
declare var EMouseCursor : { None:'None',Default:'Default',TextEditBeam:'TextEditBeam',ResizeLeftRight:'ResizeLeftRight',ResizeUpDown:'ResizeUpDown',ResizeSouthEast:'ResizeSouthEast',ResizeSouthWest:'ResizeSouthWest',CardinalCross:'CardinalCross',Crosshairs:'Crosshairs',Hand:'Hand',GrabHand:'GrabHand',GrabHandClosed:'GrabHandClosed',SlashedCircle:'SlashedCircle',EyeDropper:'EyeDropper',EMouseCursor_MAX:'EMouseCursor_MAX', };
declare class TouchInputControl { 
	Image1: Texture2D;
	Image2: Texture2D;
	Center: Vector2D;
	VisualSize: Vector2D;
	ThumbSize: Vector2D;
	InteractionSize: Vector2D;
	InputScale: Vector2D;
	MainInputKey: Key;
	AltInputKey: Key;
	clone() : TouchInputControl;
	static C(Other: UObject | any): TouchInputControl;
}

declare class TouchInterface extends UObject { 
	Controls: TouchInputControl[];
	ActiveOpacity: number;
	InactiveOpacity: number;
	TimeUntilDeactive: number;
	TimeUntilReset: number;
	ActivationDelay: number;
	bPreventRecenter: boolean;
	StartupDelay: number;
	static Load(ResourceName: string): TouchInterface;
	static Find(Outer: UObject, ResourceName: string): TouchInterface;
	static GetDefaultObject(): TouchInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TouchInterface;
	static C(Other: UObject | any): TouchInterface;
}

declare type EPlaneConstraintAxisSetting = 'Custom' | 'X' | 'Y' | 'Z' | 'UseGlobalPhysicsSetting' | 'EPlaneConstraintAxisSetting_MAX';
declare var EPlaneConstraintAxisSetting : { Custom:'Custom',X:'X',Y:'Y',Z:'Z',UseGlobalPhysicsSetting:'UseGlobalPhysicsSetting',EPlaneConstraintAxisSetting_MAX:'EPlaneConstraintAxisSetting_MAX', };
declare class PhysicsVolume extends Volume { 
	TerminalVelocity: number;
	Priority: number;
	FluidFriction: number;
	bWaterVolume: boolean;
	bPhysicsOnContact: boolean;
	static GetDefaultObject(): PhysicsVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsVolume;
	static C(Other: UObject | any): PhysicsVolume;
}

declare class MovementComponent extends ActorComponent { 
	UpdatedComponent: SceneComponent;
	UpdatedPrimitive: PrimitiveComponent;
	Velocity: Vector;
	PlaneConstraintNormal: Vector;
	PlaneConstraintOrigin: Vector;
	bUpdateOnlyIfRendered: boolean;
	bAutoUpdateTickRegistration: boolean;
	bTickBeforeOwner: boolean;
	bAutoRegisterUpdatedComponent: boolean;
	bConstrainToPlane: boolean;
	bSnapToPlaneAtStart: boolean;
	bAutoRegisterPhysicsVolumeUpdates: boolean;
	bComponentShouldUpdatePhysicsVolume: boolean;
	PlaneConstraintAxisSetting: EPlaneConstraintAxisSetting;
	static Load(ResourceName: string): MovementComponent;
	static Find(Outer: UObject, ResourceName: string): MovementComponent;
	static GetDefaultObject(): MovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovementComponent;
	StopMovementImmediately(): void;
	SnapUpdatedComponentToPlane(): void;
	SetUpdatedComponent(NewUpdatedComponent: SceneComponent): void;
	SetPlaneConstraintOrigin(PlaneOrigin: Vector): void;
	SetPlaneConstraintNormal(PlaneNormal: Vector): void;
	SetPlaneConstraintFromVectors(Forward: Vector,Up: Vector): void;
	SetPlaneConstraintEnabled(bEnabled: boolean): void;
	SetPlaneConstraintAxisSetting(NewAxisSetting: EPlaneConstraintAxisSetting): void;
	PhysicsVolumeChanged(NewVolume: PhysicsVolume): void;
	K2_MoveUpdatedComponent(Delta: Vector,NewRotation: Rotator,OutHit?: HitResult,bSweep?: boolean,bTeleport?: boolean): {OutHit: HitResult, $: boolean};
	IsExceedingMaxSpeed(MaxSpeed: number): boolean;
	GetPlaneConstraintOrigin(): Vector;
	GetPlaneConstraintNormal(): Vector;
	GetPlaneConstraintAxisSetting(): EPlaneConstraintAxisSetting;
	GetPhysicsVolume(): PhysicsVolume;
	GetMaxSpeed(): number;
	GetGravityZ(): number;
	ConstrainNormalToPlane(Normal: Vector): Vector;
	ConstrainLocationToPlane(Location: Vector): Vector;
	ConstrainDirectionToPlane(Direction: Vector): Vector;
	static C(Other: UObject | any): MovementComponent;
}

declare class MovementProperties { 
	bCanCrouch: boolean;
	bCanJump: boolean;
	bCanWalk: boolean;
	bCanSwim: boolean;
	bCanFly: boolean;
	clone() : MovementProperties;
	static C(Other: UObject | any): MovementProperties;
}

declare class NavAgentProperties extends MovementProperties { 
	AgentRadius: number;
	AgentHeight: number;
	AgentStepHeight: number;
	NavWalkingSearchHeightScale: number;
	PreferredNavData: SoftClassPath;
	clone() : NavAgentProperties;
	static C(Other: UObject | any): NavAgentProperties;
}

declare class NavMovementComponent extends MovementComponent { 
	NavAgentProps: NavAgentProperties;
	FixedPathBrakingDistance: number;
	bUpdateNavAgentWithOwnersCollision: boolean;
	bUseAccelerationForPaths: boolean;
	bUseFixedBrakingDistanceForPaths: boolean;
	MovementState: MovementProperties;
	PathFollowingComp: UObject;
	static Load(ResourceName: string): NavMovementComponent;
	static Find(Outer: UObject, ResourceName: string): NavMovementComponent;
	static GetDefaultObject(): NavMovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavMovementComponent;
	StopMovementKeepPathing(): void;
	StopActiveMovement(): void;
	IsSwimming(): boolean;
	IsMovingOnGround(): boolean;
	IsFlying(): boolean;
	IsFalling(): boolean;
	IsCrouching(): boolean;
	static C(Other: UObject | any): NavMovementComponent;
}

declare class PawnMovementComponent extends NavMovementComponent { 
	PawnOwner: Pawn;
	static Load(ResourceName: string): PawnMovementComponent;
	static Find(Outer: UObject, ResourceName: string): PawnMovementComponent;
	static GetDefaultObject(): PawnMovementComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnMovementComponent;
	IsMoveInputIgnored(): boolean;
	GetPendingInputVector(): Vector;
	GetPawnOwner(): Pawn;
	GetLastInputVector(): Vector;
	ConsumeInputVector(): Vector;
	AddInputVector(WorldVector: Vector,bForce: boolean): void;
	static C(Other: UObject | any): PawnMovementComponent;
}

declare class SphereComponent extends ShapeComponent { 
	SphereRadius: number;
	static Load(ResourceName: string): SphereComponent;
	static Find(Outer: UObject, ResourceName: string): SphereComponent;
	static GetDefaultObject(): SphereComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SphereComponent;
	SetSphereRadius(InSphereRadius: number,bUpdateOverlaps: boolean): void;
	GetUnscaledSphereRadius(): number;
	GetShapeScale(): number;
	GetScaledSphereRadius(): number;
	static C(Other: UObject | any): SphereComponent;
}

declare class StaticMeshComponentLODInfo { 
	clone() : StaticMeshComponentLODInfo;
	static C(Other: UObject | any): StaticMeshComponentLODInfo;
}

declare class StreamingTextureBuildInfo { 
	PackedRelativeBox: any;
	TextureLevelIndex: number;
	TexelFactor: number;
	clone() : StreamingTextureBuildInfo;
	static C(Other: UObject | any): StreamingTextureBuildInfo;
}

declare class LightmassPrimitiveSettings { 
	bUseTwoSidedLighting: boolean;
	bShadowIndirectOnly: boolean;
	bUseEmissiveForStaticLighting: boolean;
	bUseVertexNormalForHemisphereGather: boolean;
	EmissiveLightFalloffExponent: number;
	EmissiveLightExplicitInfluenceRadius: number;
	EmissiveBoost: number;
	DiffuseBoost: number;
	FullyOccludedSamplesFraction: number;
	clone() : LightmassPrimitiveSettings;
	static C(Other: UObject | any): LightmassPrimitiveSettings;
}

declare class ProcMeshVertex { 
	position: Vector;
	Normal: Vector;
	Tangent: ProcMeshTangent;
	Color: Color;
	UV0: Vector2D;
	UV1: Vector2D;
	UV2: Vector2D;
	UV3: Vector2D;
	clone() : ProcMeshVertex;
	static C(Other: UObject | any): ProcMeshVertex;
}

declare class ProcMeshSection { 
	ProcVertexBuffer: ProcMeshVertex[];
	ProcIndexBuffer: any[];
	SectionLocalBox: Box;
	bEnableCollision: boolean;
	bSectionVisible: boolean;
	clone() : ProcMeshSection;
	static C(Other: UObject | any): ProcMeshSection;
}

declare type EProcMeshSliceCapOption = 'NoCap' | 'CreateNewSectionForCap' | 'UseLastSectionForCap' | 'EProcMeshSliceCapOption_MAX';
declare var EProcMeshSliceCapOption : { NoCap:'NoCap',CreateNewSectionForCap:'CreateNewSectionForCap',UseLastSectionForCap:'UseLastSectionForCap',EProcMeshSliceCapOption_MAX:'EProcMeshSliceCapOption_MAX', };
declare class ProceduralMeshComponent extends MeshComponent { 
	bUseComplexAsSimpleCollision: boolean;
	bUseAsyncCooking: boolean;
	ProcMeshBodySetup: BodySetup;
	ProcMeshSections: ProcMeshSection[];
	CollisionConvexElems: KConvexElem[];
	LocalBounds: BoxSphereBounds;
	AsyncBodySetupQueue: BodySetup[];
	static Load(ResourceName: string): ProceduralMeshComponent;
	static Find(Outer: UObject, ResourceName: string): ProceduralMeshComponent;
	static GetDefaultObject(): ProceduralMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralMeshComponent;
	UpdateMeshSection_LinearColor(SectionIndex: number,Vertices: Vector[],Normals: Vector[],UV0: Vector2D[],UV1: Vector2D[],UV2: Vector2D[],UV3: Vector2D[],VertexColors: LinearColor[],Tangents: ProcMeshTangent[]): void;
	UpdateMeshSection(SectionIndex: number,Vertices: Vector[],Normals: Vector[],UV0: Vector2D[],VertexColors: Color[],Tangents: ProcMeshTangent[]): void;
	SetMeshSectionVisible(SectionIndex: number,bNewVisibility: boolean): void;
	IsMeshSectionVisible(SectionIndex: number): boolean;
	GetNumSections(): number;
	CreateMeshSection_LinearColor(SectionIndex: number,Vertices: Vector[],Triangles: number[],Normals: Vector[],UV0: Vector2D[],UV1: Vector2D[],UV2: Vector2D[],UV3: Vector2D[],VertexColors: LinearColor[],Tangents: ProcMeshTangent[],bCreateCollision: boolean): void;
	CreateMeshSection(SectionIndex: number,Vertices: Vector[],Triangles: number[],Normals: Vector[],UV0: Vector2D[],VertexColors: Color[],Tangents: ProcMeshTangent[],bCreateCollision: boolean): void;
	ClearMeshSection(SectionIndex: number): void;
	ClearCollisionConvexMeshes(): void;
	ClearAllMeshSections(): void;
	AddCollisionConvexMesh(ConvexVerts: Vector[]): void;
	static C(Other: UObject | any): ProceduralMeshComponent;
	GetSectionFromProceduralMesh(SectionIndex: number,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	SliceProceduralMesh(PlanePosition: Vector,PlaneNormal: Vector,bCreateOtherHalf: boolean,OutOtherHalfProcMesh?: ProceduralMeshComponent,CapOption?: EProcMeshSliceCapOption,CapMaterial?: MaterialInterface): {OutOtherHalfProcMesh: ProceduralMeshComponent};
	static GetSectionFromProceduralMesh(InProcMesh: ProceduralMeshComponent,SectionIndex: number,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	static SliceProceduralMesh(InProcMesh: ProceduralMeshComponent,PlanePosition: Vector,PlaneNormal: Vector,bCreateOtherHalf: boolean,OutOtherHalfProcMesh?: ProceduralMeshComponent,CapOption?: EProcMeshSliceCapOption,CapMaterial?: MaterialInterface): {OutOtherHalfProcMesh: ProceduralMeshComponent};
}

declare type EVertexPaintAxis = 'X' | 'Y' | 'Z' | 'EVertexPaintAxis_MAX';
declare var EVertexPaintAxis : { X:'X',Y:'Y',Z:'Z',EVertexPaintAxis_MAX:'EVertexPaintAxis_MAX', };
declare class StaticMeshComponent extends MeshComponent { 
	ForcedLodModel: number;
	PreviousLODLevel: number;
	MinLOD: number;
	SubDivisionStepSize: number;
	StaticMesh: StaticMesh;
	WireframeColorOverride: Color;
	bEvaluateWorldPositionOffset: boolean;
	SelectedEditorSection: number;
	SelectedEditorMaterial: number;
	SectionIndexPreview: number;
	MaterialIndexPreview: number;
	StaticMeshImportVersion: number;
	bOverrideWireframeColor: boolean;
	bOverrideMinLOD: boolean;
	bOverrideNavigationExport: boolean;
	bForceNavigationObstacle: boolean;
	bDisallowMeshPaintPerInstance: boolean;
	bIgnoreInstanceForTextureStreaming: boolean;
	bOverrideLightMapRes: boolean;
	bCastDistanceFieldIndirectShadow: boolean;
	bOverrideDistanceFieldSelfShadowBias: boolean;
	bUseSubDivisions: boolean;
	bUseDefaultCollision: boolean;
	bCustomOverrideVertexColorPerLOD: boolean;
	bDisplayVertexColors: boolean;
	bDisplayPhysicalMaterialMasks: boolean;
	bDisplayNaniteFallbackMesh: boolean;
	bSortTriangles: boolean;
	bReverseCulling: boolean;
	OverriddenLightMapRes: number;
	DistanceFieldIndirectShadowMinVisibility: number;
	DistanceFieldSelfShadowBias: number;
	StreamingDistanceMultiplier: number;
	IrrelevantLights: Guid[];
	LODData: StaticMeshComponentLODInfo[];
	StreamingTextureData: StreamingTextureBuildInfo[];
	StaticMeshDerivedDataKey: string;
	MaterialStreamingRelativeBoxes: any[];
	LightmassSettings: LightmassPrimitiveSettings;
	static Load(ResourceName: string): StaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): StaticMeshComponent;
	static GetDefaultObject(): StaticMeshComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshComponent;
	SetStaticMesh(NewMesh: StaticMesh): boolean;
	SetReverseCulling(ReverseCulling: boolean): void;
	SetForcedLodModel(NewForcedLodModel: number): void;
	SetEvaluateWorldPositionOffsetInRayTracing(NewValue: boolean): void;
	SetDistanceFieldSelfShadowBias(NewValue: number): void;
	OnRep_StaticMesh(OldStaticMesh: StaticMesh): void;
	GetLocalBounds(Min?: Vector,Max?: Vector): {Min: Vector, Max: Vector};
	static C(Other: UObject | any): StaticMeshComponent;
	GetPhysicsBodySetupFromStaticMeshComponent(): BodySetup;
	CopyProceduralMeshFromStaticMeshComponent(LODIndex: number,ProcMeshComponent: ProceduralMeshComponent,bCreateCollision: boolean): void;
	HasInstanceVertexColors(): boolean;
	PaintVerticesLerpAlongAxis(StartColor: LinearColor,EndColor: LinearColor,Axis: EVertexPaintAxis,bConvertToSRGB: boolean): void;
	PaintVerticesSingleColor(FillColor: LinearColor,bConvertToSRGB: boolean): void;
	RemovePaintedVertices(): void;
	static GetPhysicsBodySetupFromStaticMeshComponent(InStaticMeshComp: StaticMeshComponent): BodySetup;
	static CopyProceduralMeshFromStaticMeshComponent(StaticMeshComponent: StaticMeshComponent,LODIndex: number,ProcMeshComponent: ProceduralMeshComponent,bCreateCollision: boolean): void;
	static HasInstanceVertexColors(StaticMeshComponent: StaticMeshComponent): boolean;
	static PaintVerticesLerpAlongAxis(StaticMeshComponent: StaticMeshComponent,StartColor: LinearColor,EndColor: LinearColor,Axis: EVertexPaintAxis,bConvertToSRGB: boolean): void;
	static PaintVerticesSingleColor(StaticMeshComponent: StaticMeshComponent,FillColor: LinearColor,bConvertToSRGB: boolean): void;
	static RemovePaintedVertices(StaticMeshComponent: StaticMeshComponent): void;
}

declare class DefaultPawn extends Pawn { 
	BaseTurnRate: number;
	BaseLookUpRate: number;
	MovementComponent: PawnMovementComponent;
	CollisionComponent: SphereComponent;
	MeshComponent: StaticMeshComponent;
	bAddDefaultMovementBindings: boolean;
	static GetDefaultObject(): DefaultPawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultPawn;
	TurnAtRate(Rate: number): void;
	MoveUp_World(val: number): void;
	MoveRight(val: number): void;
	MoveForward(val: number): void;
	LookUpAtRate(Rate: number): void;
	static C(Other: UObject | any): DefaultPawn;
}

declare class SpectatorPawn extends DefaultPawn { 
	static GetDefaultObject(): SpectatorPawn;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpectatorPawn;
	static C(Other: UObject | any): SpectatorPawn;
}

declare type EViewTargetBlendFunction = 'VTBlend_Linear' | 'VTBlend_Cubic' | 'VTBlend_EaseIn' | 'VTBlend_EaseOut' | 'VTBlend_EaseInOut' | 'VTBlend_PreBlended' | 'VTBlend_MAX';
declare var EViewTargetBlendFunction : { VTBlend_Linear:'VTBlend_Linear',VTBlend_Cubic:'VTBlend_Cubic',VTBlend_EaseIn:'VTBlend_EaseIn',VTBlend_EaseOut:'VTBlend_EaseOut',VTBlend_EaseInOut:'VTBlend_EaseInOut',VTBlend_PreBlended:'VTBlend_PreBlended',VTBlend_MAX:'VTBlend_MAX', };
declare class Visual extends UObject { 
	static Load(ResourceName: string): Visual;
	static Find(Outer: UObject, ResourceName: string): Visual;
	static GetDefaultObject(): Visual;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Visual;
	static C(Other: UObject | any): Visual;
}

declare class PanelWidget extends Widget { 
	Slots: PanelSlot[];
	static Load(ResourceName: string): PanelWidget;
	static Find(Outer: UObject, ResourceName: string): PanelWidget;
	static GetDefaultObject(): PanelWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PanelWidget;
	RemoveChildAt(index: number): boolean;
	RemoveChild(Content: Widget): boolean;
	HasChild(Content: Widget): boolean;
	HasAnyChildren(): boolean;
	GetChildrenCount(): number;
	GetChildIndex(Content: Widget): number;
	GetChildAt(index: number): Widget;
	GetAllChildren(): Widget[];
	ClearChildren(): void;
	AddChild(Content: Widget): PanelSlot;
	static C(Other: UObject | any): PanelWidget;
}

declare class PanelSlot extends Visual { 
	Parent: PanelWidget;
	Content: Widget;
	static Load(ResourceName: string): PanelSlot;
	static Find(Outer: UObject, ResourceName: string): PanelSlot;
	static GetDefaultObject(): PanelSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PanelSlot;
	static C(Other: UObject | any): PanelSlot;
}

declare type ESlateVisibility = 'Visible' | 'Collapsed' | 'Hidden' | 'HitTestInvisible' | 'SelfHitTestInvisible' | 'ESlateVisibility_MAX';
declare var ESlateVisibility : { Visible:'Visible',Collapsed:'Collapsed',Hidden:'Hidden',HitTestInvisible:'HitTestInvisible',SelfHitTestInvisible:'SelfHitTestInvisible',ESlateVisibility_MAX:'ESlateVisibility_MAX', };
declare class WidgetTransform { 
	Translation: Vector2D;
	Scale: Vector2D;
	Shear: Vector2D;
	Angle: number;
	clone() : WidgetTransform;
	static C(Other: UObject | any): WidgetTransform;
}

declare type EFlowDirectionPreference = 'Inherit' | 'Culture' | 'LeftToRight' | 'RightToLeft' | 'EFlowDirectionPreference_MAX';
declare var EFlowDirectionPreference : { Inherit:'Inherit',Culture:'Culture',LeftToRight:'LeftToRight',RightToLeft:'RightToLeft',EFlowDirectionPreference_MAX:'EFlowDirectionPreference_MAX', };
declare type ESlateAccessibleBehavior = 'NotAccessible' | 'Auto' | 'Summary' | 'Custom' | 'ToolTip' | 'ESlateAccessibleBehavior_MAX';
declare var ESlateAccessibleBehavior : { NotAccessible:'NotAccessible',Auto:'Auto',Summary:'Summary',Custom:'Custom',ToolTip:'ToolTip',ESlateAccessibleBehavior_MAX:'ESlateAccessibleBehavior_MAX', };
declare class SlateAccessibleWidgetData extends UObject { 
	bCanChildrenBeAccessible: boolean;
	AccessibleBehavior: ESlateAccessibleBehavior;
	AccessibleSummaryBehavior: ESlateAccessibleBehavior;
	AccessibleText: string;
	AccessibleTextDelegate: UnrealEngineDelegate<() => string>;
	AccessibleSummaryText: string;
	AccessibleSummaryTextDelegate: UnrealEngineDelegate<() => string>;
	static Load(ResourceName: string): SlateAccessibleWidgetData;
	static Find(Outer: UObject, ResourceName: string): SlateAccessibleWidgetData;
	static GetDefaultObject(): SlateAccessibleWidgetData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateAccessibleWidgetData;
	static C(Other: UObject | any): SlateAccessibleWidgetData;
}

declare type EWidgetClipping = 'Inherit' | 'ClipToBounds' | 'ClipToBoundsWithoutIntersecting' | 'ClipToBoundsAlways' | 'OnDemand' | 'EWidgetClipping_MAX';
declare var EWidgetClipping : { Inherit:'Inherit',ClipToBounds:'ClipToBounds',ClipToBoundsWithoutIntersecting:'ClipToBoundsWithoutIntersecting',ClipToBoundsAlways:'ClipToBoundsAlways',OnDemand:'OnDemand',EWidgetClipping_MAX:'EWidgetClipping_MAX', };
declare type EUINavigationRule = 'Escape' | 'Explicit' | 'Wrap' | 'Stop' | 'Custom' | 'CustomBoundary' | 'Invalid' | 'EUINavigationRule_MAX';
declare var EUINavigationRule : { Escape:'Escape',Explicit:'Explicit',Wrap:'Wrap',Stop:'Stop',Custom:'Custom',CustomBoundary:'CustomBoundary',Invalid:'Invalid',EUINavigationRule_MAX:'EUINavigationRule_MAX', };
declare type EUINavigation = 'Left' | 'Right' | 'Up' | 'Down' | 'Next' | 'Previous' | 'Num' | 'Invalid' | 'EUINavigation_MAX';
declare var EUINavigation : { Left:'Left',Right:'Right',Up:'Up',Down:'Down',Next:'Next',Previous:'Previous',Num:'Num',Invalid:'Invalid',EUINavigation_MAX:'EUINavigation_MAX', };
declare class WidgetNavigationData { 
	Rule: EUINavigationRule;
	WidgetToFocus: string;
	Widget: any;
	CustomDelegate: UnrealEngineDelegate<(Navigation: EUINavigation) => Widget>;
	clone() : WidgetNavigationData;
	static C(Other: UObject | any): WidgetNavigationData;
}

declare class WidgetNavigation extends UObject { 
	Up: WidgetNavigationData;
	Down: WidgetNavigationData;
	Left: WidgetNavigationData;
	Right: WidgetNavigationData;
	Next: WidgetNavigationData;
	Previous: WidgetNavigationData;
	static Load(ResourceName: string): WidgetNavigation;
	static Find(Outer: UObject, ResourceName: string): WidgetNavigation;
	static GetDefaultObject(): WidgetNavigation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetNavigation;
	static C(Other: UObject | any): WidgetNavigation;
}

declare class PropertyPathSegment { 
	Name: string;
	ArrayIndex: number;
	struct: Struct;
	clone() : PropertyPathSegment;
	static C(Other: UObject | any): PropertyPathSegment;
}

declare class CachedPropertyPath { 
	Segments: PropertyPathSegment[];
	CachedFunction: UFunction;
	clone() : CachedPropertyPath;
	static C(Other: UObject | any): CachedPropertyPath;
}

declare class DynamicPropertyPath extends CachedPropertyPath { 
	clone() : DynamicPropertyPath;
	static C(Other: UObject | any): DynamicPropertyPath;
}

declare class PropertyBinding extends UObject { 
	SourceObject: any;
	SourcePath: DynamicPropertyPath;
	DestinationProperty: string;
	static Load(ResourceName: string): PropertyBinding;
	static Find(Outer: UObject, ResourceName: string): PropertyBinding;
	static GetDefaultObject(): PropertyBinding;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyBinding;
	static C(Other: UObject | any): PropertyBinding;
}

declare class Geometry { 
	clone() : Geometry;
	static C(Other: UObject | any): Geometry;
	CenterOf(): Vector2D;
	FindClosestPointOnGeom(TestPoint: Vector2D): Vector2D;
	AbsoluteToLocal(AbsoluteCoordinate: Vector2D): Vector2D;
	GetAbsoluteSize(): Vector2D;
	GetLocalSize(): Vector2D;
	GetLocalTopLeft(): Vector2D;
	IsUnderLocation(AbsoluteCoordinate: Vector2D): boolean;
	LocalToAbsolute(LocalCoordinate: Vector2D): Vector2D;
	TransformScalarAbsoluteToLocal(AbsoluteScalar: number): number;
	TransformScalarLocalToAbsolute(LocalScalar: number): number;
	TransformVectorAbsoluteToLocal(AbsoluteVector: Vector2D): Vector2D;
	TransformVectorLocalToAbsolute(LocalVector: Vector2D): Vector2D;
	static CenterOf(Geom: Geometry): Vector2D;
	static FindClosestPointOnGeom(Geom: Geometry,TestPoint: Vector2D): Vector2D;
	static AbsoluteToLocal(Geometry: Geometry,AbsoluteCoordinate: Vector2D): Vector2D;
	static GetAbsoluteSize(Geometry: Geometry): Vector2D;
	static GetLocalSize(Geometry: Geometry): Vector2D;
	static GetLocalTopLeft(Geometry: Geometry): Vector2D;
	static IsUnderLocation(Geometry: Geometry,AbsoluteCoordinate: Vector2D): boolean;
	static LocalToAbsolute(Geometry: Geometry,LocalCoordinate: Vector2D): Vector2D;
	static TransformScalarAbsoluteToLocal(Geometry: Geometry,AbsoluteScalar: number): number;
	static TransformScalarLocalToAbsolute(Geometry: Geometry,LocalScalar: number): number;
	static TransformVectorAbsoluteToLocal(Geometry: Geometry,AbsoluteVector: Vector2D): Vector2D;
	static TransformVectorLocalToAbsolute(Geometry: Geometry,LocalVector: Vector2D): Vector2D;
}

declare class ScriptViewportClient extends UObject { 
	static Load(ResourceName: string): ScriptViewportClient;
	static Find(Outer: UObject, ResourceName: string): ScriptViewportClient;
	static GetDefaultObject(): ScriptViewportClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScriptViewportClient;
	static C(Other: UObject | any): ScriptViewportClient;
}

declare class Console extends UObject { 
	ConsoleTargetPlayer: LocalPlayer;
	DefaultTexture_Black: Texture2D;
	DefaultTexture_White: Texture2D;
	HistoryBuffer: string[];
	static Load(ResourceName: string): Console;
	static Find(Outer: UObject, ResourceName: string): Console;
	static GetDefaultObject(): Console;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Console;
	static C(Other: UObject | any): Console;
}

declare class DebugDisplayProperty { 
	Obj: UObject;
	WithinClass: UnrealEngineClass;
	clone() : DebugDisplayProperty;
	static C(Other: UObject | any): DebugDisplayProperty;
}

declare class OnlineSession extends UObject { 
	static Load(ResourceName: string): OnlineSession;
	static Find(Outer: UObject, ResourceName: string): OnlineSession;
	static GetDefaultObject(): OnlineSession;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineSession;
	static C(Other: UObject | any): OnlineSession;
}

declare type ETravelFailure = 'NoLevel' | 'LoadMapFailure' | 'InvalidURL' | 'PackageMissing' | 'PackageVersion' | 'NoDownload' | 'TravelFailure' | 'CheatCommands' | 'PendingNetGameCreateFailure' | 'CloudSaveFailure' | 'ServerTravelFailure' | 'ClientTravelFailure' | 'ETravelFailure_MAX';
declare var ETravelFailure : { NoLevel:'NoLevel',LoadMapFailure:'LoadMapFailure',InvalidURL:'InvalidURL',PackageMissing:'PackageMissing',PackageVersion:'PackageVersion',NoDownload:'NoDownload',TravelFailure:'TravelFailure',CheatCommands:'CheatCommands',PendingNetGameCreateFailure:'PendingNetGameCreateFailure',CloudSaveFailure:'CloudSaveFailure',ServerTravelFailure:'ServerTravelFailure',ClientTravelFailure:'ClientTravelFailure',ETravelFailure_MAX:'ETravelFailure_MAX', };
declare type ENetworkFailure = 'NetDriverAlreadyExists' | 'NetDriverCreateFailure' | 'NetDriverListenFailure' | 'ConnectionLost' | 'ConnectionTimeout' | 'FailureReceived' | 'OutdatedClient' | 'OutdatedServer' | 'PendingConnectionFailure' | 'NetGuidMismatch' | 'NetChecksumMismatch' | 'ENetworkFailure_MAX';
declare var ENetworkFailure : { NetDriverAlreadyExists:'NetDriverAlreadyExists',NetDriverCreateFailure:'NetDriverCreateFailure',NetDriverListenFailure:'NetDriverListenFailure',ConnectionLost:'ConnectionLost',ConnectionTimeout:'ConnectionTimeout',FailureReceived:'FailureReceived',OutdatedClient:'OutdatedClient',OutdatedServer:'OutdatedServer',PendingConnectionFailure:'PendingConnectionFailure',NetGuidMismatch:'NetGuidMismatch',NetChecksumMismatch:'NetChecksumMismatch',ENetworkFailure_MAX:'ENetworkFailure_MAX', };
declare class GameInstance extends UObject { 
	LocalPlayers: LocalPlayer[];
	OnlineSession: OnlineSession;
	ReferencedObjects: UObject[];
	OnPawnControllerChangedDelegates: UnrealEngineMulticastDelegate<(Pawn: Pawn, Controller: Controller) => void>;
	static Load(ResourceName: string): GameInstance;
	static Find(Outer: UObject, ResourceName: string): GameInstance;
	static GetDefaultObject(): GameInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameInstance;
	ReceiveShutdown(): void;
	ReceiveInit(): void;
	HandleTravelError(FailureType: ETravelFailure): void;
	HandleNetworkError(FailureType: ENetworkFailure,bIsServer: boolean): void;
	DebugRemovePlayer(ControllerId: number): void;
	DebugCreatePlayer(ControllerId: number): void;
	static C(Other: UObject | any): GameInstance;
}

declare class GameViewportClient extends ScriptViewportClient { 
	ViewportConsole: Console;
	DebugProperties: DebugDisplayProperty[];
	MaxSplitscreenPlayers: number;
	World: World;
	GameInstance: GameInstance;
	static Load(ResourceName: string): GameViewportClient;
	static Find(Outer: UObject, ResourceName: string): GameViewportClient;
	static GetDefaultObject(): GameViewportClient;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameViewportClient;
	SSSwapControllers(): void;
	ShowTitleSafeArea(): void;
	SetConsoleTarget(PlayerIndex: number): void;
	static C(Other: UObject | any): GameViewportClient;
}

declare type EAspectRatioAxisConstraint = 'AspectRatio_MaintainYFOV' | 'AspectRatio_MaintainXFOV' | 'AspectRatio_MajorAxisFOV' | 'AspectRatio_MAX';
declare var EAspectRatioAxisConstraint : { AspectRatio_MaintainYFOV:'AspectRatio_MaintainYFOV',AspectRatio_MaintainXFOV:'AspectRatio_MaintainXFOV',AspectRatio_MajorAxisFOV:'AspectRatio_MajorAxisFOV',AspectRatio_MAX:'AspectRatio_MAX', };
declare class LocalPlayer extends Player { 
	ViewportClient: GameViewportClient;
	AspectRatioAxisConstraint: EAspectRatioAxisConstraint;
	PendingLevelPlayerControllerClass: UnrealEngineClass;
	bSentSplitJoin: boolean;
	ControllerId: number;
	static Load(ResourceName: string): LocalPlayer;
	static Find(Outer: UObject, ResourceName: string): LocalPlayer;
	static GetDefaultObject(): LocalPlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalPlayer;
	static C(Other: UObject | any): LocalPlayer;
}

declare class JavascriptSlateWidget { 
	clone() : JavascriptSlateWidget;
	static C(Other: UObject | any): JavascriptSlateWidget;
	EditorAddModalWindow(): void;
	AddWindow(bShowImmediately: boolean): void;
	AddWindowAsNativeChild(RootWindow: JavascriptSlateWidget): void;
	ShowWindow(): void;
	static EditorAddModalWindow(Widget: JavascriptSlateWidget): void;
	static AddWindow(NewWindow: JavascriptSlateWidget,bShowImmediately: boolean): void;
	static AddWindowAsNativeChild(NewWindow: JavascriptSlateWidget,RootWindow: JavascriptSlateWidget): void;
	static ShowWindow(NewWindow: JavascriptSlateWidget): void;
	static CreateLogListingWidget(InLogName: string): JavascriptSlateWidget;
	static GetRootWindow(): JavascriptSlateWidget;
	static GetRootWindow(): JavascriptSlateWidget;
}

declare type EHorizontalAlignment = 'HAlign_Fill' | 'HAlign_Left' | 'HAlign_Center' | 'HAlign_Right' | 'HAlign_MAX';
declare var EHorizontalAlignment : { HAlign_Fill:'HAlign_Fill',HAlign_Left:'HAlign_Left',HAlign_Center:'HAlign_Center',HAlign_Right:'HAlign_Right',HAlign_MAX:'HAlign_MAX', };
declare type EVerticalAlignment = 'VAlign_Fill' | 'VAlign_Top' | 'VAlign_Center' | 'VAlign_Bottom' | 'VAlign_MAX';
declare var EVerticalAlignment : { VAlign_Fill:'VAlign_Fill',VAlign_Top:'VAlign_Top',VAlign_Center:'VAlign_Center',VAlign_Bottom:'VAlign_Bottom',VAlign_MAX:'VAlign_MAX', };
declare class BorderSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): BorderSlot;
	static Find(Outer: UObject, ResourceName: string): BorderSlot;
	static GetDefaultObject(): BorderSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BorderSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): BorderSlot;
}

declare class Anchors { 
	Minimum: Vector2D;
	Maximum: Vector2D;
	clone() : Anchors;
	static C(Other: UObject | any): Anchors;
}

declare class AnchorData { 
	Offsets: Margin;
	Anchors: Anchors;
	Alignment: Vector2D;
	clone() : AnchorData;
	static C(Other: UObject | any): AnchorData;
}

declare class CanvasPanelSlot extends PanelSlot { 
	LayoutData: AnchorData;
	bAutoSize: boolean;
	ZOrder: number;
	static Load(ResourceName: string): CanvasPanelSlot;
	static Find(Outer: UObject, ResourceName: string): CanvasPanelSlot;
	static GetDefaultObject(): CanvasPanelSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CanvasPanelSlot;
	SetZOrder(InZOrder: number): void;
	SetSize(InSize: Vector2D): void;
	SetPosition(InPosition: Vector2D): void;
	SetOffsets(InOffset: Margin): void;
	SetMinimum(InMinimumAnchors: Vector2D): void;
	SetMaximum(InMaximumAnchors: Vector2D): void;
	SetLayout(InLayoutData: AnchorData): void;
	SetAutoSize(InbAutoSize: boolean): void;
	SetAnchors(InAnchors: Anchors): void;
	SetAlignment(InAlignment: Vector2D): void;
	GetZOrder(): number;
	GetSize(): Vector2D;
	GetPosition(): Vector2D;
	GetOffsets(): Margin;
	GetLayout(): AnchorData;
	GetAutoSize(): boolean;
	GetAnchors(): Anchors;
	GetAlignment(): Vector2D;
	static C(Other: UObject | any): CanvasPanelSlot;
}

declare class GridSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	Row: number;
	RowSpan: number;
	Column: number;
	ColumnSpan: number;
	Layer: number;
	Nudge: Vector2D;
	static Load(ResourceName: string): GridSlot;
	static Find(Outer: UObject, ResourceName: string): GridSlot;
	static GetDefaultObject(): GridSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetRowSpan(InRowSpan: number): void;
	SetRow(InRow: number): void;
	SetPadding(InPadding: Margin): void;
	SetNudge(InNudge: Vector2D): void;
	SetLayer(InLayer: number): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetColumnSpan(InColumnSpan: number): void;
	SetColumn(InColumn: number): void;
	static C(Other: UObject | any): GridSlot;
}

declare type ESlateSizeRule = 'Automatic' | 'Fill' | 'ESlateSizeRule_MAX';
declare var ESlateSizeRule : { Automatic:'Automatic',Fill:'Fill',ESlateSizeRule_MAX:'ESlateSizeRule_MAX', };
declare class SlateChildSize { 
	Value: number;
	SizeRule: ESlateSizeRule;
	clone() : SlateChildSize;
	static C(Other: UObject | any): SlateChildSize;
}

declare class HorizontalBoxSlot extends PanelSlot { 
	Padding: Margin;
	Size: SlateChildSize;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): HorizontalBoxSlot;
	static Find(Outer: UObject, ResourceName: string): HorizontalBoxSlot;
	static GetDefaultObject(): HorizontalBoxSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HorizontalBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetSize(InSize: SlateChildSize): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): HorizontalBoxSlot;
}

declare class OverlaySlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): OverlaySlot;
	static Find(Outer: UObject, ResourceName: string): OverlaySlot;
	static GetDefaultObject(): OverlaySlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OverlaySlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): OverlaySlot;
}

declare class SafeZoneSlot extends PanelSlot { 
	bIsTitleSafe: boolean;
	SafeAreaScale: Margin;
	HAlign: EHorizontalAlignment;
	VAlign: EVerticalAlignment;
	Padding: Margin;
	static Load(ResourceName: string): SafeZoneSlot;
	static Find(Outer: UObject, ResourceName: string): SafeZoneSlot;
	static GetDefaultObject(): SafeZoneSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SafeZoneSlot;
	static C(Other: UObject | any): SafeZoneSlot;
}

declare class ScaleBoxSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): ScaleBoxSlot;
	static Find(Outer: UObject, ResourceName: string): ScaleBoxSlot;
	static GetDefaultObject(): ScaleBoxSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScaleBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): ScaleBoxSlot;
}

declare class ScrollBoxSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): ScrollBoxSlot;
	static Find(Outer: UObject, ResourceName: string): ScrollBoxSlot;
	static GetDefaultObject(): ScrollBoxSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ScrollBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): ScrollBoxSlot;
}

declare class SizeBoxSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): SizeBoxSlot;
	static Find(Outer: UObject, ResourceName: string): SizeBoxSlot;
	static GetDefaultObject(): SizeBoxSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SizeBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): SizeBoxSlot;
}

declare class UniformGridSlot extends PanelSlot { 
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	Row: number;
	Column: number;
	static Load(ResourceName: string): UniformGridSlot;
	static Find(Outer: UObject, ResourceName: string): UniformGridSlot;
	static GetDefaultObject(): UniformGridSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformGridSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetRow(InRow: number): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetColumn(InColumn: number): void;
	static C(Other: UObject | any): UniformGridSlot;
}

declare class VerticalBoxSlot extends PanelSlot { 
	Size: SlateChildSize;
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): VerticalBoxSlot;
	static Find(Outer: UObject, ResourceName: string): VerticalBoxSlot;
	static GetDefaultObject(): VerticalBoxSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VerticalBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetSize(InSize: SlateChildSize): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): VerticalBoxSlot;
}

declare class WidgetSwitcherSlot extends PanelSlot { 
	Padding: Margin;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	static Load(ResourceName: string): WidgetSwitcherSlot;
	static Find(Outer: UObject, ResourceName: string): WidgetSwitcherSlot;
	static GetDefaultObject(): WidgetSwitcherSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetSwitcherSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject | any): WidgetSwitcherSlot;
}

declare class WrapBoxSlot extends PanelSlot { 
	Padding: Margin;
	bFillEmptySpace: boolean;
	FillSpanWhenLessThan: number;
	HorizontalAlignment: EHorizontalAlignment;
	VerticalAlignment: EVerticalAlignment;
	bForceNewLine: boolean;
	static Load(ResourceName: string): WrapBoxSlot;
	static Find(Outer: UObject, ResourceName: string): WrapBoxSlot;
	static GetDefaultObject(): WrapBoxSlot;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WrapBoxSlot;
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	SetPadding(InPadding: Margin): void;
	SetNewLine(InForceNewLine: boolean): void;
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	SetFillSpanWhenLessThan(InFillSpanWhenLessThan: number): void;
	SetFillEmptySpace(InbFillEmptySpace: boolean): void;
	static C(Other: UObject | any): WrapBoxSlot;
}

declare type EWindowTitleBarMode = 'Overlay' | 'VerticalBox' | 'EWindowTitleBarMode_MAX';
declare var EWindowTitleBarMode : { Overlay:'Overlay',VerticalBox:'VerticalBox',EWindowTitleBarMode_MAX:'EWindowTitleBarMode_MAX', };
declare class Widget extends Visual { 
	Slot: PanelSlot;
	bIsEnabledDelegate: UnrealEngineDelegate<() => boolean>;
	ToolTipText: string;
	ToolTipTextDelegate: UnrealEngineDelegate<() => string>;
	ToolTipWidget: Widget;
	ToolTipWidgetDelegate: UnrealEngineDelegate<() => Widget>;
	VisibilityDelegate: UnrealEngineDelegate<() => ESlateVisibility>;
	RenderTransform: WidgetTransform;
	RenderTransformPivot: Vector2D;
	bIsVariable: boolean;
	bCreatedByConstructionScript: boolean;
	bIsEnabled: boolean;
	bOverride_Cursor: boolean;
	FlowDirectionPreference: EFlowDirectionPreference;
	bOverrideAccessibleDefaults: boolean;
	bCanChildrenBeAccessible: boolean;
	AccessibleBehavior: ESlateAccessibleBehavior;
	AccessibleSummaryBehavior: ESlateAccessibleBehavior;
	AccessibleText: string;
	AccessibleTextDelegate: UnrealEngineDelegate<() => string>;
	AccessibleSummaryText: string;
	AccessibleSummaryTextDelegate: UnrealEngineDelegate<() => string>;
	AccessibleWidgetData: SlateAccessibleWidgetData;
	bIsVolatile: boolean;
	bHiddenInDesigner: boolean;
	bExpandedInDesigner: boolean;
	bLockedInDesigner: boolean;
	Cursor: EMouseCursor;
	Clipping: EWidgetClipping;
	Visibility: ESlateVisibility;
	RenderOpacity: number;
	Navigation: WidgetNavigation;
	NativeBindings: PropertyBinding[];
	DesignerFlags: number;
	DisplayLabel: string;
	CategoryName: string;
	static Load(ResourceName: string): Widget;
	static Find(Outer: UObject, ResourceName: string): Widget;
	static GetDefaultObject(): Widget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Widget;
	SetVisibility(InVisibility: ESlateVisibility): void;
	SetUserFocus(PlayerController: PlayerController): void;
	SetToolTipText(InToolTipText: string): void;
	SetToolTip(Widget: Widget): void;
	SetRenderTranslation(Translation: Vector2D): void;
	SetRenderTransformPivot(Pivot: Vector2D): void;
	SetRenderTransformAngle(Angle: number): void;
	SetRenderTransform(InTransform: WidgetTransform): void;
	SetRenderShear(Shear: Vector2D): void;
	SetRenderScale(Scale: Vector2D): void;
	SetRenderOpacity(InOpacity: number): void;
	SetNavigationRuleExplicit(Direction: EUINavigation,InWidget: Widget): void;
	SetNavigationRuleBase(Direction: EUINavigation,Rule: EUINavigationRule): void;
	SetNavigationRule(Direction: EUINavigation,Rule: EUINavigationRule,WidgetToFocus: string): void;
	SetKeyboardFocus(): void;
	SetIsEnabled(bInIsEnabled: boolean): void;
	SetFocus(): void;
	SetCursor(InCursor: EMouseCursor): void;
	SetClipping(InClipping: EWidgetClipping): void;
	SetAllNavigationRules(Rule: EUINavigationRule,WidgetToFocus: string): void;
	ResetCursor(): void;
	RemoveFromParent(): void;
	IsVisible(): boolean;
	IsHovered(): boolean;
	InvalidateLayoutAndVolatility(): void;
	HasUserFocusedDescendants(PlayerController: PlayerController): boolean;
	HasUserFocus(PlayerController: PlayerController): boolean;
	HasMouseCaptureByUser(UserIndex: number,PointerIndex: number): boolean;
	HasMouseCapture(): boolean;
	HasKeyboardFocus(): boolean;
	HasFocusedDescendants(): boolean;
	HasAnyUserFocus(): boolean;
	GetVisibility(): ESlateVisibility;
	GetTickSpaceGeometry(): Geometry;
	GetRenderTransformAngle(): number;
	GetRenderOpacity(): number;
	GetParent(): PanelWidget;
	GetPaintSpaceGeometry(): Geometry;
	GetOwningPlayer(): PlayerController;
	GetOwningLocalPlayer(): LocalPlayer;
	GetIsEnabled(): boolean;
	GetGameInstance(): GameInstance;
	GetDesiredSize(): Vector2D;
	GetClipping(): EWidgetClipping;
	GetCachedGeometry(): Geometry;
	GetAccessibleText(): string;
	GetAccessibleSummaryText(): string;
	ForceVolatile(bForce: boolean): void;
	ForceLayoutPrepass(): void;
	static C(Other: UObject | any): Widget;
	GetUIGeometry(): Geometry;
	TakeWidget(): JavascriptSlateWidget;
	SlotAsBorderSlot(): BorderSlot;
	SlotAsCanvasSlot(): CanvasPanelSlot;
	SlotAsGridSlot(): GridSlot;
	SlotAsHorizontalBoxSlot(): HorizontalBoxSlot;
	SlotAsOverlaySlot(): OverlaySlot;
	SlotAsSafeBoxSlot(): SafeZoneSlot;
	SlotAsScaleBoxSlot(): ScaleBoxSlot;
	SlotAsScrollBoxSlot(): ScrollBoxSlot;
	SlotAsSizeBoxSlot(): SizeBoxSlot;
	SlotAsUniformGridSlot(): UniformGridSlot;
	SlotAsVerticalBoxSlot(): VerticalBoxSlot;
	SlotAsWidgetSwitcherSlot(): WidgetSwitcherSlot;
	SlotAsWrapBoxSlot(): WrapBoxSlot;
	SetWindowTitleBarState(Mode: EWindowTitleBarMode,bTitleBarDragEnabled: boolean,bWindowButtonsVisible: boolean,bTitleBarVisible: boolean): void;
	static GetUIGeometry(Widget: Widget): Geometry;
	static TakeWidget(Widget: Widget): JavascriptSlateWidget;
	static SlotAsBorderSlot(Widget: Widget): BorderSlot;
	static SlotAsCanvasSlot(Widget: Widget): CanvasPanelSlot;
	static SlotAsGridSlot(Widget: Widget): GridSlot;
	static SlotAsHorizontalBoxSlot(Widget: Widget): HorizontalBoxSlot;
	static SlotAsOverlaySlot(Widget: Widget): OverlaySlot;
	static SlotAsSafeBoxSlot(Widget: Widget): SafeZoneSlot;
	static SlotAsScaleBoxSlot(Widget: Widget): ScaleBoxSlot;
	static SlotAsScrollBoxSlot(Widget: Widget): ScrollBoxSlot;
	static SlotAsSizeBoxSlot(Widget: Widget): SizeBoxSlot;
	static SlotAsUniformGridSlot(Widget: Widget): UniformGridSlot;
	static SlotAsVerticalBoxSlot(Widget: Widget): VerticalBoxSlot;
	static SlotAsWidgetSwitcherSlot(Widget: Widget): WidgetSwitcherSlot;
	static SlotAsWrapBoxSlot(Widget: Widget): WrapBoxSlot;
	static SetWindowTitleBarState(TitleBarContent: Widget,Mode: EWindowTitleBarMode,bTitleBarDragEnabled: boolean,bWindowButtonsVisible: boolean,bTitleBarVisible: boolean): void;
}

declare class WidgetAnimationBinding { 
	WidgetName: string;
	SlotWidgetName: string;
	AnimationGuid: Guid;
	bIsRootWidget: boolean;
	clone() : WidgetAnimationBinding;
	static C(Other: UObject | any): WidgetAnimationBinding;
}

declare class WidgetAnimation extends MovieSceneSequence { 
	OnAnimationStarted: UnrealEngineMulticastDelegate<() => void>;
	OnAnimationFinished: UnrealEngineMulticastDelegate<() => void>;
	MovieScene: MovieScene;
	AnimationBindings: WidgetAnimationBinding[];
	bLegacyFinishOnStop: boolean;
	DisplayLabel: string;
	static Load(ResourceName: string): WidgetAnimation;
	static Find(Outer: UObject, ResourceName: string): WidgetAnimation;
	static GetDefaultObject(): WidgetAnimation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetAnimation;
	UnbindAllFromAnimationStarted(Widget: UserWidget): void;
	UnbindAllFromAnimationFinished(Widget: UserWidget): void;
	GetStartTime(): number;
	GetEndTime(): number;
	static C(Other: UObject | any): WidgetAnimation;
}

declare class UMGSequencePlayer extends UObject { 
	Animation: WidgetAnimation;
	RootTemplateInstance: MovieSceneRootEvaluationTemplateInstance;
	static Load(ResourceName: string): UMGSequencePlayer;
	static Find(Outer: UObject, ResourceName: string): UMGSequencePlayer;
	static GetDefaultObject(): UMGSequencePlayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UMGSequencePlayer;
	SetUserTag(InUserTag: string): void;
	GetUserTag(): string;
	static C(Other: UObject | any): UMGSequencePlayer;
}

declare class UMGSequenceTickManager extends UObject { 
	WeakUserWidgetData: any;
	Linker: MovieSceneEntitySystemLinker;
	static Load(ResourceName: string): UMGSequenceTickManager;
	static Find(Outer: UObject, ResourceName: string): UMGSequenceTickManager;
	static GetDefaultObject(): UMGSequenceTickManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UMGSequenceTickManager;
	static C(Other: UObject | any): UMGSequenceTickManager;
}

declare class NamedSlotBinding { 
	Name: string;
	Content: Widget;
	clone() : NamedSlotBinding;
	static C(Other: UObject | any): NamedSlotBinding;
}

declare class WidgetTree extends UObject { 
	RootWidget: Widget;
	AllWidgets: Widget[];
	static Load(ResourceName: string): WidgetTree;
	static Find(Outer: UObject, ResourceName: string): WidgetTree;
	static GetDefaultObject(): WidgetTree;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetTree;
	static C(Other: UObject | any): WidgetTree;
}

declare type EDesignPreviewSizeMode = 'FillScreen' | 'Custom' | 'CustomOnScreen' | 'Desired' | 'DesiredOnScreen' | 'EDesignPreviewSizeMode_MAX';
declare var EDesignPreviewSizeMode : { FillScreen:'FillScreen',Custom:'Custom',CustomOnScreen:'CustomOnScreen',Desired:'Desired',DesiredOnScreen:'DesiredOnScreen',EDesignPreviewSizeMode_MAX:'EDesignPreviewSizeMode_MAX', };
declare type EWidgetTickFrequency = 'Never' | 'Auto' | 'EWidgetTickFrequency_MAX';
declare var EWidgetTickFrequency : { Never:'Never',Auto:'Auto',EWidgetTickFrequency_MAX:'EWidgetTickFrequency_MAX', };
declare type EWidgetAnimationEvent = 'Started' | 'Finished' | 'EWidgetAnimationEvent_MAX';
declare var EWidgetAnimationEvent : { Started:'Started',Finished:'Finished',EWidgetAnimationEvent_MAX:'EWidgetAnimationEvent_MAX', };
declare class AnimationEventBinding { 
	Animation: WidgetAnimation;
	delegate: UnrealEngineDelegate<() => void>;
	AnimationEvent: EWidgetAnimationEvent;
	UserTag: string;
	clone() : AnimationEventBinding;
	static C(Other: UObject | any): AnimationEventBinding;
}

declare type EInputEvent = 'IE_Pressed' | 'IE_Released' | 'IE_Repeat' | 'IE_DoubleClick' | 'IE_Axis' | 'IE_MAX';
declare var EInputEvent : { IE_Pressed:'IE_Pressed',IE_Released:'IE_Released',IE_Repeat:'IE_Repeat',IE_DoubleClick:'IE_DoubleClick',IE_Axis:'IE_Axis',IE_MAX:'IE_MAX', };
declare class SoundModulatorBase extends UObject { 
	static Load(ResourceName: string): SoundModulatorBase;
	static Find(Outer: UObject, ResourceName: string): SoundModulatorBase;
	static GetDefaultObject(): SoundModulatorBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundModulatorBase;
	static C(Other: UObject | any): SoundModulatorBase;
}

declare class SoundModulationDestinationSettings { 
	Value: number;
	bEnableModulation: boolean;
	Modulator: SoundModulatorBase;
	clone() : SoundModulationDestinationSettings;
	static C(Other: UObject | any): SoundModulationDestinationSettings;
}

declare class SoundModulationDefaultSettings { 
	VolumeModulationDestination: SoundModulationDestinationSettings;
	PitchModulationDestination: SoundModulationDestinationSettings;
	HighpassModulationDestination: SoundModulationDestinationSettings;
	LowpassModulationDestination: SoundModulationDestinationSettings;
	clone() : SoundModulationDefaultSettings;
	static C(Other: UObject | any): SoundModulationDefaultSettings;
}

declare type EAudioOutputTarget = 'Speaker' | 'Controller' | 'ControllerFallbackToSpeaker' | 'EAudioOutputTarget_MAX';
declare var EAudioOutputTarget : { Speaker:'Speaker',Controller:'Controller',ControllerFallbackToSpeaker:'ControllerFallbackToSpeaker',EAudioOutputTarget_MAX:'EAudioOutputTarget_MAX', };
declare type ESoundWaveLoadingBehavior = 'Inherited' | 'RetainOnLoad' | 'PrimeOnLoad' | 'LoadOnDemand' | 'ForceInline' | 'Uninitialized' | 'ESoundWaveLoadingBehavior_MAX';
declare var ESoundWaveLoadingBehavior : { Inherited:'Inherited',RetainOnLoad:'RetainOnLoad',PrimeOnLoad:'PrimeOnLoad',LoadOnDemand:'LoadOnDemand',ForceInline:'ForceInline',Uninitialized:'Uninitialized',ESoundWaveLoadingBehavior_MAX:'ESoundWaveLoadingBehavior_MAX', };
declare class SoundSubmixBase extends UObject { 
	bAutoDisable: boolean;
	AutoDisableTime: number;
	ChildSubmixes: SoundSubmixBase[];
	static Load(ResourceName: string): SoundSubmixBase;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixBase;
	static GetDefaultObject(): SoundSubmixBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixBase;
	static C(Other: UObject | any): SoundSubmixBase;
}

declare class SoundSubmixWithParentBase extends SoundSubmixBase { 
	ParentSubmix: SoundSubmixBase;
	static Load(ResourceName: string): SoundSubmixWithParentBase;
	static Find(Outer: UObject, ResourceName: string): SoundSubmixWithParentBase;
	static GetDefaultObject(): SoundSubmixWithParentBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmixWithParentBase;
	static C(Other: UObject | any): SoundSubmixWithParentBase;
}

declare class SoundEffectPreset extends UObject { 
	static Load(ResourceName: string): SoundEffectPreset;
	static Find(Outer: UObject, ResourceName: string): SoundEffectPreset;
	static GetDefaultObject(): SoundEffectPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectPreset;
	static C(Other: UObject | any): SoundEffectPreset;
}

declare class SoundEffectSubmixPreset extends SoundEffectPreset { 
	static Load(ResourceName: string): SoundEffectSubmixPreset;
	static Find(Outer: UObject, ResourceName: string): SoundEffectSubmixPreset;
	static GetDefaultObject(): SoundEffectSubmixPreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectSubmixPreset;
	static C(Other: UObject | any): SoundEffectSubmixPreset;
}

declare class SoundfieldEncodingSettingsBase extends UObject { 
	static Load(ResourceName: string): SoundfieldEncodingSettingsBase;
	static Find(Outer: UObject, ResourceName: string): SoundfieldEncodingSettingsBase;
	static GetDefaultObject(): SoundfieldEncodingSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundfieldEncodingSettingsBase;
	static C(Other: UObject | any): SoundfieldEncodingSettingsBase;
}

declare class AudioLinkSettingsAbstract extends UObject { 
	static Load(ResourceName: string): AudioLinkSettingsAbstract;
	static Find(Outer: UObject, ResourceName: string): AudioLinkSettingsAbstract;
	static GetDefaultObject(): AudioLinkSettingsAbstract;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioLinkSettingsAbstract;
	static C(Other: UObject | any): AudioLinkSettingsAbstract;
}

declare type ESoundwaveSampleRateSettings = 'Max' | 'High' | 'Medium' | 'Low' | 'Min' | 'MatchDevice' | 'ESoundwaveSampleRateSettings_MAX';
declare var ESoundwaveSampleRateSettings : { Max:'Max',High:'High',Medium:'Medium',Low:'Low',Min:'Min',MatchDevice:'MatchDevice',ESoundwaveSampleRateSettings_MAX:'ESoundwaveSampleRateSettings_MAX', };
declare type ESoundGroup = 'SOUNDGROUP_Default' | 'SOUNDGROUP_Effects' | 'SOUNDGROUP_UI' | 'SOUNDGROUP_Music' | 'SOUNDGROUP_Voice' | 'SOUNDGROUP_GameSoundGroup1' | 'SOUNDGROUP_GameSoundGroup2' | 'SOUNDGROUP_GameSoundGroup3' | 'SOUNDGROUP_GameSoundGroup4' | 'SOUNDGROUP_GameSoundGroup5' | 'SOUNDGROUP_GameSoundGroup6' | 'SOUNDGROUP_GameSoundGroup7' | 'SOUNDGROUP_GameSoundGroup8' | 'SOUNDGROUP_GameSoundGroup9' | 'SOUNDGROUP_GameSoundGroup10' | 'SOUNDGROUP_GameSoundGroup11' | 'SOUNDGROUP_GameSoundGroup12' | 'SOUNDGROUP_GameSoundGroup13' | 'SOUNDGROUP_GameSoundGroup14' | 'SOUNDGROUP_GameSoundGroup15' | 'SOUNDGROUP_GameSoundGroup16' | 'SOUNDGROUP_GameSoundGroup17' | 'SOUNDGROUP_GameSoundGroup18' | 'SOUNDGROUP_GameSoundGroup19' | 'SOUNDGROUP_GameSoundGroup20' | 'SOUNDGROUP_MAX';
declare var ESoundGroup : { SOUNDGROUP_Default:'SOUNDGROUP_Default',SOUNDGROUP_Effects:'SOUNDGROUP_Effects',SOUNDGROUP_UI:'SOUNDGROUP_UI',SOUNDGROUP_Music:'SOUNDGROUP_Music',SOUNDGROUP_Voice:'SOUNDGROUP_Voice',SOUNDGROUP_GameSoundGroup1:'SOUNDGROUP_GameSoundGroup1',SOUNDGROUP_GameSoundGroup2:'SOUNDGROUP_GameSoundGroup2',SOUNDGROUP_GameSoundGroup3:'SOUNDGROUP_GameSoundGroup3',SOUNDGROUP_GameSoundGroup4:'SOUNDGROUP_GameSoundGroup4',SOUNDGROUP_GameSoundGroup5:'SOUNDGROUP_GameSoundGroup5',SOUNDGROUP_GameSoundGroup6:'SOUNDGROUP_GameSoundGroup6',SOUNDGROUP_GameSoundGroup7:'SOUNDGROUP_GameSoundGroup7',SOUNDGROUP_GameSoundGroup8:'SOUNDGROUP_GameSoundGroup8',SOUNDGROUP_GameSoundGroup9:'SOUNDGROUP_GameSoundGroup9',SOUNDGROUP_GameSoundGroup10:'SOUNDGROUP_GameSoundGroup10',SOUNDGROUP_GameSoundGroup11:'SOUNDGROUP_GameSoundGroup11',SOUNDGROUP_GameSoundGroup12:'SOUNDGROUP_GameSoundGroup12',SOUNDGROUP_GameSoundGroup13:'SOUNDGROUP_GameSoundGroup13',SOUNDGROUP_GameSoundGroup14:'SOUNDGROUP_GameSoundGroup14',SOUNDGROUP_GameSoundGroup15:'SOUNDGROUP_GameSoundGroup15',SOUNDGROUP_GameSoundGroup16:'SOUNDGROUP_GameSoundGroup16',SOUNDGROUP_GameSoundGroup17:'SOUNDGROUP_GameSoundGroup17',SOUNDGROUP_GameSoundGroup18:'SOUNDGROUP_GameSoundGroup18',SOUNDGROUP_GameSoundGroup19:'SOUNDGROUP_GameSoundGroup19',SOUNDGROUP_GameSoundGroup20:'SOUNDGROUP_GameSoundGroup20',SOUNDGROUP_MAX:'SOUNDGROUP_MAX', };
declare type ESoundAssetCompressionType = 'BinkAudio' | 'ADPCM' | 'PCM' | 'PlatformSpecific' | 'ESoundAssetCompressionType_MAX';
declare var ESoundAssetCompressionType : { BinkAudio:'BinkAudio',ADPCM:'ADPCM',PCM:'PCM',PlatformSpecific:'PlatformSpecific',ESoundAssetCompressionType_MAX:'ESoundAssetCompressionType_MAX', };
declare type ESoundWaveFFTSize = 'VerySmall_64' | 'Small_256' | 'Medium_512' | 'Large_1024' | 'VeryLarge_2048' | 'ESoundWaveFFTSize_MAX';
declare var ESoundWaveFFTSize : { VerySmall_64:'VerySmall_64',Small_256:'Small_256',Medium_512:'Medium_512',Large_1024:'Large_1024',VeryLarge_2048:'VeryLarge_2048',ESoundWaveFFTSize_MAX:'ESoundWaveFFTSize_MAX', };
declare type EModulationRouting = 'Disable' | 'Inherit' | 'Override' | 'EModulationRouting_MAX';
declare var EModulationRouting : { Disable:'Disable',Inherit:'Inherit',Override:'Override',EModulationRouting_MAX:'EModulationRouting_MAX', };
declare class SoundModulationDefaultRoutingSettings extends SoundModulationDefaultSettings { 
	VolumeRouting: EModulationRouting;
	PitchRouting: EModulationRouting;
	HighpassRouting: EModulationRouting;
	LowpassRouting: EModulationRouting;
	clone() : SoundModulationDefaultRoutingSettings;
	static C(Other: UObject | any): SoundModulationDefaultRoutingSettings;
}

declare class SoundWaveSpectralDataEntry { 
	Magnitude: number;
	NormalizedMagnitude: number;
	clone() : SoundWaveSpectralDataEntry;
	static C(Other: UObject | any): SoundWaveSpectralDataEntry;
}

declare class SoundWaveSpectralTimeData { 
	Data: SoundWaveSpectralDataEntry[];
	TimeSec: number;
	clone() : SoundWaveSpectralTimeData;
	static C(Other: UObject | any): SoundWaveSpectralTimeData;
}

declare class SoundWaveEnvelopeTimeData { 
	Amplitude: number;
	TimeSec: number;
	clone() : SoundWaveEnvelopeTimeData;
	static C(Other: UObject | any): SoundWaveEnvelopeTimeData;
}

declare class SoundWaveCuePoint { 
	CuePointID: number;
	Label: string;
	FramePosition: number;
	FrameLength: number;
	clone() : SoundWaveCuePoint;
	static C(Other: UObject | any): SoundWaveCuePoint;
}

declare class SubtitleCue { 
	text: string;
	Time: number;
	clone() : SubtitleCue;
	static C(Other: UObject | any): SubtitleCue;
}

declare class SoundWave extends SoundBase { 
	CompressionQuality: number;
	StreamingPriority: number;
	SampleRateQuality: ESoundwaveSampleRateSettings;
	SoundGroup: ESoundGroup;
	bLooping: boolean;
	bStreaming: boolean;
	SoundAssetCompressionType: ESoundAssetCompressionType;
	bSeekableStreaming: boolean;
	bUseBinkAudio: boolean;
	OverrideSoundToUseForAnalysis: SoundWave;
	TreatFileAsLoopingForAnalysis: boolean;
	bEnableBakedFFTAnalysis: boolean;
	bEnableAmplitudeEnvelopeAnalysis: boolean;
	FFTSize: ESoundWaveFFTSize;
	FFTAnalysisFrameSize: number;
	FFTAnalysisAttackTime: number;
	FFTAnalysisReleaseTime: number;
	EnvelopeFollowerFrameSize: number;
	EnvelopeFollowerAttackTime: number;
	EnvelopeFollowerReleaseTime: number;
	ModulationSettings: SoundModulationDefaultRoutingSettings;
	FrequenciesToAnalyze: number[];
	CookedSpectralTimeData: SoundWaveSpectralTimeData[];
	CookedEnvelopeTimeData: SoundWaveEnvelopeTimeData[];
	InitialChunkSize: number;
	bMature: boolean;
	bManualWordWrap: boolean;
	bSingleLine: boolean;
	bVirtualizeWhenSilent: boolean;
	bIsAmbisonics: boolean;
	LoadingBehavior: ESoundWaveLoadingBehavior;
	SpokenText: string;
	SubtitlePriority: number;
	Volume: number;
	Pitch: number;
	NumChannels: number;
	CuePoints: SoundWaveCuePoint[];
	ChannelOffsets: number[];
	ChannelSizes: number[];
	SampleRate: number;
	ImportedSampleRate: number;
	Subtitles: SubtitleCue[];
	Comment: string;
	SourceFilePath: string;
	SourceFileTimestamp: string;
	AssetImportData: AssetImportData;
	Curves: CurveTable;
	InternalCurves: CurveTable;
	static Load(ResourceName: string): SoundWave;
	static Find(Outer: UObject, ResourceName: string): SoundWave;
	static GetDefaultObject(): SoundWave;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundWave;
	SetSoundAssetCompressionType(InSoundAssetCompressionType: ESoundAssetCompressionType): void;
	GetSoundAssetCompressionType(): ESoundAssetCompressionType;
	static C(Other: UObject | any): SoundWave;
	PrimeSoundForPlayback(OnLoadCompletion: UnrealEngineDelegate<(LoadedSoundWave: SoundWave, WasCancelled: boolean) => void>): void;
	static PrimeSoundForPlayback(SoundWave: SoundWave,OnLoadCompletion: UnrealEngineDelegate<(LoadedSoundWave: SoundWave, WasCancelled: boolean) => void>): void;
}

declare type EAudioRecordingExportType = 'SoundWave' | 'WavFile' | 'EAudioRecordingExportType_MAX';
declare var EAudioRecordingExportType : { SoundWave:'SoundWave',WavFile:'WavFile',EAudioRecordingExportType_MAX:'EAudioRecordingExportType_MAX', };
declare type EFFTSize = 'DefaultSize' | 'Min' | 'Small' | 'Medium' | 'Large' | 'VeryLarge' | 'Max' | 'EFFTSize_MAX';
declare var EFFTSize : { DefaultSize:'DefaultSize',Min:'Min',Small:'Small',Medium:'Medium',Large:'Large',VeryLarge:'VeryLarge',Max:'Max',EFFTSize_MAX:'EFFTSize_MAX', };
declare type EFFTPeakInterpolationMethod = 'NearestNeighbor' | 'Linear' | 'Quadratic' | 'ConstantQ' | 'EFFTPeakInterpolationMethod_MAX';
declare var EFFTPeakInterpolationMethod : { NearestNeighbor:'NearestNeighbor',Linear:'Linear',Quadratic:'Quadratic',ConstantQ:'ConstantQ',EFFTPeakInterpolationMethod_MAX:'EFFTPeakInterpolationMethod_MAX', };
declare type EFFTWindowType = 'None' | 'Hamming' | 'Hann' | 'Blackman' | 'EFFTWindowType_MAX';
declare var EFFTWindowType : { None:'None',Hamming:'Hamming',Hann:'Hann',Blackman:'Blackman',EFFTWindowType_MAX:'EFFTWindowType_MAX', };
declare type EAudioSpectrumType = 'MagnitudeSpectrum' | 'PowerSpectrum' | 'Decibel' | 'EAudioSpectrumType_MAX';
declare var EAudioSpectrumType : { MagnitudeSpectrum:'MagnitudeSpectrum',PowerSpectrum:'PowerSpectrum',Decibel:'Decibel',EAudioSpectrumType_MAX:'EAudioSpectrumType_MAX', };
declare class SoundSubmix extends SoundSubmixWithParentBase { 
	bMuteWhenBackgrounded: boolean;
	SubmixEffectChain: SoundEffectSubmixPreset[];
	AmbisonicsPluginSettings: SoundfieldEncodingSettingsBase;
	EnvelopeFollowerAttackTime: number;
	EnvelopeFollowerReleaseTime: number;
	OutputVolume: number;
	WetLevel: number;
	DryLevel: number;
	OutputVolumeModulation: SoundModulationDestinationSettings;
	WetLevelModulation: SoundModulationDestinationSettings;
	DryLevelModulation: SoundModulationDestinationSettings;
	AudioLinkSettings: AudioLinkSettingsAbstract;
	OnSubmixRecordedFileDone: UnrealEngineMulticastDelegate<(ResultingSoundWave: SoundWave) => void>;
	static Load(ResourceName: string): SoundSubmix;
	static Find(Outer: UObject, ResourceName: string): SoundSubmix;
	static GetDefaultObject(): SoundSubmix;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSubmix;
	StopSpectralAnalysis(WorldContextObject: UObject): void;
	StopRecordingOutput(WorldContextObject: UObject,ExportType: EAudioRecordingExportType,Name: string,Path: string,ExistingSoundWaveToOverwrite: SoundWave): void;
	StopEnvelopeFollowing(WorldContextObject: UObject): void;
	StartSpectralAnalysis(WorldContextObject: UObject,FFTSize: EFFTSize,InterpolationMethod: EFFTPeakInterpolationMethod,WindowType: EFFTWindowType,HopSize: number,SpectrumType: EAudioSpectrumType): void;
	StartRecordingOutput(WorldContextObject: UObject,ExpectedDuration: number): void;
	StartEnvelopeFollowing(WorldContextObject: UObject): void;
	SetSubmixWetLevel(WorldContextObject: UObject,InWetLevel: number): void;
	SetSubmixOutputVolume(WorldContextObject: UObject,InOutputVolume: number): void;
	SetSubmixDryLevel(WorldContextObject: UObject,InDryLevel: number): void;
	static C(Other: UObject | any): SoundSubmix;
}

declare class SoundClassProperties { 
	Volume: number;
	Pitch: number;
	LowPassFilterFrequency: number;
	AttenuationDistanceScale: number;
	LFEBleed: number;
	VoiceCenterChannelVolume: number;
	RadioFilterVolume: number;
	RadioFilterVolumeThreshold: number;
	bApplyEffects: boolean;
	bAlwaysPlay: boolean;
	bIsUISound: boolean;
	bIsMusic: boolean;
	bCenterChannelOnly: boolean;
	bApplyAmbientVolumes: boolean;
	bReverb: boolean;
	Default2DReverbSendAmount: number;
	ModulationSettings: SoundModulationDefaultSettings;
	OutputTarget: EAudioOutputTarget;
	LoadingBehavior: ESoundWaveLoadingBehavior;
	DefaultSubmix: SoundSubmix;
	clone() : SoundClassProperties;
	static C(Other: UObject | any): SoundClassProperties;
}

declare class AudioEffectParameters { 
	clone() : AudioEffectParameters;
	static C(Other: UObject | any): AudioEffectParameters;
}

declare class AudioEQEffect extends AudioEffectParameters { 
	FrequencyCenter0: number;
	Gain0: number;
	Bandwidth0: number;
	FrequencyCenter1: number;
	Gain1: number;
	Bandwidth1: number;
	FrequencyCenter2: number;
	Gain2: number;
	Bandwidth2: number;
	FrequencyCenter3: number;
	Gain3: number;
	Bandwidth3: number;
	clone() : AudioEQEffect;
	static C(Other: UObject | any): AudioEQEffect;
}

declare class SoundClassAdjuster { 
	SoundClassObject: SoundClass;
	VolumeAdjuster: number;
	PitchAdjuster: number;
	LowPassFilterFrequency: number;
	bApplyToChildren: boolean;
	VoiceCenterChannelVolumeAdjuster: number;
	clone() : SoundClassAdjuster;
	static C(Other: UObject | any): SoundClassAdjuster;
}

declare class SoundMix extends UObject { 
	bApplyEQ: boolean;
	EQPriority: number;
	EQSettings: AudioEQEffect;
	SoundClassEffects: SoundClassAdjuster[];
	InitialDelay: number;
	FadeInTime: number;
	Duration: number;
	FadeOutTime: number;
	bChanged: boolean;
	static Load(ResourceName: string): SoundMix;
	static Find(Outer: UObject, ResourceName: string): SoundMix;
	static GetDefaultObject(): SoundMix;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundMix;
	static C(Other: UObject | any): SoundMix;
}

declare class PassiveSoundMixModifier { 
	SoundMix: SoundMix;
	MinVolumeThreshold: number;
	MaxVolumeThreshold: number;
	clone() : PassiveSoundMixModifier;
	static C(Other: UObject | any): PassiveSoundMixModifier;
}

declare class SoundClass extends UObject { 
	Properties: SoundClassProperties;
	ChildClasses: SoundClass[];
	PassiveSoundMixModifiers: PassiveSoundMixModifier[];
	ParentClass: SoundClass;
	static Load(ResourceName: string): SoundClass;
	static Find(Outer: UObject, ResourceName: string): SoundClass;
	static GetDefaultObject(): SoundClass;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClass;
	static C(Other: UObject | any): SoundClass;
	PrimeAllSoundsInSoundClass(): void;
	UnRetainAllSoundsInSoundClass(): void;
	static PrimeAllSoundsInSoundClass(InSoundClass: SoundClass): void;
	static UnRetainAllSoundsInSoundClass(InSoundClass: SoundClass): void;
}

declare type EVirtualizationMode = 'Disabled' | 'PlayWhenSilent' | 'Restart' | 'EVirtualizationMode_MAX';
declare var EVirtualizationMode : { Disabled:'Disabled',PlayWhenSilent:'PlayWhenSilent',Restart:'Restart',EVirtualizationMode_MAX:'EVirtualizationMode_MAX', };
declare type EMaxConcurrentResolutionRule = 'PreventNew' | 'StopOldest' | 'StopFarthestThenPreventNew' | 'StopFarthestThenOldest' | 'StopLowestPriority' | 'StopQuietest' | 'StopLowestPriorityThenPreventNew' | 'Count' | 'EMaxConcurrentResolutionRule_MAX';
declare var EMaxConcurrentResolutionRule : { PreventNew:'PreventNew',StopOldest:'StopOldest',StopFarthestThenPreventNew:'StopFarthestThenPreventNew',StopFarthestThenOldest:'StopFarthestThenOldest',StopLowestPriority:'StopLowestPriority',StopQuietest:'StopQuietest',StopLowestPriorityThenPreventNew:'StopLowestPriorityThenPreventNew',Count:'Count',EMaxConcurrentResolutionRule_MAX:'EMaxConcurrentResolutionRule_MAX', };
declare type EConcurrencyVolumeScaleMode = 'Default' | 'Distance' | 'Priority' | 'EConcurrencyVolumeScaleMode_MAX';
declare var EConcurrencyVolumeScaleMode : { Default:'Default',Distance:'Distance',Priority:'Priority',EConcurrencyVolumeScaleMode_MAX:'EConcurrencyVolumeScaleMode_MAX', };
declare class SoundConcurrencySettings { 
	MaxCount: number;
	bLimitToOwner: boolean;
	ResolutionRule: EMaxConcurrentResolutionRule;
	RetriggerTime: number;
	VolumeScale: number;
	VolumeScaleMode: EConcurrencyVolumeScaleMode;
	VolumeScaleAttackTime: number;
	bVolumeScaleCanRelease: boolean;
	VolumeScaleReleaseTime: number;
	VoiceStealReleaseTime: number;
	clone() : SoundConcurrencySettings;
	static C(Other: UObject | any): SoundConcurrencySettings;
}

declare class SoundConcurrency extends UObject { 
	Concurrency: SoundConcurrencySettings;
	static Load(ResourceName: string): SoundConcurrency;
	static Find(Outer: UObject, ResourceName: string): SoundConcurrency;
	static GetDefaultObject(): SoundConcurrency;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundConcurrency;
	static C(Other: UObject | any): SoundConcurrency;
}

declare type ESoundSpatializationAlgorithm = 'SPATIALIZATION_Default' | 'SPATIALIZATION_HRTF' | 'SPATIALIZATION_MAX';
declare var ESoundSpatializationAlgorithm : { SPATIALIZATION_Default:'SPATIALIZATION_Default',SPATIALIZATION_HRTF:'SPATIALIZATION_HRTF',SPATIALIZATION_MAX:'SPATIALIZATION_MAX', };
declare type EAirAbsorptionMethod = 'Linear' | 'CustomCurve' | 'EAirAbsorptionMethod_MAX';
declare var EAirAbsorptionMethod : { Linear:'Linear',CustomCurve:'CustomCurve',EAirAbsorptionMethod_MAX:'EAirAbsorptionMethod_MAX', };
declare type EReverbSendMethod = 'Linear' | 'CustomCurve' | 'Manual' | 'EReverbSendMethod_MAX';
declare var EReverbSendMethod : { Linear:'Linear',CustomCurve:'CustomCurve',Manual:'Manual',EReverbSendMethod_MAX:'EReverbSendMethod_MAX', };
declare type EPriorityAttenuationMethod = 'Linear' | 'CustomCurve' | 'Manual' | 'EPriorityAttenuationMethod_MAX';
declare var EPriorityAttenuationMethod : { Linear:'Linear',CustomCurve:'CustomCurve',Manual:'Manual',EPriorityAttenuationMethod_MAX:'EPriorityAttenuationMethod_MAX', };
declare type ESoundDistanceCalc = 'SOUNDDISTANCE_Normal' | 'SOUNDDISTANCE_InfiniteXYPlane' | 'SOUNDDISTANCE_InfiniteXZPlane' | 'SOUNDDISTANCE_InfiniteYZPlane' | 'SOUNDDISTANCE_MAX';
declare var ESoundDistanceCalc : { SOUNDDISTANCE_Normal:'SOUNDDISTANCE_Normal',SOUNDDISTANCE_InfiniteXYPlane:'SOUNDDISTANCE_InfiniteXYPlane',SOUNDDISTANCE_InfiniteXZPlane:'SOUNDDISTANCE_InfiniteXZPlane',SOUNDDISTANCE_InfiniteYZPlane:'SOUNDDISTANCE_InfiniteYZPlane',SOUNDDISTANCE_MAX:'SOUNDDISTANCE_MAX', };
declare class SpatializationPluginSourceSettingsBase extends UObject { 
	static Load(ResourceName: string): SpatializationPluginSourceSettingsBase;
	static Find(Outer: UObject, ResourceName: string): SpatializationPluginSourceSettingsBase;
	static GetDefaultObject(): SpatializationPluginSourceSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpatializationPluginSourceSettingsBase;
	static C(Other: UObject | any): SpatializationPluginSourceSettingsBase;
}

declare class OcclusionPluginSourceSettingsBase extends UObject { 
	static Load(ResourceName: string): OcclusionPluginSourceSettingsBase;
	static Find(Outer: UObject, ResourceName: string): OcclusionPluginSourceSettingsBase;
	static GetDefaultObject(): OcclusionPluginSourceSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OcclusionPluginSourceSettingsBase;
	static C(Other: UObject | any): OcclusionPluginSourceSettingsBase;
}

declare class ReverbPluginSourceSettingsBase extends UObject { 
	static Load(ResourceName: string): ReverbPluginSourceSettingsBase;
	static Find(Outer: UObject, ResourceName: string): ReverbPluginSourceSettingsBase;
	static GetDefaultObject(): ReverbPluginSourceSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReverbPluginSourceSettingsBase;
	static C(Other: UObject | any): ReverbPluginSourceSettingsBase;
}

declare type ESubmixSendMethod = 'Linear' | 'CustomCurve' | 'Manual' | 'ESubmixSendMethod_MAX';
declare var ESubmixSendMethod : { Linear:'Linear',CustomCurve:'CustomCurve',Manual:'Manual',ESubmixSendMethod_MAX:'ESubmixSendMethod_MAX', };
declare class AttenuationSubmixSendSettings { 
	Submix: SoundSubmixBase;
	SubmixSendMethod: ESubmixSendMethod;
	SubmixSendLevelMin: number;
	SubmixSendLevelMax: number;
	SubmixSendDistanceMin: number;
	SubmixSendDistanceMax: number;
	ManualSubmixSendLevel: number;
	CustomSubmixSendCurve: RuntimeFloatCurve;
	clone() : AttenuationSubmixSendSettings;
	static C(Other: UObject | any): AttenuationSubmixSendSettings;
}

declare class SourceDataOverridePluginSourceSettingsBase extends UObject { 
	static Load(ResourceName: string): SourceDataOverridePluginSourceSettingsBase;
	static Find(Outer: UObject, ResourceName: string): SourceDataOverridePluginSourceSettingsBase;
	static GetDefaultObject(): SourceDataOverridePluginSourceSettingsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceDataOverridePluginSourceSettingsBase;
	static C(Other: UObject | any): SourceDataOverridePluginSourceSettingsBase;
}

declare class SoundAttenuationPluginSettings { 
	SpatializationPluginSettingsArray: SpatializationPluginSourceSettingsBase[];
	OcclusionPluginSettingsArray: OcclusionPluginSourceSettingsBase[];
	ReverbPluginSettingsArray: ReverbPluginSourceSettingsBase[];
	SourceDataOverridePluginSettingsArray: SourceDataOverridePluginSourceSettingsBase[];
	clone() : SoundAttenuationPluginSettings;
	static C(Other: UObject | any): SoundAttenuationPluginSettings;
}

declare class SoundAttenuationSettings extends BaseAttenuationSettings { 
	bAttenuate: boolean;
	bSpatialize: boolean;
	bAttenuateWithLPF: boolean;
	bEnableListenerFocus: boolean;
	bEnableFocusInterpolation: boolean;
	bEnableOcclusion: boolean;
	bUseComplexCollisionForOcclusion: boolean;
	bEnableReverbSend: boolean;
	bEnablePriorityAttenuation: boolean;
	bApplyNormalizationToStereoSounds: boolean;
	bEnableLogFrequencyScaling: boolean;
	bEnableSubmixSends: boolean;
	bEnableSourceDataOverride: boolean;
	SpatializationAlgorithm: ESoundSpatializationAlgorithm;
	BinauralRadius: number;
	AbsorptionMethod: EAirAbsorptionMethod;
	OcclusionTraceChannel: ECollisionChannel;
	ReverbSendMethod: EReverbSendMethod;
	PriorityAttenuationMethod: EPriorityAttenuationMethod;
	DistanceType: ESoundDistanceCalc;
	OmniRadius: number;
	StereoSpread: number;
	SpatializationPluginSettings: SpatializationPluginSourceSettingsBase;
	RadiusMin: number;
	RadiusMax: number;
	LPFRadiusMin: number;
	LPFRadiusMax: number;
	CustomLowpassAirAbsorptionCurve: RuntimeFloatCurve;
	CustomHighpassAirAbsorptionCurve: RuntimeFloatCurve;
	LPFFrequencyAtMin: number;
	LPFFrequencyAtMax: number;
	HPFFrequencyAtMin: number;
	HPFFrequencyAtMax: number;
	FocusAzimuth: number;
	NonFocusAzimuth: number;
	FocusDistanceScale: number;
	NonFocusDistanceScale: number;
	FocusPriorityScale: number;
	NonFocusPriorityScale: number;
	FocusVolumeAttenuation: number;
	NonFocusVolumeAttenuation: number;
	FocusAttackInterpSpeed: number;
	FocusReleaseInterpSpeed: number;
	OcclusionLowPassFilterFrequency: number;
	OcclusionVolumeAttenuation: number;
	OcclusionInterpolationTime: number;
	OcclusionPluginSettings: OcclusionPluginSourceSettingsBase;
	ReverbPluginSettings: ReverbPluginSourceSettingsBase;
	ReverbWetLevelMin: number;
	ReverbWetLevelMax: number;
	ReverbDistanceMin: number;
	ReverbDistanceMax: number;
	ManualReverbSendLevel: number;
	CustomReverbSendCurve: RuntimeFloatCurve;
	SubmixSendSettings: AttenuationSubmixSendSettings[];
	PriorityAttenuationMin: number;
	PriorityAttenuationMax: number;
	PriorityAttenuationDistanceMin: number;
	PriorityAttenuationDistanceMax: number;
	ManualPriorityAttenuation: number;
	CustomPriorityAttenuationCurve: RuntimeFloatCurve;
	PluginSettings: SoundAttenuationPluginSettings;
	clone() : SoundAttenuationSettings;
	static C(Other: UObject | any): SoundAttenuationSettings;
}

declare class SoundAttenuation extends UObject { 
	Attenuation: SoundAttenuationSettings;
	static Load(ResourceName: string): SoundAttenuation;
	static Find(Outer: UObject, ResourceName: string): SoundAttenuation;
	static GetDefaultObject(): SoundAttenuation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundAttenuation;
	static C(Other: UObject | any): SoundAttenuation;
}

declare type ESendLevelControlMethod = 'Linear' | 'CustomCurve' | 'Manual' | 'ESendLevelControlMethod_MAX';
declare var ESendLevelControlMethod : { Linear:'Linear',CustomCurve:'CustomCurve',Manual:'Manual',ESendLevelControlMethod_MAX:'ESendLevelControlMethod_MAX', };
declare type ESubmixSendStage = 'PostDistanceAttenuation' | 'PreDistanceAttenuation' | 'ESubmixSendStage_MAX';
declare var ESubmixSendStage : { PostDistanceAttenuation:'PostDistanceAttenuation',PreDistanceAttenuation:'PreDistanceAttenuation',ESubmixSendStage_MAX:'ESubmixSendStage_MAX', };
declare class SoundSubmixSendInfo { 
	SendLevelControlMethod: ESendLevelControlMethod;
	SendStage: ESubmixSendStage;
	SoundSubmix: SoundSubmixBase;
	SendLevel: number;
	DisableManualSendClamp: boolean;
	MinSendLevel: number;
	MaxSendLevel: number;
	MinSendDistance: number;
	MaxSendDistance: number;
	CustomSendLevelCurve: RuntimeFloatCurve;
	clone() : SoundSubmixSendInfo;
	static C(Other: UObject | any): SoundSubmixSendInfo;
}

declare class SoundEffectSourcePreset extends SoundEffectPreset { 
	static Load(ResourceName: string): SoundEffectSourcePreset;
	static Find(Outer: UObject, ResourceName: string): SoundEffectSourcePreset;
	static GetDefaultObject(): SoundEffectSourcePreset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectSourcePreset;
	static C(Other: UObject | any): SoundEffectSourcePreset;
}

declare class SourceEffectChainEntry { 
	Preset: SoundEffectSourcePreset;
	bBypass: boolean;
	clone() : SourceEffectChainEntry;
	static C(Other: UObject | any): SourceEffectChainEntry;
}

declare class SoundEffectSourcePresetChain extends UObject { 
	Chain: SourceEffectChainEntry[];
	bPlayEffectChainTails: boolean;
	static Load(ResourceName: string): SoundEffectSourcePresetChain;
	static Find(Outer: UObject, ResourceName: string): SoundEffectSourcePresetChain;
	static GetDefaultObject(): SoundEffectSourcePresetChain;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundEffectSourcePresetChain;
	static C(Other: UObject | any): SoundEffectSourcePresetChain;
}

declare type ESourceBusSendLevelControlMethod = 'Linear' | 'CustomCurve' | 'Manual' | 'ESourceBusSendLevelControlMethod_MAX';
declare var ESourceBusSendLevelControlMethod : { Linear:'Linear',CustomCurve:'CustomCurve',Manual:'Manual',ESourceBusSendLevelControlMethod_MAX:'ESourceBusSendLevelControlMethod_MAX', };
declare type ESourceBusChannels = 'Mono' | 'Stereo' | 'ESourceBusChannels_MAX';
declare var ESourceBusChannels : { Mono:'Mono',Stereo:'Stereo',ESourceBusChannels_MAX:'ESourceBusChannels_MAX', };
declare type EAudioBusChannels = 'Mono' | 'Stereo' | 'Quad' | 'FivePointOne' | 'SevenPointOne' | 'EAudioBusChannels_MAX';
declare var EAudioBusChannels : { Mono:'Mono',Stereo:'Stereo',Quad:'Quad',FivePointOne:'FivePointOne',SevenPointOne:'SevenPointOne',EAudioBusChannels_MAX:'EAudioBusChannels_MAX', };
declare class AudioBus extends UObject { 
	AudioBusChannels: EAudioBusChannels;
	static Load(ResourceName: string): AudioBus;
	static Find(Outer: UObject, ResourceName: string): AudioBus;
	static GetDefaultObject(): AudioBus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioBus;
	static C(Other: UObject | any): AudioBus;
}

declare class SoundSourceBus extends SoundWave { 
	SourceBusChannels: ESourceBusChannels;
	SourceBusDuration: number;
	AudioBus: AudioBus;
	bAutoDeactivateWhenSilent: boolean;
	static Load(ResourceName: string): SoundSourceBus;
	static Find(Outer: UObject, ResourceName: string): SoundSourceBus;
	static GetDefaultObject(): SoundSourceBus;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundSourceBus;
	static C(Other: UObject | any): SoundSourceBus;
}

declare class SoundSourceBusSendInfo { 
	SourceBusSendLevelControlMethod: ESourceBusSendLevelControlMethod;
	SoundSourceBus: SoundSourceBus;
	AudioBus: AudioBus;
	SendLevel: number;
	MinSendLevel: number;
	MaxSendLevel: number;
	MinSendDistance: number;
	MaxSendDistance: number;
	CustomSendLevelCurve: RuntimeFloatCurve;
	clone() : SoundSourceBusSendInfo;
	static C(Other: UObject | any): SoundSourceBusSendInfo;
}

declare type EAudioParameterType = 'None' | 'Boolean' | 'Integer' | 'Float' | 'String' | 'Object' | 'NoneArray' | 'BooleanArray' | 'IntegerArray' | 'FloatArray' | 'StringArray' | 'ObjectArray' | 'COUNT' | 'EAudioParameterType_MAX';
declare var EAudioParameterType : { None:'None',Boolean:'Boolean',Integer:'Integer',Float:'Float',String:'String',Object:'Object',NoneArray:'NoneArray',BooleanArray:'BooleanArray',IntegerArray:'IntegerArray',FloatArray:'FloatArray',StringArray:'StringArray',ObjectArray:'ObjectArray',COUNT:'COUNT',EAudioParameterType_MAX:'EAudioParameterType_MAX', };
declare class AudioParameter { 
	ParamName: string;
	FloatParam: number;
	BoolParam: boolean;
	IntParam: number;
	ObjectParam: UObject;
	StringParam: string;
	ArrayFloatParam: number[];
	ArrayBoolParam: boolean[];
	ArrayIntParam: number[];
	ArrayObjectParam: UObject[];
	ArrayStringParam: string[];
	ParamType: EAudioParameterType;
	TypeName: string;
	clone() : AudioParameter;
	static C(Other: UObject | any): AudioParameter;
	static BooleanArrayToAudioParameter(Name: string,Bools: boolean[]): AudioParameter;
	static BooleanToAudioParameter(Name: string,bool: boolean): AudioParameter;
	static FloatArrayToAudioParameter(Name: string,Floats: number[]): AudioParameter;
	static FloatToAudioParameter(Name: string,float: number): AudioParameter;
	static IntegerArrayToAudioParameter(Name: string,Integers: number[]): AudioParameter;
	static IntegerToAudioParameter(Name: string,Integer: number): AudioParameter;
	static ObjectArrayToAudioParameter(Name: string,Objects: UObject[]): AudioParameter;
	static ObjectToAudioParameter(Name: string,UObject: UObject): AudioParameter;
	static StringArrayToAudioParameter(Name: string,Strings: string[]): AudioParameter;
	static StringToAudioParameter(Name: string,string: string): AudioParameter;
}

declare type EAudioComponentPlayState = 'Playing' | 'Stopped' | 'Paused' | 'FadingIn' | 'FadingOut' | 'Count' | 'EAudioComponentPlayState_MAX';
declare var EAudioComponentPlayState : { Playing:'Playing',Stopped:'Stopped',Paused:'Paused',FadingIn:'FadingIn',FadingOut:'FadingOut',Count:'Count',EAudioComponentPlayState_MAX:'EAudioComponentPlayState_MAX', };
declare class SoundWaveSpectralData { 
	FrequencyHz: number;
	Magnitude: number;
	NormalizedMagnitude: number;
	clone() : SoundWaveSpectralData;
	static C(Other: UObject | any): SoundWaveSpectralData;
}

declare class SoundWaveSpectralDataPerSound { 
	SpectralData: SoundWaveSpectralData[];
	PlaybackTime: number;
	SoundWave: SoundWave;
	clone() : SoundWaveSpectralDataPerSound;
	static C(Other: UObject | any): SoundWaveSpectralDataPerSound;
}

declare class SoundWaveEnvelopeDataPerSound { 
	Envelope: number;
	PlaybackTime: number;
	SoundWave: SoundWave;
	clone() : SoundWaveEnvelopeDataPerSound;
	static C(Other: UObject | any): SoundWaveEnvelopeDataPerSound;
}

declare type EAudioFaderCurve = 'Linear' | 'Logarithmic' | 'SCurve' | 'Sin' | 'Count' | 'EAudioFaderCurve_MAX';
declare var EAudioFaderCurve : { Linear:'Linear',Logarithmic:'Logarithmic',SCurve:'SCurve',Sin:'Sin',Count:'Count',EAudioFaderCurve_MAX:'EAudioFaderCurve_MAX', };
declare class AudioComponent extends SceneComponent { 
	Sound: SoundBase;
	DefaultParameters: AudioParameter[];
	InstanceParameters: AudioParameter[];
	SoundClassOverride: SoundClass;
	bAutoDestroy: boolean;
	bStopWhenOwnerDestroyed: boolean;
	bShouldRemainActiveIfDropped: boolean;
	bAllowSpatialization: boolean;
	bOverrideAttenuation: boolean;
	bOverrideSubtitlePriority: boolean;
	bIsUISound: boolean;
	bEnableLowPassFilter: boolean;
	bOverridePriority: boolean;
	bSuppressSubtitles: boolean;
	bCanPlayMultipleInstances: boolean;
	bDisableParameterUpdatesWhilePlaying: boolean;
	bAutoManageAttachment: boolean;
	AudioComponentUserID: string;
	PitchModulationMin: number;
	PitchModulationMax: number;
	VolumeModulationMin: number;
	VolumeModulationMax: number;
	VolumeMultiplier: number;
	EnvelopeFollowerAttackTime: number;
	EnvelopeFollowerReleaseTime: number;
	Priority: number;
	SubtitlePriority: number;
	SourceEffectChain: SoundEffectSourcePresetChain;
	VolumeWeightedPriorityScale: number;
	HighFrequencyGainMultiplier: number;
	PitchMultiplier: number;
	LowPassFilterFrequency: number;
	AttenuationSettings: SoundAttenuation;
	AttenuationOverrides: SoundAttenuationSettings;
	ConcurrencySettings: SoundConcurrency;
	ConcurrencySet: any;
	AutoAttachLocationRule: EAttachmentRule;
	AutoAttachRotationRule: EAttachmentRule;
	AutoAttachScaleRule: EAttachmentRule;
	ModulationRouting: SoundModulationDefaultRoutingSettings;
	OnAudioPlayStateChanged: UnrealEngineMulticastDelegate<(PlayState: EAudioComponentPlayState) => void>;
	OnAudioVirtualizationChanged: UnrealEngineMulticastDelegate<(bIsVirtualized: boolean) => void>;
	OnAudioFinished: UnrealEngineMulticastDelegate<() => void>;
	OnAudioPlaybackPercent: UnrealEngineMulticastDelegate<(PlayingSoundWave: SoundWave, PlaybackPercent: number) => void>;
	OnAudioSingleEnvelopeValue: UnrealEngineMulticastDelegate<(PlayingSoundWave: SoundWave, EnvelopeValue: number) => void>;
	OnAudioMultiEnvelopeValue: UnrealEngineMulticastDelegate<(AverageEnvelopeValue: number, MaxEnvelope: number, NumWaveInstances: number) => void>;
	OnQueueSubtitles: UnrealEngineDelegate<(Subtitles: SubtitleCue[], CueDuration: number) => void>;
	AutoAttachParent: any;
	AutoAttachSocketName: string;
	static Load(ResourceName: string): AudioComponent;
	static Find(Outer: UObject, ResourceName: string): AudioComponent;
	static GetDefaultObject(): AudioComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioComponent;
	StopDelayed(DelayTime: number): void;
	Stop(): void;
	SetWaveParameter(InName: string,InWave: SoundWave): void;
	SetVolumeMultiplier(NewVolumeMultiplier: number): void;
	SetUISound(bInUISound: boolean): void;
	SetSubmixSend(Submix: SoundSubmixBase,SendLevel: number): void;
	SetSourceBusSendPreEffect(SoundSourceBus: SoundSourceBus,SourceBusSendLevel: number): void;
	SetSourceBusSendPostEffect(SoundSourceBus: SoundSourceBus,SourceBusSendLevel: number): void;
	SetSound(NewSound: SoundBase): void;
	SetPitchMultiplier(NewPitchMultiplier: number): void;
	SetPaused(bPause: boolean): void;
	SetOutputToBusOnly(bInOutputToBusOnly: boolean): void;
	SetLowPassFilterFrequency(InLowPassFilterFrequency: number): void;
	SetLowPassFilterEnabled(InLowPassFilterEnabled: boolean): void;
	SetIntParameter(InName: string,inInt: number): void;
	SetFloatParameter(InName: string,InFloat: number): void;
	SetBoolParameter(InName: string,InBool: boolean): void;
	SetAudioBusSendPreEffect(AudioBus: AudioBus,AudioBusSendLevel: number): void;
	SetAudioBusSendPostEffect(AudioBus: AudioBus,AudioBusSendLevel: number): void;
	Play(StartTime: number): void;
	IsVirtualized(): boolean;
	IsPlaying(): boolean;
	HasCookedFFTData(): boolean;
	HasCookedAmplitudeEnvelopeData(): boolean;
	GetPlayState(): EAudioComponentPlayState;
	GetCookedFFTDataForAllPlayingSounds(OutSoundWaveSpectralData?: SoundWaveSpectralDataPerSound[]): {OutSoundWaveSpectralData: SoundWaveSpectralDataPerSound[], $: boolean};
	GetCookedFFTData(FrequenciesToGet: number[],OutSoundWaveSpectralData?: SoundWaveSpectralData[]): {OutSoundWaveSpectralData: SoundWaveSpectralData[], $: boolean};
	GetCookedEnvelopeDataForAllPlayingSounds(OutEnvelopeData?: SoundWaveEnvelopeDataPerSound[]): {OutEnvelopeData: SoundWaveEnvelopeDataPerSound[], $: boolean};
	GetCookedEnvelopeData(OutEnvelopeData?: number): {OutEnvelopeData: number, $: boolean};
	FadeOut(FadeOutDuration: number,FadeVolumeLevel: number,FadeCurve: EAudioFaderCurve): void;
	FadeIn(FadeInDuration: number,FadeVolumeLevel: number,StartTime: number,FadeCurve: EAudioFaderCurve): void;
	BP_GetAttenuationSettingsToApply(OutAttenuationSettings?: SoundAttenuationSettings): {OutAttenuationSettings: SoundAttenuationSettings, $: boolean};
	AdjustVolume(AdjustVolumeDuration: number,AdjustVolumeLevel: number,FadeCurve: EAudioFaderCurve): void;
	AdjustAttenuation(InAttenuationSettings: SoundAttenuationSettings): void;
	static C(Other: UObject | any): AudioComponent;
}

declare class SoundBase extends UObject { 
	SoundClassObject: SoundClass;
	bDebug: boolean;
	bOverrideConcurrency: boolean;
	bOutputToBusOnly: boolean;
	bEnableBusSends: boolean;
	bEnableBaseSubmix: boolean;
	bEnableSubmixSends: boolean;
	bHasDelayNode: boolean;
	bHasConcatenatorNode: boolean;
	bHasVirtualizeWhenSilent: boolean;
	bBypassVolumeScaleForPriority: boolean;
	VirtualizationMode: EVirtualizationMode;
	MaxConcurrentResolutionRule: EMaxConcurrentResolutionRule;
	SoundConcurrencySettings: SoundConcurrency;
	ConcurrencySet: any;
	ConcurrencyOverrides: SoundConcurrencySettings;
	MaxConcurrentPlayCount: number;
	Duration: number;
	MaxDistance: number;
	TotalSamples: number;
	Priority: number;
	AttenuationSettings: SoundAttenuation;
	SoundSubmixObject: SoundSubmixBase;
	SoundSubmixSends: SoundSubmixSendInfo[];
	SourceEffectChain: SoundEffectSourcePresetChain;
	BusSends: SoundSourceBusSendInfo[];
	PreEffectBusSends: SoundSourceBusSendInfo[];
	AssetUserData: AssetUserData[];
	static Load(ResourceName: string): SoundBase;
	static Find(Outer: UObject, ResourceName: string): SoundBase;
	static GetDefaultObject(): SoundBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundBase;
	static C(Other: UObject | any): SoundBase;
	PrimeSound(): void;
	SpawnSoundAttached(AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,bAutoDestroy: boolean): AudioComponent;
	static PrimeSound(InSound: SoundBase): void;
	static SpawnSoundAttached(Sound: SoundBase,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency,bAutoDestroy: boolean): AudioComponent;
}

declare type EUMGSequencePlayMode = 'Forward' | 'Reverse' | 'PingPong' | 'EUMGSequencePlayMode_MAX';
declare var EUMGSequencePlayMode : { Forward:'Forward',Reverse:'Reverse',PingPong:'PingPong',EUMGSequencePlayMode_MAX:'EUMGSequencePlayMode_MAX', };
declare class InputEvent { 
	clone() : InputEvent;
	static C(Other: UObject | any): InputEvent;
	InputEvent_IsAltDown(): boolean;
	InputEvent_IsCommandDown(): boolean;
	InputEvent_IsControlDown(): boolean;
	InputEvent_IsLeftAltDown(): boolean;
	InputEvent_IsLeftCommandDown(): boolean;
	InputEvent_IsLeftControlDown(): boolean;
	InputEvent_IsLeftShiftDown(): boolean;
	InputEvent_IsRepeat(): boolean;
	InputEvent_IsRightAltDown(): boolean;
	InputEvent_IsRightCommandDown(): boolean;
	InputEvent_IsRightControlDown(): boolean;
	InputEvent_IsRightShiftDown(): boolean;
	InputEvent_IsShiftDown(): boolean;
	static InputEvent_IsAltDown(Input: InputEvent): boolean;
	static InputEvent_IsCommandDown(Input: InputEvent): boolean;
	static InputEvent_IsControlDown(Input: InputEvent): boolean;
	static InputEvent_IsLeftAltDown(Input: InputEvent): boolean;
	static InputEvent_IsLeftCommandDown(Input: InputEvent): boolean;
	static InputEvent_IsLeftControlDown(Input: InputEvent): boolean;
	static InputEvent_IsLeftShiftDown(Input: InputEvent): boolean;
	static InputEvent_IsRepeat(Input: InputEvent): boolean;
	static InputEvent_IsRightAltDown(Input: InputEvent): boolean;
	static InputEvent_IsRightCommandDown(Input: InputEvent): boolean;
	static InputEvent_IsRightControlDown(Input: InputEvent): boolean;
	static InputEvent_IsRightShiftDown(Input: InputEvent): boolean;
	static InputEvent_IsShiftDown(Input: InputEvent): boolean;
}

declare type ESlateGesture = 'None' | 'Scroll' | 'Magnify' | 'Swipe' | 'Rotate' | 'LongPress' | 'ESlateGesture_MAX';
declare var ESlateGesture : { None:'None',Scroll:'Scroll',Magnify:'Magnify',Swipe:'Swipe',Rotate:'Rotate',LongPress:'LongPress',ESlateGesture_MAX:'ESlateGesture_MAX', };
declare class EventReply { 
	clone() : EventReply;
	static C(Other: UObject | any): EventReply;
	CaptureJoystick(CapturingWidget?: Widget,bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	CaptureMouse(CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	ClearUserFocus(bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	DetectDrag(WidgetDetectingDrag?: Widget,DragKey?: Key): {Reply: EventReply, $: EventReply};
	EndDragDrop(): {Reply: EventReply, $: EventReply};
	LockMouse(CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	ReleaseJoystickCapture(bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	ReleaseMouseCapture(): {Reply: EventReply, $: EventReply};
	SetMousePosition(NewMousePosition?: Vector2D): {Reply: EventReply, $: EventReply};
	SetUserFocus(FocusWidget?: Widget,bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	UnlockMouse(): {Reply: EventReply, $: EventReply};
	static CaptureJoystick(Reply?: EventReply,CapturingWidget?: Widget,bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	static CaptureMouse(Reply?: EventReply,CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	static ClearUserFocus(Reply?: EventReply,bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	static DetectDrag(Reply?: EventReply,WidgetDetectingDrag?: Widget,DragKey?: Key): {Reply: EventReply, $: EventReply};
	static EndDragDrop(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static LockMouse(Reply?: EventReply,CapturingWidget?: Widget): {Reply: EventReply, $: EventReply};
	static ReleaseJoystickCapture(Reply?: EventReply,bInAllJoysticks?: boolean): {Reply: EventReply, $: EventReply};
	static ReleaseMouseCapture(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static SetMousePosition(Reply?: EventReply,NewMousePosition?: Vector2D): {Reply: EventReply, $: EventReply};
	static SetUserFocus(Reply?: EventReply,FocusWidget?: Widget,bInAllUsers?: boolean): {Reply: EventReply, $: EventReply};
	static UnlockMouse(Reply?: EventReply): {Reply: EventReply, $: EventReply};
	static Handled(): EventReply;
	static Unhandled(): EventReply;
}

declare class UPointerEvent extends InputEvent { 
	clone() : UPointerEvent;
	static C(Other: UObject | any): UPointerEvent;
	PointerEvent_GetCursorDelta(): Vector2D;
	PointerEvent_GetEffectingButton(): Key;
	PointerEvent_GetGestureDelta(): Vector2D;
	PointerEvent_GetGestureType(): ESlateGesture;
	PointerEvent_GetLastScreenSpacePosition(): Vector2D;
	PointerEvent_GetPointerIndex(): number;
	PointerEvent_GetScreenSpacePosition(): Vector2D;
	PointerEvent_GetTouchpadIndex(): number;
	PointerEvent_GetUserIndex(): number;
	PointerEvent_GetWheelDelta(): number;
	PointerEvent_IsMouseButtonDown(MouseButton: Key): boolean;
	PointerEvent_IsTouchEvent(): boolean;
	DetectDragIfPressed(WidgetDetectingDrag: Widget,DragKey: Key): EventReply;
	GetInputEventFromPointerEvent(): InputEvent;
	static PointerEvent_GetCursorDelta(Input: UPointerEvent): Vector2D;
	static PointerEvent_GetEffectingButton(Input: UPointerEvent): Key;
	static PointerEvent_GetGestureDelta(Input: UPointerEvent): Vector2D;
	static PointerEvent_GetGestureType(Input: UPointerEvent): ESlateGesture;
	static PointerEvent_GetLastScreenSpacePosition(Input: UPointerEvent): Vector2D;
	static PointerEvent_GetPointerIndex(Input: UPointerEvent): number;
	static PointerEvent_GetScreenSpacePosition(Input: UPointerEvent): Vector2D;
	static PointerEvent_GetTouchpadIndex(Input: UPointerEvent): number;
	static PointerEvent_GetUserIndex(Input: UPointerEvent): number;
	static PointerEvent_GetWheelDelta(Input: UPointerEvent): number;
	static PointerEvent_IsMouseButtonDown(Input: UPointerEvent,MouseButton: Key): boolean;
	static PointerEvent_IsTouchEvent(Input: UPointerEvent): boolean;
	static DetectDragIfPressed(UPointerEvent: UPointerEvent,WidgetDetectingDrag: Widget,DragKey: Key): EventReply;
	static GetInputEventFromPointerEvent(Event: UPointerEvent): InputEvent;
}

declare class UFocusEvent { 
	clone() : UFocusEvent;
	static C(Other: UObject | any): UFocusEvent;
}

declare class KeyEvent extends InputEvent { 
	clone() : KeyEvent;
	static C(Other: UObject | any): KeyEvent;
	GetIsAltDownByKeyEvent(): boolean;
	GetIsControlDownByKeyEvent(): boolean;
	GetIsShiftDownByKeyEvent(): boolean;
	GetKeyNameByKeyEvent(): string;
	GetKey(): Key;
	GetUserIndex(): number;
	Key_GetNavigationActionFromKey(): EUINavigationAction;
	Key_GetNavigationDirectionFromKey(): EUINavigation;
	GetInputEventFromKeyEvent(): InputEvent;
	static GetIsAltDownByKeyEvent(Event: KeyEvent): boolean;
	static GetIsControlDownByKeyEvent(Event: KeyEvent): boolean;
	static GetIsShiftDownByKeyEvent(Event: KeyEvent): boolean;
	static GetKeyNameByKeyEvent(Event: KeyEvent): string;
	static GetKey(Input: KeyEvent): Key;
	static GetUserIndex(Input: KeyEvent): number;
	static Key_GetNavigationActionFromKey(InKeyEvent: KeyEvent): EUINavigationAction;
	static Key_GetNavigationDirectionFromKey(InKeyEvent: KeyEvent): EUINavigation;
	static GetInputEventFromKeyEvent(Event: KeyEvent): InputEvent;
}

declare class SlateBrushAsset extends UObject { 
	Brush: SlateBrush;
	static Load(ResourceName: string): SlateBrushAsset;
	static Find(Outer: UObject, ResourceName: string): SlateBrushAsset;
	static GetDefaultObject(): SlateBrushAsset;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateBrushAsset;
	static C(Other: UObject | any): SlateBrushAsset;
	MakeBrushFromAsset(): SlateBrush;
	static MakeBrushFromAsset(BrushAsset: SlateBrushAsset): SlateBrush;
}

declare class PaintContext { 
	clone() : PaintContext;
	static C(Other: UObject | any): PaintContext;
	DrawSpaceSpline(InStart?: Vector2D,InStartDir?: Vector2D,InEnd?: Vector2D,InEndDir?: Vector2D,InThickness?: number,InTint?: LinearColor): {Context: PaintContext};
	DrawBox(position?: Vector2D,Size?: Vector2D,Brush?: SlateBrushAsset,Tint?: LinearColor): {Context: PaintContext};
	DrawLine(PositionA?: Vector2D,PositionB?: Vector2D,Tint?: LinearColor,bAntiAlias?: boolean,Thickness?: number): {Context: PaintContext};
	DrawLines(Points?: Vector2D[],Tint?: LinearColor,bAntiAlias?: boolean,Thickness?: number): {Context: PaintContext};
	DrawText(InString?: string,position?: Vector2D,Tint?: LinearColor): {Context: PaintContext};
	DrawTextFormatted(text?: string,position?: Vector2D,Font?: Font,FontSize?: number,FontTypeFace?: string,Tint?: LinearColor): {Context: PaintContext};
	static DrawSpaceSpline(Context?: PaintContext,InStart?: Vector2D,InStartDir?: Vector2D,InEnd?: Vector2D,InEndDir?: Vector2D,InThickness?: number,InTint?: LinearColor): {Context: PaintContext};
	static DrawBox(Context?: PaintContext,position?: Vector2D,Size?: Vector2D,Brush?: SlateBrushAsset,Tint?: LinearColor): {Context: PaintContext};
	static DrawLine(Context?: PaintContext,PositionA?: Vector2D,PositionB?: Vector2D,Tint?: LinearColor,bAntiAlias?: boolean,Thickness?: number): {Context: PaintContext};
	static DrawLines(Context?: PaintContext,Points?: Vector2D[],Tint?: LinearColor,bAntiAlias?: boolean,Thickness?: number): {Context: PaintContext};
	static DrawText(Context?: PaintContext,InString?: string,position?: Vector2D,Tint?: LinearColor): {Context: PaintContext};
	static DrawTextFormatted(Context?: PaintContext,text?: string,position?: Vector2D,Font?: Font,FontSize?: number,FontTypeFace?: string,Tint?: LinearColor): {Context: PaintContext};
}

declare class MotionEvent extends InputEvent { 
	clone() : MotionEvent;
	static C(Other: UObject | any): MotionEvent;
}

declare class CharacterEvent extends InputEvent { 
	clone() : CharacterEvent;
	static C(Other: UObject | any): CharacterEvent;
	GetInputEventFromCharacterEvent(): InputEvent;
	static GetInputEventFromCharacterEvent(Event: CharacterEvent): InputEvent;
}

declare type EDragPivot = 'MouseDown' | 'TopLeft' | 'TopCenter' | 'TopRight' | 'CenterLeft' | 'CenterCenter' | 'CenterRight' | 'BottomLeft' | 'BottomCenter' | 'BottomRight' | 'EDragPivot_MAX';
declare var EDragPivot : { MouseDown:'MouseDown',TopLeft:'TopLeft',TopCenter:'TopCenter',TopRight:'TopRight',CenterLeft:'CenterLeft',CenterCenter:'CenterCenter',CenterRight:'CenterRight',BottomLeft:'BottomLeft',BottomCenter:'BottomCenter',BottomRight:'BottomRight',EDragPivot_MAX:'EDragPivot_MAX', };
declare class DragDropOperation extends UObject { 
	Tag: string;
	Payload: UObject;
	DefaultDragVisual: Widget;
	Pivot: EDragPivot;
	Offset: Vector2D;
	OnDrop: UnrealEngineMulticastDelegate<(Operation: DragDropOperation) => void>;
	OnDragCancelled: UnrealEngineMulticastDelegate<(Operation: DragDropOperation) => void>;
	OnDragged: UnrealEngineMulticastDelegate<(Operation: DragDropOperation) => void>;
	static Load(ResourceName: string): DragDropOperation;
	static Find(Outer: UObject, ResourceName: string): DragDropOperation;
	static GetDefaultObject(): DragDropOperation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DragDropOperation;
	Drop(UPointerEvent: UPointerEvent): void;
	Dragged(UPointerEvent: UPointerEvent): void;
	DragCancelled(UPointerEvent: UPointerEvent): void;
	static C(Other: UObject | any): DragDropOperation;
}

declare class AnalogInputEvent extends KeyEvent { 
	clone() : AnalogInputEvent;
	static C(Other: UObject | any): AnalogInputEvent;
	GetAnalogValue(): number;
	Key_GetNavigationDirectionFromAnalog(): EUINavigation;
	GetKeyEventFromAnalogInputEvent(): KeyEvent;
	static GetAnalogValue(Input: AnalogInputEvent): number;
	static Key_GetNavigationDirectionFromAnalog(InAnalogEvent: AnalogInputEvent): EUINavigation;
	static GetKeyEventFromAnalogInputEvent(Event: AnalogInputEvent): KeyEvent;
}

declare class UserWidget extends Widget { 
	ColorAndOpacity: LinearColor;
	ColorAndOpacityDelegate: UnrealEngineDelegate<() => LinearColor>;
	ForegroundColor: SlateColor;
	ForegroundColorDelegate: UnrealEngineDelegate<() => SlateColor>;
	OnVisibilityChanged: UnrealEngineMulticastDelegate<(InVisibility: ESlateVisibility) => void>;
	Padding: Margin;
	ActiveSequencePlayers: UMGSequencePlayer[];
	AnimationTickManager: UMGSequenceTickManager;
	StoppedSequencePlayers: UMGSequencePlayer[];
	NamedSlotBindings: NamedSlotBinding[];
	WidgetTree: WidgetTree;
	DesignTimeSize: Vector2D;
	DesignSizeMode: EDesignPreviewSizeMode;
	PaletteCategory: string;
	PreviewBackground: Texture2D;
	Priority: number;
	bSupportsKeyboardFocus: boolean;
	bIsFocusable: boolean;
	bStopAction: boolean;
	bHasScriptImplementedTick: boolean;
	bHasScriptImplementedPaint: boolean;
	TickFrequency: EWidgetTickFrequency;
	InputComponent: InputComponent;
	AnimationCallbacks: AnimationEventBinding[];
	static Load(ResourceName: string): UserWidget;
	static Find(Outer: UObject, ResourceName: string): UserWidget;
	static GetDefaultObject(): UserWidget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserWidget;
	UnregisterInputComponent(): void;
	UnbindAllFromAnimationStarted(Animation: WidgetAnimation): void;
	UnbindAllFromAnimationFinished(Animation: WidgetAnimation): void;
	Tick(MyGeometry: Geometry,InDeltaTime: number): void;
	StopListeningForInputAction(ActionName: string,EventType: EInputEvent): void;
	StopListeningForAllInputActions(): void;
	StopAnimationsAndLatentActions(): void;
	StopAnimation(InAnimation: WidgetAnimation): void;
	StopAllAnimations(): void;
	SetPositionInViewport(position: Vector2D,bRemoveDPIScale: boolean): void;
	SetPlaybackSpeed(InAnimation: WidgetAnimation,PlaybackSpeed: number): void;
	SetPadding(InPadding: Margin): void;
	SetOwningPlayer(LocalPlayerController: PlayerController): void;
	SetNumLoopsToPlay(InAnimation: WidgetAnimation,NumLoopsToPlay: number): void;
	SetInputActionPriority(NewPriority: number): void;
	SetInputActionBlocking(bShouldBlock: boolean): void;
	SetForegroundColor(InForegroundColor: SlateColor): void;
	SetDesiredSizeInViewport(Size: Vector2D): void;
	SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
	SetAnimationCurrentTime(InAnimation: WidgetAnimation,InTime: number): void;
	SetAnchorsInViewport(Anchors: Anchors): void;
	SetAlignmentInViewport(Alignment: Vector2D): void;
	ReverseAnimation(InAnimation: WidgetAnimation): void;
	RemoveFromViewport(): void;
	RegisterInputComponent(): void;
	PreConstruct(IsDesignTime: boolean): void;
	PlaySound(SoundToPlay: SoundBase): void;
	PlayAnimationTimeRange(InAnimation: WidgetAnimation,StartAtTime: number,EndAtTime: number,NumLoopsToPlay: number,PlayMode: EUMGSequencePlayMode,PlaybackSpeed: number,bRestoreState: boolean): UMGSequencePlayer;
	PlayAnimationReverse(InAnimation: WidgetAnimation,PlaybackSpeed: number,bRestoreState: boolean): UMGSequencePlayer;
	PlayAnimationForward(InAnimation: WidgetAnimation,PlaybackSpeed: number,bRestoreState: boolean): UMGSequencePlayer;
	PlayAnimation(InAnimation: WidgetAnimation,StartAtTime: number,NumLoopsToPlay: number,PlayMode: EUMGSequencePlayMode,PlaybackSpeed: number,bRestoreState: boolean): UMGSequencePlayer;
	PauseAnimation(InAnimation: WidgetAnimation): number;
	OnTouchStarted(MyGeometry: Geometry,InTouchEvent: UPointerEvent): EventReply;
	OnTouchMoved(MyGeometry: Geometry,InTouchEvent: UPointerEvent): EventReply;
	OnTouchGesture(MyGeometry: Geometry,GestureEvent: UPointerEvent): EventReply;
	OnTouchForceChanged(MyGeometry: Geometry,InTouchEvent: UPointerEvent): EventReply;
	OnTouchEnded(MyGeometry: Geometry,InTouchEvent: UPointerEvent): EventReply;
	OnRemovedFromFocusPath(InFocusEvent: UFocusEvent): void;
	OnPreviewMouseButtonDown(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnPreviewKeyDown(MyGeometry: Geometry,InKeyEvent: KeyEvent): EventReply;
	OnPaint(Context?: PaintContext): {Context: PaintContext};
	OnMouseWheel(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnMouseMove(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnMouseLeave(MouseEvent: UPointerEvent): void;
	OnMouseEnter(MyGeometry: Geometry,MouseEvent: UPointerEvent): void;
	OnMouseCaptureLost(): void;
	OnMouseButtonUp(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnMouseButtonDown(MyGeometry: Geometry,MouseEvent: UPointerEvent): EventReply;
	OnMouseButtonDoubleClick(InMyGeometry: Geometry,InMouseEvent: UPointerEvent): EventReply;
	OnMotionDetected(MyGeometry: Geometry,InMotionEvent: MotionEvent): EventReply;
	OnKeyUp(MyGeometry: Geometry,InKeyEvent: KeyEvent): EventReply;
	OnKeyDown(MyGeometry: Geometry,InKeyEvent: KeyEvent): EventReply;
	OnKeyChar(MyGeometry: Geometry,InCharacterEvent: CharacterEvent): EventReply;
	OnInitialized(): void;
	OnFocusReceived(MyGeometry: Geometry,InFocusEvent: UFocusEvent): EventReply;
	OnFocusLost(InFocusEvent: UFocusEvent): void;
	OnDrop(MyGeometry: Geometry,UPointerEvent: UPointerEvent,Operation: DragDropOperation): boolean;
	OnDragOver(MyGeometry: Geometry,UPointerEvent: UPointerEvent,Operation: DragDropOperation): boolean;
	OnDragLeave(UPointerEvent: UPointerEvent,Operation: DragDropOperation): void;
	OnDragEnter(MyGeometry: Geometry,UPointerEvent: UPointerEvent,Operation: DragDropOperation): void;
	OnDragDetected(MyGeometry: Geometry,UPointerEvent: UPointerEvent,Operation?: DragDropOperation): {Operation: DragDropOperation};
	OnDragCancelled(UPointerEvent: UPointerEvent,Operation: DragDropOperation): void;
	OnAnimationStarted(Animation: WidgetAnimation): void;
	OnAnimationFinished(Animation: WidgetAnimation): void;
	OnAnalogValueChanged(MyGeometry: Geometry,InAnalogInputEvent: AnalogInputEvent): EventReply;
	OnAddedToFocusPath(InFocusEvent: UFocusEvent): void;
	IsPlayingAnimation(): boolean;
	IsListeningForInputAction(ActionName: string): boolean;
	IsInViewport(): boolean;
	IsInteractable(): boolean;
	IsAnyAnimationPlaying(): boolean;
	IsAnimationPlayingForward(InAnimation: WidgetAnimation): boolean;
	IsAnimationPlaying(InAnimation: WidgetAnimation): boolean;
	GetOwningPlayerPawn(): Pawn;
	GetOwningPlayerCameraManager(): PlayerCameraManager;
	GetIsVisible(): boolean;
	GetAnimationCurrentTime(InAnimation: WidgetAnimation): number;
	GetAnchorsInViewport(): Anchors;
	GetAlignmentInViewport(): Vector2D;
	FlushAnimations(): void;
	Destruct(): void;
	Construct(): void;
	CancelLatentActions(): void;
	AddToViewport(ZOrder: number): void;
	AddToPlayerScreen(ZOrder: number): boolean;
	static C(Other: UObject | any): UserWidget;
}

declare class ViewTargetTransitionParams { 
	BlendTime: number;
	BlendFunction: EViewTargetBlendFunction;
	BlendExp: number;
	bLockOutgoing: boolean;
	clone() : ViewTargetTransitionParams;
	static C(Other: UObject | any): ViewTargetTransitionParams;
}

declare class UpdateLevelVisibilityLevelInfo { 
	PackageName: string;
	Filename: string;
	bIsVisible: boolean;
	clone() : UpdateLevelVisibilityLevelInfo;
	static C(Other: UObject | any): UpdateLevelVisibilityLevelInfo;
}

declare class HapticFeedbackEffect_Base extends UObject { 
	static Load(ResourceName: string): HapticFeedbackEffect_Base;
	static Find(Outer: UObject, ResourceName: string): HapticFeedbackEffect_Base;
	static GetDefaultObject(): HapticFeedbackEffect_Base;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HapticFeedbackEffect_Base;
	static C(Other: UObject | any): HapticFeedbackEffect_Base;
}

declare type EDynamicForceFeedbackAction = 'Start' | 'Update' | 'Stop' | 'EDynamicForceFeedbackAction_MAX';
declare var EDynamicForceFeedbackAction : { Start:'Start',Update:'Update',Stop:'Stop',EDynamicForceFeedbackAction_MAX:'EDynamicForceFeedbackAction_MAX', };
declare class LatentActionInfo { 
	Linkage: number;
	UUID: number;
	ExecutionFunction: string;
	CallbackTarget: UObject;
	clone() : LatentActionInfo;
	static C(Other: UObject | any): LatentActionInfo;
}

declare type ETouchIndex = 'Touch1' | 'Touch2' | 'Touch3' | 'Touch4' | 'Touch5' | 'Touch6' | 'Touch7' | 'Touch8' | 'Touch9' | 'Touch10' | 'CursorPointerIndex' | 'MAX_TOUCHES' | 'ETouchIndex_MAX';
declare var ETouchIndex : { Touch1:'Touch1',Touch2:'Touch2',Touch3:'Touch3',Touch4:'Touch4',Touch5:'Touch5',Touch6:'Touch6',Touch7:'Touch7',Touch8:'Touch8',Touch9:'Touch9',Touch10:'Touch10',CursorPointerIndex:'CursorPointerIndex',MAX_TOUCHES:'MAX_TOUCHES',ETouchIndex_MAX:'ETouchIndex_MAX', };
declare type EObjectTypeQuery = 'ObjectTypeQuery1' | 'ObjectTypeQuery2' | 'ObjectTypeQuery3' | 'ObjectTypeQuery4' | 'ObjectTypeQuery5' | 'ObjectTypeQuery6' | 'ObjectTypeQuery7' | 'ObjectTypeQuery8' | 'ObjectTypeQuery9' | 'ObjectTypeQuery10' | 'ObjectTypeQuery11' | 'ObjectTypeQuery12' | 'ObjectTypeQuery13' | 'ObjectTypeQuery14' | 'ObjectTypeQuery15' | 'ObjectTypeQuery16' | 'ObjectTypeQuery17' | 'ObjectTypeQuery18' | 'ObjectTypeQuery19' | 'ObjectTypeQuery20' | 'ObjectTypeQuery21' | 'ObjectTypeQuery22' | 'ObjectTypeQuery23' | 'ObjectTypeQuery24' | 'ObjectTypeQuery25' | 'ObjectTypeQuery26' | 'ObjectTypeQuery27' | 'ObjectTypeQuery28' | 'ObjectTypeQuery29' | 'ObjectTypeQuery30' | 'ObjectTypeQuery31' | 'ObjectTypeQuery32' | 'ObjectTypeQuery_MAX' | 'EObjectTypeQuery_MAX';
declare var EObjectTypeQuery : { ObjectTypeQuery1:'ObjectTypeQuery1',ObjectTypeQuery2:'ObjectTypeQuery2',ObjectTypeQuery3:'ObjectTypeQuery3',ObjectTypeQuery4:'ObjectTypeQuery4',ObjectTypeQuery5:'ObjectTypeQuery5',ObjectTypeQuery6:'ObjectTypeQuery6',ObjectTypeQuery7:'ObjectTypeQuery7',ObjectTypeQuery8:'ObjectTypeQuery8',ObjectTypeQuery9:'ObjectTypeQuery9',ObjectTypeQuery10:'ObjectTypeQuery10',ObjectTypeQuery11:'ObjectTypeQuery11',ObjectTypeQuery12:'ObjectTypeQuery12',ObjectTypeQuery13:'ObjectTypeQuery13',ObjectTypeQuery14:'ObjectTypeQuery14',ObjectTypeQuery15:'ObjectTypeQuery15',ObjectTypeQuery16:'ObjectTypeQuery16',ObjectTypeQuery17:'ObjectTypeQuery17',ObjectTypeQuery18:'ObjectTypeQuery18',ObjectTypeQuery19:'ObjectTypeQuery19',ObjectTypeQuery20:'ObjectTypeQuery20',ObjectTypeQuery21:'ObjectTypeQuery21',ObjectTypeQuery22:'ObjectTypeQuery22',ObjectTypeQuery23:'ObjectTypeQuery23',ObjectTypeQuery24:'ObjectTypeQuery24',ObjectTypeQuery25:'ObjectTypeQuery25',ObjectTypeQuery26:'ObjectTypeQuery26',ObjectTypeQuery27:'ObjectTypeQuery27',ObjectTypeQuery28:'ObjectTypeQuery28',ObjectTypeQuery29:'ObjectTypeQuery29',ObjectTypeQuery30:'ObjectTypeQuery30',ObjectTypeQuery31:'ObjectTypeQuery31',ObjectTypeQuery32:'ObjectTypeQuery32',ObjectTypeQuery_MAX:'ObjectTypeQuery_MAX',EObjectTypeQuery_MAX:'EObjectTypeQuery_MAX', };
declare type ETraceTypeQuery = 'TraceTypeQuery1' | 'TraceTypeQuery2' | 'TraceTypeQuery3' | 'TraceTypeQuery4' | 'TraceTypeQuery5' | 'TraceTypeQuery6' | 'TraceTypeQuery7' | 'TraceTypeQuery8' | 'TraceTypeQuery9' | 'TraceTypeQuery10' | 'TraceTypeQuery11' | 'TraceTypeQuery12' | 'TraceTypeQuery13' | 'TraceTypeQuery14' | 'TraceTypeQuery15' | 'TraceTypeQuery16' | 'TraceTypeQuery17' | 'TraceTypeQuery18' | 'TraceTypeQuery19' | 'TraceTypeQuery20' | 'TraceTypeQuery21' | 'TraceTypeQuery22' | 'TraceTypeQuery23' | 'TraceTypeQuery24' | 'TraceTypeQuery25' | 'TraceTypeQuery26' | 'TraceTypeQuery27' | 'TraceTypeQuery28' | 'TraceTypeQuery29' | 'TraceTypeQuery30' | 'TraceTypeQuery31' | 'TraceTypeQuery32' | 'TraceTypeQuery_MAX' | 'ETraceTypeQuery_MAX';
declare var ETraceTypeQuery : { TraceTypeQuery1:'TraceTypeQuery1',TraceTypeQuery2:'TraceTypeQuery2',TraceTypeQuery3:'TraceTypeQuery3',TraceTypeQuery4:'TraceTypeQuery4',TraceTypeQuery5:'TraceTypeQuery5',TraceTypeQuery6:'TraceTypeQuery6',TraceTypeQuery7:'TraceTypeQuery7',TraceTypeQuery8:'TraceTypeQuery8',TraceTypeQuery9:'TraceTypeQuery9',TraceTypeQuery10:'TraceTypeQuery10',TraceTypeQuery11:'TraceTypeQuery11',TraceTypeQuery12:'TraceTypeQuery12',TraceTypeQuery13:'TraceTypeQuery13',TraceTypeQuery14:'TraceTypeQuery14',TraceTypeQuery15:'TraceTypeQuery15',TraceTypeQuery16:'TraceTypeQuery16',TraceTypeQuery17:'TraceTypeQuery17',TraceTypeQuery18:'TraceTypeQuery18',TraceTypeQuery19:'TraceTypeQuery19',TraceTypeQuery20:'TraceTypeQuery20',TraceTypeQuery21:'TraceTypeQuery21',TraceTypeQuery22:'TraceTypeQuery22',TraceTypeQuery23:'TraceTypeQuery23',TraceTypeQuery24:'TraceTypeQuery24',TraceTypeQuery25:'TraceTypeQuery25',TraceTypeQuery26:'TraceTypeQuery26',TraceTypeQuery27:'TraceTypeQuery27',TraceTypeQuery28:'TraceTypeQuery28',TraceTypeQuery29:'TraceTypeQuery29',TraceTypeQuery30:'TraceTypeQuery30',TraceTypeQuery31:'TraceTypeQuery31',TraceTypeQuery32:'TraceTypeQuery32',TraceTypeQuery_MAX:'TraceTypeQuery_MAX',ETraceTypeQuery_MAX:'ETraceTypeQuery_MAX', };
declare class UpdateLevelStreamingLevelStatus { 
	PackageName: string;
	LODIndex: number;
	bNewShouldBeLoaded: boolean;
	bNewShouldBeVisible: boolean;
	bNewShouldBlockOnLoad: boolean;
	clone() : UpdateLevelStreamingLevelStatus;
	static C(Other: UObject | any): UpdateLevelStreamingLevelStatus;
}

declare type ETravelType = 'TRAVEL_Absolute' | 'TRAVEL_Partial' | 'TRAVEL_Relative' | 'TRAVEL_MAX';
declare var ETravelType : { TRAVEL_Absolute:'TRAVEL_Absolute',TRAVEL_Partial:'TRAVEL_Partial',TRAVEL_Relative:'TRAVEL_Relative',TRAVEL_MAX:'TRAVEL_MAX', };
declare class LocalMessage extends UObject { 
	static Load(ResourceName: string): LocalMessage;
	static Find(Outer: UObject, ResourceName: string): LocalMessage;
	static GetDefaultObject(): LocalMessage;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalMessage;
	static C(Other: UObject | any): LocalMessage;
}

declare class ForceFeedbackParameters { 
	Tag: string;
	bLooping: boolean;
	bIgnoreTimeDilation: boolean;
	bPlayWhilePaused: boolean;
	clone() : ForceFeedbackParameters;
	static C(Other: UObject | any): ForceFeedbackParameters;
}

declare class Subsystem extends UObject { 
	static Load(ResourceName: string): Subsystem;
	static Find(Outer: UObject, ResourceName: string): Subsystem;
	static GetDefaultObject(): Subsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Subsystem;
	static C(Other: UObject | any): Subsystem;
}

declare class LocalPlayerSubsystem extends Subsystem { 
	static Load(ResourceName: string): LocalPlayerSubsystem;
	static Find(Outer: UObject, ResourceName: string): LocalPlayerSubsystem;
	static GetDefaultObject(): LocalPlayerSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalPlayerSubsystem;
	static C(Other: UObject | any): LocalPlayerSubsystem;
}

declare type EMouseLockMode = 'DoNotLock' | 'LockOnCapture' | 'LockAlways' | 'LockInFullscreen' | 'EMouseLockMode_MAX';
declare var EMouseLockMode : { DoNotLock:'DoNotLock',LockOnCapture:'LockOnCapture',LockAlways:'LockAlways',LockInFullscreen:'LockInFullscreen',EMouseLockMode_MAX:'EMouseLockMode_MAX', };
declare class PlayerController extends Controller { 
	Player: Player;
	AcknowledgedPawn: Pawn;
	ControllingDirTrackInst: InterpTrackInstDirector;
	MyHUD: HUD;
	PlayerCameraManager: PlayerCameraManager;
	PlayerCameraManagerClass: UnrealEngineClass;
	bAutoManageActiveCameraTarget: boolean;
	TargetViewRotation: Rotator;
	SmoothTargetViewRotationSpeed: number;
	HiddenActors: Actor[];
	HiddenPrimitiveComponents: any[];
	LastSpectatorStateSynchTime: number;
	LastSpectatorSyncLocation: Vector;
	LastSpectatorSyncRotation: Rotator;
	ClientCap: number;
	CheatManager: CheatManager;
	CheatClass: UnrealEngineClass;
	PlayerInput: PlayerInput;
	ActiveForceFeedbackEffects: ActiveForceFeedbackEffect[];
	bPlayerIsWaiting: boolean;
	NetPlayerIndex: number;
	PendingSwapConnection: NetConnection;
	NetConnection: NetConnection;
	InputYawScale: number;
	InputPitchScale: number;
	InputRollScale: number;
	bShowMouseCursor: boolean;
	bEnableClickEvents: boolean;
	bEnableTouchEvents: boolean;
	bEnableMouseOverEvents: boolean;
	bEnableTouchOverEvents: boolean;
	bForceFeedbackEnabled: boolean;
	bEnableStreamingSource: boolean;
	bStreamingSourceShouldActivate: boolean;
	bStreamingSourceShouldBlockOnSlowStreaming: boolean;
	ForceFeedbackScale: number;
	ClickEventKeys: Key[];
	DefaultMouseCursor: EMouseCursor;
	CurrentMouseCursor: EMouseCursor;
	DefaultClickTraceChannel: ECollisionChannel;
	CurrentClickTraceChannel: ECollisionChannel;
	HitResultTraceDistance: number;
	SeamlessTravelCount: any;
	LastCompletedSeamlessTravelCount: any;
	InactiveStateInputComponent: InputComponent;
	bShouldPerformFullTickWhenPaused: boolean;
	CurrentTouchInterface: TouchInterface;
	SpectatorPawn: SpectatorPawn;
	bIsLocalPlayerController: boolean;
	SpawnLocation: Vector;
	static GetDefaultObject(): PlayerController;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerController;
	WasInputKeyJustReleased(Key: Key): boolean;
	WasInputKeyJustPressed(Key: Key): boolean;
	ToggleSpeaking(bInSpeaking: boolean): void;
	TestServerLevelVisibilityChange(PackageName: string,Filename: string): void;
	SwitchLevel(URL: string): void;
	StreamingSourceShouldBlockOnSlowStreaming(): boolean;
	StreamingSourceShouldActivate(): boolean;
	StopHapticEffect(Hand: EControllerHand): void;
	StartFire(FireModeNum: number): void;
	SetVirtualJoystickVisibility(bVisible: boolean): void;
	SetViewTargetWithBlend(NewViewTarget: Actor,BlendTime: number,BlendFunc: EViewTargetBlendFunction,BlendExp: number,bLockOutgoing: boolean): void;
	SetName(S: string): void;
	SetMouseLocation(X: number,Y: number): void;
	SetMouseCursorWidget(Cursor: EMouseCursor,CursorWidget: UserWidget): void;
	SetHapticsByValue(Frequency: number,Amplitude: number,Hand: EControllerHand): void;
	SetDisableHaptics(bNewDisabled: boolean): void;
	SetDeprecatedInputYawScale(NewValue: number): void;
	SetDeprecatedInputRollScale(NewValue: number): void;
	SetDeprecatedInputPitchScale(NewValue: number): void;
	SetControllerLightColor(Color: Color): void;
	SetCinematicMode(bInCinematicMode: boolean,bHidePlayer: boolean,bAffectsHUD: boolean,bAffectsMovement: boolean,bAffectsTurning: boolean): void;
	SetAudioListenerOverride(AttachToComponent: SceneComponent,Location: Vector,Rotation: Rotator): void;
	SetAudioListenerAttenuationOverride(AttachToComponent: SceneComponent,AttenuationLocationOVerride: Vector): void;
	ServerViewSelf(TransitionParams: ViewTargetTransitionParams): void;
	ServerViewPrevPlayer(): void;
	ServerViewNextPlayer(): void;
	ServerVerifyViewTarget(): void;
	ServerUpdateMultipleLevelsVisibility(LevelVisibilities: UpdateLevelVisibilityLevelInfo[]): void;
	ServerUpdateLevelVisibility(LevelVisibility: UpdateLevelVisibilityLevelInfo): void;
	ServerUpdateCamera(CamLoc: Vector_NetQuantize,CamPitchAndYaw: number): void;
	ServerUnmutePlayer(PlayerId: UniqueNetIdRepl): void;
	ServerUnblockPlayer(PlayerId: UniqueNetIdRepl): void;
	ServerToggleAILogging(): void;
	ServerShortTimeout(): void;
	ServerSetSpectatorWaiting(bWaiting: boolean): void;
	ServerSetSpectatorLocation(NewLoc: Vector,NewRot: Rotator): void;
	ServerRestartPlayer(): void;
	ServerRecvClientInputFrame(RecvClientInputFrame: number,Data: number[]): void;
	ServerPause(): void;
	ServerNotifyLoadedWorld(WorldPackageName: string): void;
	ServerMutePlayer(PlayerId: UniqueNetIdRepl): void;
	ServerExecRPC(Msg: string): void;
	ServerExec(Msg: string): void;
	ServerCheckClientPossessionReliable(): void;
	ServerCheckClientPossession(): void;
	ServerChangeName(S: string): void;
	ServerCamera(NewMode: string): void;
	ServerBlockPlayer(PlayerId: UniqueNetIdRepl): void;
	ServerAcknowledgePossession(P: Pawn): void;
	SendToConsole(Command: string): void;
	RestartLevel(): void;
	ResetControllerLightColor(): void;
	ProjectWorldLocationToScreen(WorldLocation: Vector,ScreenLocation?: Vector2D,bPlayerViewportRelative?: boolean): {ScreenLocation: Vector2D, $: boolean};
	PlayHapticEffect(HapticEffect: HapticFeedbackEffect_Base,Hand: EControllerHand,Scale: number,bLoop: boolean): void;
	PlayDynamicForceFeedback(Intensity: number,Duration: number,bAffectsLeftLarge: boolean,bAffectsLeftSmall: boolean,bAffectsRightLarge: boolean,bAffectsRightSmall: boolean,Action: EDynamicForceFeedbackAction,LatentInfo: LatentActionInfo): void;
	Pause(): void;
	OnServerStartedVisualLogger(bIsLogging: boolean): void;
	LocalTravel(URL: string): void;
	K2_ClientPlayForceFeedback(ForceFeedbackEffect: ForceFeedbackEffect,Tag: string,bLooping: boolean,bIgnoreTimeDilation: boolean,bPlayWhilePaused: boolean): void;
	IsStreamingSourceEnabled(): boolean;
	IsInputKeyDown(Key: Key): boolean;
	GetViewportSize(SizeX?: number,SizeY?: number): {SizeX: number, SizeY: number};
	GetSpectatorPawn(): SpectatorPawn;
	GetMousePosition(LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	GetInputVectorKeyState(Key: Key): Vector;
	GetInputTouchState(FingerIndex: ETouchIndex,LocationX?: number,LocationY?: number,bIsCurrentlyPressed?: boolean): {LocationX: number, LocationY: number, bIsCurrentlyPressed: boolean};
	GetInputMouseDelta(DeltaX?: number,DeltaY?: number): {DeltaX: number, DeltaY: number};
	GetInputMotionState(Tilt?: Vector,RotationRate?: Vector,Gravity?: Vector,Acceleration?: Vector): {Tilt: Vector, RotationRate: Vector, Gravity: Vector, Acceleration: Vector};
	GetInputKeyTimeDown(Key: Key): number;
	GetInputAnalogStickState(WhichStick: EControllerAnalogStick,StickX?: number,StickY?: number): {StickX: number, StickY: number};
	GetInputAnalogKeyState(Key: Key): number;
	GetHUD(): HUD;
	GetHitResultUnderFingerForObjects(FingerIndex: ETouchIndex,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderFingerByChannel(FingerIndex: ETouchIndex,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderFinger(FingerIndex: ETouchIndex,TraceChannel: ECollisionChannel,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderCursorForObjects(ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderCursorByChannel(TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetHitResultUnderCursor(TraceChannel: ECollisionChannel,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	GetFocalLocation(): Vector;
	GetDeprecatedInputYawScale(): number;
	GetDeprecatedInputRollScale(): number;
	GetDeprecatedInputPitchScale(): number;
	FOV(NewFOV: number): void;
	EnableCheats(): void;
	DeprojectScreenPositionToWorld(ScreenX: number,ScreenY: number,WorldLocation?: Vector,WorldDirection?: Vector): {WorldLocation: Vector, WorldDirection: Vector, $: boolean};
	DeprojectMousePositionToWorld(WorldLocation?: Vector,WorldDirection?: Vector): {WorldLocation: Vector, WorldDirection: Vector, $: boolean};
	ConsoleKey(Key: Key): void;
	ClientWasKicked(KickReason: string): void;
	ClientVoiceHandshakeComplete(): void;
	ClientUpdateMultipleLevelsStreamingStatus(LevelStatuses: UpdateLevelStreamingLevelStatus[]): void;
	ClientUpdateLevelStreamingStatus(PackageName: string,bNewShouldBeLoaded: boolean,bNewShouldBeVisible: boolean,bNewShouldBlockOnLoad: boolean,LODIndex: number): void;
	ClientUnmutePlayers(PlayerIds: UniqueNetIdRepl[]): void;
	ClientUnmutePlayer(PlayerId: UniqueNetIdRepl): void;
	ClientTravelInternal(URL: string,TravelType: ETravelType,bSeamless: boolean,MapPackageGuid: Guid): void;
	ClientTravel(URL: string,TravelType: ETravelType,bSeamless: boolean,MapPackageGuid: Guid): void;
	ClientTeamMessage(SenderPlayerState: PlayerState,S: string,Type: string,MsgLifeTime: number): void;
	ClientStopForceFeedback(ForceFeedbackEffect: ForceFeedbackEffect,Tag: string): void;
	ClientStopCameraShakesFromSource(SourceComponent: CameraShakeSourceComponent,bImmediately: boolean): void;
	ClientStopCameraShake(Shake: UnrealEngineClass,bImmediately: boolean): void;
	ClientStopCameraAnim(AnimToStop: CameraAnim): void;
	ClientStartOnlineSession(): void;
	ClientStartCameraShakeFromSource(Shake: UnrealEngineClass,SourceComponent: CameraShakeSourceComponent): void;
	ClientStartCameraShake(Shake: UnrealEngineClass,Scale: number,PlaySpace: ECameraShakePlaySpace,UserPlaySpaceRot: Rotator): void;
	ClientSpawnGenericCameraLensEffect(LensEffectEmitterClass: UnrealEngineClass): void;
	ClientSpawnCameraLensEffect(LensEffectEmitterClass: UnrealEngineClass): void;
	ClientSetViewTarget(A: Actor,TransitionParams: ViewTargetTransitionParams): void;
	ClientSetSpectatorWaiting(bWaiting: boolean): void;
	ClientSetHUD(NewHUDClass: UnrealEngineClass): void;
	ClientSetForceMipLevelsToBeResident(Material: MaterialInterface,ForceDuration: number,CinematicTextureGroups: number): void;
	ClientSetCinematicMode(bInCinematicMode: boolean,bAffectsMovement: boolean,bAffectsTurning: boolean,bAffectsHUD: boolean): void;
	ClientSetCameraMode(NewCamMode: string): void;
	ClientSetCameraFade(bEnableFading: boolean,FadeColor: Color,FadeAlpha: Vector2D,FadeTime: number,bFadeAudio: boolean,bHoldWhenFinished: boolean): void;
	ClientSetBlockOnAsyncLoading(): void;
	ClientReturnToMainMenuWithTextReason(ReturnReason: string): void;
	ClientReturnToMainMenu(ReturnReason: string): void;
	ClientRetryClientRestart(NewPawn: Pawn): void;
	ClientRestart(NewPawn: Pawn): void;
	ClientReset(): void;
	ClientRepObjRef(UObject: UObject): void;
	ClientRecvServerAckFrameDebug(NumBuffered: number,TargetNumBufferedCmds: number): void;
	ClientRecvServerAckFrame(LastProcessedInputFrame: number,RecvServerFrameNumber: number,TimeDilation: any): void;
	ClientReceiveLocalizedMessage(Message: UnrealEngineClass,SWITCH: number,RelatedPlayerState_1: PlayerState,RelatedPlayerState_2: PlayerState,OptionalObject: UObject): void;
	ClientPrestreamTextures(ForcedActor: Actor,ForceDuration: number,bEnableStreaming: boolean,CinematicTextureGroups: number): void;
	ClientPrepareMapChange(LevelName: string,bFirst: boolean,bLast: boolean): void;
	ClientPlaySoundAtLocation(Sound: SoundBase,Location: Vector,VolumeMultiplier: number,PitchMultiplier: number): void;
	ClientPlaySound(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number): void;
	ClientPlayForceFeedback_Internal(ForceFeedbackEffect: ForceFeedbackEffect,Params: ForceFeedbackParameters): void;
	ClientPlayCameraAnim(AnimToPlay: CameraAnim,Scale: number,Rate: number,BlendInTime: number,BlendOutTime: number,bLoop: boolean,bRandomStartTime: boolean,Space: ECameraShakePlaySpace,CustomPlaySpace: Rotator): void;
	ClientMutePlayer(PlayerId: UniqueNetIdRepl): void;
	ClientMessage(S: string,Type: string,MsgLifeTime: number): void;
	ClientIgnoreMoveInput(bIgnore: boolean): void;
	ClientIgnoreLookInput(bIgnore: boolean): void;
	ClientGotoState(NewState: string): void;
	ClientGameEnded(EndGameFocus: Actor,bIsWinner: boolean): void;
	ClientForceGarbageCollection(): void;
	ClientFlushLevelStreaming(): void;
	ClientEndOnlineSession(): void;
	ClientEnableNetworkVoice(bEnable: boolean): void;
	ClientCommitMapChange(): void;
	ClientClearCameraLensEffects(): void;
	ClientCapBandwidth(Cap: number): void;
	ClientCancelPendingMapChange(): void;
	ClientAddTextureStreamingLoc(InLoc: Vector,Duration: number,bOverrideLocation: boolean): void;
	ClearAudioListenerOverride(): void;
	ClearAudioListenerAttenuationOverride(): void;
	CanRestartPlayer(): boolean;
	Camera(NewMode: string): void;
	AddYawInput(val: number): void;
	AddRollInput(val: number): void;
	AddPitchInput(val: number): void;
	ActivateTouchInterface(NewTouchInterface: TouchInterface): void;
	static C(Other: UObject | any): PlayerController;
	GetCameraCachePOV(): MinimalViewInfo;
	GetLastFrameCameraCachePOV(): MinimalViewInfo;
	GetPostProcessBlendCache(PPIndex: number,OutPPSettings?: PostProcessSettings,OutPPBlendWeight?: number): {OutPPSettings: PostProcessSettings, OutPPBlendWeight: number, $: boolean};
	WriteLeaderboardInteger(StatName: string,StatValue: number): boolean;
	GetLocalPlayerSubSystemFromPlayerController(Class: UnrealEngineClass): LocalPlayerSubsystem;
	IsLoggedIn(): boolean;
	ShowPlatformSpecificAchievementsScreen(): void;
	DeprojectScreenToWorld(ScreenPosition: Vector2D,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector, $: boolean};
	GetPlayerControllerID(): number;
	ProjectWorldToScreen(WorldPosition: Vector,ScreenPosition?: Vector2D,bPlayerViewportRelative?: boolean): {ScreenPosition: Vector2D, $: boolean};
	RemovePlayer(bDestroyPawn: boolean): void;
	SetPlayerControllerID(ControllerId: number): void;
	GetMousePositionScaledByDPI(LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	GetPlayerScreenWidgetGeometry(): Geometry;
	ProjectWorldLocationToWidgetPosition(WorldLocation: Vector,ScreenPosition?: Vector2D,bPlayerViewportRelative?: boolean): {ScreenPosition: Vector2D, $: boolean};
	SetInputMode_GameAndUIEx(InWidgetToFocus: Widget,InMouseLockMode: EMouseLockMode,bHideCursorDuringCapture: boolean): void;
	SetInputMode_GameOnly(): void;
	SetInputMode_UIOnlyEx(InWidgetToFocus: Widget,InMouseLockMode: EMouseLockMode): void;
	static GetCameraCachePOV(PlayerController: PlayerController): MinimalViewInfo;
	static GetLastFrameCameraCachePOV(PlayerController: PlayerController): MinimalViewInfo;
	static GetPostProcessBlendCache(PlayerController: PlayerController,PPIndex: number,OutPPSettings?: PostProcessSettings,OutPPBlendWeight?: number): {OutPPSettings: PostProcessSettings, OutPPBlendWeight: number, $: boolean};
	static WriteLeaderboardInteger(PlayerController: PlayerController,StatName: string,StatValue: number): boolean;
	static GetLocalPlayerSubSystemFromPlayerController(PlayerController: PlayerController,Class: UnrealEngineClass): LocalPlayerSubsystem;
	static IsLoggedIn(SpecificPlayer: PlayerController): boolean;
	static ShowPlatformSpecificAchievementsScreen(SpecificPlayer: PlayerController): void;
	static DeprojectScreenToWorld(Player: PlayerController,ScreenPosition: Vector2D,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector, $: boolean};
	static GetPlayerControllerID(Player: PlayerController): number;
	static ProjectWorldToScreen(Player: PlayerController,WorldPosition: Vector,ScreenPosition?: Vector2D,bPlayerViewportRelative?: boolean): {ScreenPosition: Vector2D, $: boolean};
	static RemovePlayer(Player: PlayerController,bDestroyPawn: boolean): void;
	static SetPlayerControllerID(Player: PlayerController,ControllerId: number): void;
	static GetMousePositionScaledByDPI(Player: PlayerController,LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	static GetPlayerScreenWidgetGeometry(PlayerController: PlayerController): Geometry;
	static ProjectWorldLocationToWidgetPosition(PlayerController: PlayerController,WorldLocation: Vector,ScreenPosition?: Vector2D,bPlayerViewportRelative?: boolean): {ScreenPosition: Vector2D, $: boolean};
	static SetInputMode_GameAndUIEx(PlayerController: PlayerController,InWidgetToFocus: Widget,InMouseLockMode: EMouseLockMode,bHideCursorDuringCapture: boolean): void;
	static SetInputMode_GameOnly(PlayerController: PlayerController): void;
	static SetInputMode_UIOnlyEx(PlayerController: PlayerController,InWidgetToFocus: Widget,InMouseLockMode: EMouseLockMode): void;
}

declare class WorldReticleParameters { 
	AOEScale: Vector;
	clone() : WorldReticleParameters;
	static C(Other: UObject | any): WorldReticleParameters;
}

declare class GameplayAbilityWorldReticle extends Actor { 
	Parameters: WorldReticleParameters;
	bFaceOwnerFlat: boolean;
	bSnapToTargetedActor: boolean;
	bIsTargetValid: boolean;
	bIsTargetAnActor: boolean;
	MasterPC: PlayerController;
	TargetingActor: Actor;
	static GetDefaultObject(): GameplayAbilityWorldReticle;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbilityWorldReticle;
	SetReticleMaterialParamVector(ParamName: string,Value: Vector): void;
	SetReticleMaterialParamFloat(ParamName: string,Value: number): void;
	OnValidTargetChanged(bNewValue: boolean): void;
	OnTargetingAnActor(bNewValue: boolean): void;
	OnParametersInitialized(): void;
	FaceTowardSource(bFaceIn2D: boolean): void;
	static C(Other: UObject | any): GameplayAbilityWorldReticle;
}

declare class GameplayAbilityTargetActor extends Actor { 
	ShouldProduceTargetDataOnServer: boolean;
	StartLocation: GameplayAbilityTargetingLocationInfo;
	MasterPC: PlayerController;
	OwningAbility: GameplayAbility;
	bDestroyOnConfirmation: boolean;
	SourceActor: Actor;
	ReticleParams: WorldReticleParameters;
	ReticleClass: UnrealEngineClass;
	Filter: GameplayTargetDataFilterHandle;
	bDebug: boolean;
	GenericDelegateBoundASC: AbilitySystemComponent;
	static GetDefaultObject(): GameplayAbilityTargetActor;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbilityTargetActor;
	ConfirmTargeting(): void;
	CancelTargeting(): void;
	static C(Other: UObject | any): GameplayAbilityTargetActor;
}

declare type EFastArraySerializerDeltaFlags = 'None' | 'HasBeenSerialized' | 'HasDeltaBeenRequested' | 'IsUsingDeltaSerialization' | 'EFastArraySerializerDeltaFlags_MAX';
declare var EFastArraySerializerDeltaFlags : { None:'None',HasBeenSerialized:'HasBeenSerialized',HasDeltaBeenRequested:'HasDeltaBeenRequested',IsUsingDeltaSerialization:'IsUsingDeltaSerialization',EFastArraySerializerDeltaFlags_MAX:'EFastArraySerializerDeltaFlags_MAX', };
declare class FastArraySerializer { 
	ArrayReplicationKey: number;
	DeltaFlags: EFastArraySerializerDeltaFlags;
	clone() : FastArraySerializer;
	static C(Other: UObject | any): FastArraySerializer;
}

declare class FastArraySerializerItem { 
	ReplicationID: number;
	ReplicationKey: number;
	MostRecentArrayReplicationKey: number;
	clone() : FastArraySerializerItem;
	static C(Other: UObject | any): FastArraySerializerItem;
}

declare class GameplayAbilitySpec extends FastArraySerializerItem { 
	Handle: GameplayAbilitySpecHandle;
	Ability: GameplayAbility;
	Level: number;
	InputID: number;
	SourceObject: UObject;
	ActiveCount: number;
	InputPressed: boolean;
	RemoveAfterActivation: boolean;
	PendingRemove: boolean;
	bActivateOnce: boolean;
	ActivationInfo: GameplayAbilityActivationInfo;
	DynamicAbilityTags: GameplayTagContainer;
	NonReplicatedInstances: GameplayAbility[];
	ReplicatedInstances: GameplayAbility[];
	GameplayEffectHandle: ActiveGameplayEffectHandle;
	clone() : GameplayAbilitySpec;
	static C(Other: UObject | any): GameplayAbilitySpec;
}

declare class GameplayAbilitySpecContainer extends FastArraySerializer { 
	items: GameplayAbilitySpec[];
	Owner: AbilitySystemComponent;
	clone() : GameplayAbilitySpecContainer;
	static C(Other: UObject | any): GameplayAbilitySpecContainer;
}

declare class GameplayAbilityRepAnimMontage { 
	AnimMontage: AnimMontage;
	PlayRate: number;
	position: number;
	BlendTime: number;
	NextSectionID: number;
	PlayInstanceId: number;
	bRepPosition: boolean;
	IsStopped: boolean;
	SkipPositionCorrection: boolean;
	bSkipPlayRate: boolean;
	PredictionKey: PredictionKey;
	SectionIdToPlay: number;
	clone() : GameplayAbilityRepAnimMontage;
	static C(Other: UObject | any): GameplayAbilityRepAnimMontage;
}

declare class GameplayAbilityLocalAnimMontage { 
	AnimMontage: AnimMontage;
	PlayInstanceId: number;
	PredictionKey: PredictionKey;
	AnimatingAbility: GameplayAbility;
	clone() : GameplayAbilityLocalAnimMontage;
	static C(Other: UObject | any): GameplayAbilityLocalAnimMontage;
}

declare class ActiveGameplayEffect extends FastArraySerializerItem { 
	Spec: GameplayEffectSpec;
	PredictionKey: PredictionKey;
	StartServerWorldTime: number;
	CachedStartServerWorldTime: number;
	StartWorldTime: number;
	bIsInhibited: boolean;
	clone() : ActiveGameplayEffect;
	static C(Other: UObject | any): ActiveGameplayEffect;
}

declare class ActiveGameplayEffectsContainer extends FastArraySerializer { 
	GameplayEffects_Internal: ActiveGameplayEffect[];
	ApplicationImmunityQueryEffects: GameplayEffect[];
	clone() : ActiveGameplayEffectsContainer;
	static C(Other: UObject | any): ActiveGameplayEffectsContainer;
}

declare class ActiveGameplayCue extends FastArraySerializerItem { 
	GameplayCueTag: GameplayTag;
	PredictionKey: PredictionKey;
	Parameters: GameplayCueParameters;
	bPredictivelyRemoved: boolean;
	clone() : ActiveGameplayCue;
	static C(Other: UObject | any): ActiveGameplayCue;
}

declare class ActiveGameplayCueContainer extends FastArraySerializer { 
	GameplayCues: ActiveGameplayCue[];
	Owner: AbilitySystemComponent;
	clone() : ActiveGameplayCueContainer;
	static C(Other: UObject | any): ActiveGameplayCueContainer;
}

declare class MinimalReplicationTagCountMap { 
	Owner: AbilitySystemComponent;
	clone() : MinimalReplicationTagCountMap;
	static C(Other: UObject | any): MinimalReplicationTagCountMap;
}

declare class ReplicatedPredictionKeyItem extends FastArraySerializerItem { 
	PredictionKey: PredictionKey;
	clone() : ReplicatedPredictionKeyItem;
	static C(Other: UObject | any): ReplicatedPredictionKeyItem;
}

declare class ReplicatedPredictionKeyMap extends FastArraySerializer { 
	PredictionKeys: ReplicatedPredictionKeyItem[];
	clone() : ReplicatedPredictionKeyMap;
	static C(Other: UObject | any): ReplicatedPredictionKeyMap;
}

declare class GameplayEffectQuery { 
	CustomMatchDelegate_BP: UnrealEngineDelegate<(Effect: ActiveGameplayEffect, bMatches: boolean) => void>;
	OwningTagQuery: GameplayTagQuery;
	EffectTagQuery: GameplayTagQuery;
	SourceTagQuery: GameplayTagQuery;
	ModifyingAttribute: GameplayAttribute;
	EffectSource: UObject;
	EffectDefinition: UnrealEngineClass;
	clone() : GameplayEffectQuery;
	static C(Other: UObject | any): GameplayEffectQuery;
}

declare type EAbilityGenericReplicatedEvent = 'GenericConfirm' | 'GenericCancel' | 'InputPressed' | 'InputReleased' | 'GenericSignalFromClient' | 'GenericSignalFromServer' | 'GameCustom1' | 'GameCustom2' | 'GameCustom3' | 'GameCustom4' | 'GameCustom5' | 'GameCustom6' | 'MAX';
declare var EAbilityGenericReplicatedEvent : { GenericConfirm:'GenericConfirm',GenericCancel:'GenericCancel',InputPressed:'InputPressed',InputReleased:'InputReleased',GenericSignalFromClient:'GenericSignalFromClient',GenericSignalFromServer:'GenericSignalFromServer',GameCustom1:'GameCustom1',GameCustom2:'GameCustom2',GameCustom3:'GameCustom3',GameCustom4:'GameCustom4',GameCustom5:'GameCustom5',GameCustom6:'GameCustom6',MAX:'MAX', };
declare class ServerAbilityRPCBatch { 
	AbilitySpecHandle: GameplayAbilitySpecHandle;
	PredictionKey: PredictionKey;
	TargetData: GameplayAbilityTargetDataHandle;
	InputPressed: boolean;
	Ended: boolean;
	Started: boolean;
	clone() : ServerAbilityRPCBatch;
	static C(Other: UObject | any): ServerAbilityRPCBatch;
}

declare class GameplayEffectSpecForRPC { 
	Def: GameplayEffect;
	ModifiedAttributes: GameplayEffectModifiedAttribute[];
	EffectContext: GameplayEffectContextHandle;
	AggregatedSourceTags: GameplayTagContainer;
	AggregatedTargetTags: GameplayTagContainer;
	Level: number;
	AbilityLevel: number;
	clone() : GameplayEffectSpecForRPC;
	static C(Other: UObject | any): GameplayEffectSpecForRPC;
}

declare class AbilitySystemComponent extends GameplayTasksComponent { 
	DefaultStartingData: AttributeDefaults[];
	SpawnedAttributes: AttributeSet[];
	AffectedAnimInstanceTag: string;
	OutgoingDuration: number;
	IncomingDuration: number;
	ClientDebugStrings: string[];
	ServerDebugStrings: string[];
	UserAbilityActivationInhibited: boolean;
	ReplicationProxyEnabled: boolean;
	bSuppressGrantAbility: boolean;
	bSuppressGameplayCues: boolean;
	SpawnedTargetActors: GameplayAbilityTargetActor[];
	OwnerActor: Actor;
	AvatarActor: Actor;
	ActivatableAbilities: GameplayAbilitySpecContainer;
	AllReplicatedInstancedAbilities: GameplayAbility[];
	RepAnimMontageInfo: GameplayAbilityRepAnimMontage;
	bCachedIsNetSimulated: boolean;
	bPendingMontageRep: boolean;
	LocalAnimMontageInfo: GameplayAbilityLocalAnimMontage;
	ActiveGameplayEffects: ActiveGameplayEffectsContainer;
	ActiveGameplayCues: ActiveGameplayCueContainer;
	MinimalReplicationGameplayCues: ActiveGameplayCueContainer;
	BlockedAbilityBindings: number[];
	MinimalReplicationTags: MinimalReplicationTagCountMap;
	ReplicatedLooseTags: MinimalReplicationTagCountMap;
	ReplicatedPredictionKeyMap: ReplicatedPredictionKeyMap;
	static Load(ResourceName: string): AbilitySystemComponent;
	static Find(Outer: UObject, ResourceName: string): AbilitySystemComponent;
	static GetDefaultObject(): AbilitySystemComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbilitySystemComponent;
	UpdateActiveGameplayEffectSetByCallerMagnitudes(ActiveHandle: ActiveGameplayEffectHandle,NewSetByCallerValues: any): void;
	UpdateActiveGameplayEffectSetByCallerMagnitude(ActiveHandle: ActiveGameplayEffectHandle,SetByCallerTag: GameplayTag,NewValue: number): void;
	TryActivateAbilityByClass(InAbilityToActivate: UnrealEngineClass,bAllowRemoteActivation: boolean): boolean;
	TryActivateAbility(AbilityToActivate: GameplayAbilitySpecHandle,bAllowRemoteActivation: boolean): boolean;
	TryActivateAbilitiesByTag(GameplayTagContainer: GameplayTagContainer,bAllowRemoteActivation: boolean): boolean;
	TargetConfirm(): void;
	TargetCancel(): void;
	SetUserAbilityActivationInhibited(NewInhibit: boolean): void;
	SetActiveGameplayEffectLevelUsingQuery(Query: GameplayEffectQuery,NewLevel: number): void;
	SetActiveGameplayEffectLevel(ActiveHandle: ActiveGameplayEffectHandle,NewLevel: number): void;
	ServerTryActivateAbilityWithEventData(AbilityToActivate: GameplayAbilitySpecHandle,InputPressed: boolean,PredictionKey: PredictionKey,TriggerEventData: GameplayEventData): void;
	ServerTryActivateAbility(AbilityToActivate: GameplayAbilitySpecHandle,InputPressed: boolean,PredictionKey: PredictionKey): void;
	ServerSetReplicatedTargetDataCancelled(AbilityHandle: GameplayAbilitySpecHandle,AbilityOriginalPredictionKey: PredictionKey,CurrentPredictionKey: PredictionKey): void;
	ServerSetReplicatedTargetData(AbilityHandle: GameplayAbilitySpecHandle,AbilityOriginalPredictionKey: PredictionKey,ReplicatedTargetDataHandle: GameplayAbilityTargetDataHandle,ApplicationTag: GameplayTag,CurrentPredictionKey: PredictionKey): void;
	ServerSetReplicatedEventWithPayload(EventType: EAbilityGenericReplicatedEvent,AbilityHandle: GameplayAbilitySpecHandle,AbilityOriginalPredictionKey: PredictionKey,CurrentPredictionKey: PredictionKey,VectorPayload: Vector_NetQuantize100): void;
	ServerSetReplicatedEvent(EventType: EAbilityGenericReplicatedEvent,AbilityHandle: GameplayAbilitySpecHandle,AbilityOriginalPredictionKey: PredictionKey,CurrentPredictionKey: PredictionKey): void;
	ServerSetInputReleased(AbilityHandle: GameplayAbilitySpecHandle): void;
	ServerSetInputPressed(AbilityHandle: GameplayAbilitySpecHandle): void;
	ServerPrintDebug_RequestWithStrings(Strings: string[]): void;
	ServerPrintDebug_Request(): void;
	ServerEndAbility(AbilityToEnd: GameplayAbilitySpecHandle,ActivationInfo: GameplayAbilityActivationInfo,PredictionKey: PredictionKey): void;
	ServerCurrentMontageSetPlayRate(ClientAnimMontage: AnimMontage,InPlayRate: number): void;
	ServerCurrentMontageSetNextSectionName(ClientAnimMontage: AnimMontage,ClientPosition: number,SectionName: string,NextSectionName: string): void;
	ServerCurrentMontageJumpToSectionName(ClientAnimMontage: AnimMontage,SectionName: string): void;
	ServerCancelAbility(AbilityToCancel: GameplayAbilitySpecHandle,ActivationInfo: GameplayAbilityActivationInfo): void;
	ServerAbilityRPCBatch(BatchInfo: ServerAbilityRPCBatch): void;
	RemoveActiveGameplayEffectBySourceEffect(GameplayEffect: UnrealEngineClass,InstigatorAbilitySystemComponent: AbilitySystemComponent,StacksToRemove: number): void;
	RemoveActiveGameplayEffect(Handle: ActiveGameplayEffectHandle,StacksToRemove: number): boolean;
	RemoveActiveEffectsWithTags(Tags: GameplayTagContainer): number;
	RemoveActiveEffectsWithSourceTags(Tags: GameplayTagContainer): number;
	RemoveActiveEffectsWithGrantedTags(Tags: GameplayTagContainer): number;
	RemoveActiveEffectsWithAppliedTags(Tags: GameplayTagContainer): number;
	ReleaseInputID(InputID: number): void;
	PressInputID(InputID: number): void;
	OnSpawnedAttributesEndPlayed(InActor: Actor,EndPlayReason: EEndPlayReason): void;
	OnRep_ServerDebugString(): void;
	OnRep_ReplicatedAnimMontage(): void;
	OnRep_OwningActor(): void;
	OnRep_ClientDebugString(): void;
	OnRep_ActivateAbilities(): void;
	OnOwnerActorDestroyed(InActor: Actor): void;
	OnAvatarActorDestroyed(InActor: Actor): void;
	NetMulticast_InvokeGameplayCuesExecuted_WithParams(GameplayCueTags: GameplayTagContainer,PredictionKey: PredictionKey,GameplayCueParameters: GameplayCueParameters): void;
	NetMulticast_InvokeGameplayCuesExecuted(GameplayCueTags: GameplayTagContainer,PredictionKey: PredictionKey,EffectContext: GameplayEffectContextHandle): void;
	NetMulticast_InvokeGameplayCuesAddedAndWhileActive_WithParams(GameplayCueTags: GameplayTagContainer,PredictionKey: PredictionKey,GameplayCueParameters: GameplayCueParameters): void;
	NetMulticast_InvokeGameplayCueExecuted_WithParams(GameplayCueTag: GameplayTag,PredictionKey: PredictionKey,GameplayCueParameters: GameplayCueParameters): void;
	NetMulticast_InvokeGameplayCueExecuted_FromSpec(Spec: GameplayEffectSpecForRPC,PredictionKey: PredictionKey): void;
	NetMulticast_InvokeGameplayCueExecuted(GameplayCueTag: GameplayTag,PredictionKey: PredictionKey,EffectContext: GameplayEffectContextHandle): void;
	NetMulticast_InvokeGameplayCueAddedAndWhileActive_WithParams(GameplayCueTag: GameplayTag,PredictionKey: PredictionKey,GameplayCueParameters: GameplayCueParameters): void;
	NetMulticast_InvokeGameplayCueAddedAndWhileActive_FromSpec(Spec: GameplayEffectSpecForRPC,PredictionKey: PredictionKey): void;
	NetMulticast_InvokeGameplayCueAdded_WithParams(GameplayCueTag: GameplayTag,PredictionKey: PredictionKey,Parameters: GameplayCueParameters): void;
	NetMulticast_InvokeGameplayCueAdded(GameplayCueTag: GameplayTag,PredictionKey: PredictionKey,EffectContext: GameplayEffectContextHandle): void;
	MakeOutgoingSpec(GameplayEffectClass: UnrealEngineClass,Level: number,Context: GameplayEffectContextHandle): GameplayEffectSpecHandle;
	MakeEffectContext(): GameplayEffectContextHandle;
	K2_InitStats(Attributes: UnrealEngineClass,DataTable: DataTable): void;
	K2_GiveAbilityAndActivateOnce(AbilityClass: UnrealEngineClass,Level: number,InputID: number): GameplayAbilitySpecHandle;
	K2_GiveAbility(AbilityClass: UnrealEngineClass,Level: number,InputID: number): GameplayAbilitySpecHandle;
	IsGameplayCueActive(GameplayCueTag: GameplayTag): boolean;
	InputConfirm(): void;
	InputCancel(): void;
	GetUserAbilityActivationInhibited(): boolean;
	GetGameplayTagCount(GameplayTag: GameplayTag): number;
	GetGameplayEffectMagnitude(Handle: ActiveGameplayEffectHandle,Attribute: GameplayAttribute): number;
	GetGameplayEffectCount(SourceGameplayEffect: UnrealEngineClass,OptionalInstigatorFilterComponent: AbilitySystemComponent,bEnforceOnGoingCheck: boolean): number;
	GetGameplayAttributeValue(Attribute: GameplayAttribute,bFound?: boolean): {bFound: boolean, $: number};
	GetAttributeSet(AttributeSetClass: UnrealEngineClass): AttributeSet;
	GetAllAttributes(OutAttributes?: GameplayAttribute[]): {OutAttributes: GameplayAttribute[]};
	GetAllAbilities(OutAbilityHandles?: GameplayAbilitySpecHandle[]): {OutAbilityHandles: GameplayAbilitySpecHandle[]};
	GetActiveEffectsWithAllTags(Tags: GameplayTagContainer): ActiveGameplayEffectHandle[];
	GetActiveEffects(Query: GameplayEffectQuery): ActiveGameplayEffectHandle[];
	FindAllAbilitiesWithTags(OutAbilityHandles?: GameplayAbilitySpecHandle[],Tags?: GameplayTagContainer,bExactMatch?: boolean): {OutAbilityHandles: GameplayAbilitySpecHandle[]};
	FindAllAbilitiesWithInputID(OutAbilityHandles?: GameplayAbilitySpecHandle[],InputID?: number): {OutAbilityHandles: GameplayAbilitySpecHandle[]};
	FindAllAbilitiesMatchingQuery(OutAbilityHandles?: GameplayAbilitySpecHandle[],Query?: GameplayTagQuery): {OutAbilityHandles: GameplayAbilitySpecHandle[]};
	ClientTryActivateAbility(AbilityToActivate: GameplayAbilitySpecHandle): void;
	ClientSetReplicatedEvent(EventType: EAbilityGenericReplicatedEvent,AbilityHandle: GameplayAbilitySpecHandle,AbilityOriginalPredictionKey: PredictionKey): void;
	ClientPrintDebug_Response(Strings: string[],GameFlags: number): void;
	ClientEndAbility(AbilityToEnd: GameplayAbilitySpecHandle,ActivationInfo: GameplayAbilityActivationInfo): void;
	ClientCancelAbility(AbilityToCancel: GameplayAbilitySpecHandle,ActivationInfo: GameplayAbilityActivationInfo): void;
	ClientActivateAbilitySucceedWithEventData(AbilityToActivate: GameplayAbilitySpecHandle,PredictionKey: PredictionKey,TriggerEventData: GameplayEventData): void;
	ClientActivateAbilitySucceed(AbilityToActivate: GameplayAbilitySpecHandle,PredictionKey: PredictionKey): void;
	ClientActivateAbilityFailed(AbilityToActivate: GameplayAbilitySpecHandle,PredictionKey: any): void;
	ClearAllAbilitiesWithInputID(InputID: number): void;
	ClearAllAbilities(): void;
	ClearAbility(Handle: GameplayAbilitySpecHandle): void;
	BP_ApplyGameplayEffectToTarget(GameplayEffectClass: UnrealEngineClass,Target: AbilitySystemComponent,Level: number,Context: GameplayEffectContextHandle): ActiveGameplayEffectHandle;
	BP_ApplyGameplayEffectToSelf(GameplayEffectClass: UnrealEngineClass,Level: number,EffectContext: GameplayEffectContextHandle): ActiveGameplayEffectHandle;
	BP_ApplyGameplayEffectSpecToTarget(SpecHandle: GameplayEffectSpecHandle,Target: AbilitySystemComponent): ActiveGameplayEffectHandle;
	BP_ApplyGameplayEffectSpecToSelf(SpecHandle: GameplayEffectSpecHandle): ActiveGameplayEffectHandle;
	static C(Other: UObject | any): AbilitySystemComponent;
	EvaluateAttributeValueWithTags(Attribute: GameplayAttribute,SourceTags: GameplayTagContainer,TargetTags: GameplayTagContainer,bSuccess?: boolean): {bSuccess: boolean, $: number};
	EvaluateAttributeValueWithTagsAndBase(Attribute: GameplayAttribute,SourceTags: GameplayTagContainer,TargetTags: GameplayTagContainer,BaseValue: number,bSuccess?: boolean): {bSuccess: boolean, $: number};
	GetFloatAttributeBaseFromAbilitySystemComponent(Attribute: GameplayAttribute,bSuccessfullyFoundAttribute?: boolean): {bSuccessfullyFoundAttribute: boolean, $: number};
	GetFloatAttributeFromAbilitySystemComponent(Attribute: GameplayAttribute,bSuccessfullyFoundAttribute?: boolean): {bSuccessfullyFoundAttribute: boolean, $: number};
	GetGameplayAbilityFromSpecHandle(AbilitySpecHandle: GameplayAbilitySpecHandle,bIsInstance?: boolean): {bIsInstance: boolean, $: GameplayAbility};
	static EvaluateAttributeValueWithTags(AbilitySystem: AbilitySystemComponent,Attribute: GameplayAttribute,SourceTags: GameplayTagContainer,TargetTags: GameplayTagContainer,bSuccess?: boolean): {bSuccess: boolean, $: number};
	static EvaluateAttributeValueWithTagsAndBase(AbilitySystem: AbilitySystemComponent,Attribute: GameplayAttribute,SourceTags: GameplayTagContainer,TargetTags: GameplayTagContainer,BaseValue: number,bSuccess?: boolean): {bSuccess: boolean, $: number};
	static GetFloatAttributeBaseFromAbilitySystemComponent(AbilitySystemComponent: AbilitySystemComponent,Attribute: GameplayAttribute,bSuccessfullyFoundAttribute?: boolean): {bSuccessfullyFoundAttribute: boolean, $: number};
	static GetFloatAttributeFromAbilitySystemComponent(AbilitySystem: AbilitySystemComponent,Attribute: GameplayAttribute,bSuccessfullyFoundAttribute?: boolean): {bSuccessfullyFoundAttribute: boolean, $: number};
	static GetGameplayAbilityFromSpecHandle(AbilitySystem: AbilitySystemComponent,AbilitySpecHandle: GameplayAbilitySpecHandle,bIsInstance?: boolean): {bIsInstance: boolean, $: GameplayAbility};
}

declare class GameplayAbility extends UObject { 
	AbilityTags: GameplayTagContainer;
	bReplicateInputDirectly: boolean;
	RemoteInstanceEnded: boolean;
	ReplicationPolicy: EGameplayAbilityReplicationPolicy;
	InstancingPolicy: EGameplayAbilityInstancingPolicy;
	bServerRespectsRemoteAbilityCancellation: boolean;
	bRetriggerInstancedAbility: boolean;
	CurrentActivationInfo: GameplayAbilityActivationInfo;
	CurrentEventData: GameplayEventData;
	NetExecutionPolicy: EGameplayAbilityNetExecutionPolicy;
	NetSecurityPolicy: EGameplayAbilityNetSecurityPolicy;
	CostGameplayEffectClass: UnrealEngineClass;
	AbilityTriggers: AbilityTriggerData[];
	CooldownGameplayEffectClass: UnrealEngineClass;
	CancelAbilitiesWithTag: GameplayTagContainer;
	BlockAbilitiesWithTag: GameplayTagContainer;
	ActivationOwnedTags: GameplayTagContainer;
	ActivationRequiredTags: GameplayTagContainer;
	ActivationBlockedTags: GameplayTagContainer;
	SourceRequiredTags: GameplayTagContainer;
	SourceBlockedTags: GameplayTagContainer;
	TargetRequiredTags: GameplayTagContainer;
	TargetBlockedTags: GameplayTagContainer;
	ActiveTasks: GameplayTask[];
	CurrentMontage: AnimMontage;
	bIsActive: boolean;
	bIsAbilityEnding: boolean;
	bIsCancelable: boolean;
	bIsBlockingOtherAbilities: boolean;
	bMarkPendingKillOnAbilityEnd: boolean;
	static Load(ResourceName: string): GameplayAbility;
	static Find(Outer: UObject, ResourceName: string): GameplayAbility;
	static GetDefaultObject(): GameplayAbility;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayAbility;
	SetShouldBlockOtherAbilities(bShouldBlockAbilities: boolean): void;
	SetCanBeCanceled(bCanBeCanceled: boolean): void;
	SendGameplayEvent(EventTag: GameplayTag,Payload: GameplayEventData): void;
	RemoveGrantedByEffect(): void;
	MontageStop(OverrideBlendOutTime: number): void;
	MontageSetNextSectionName(FromSectionName: string,ToSectionName: string): void;
	MontageJumpToSection(SectionName: string): void;
	MakeTargetLocationInfoFromOwnerSkeletalMeshComponent(SocketName: string): GameplayAbilityTargetingLocationInfo;
	MakeTargetLocationInfoFromOwnerActor(): GameplayAbilityTargetingLocationInfo;
	MakeOutgoingGameplayEffectSpec(GameplayEffectClass: UnrealEngineClass,Level: number): GameplayEffectSpecHandle;
	K2_ShouldAbilityRespondToEvent(ActorInfo: GameplayAbilityActorInfo,Payload: GameplayEventData): boolean;
	K2_RemoveGameplayCue(GameplayCueTag: GameplayTag): void;
	K2_OnEndAbility(bWasCancelled: boolean): void;
	K2_HasAuthority(): boolean;
	K2_ExecuteGameplayCueWithParams(GameplayCueTag: GameplayTag,GameplayCueParameters: GameplayCueParameters): void;
	K2_ExecuteGameplayCue(GameplayCueTag: GameplayTag,Context: GameplayEffectContextHandle): void;
	K2_EndAbilityLocally(): void;
	K2_EndAbility(): void;
	K2_CommitExecute(): void;
	K2_CommitAbilityCost(BroadcastCommitEvent: boolean): boolean;
	K2_CommitAbilityCooldown(BroadcastCommitEvent: boolean,ForceCooldown: boolean): boolean;
	K2_CommitAbility(): boolean;
	K2_CheckAbilityCost(): boolean;
	K2_CheckAbilityCooldown(): boolean;
	K2_CancelAbility(): void;
	K2_CanActivateAbility(ActorInfo: GameplayAbilityActorInfo,Handle: GameplayAbilitySpecHandle,RelevantTags?: GameplayTagContainer): {RelevantTags: GameplayTagContainer, $: boolean};
	K2_ApplyGameplayEffectSpecToTarget(EffectSpecHandle: GameplayEffectSpecHandle,TargetData: GameplayAbilityTargetDataHandle): ActiveGameplayEffectHandle[];
	K2_ApplyGameplayEffectSpecToOwner(EffectSpecHandle: GameplayEffectSpecHandle): ActiveGameplayEffectHandle;
	K2_AddGameplayCueWithParams(GameplayCueTag: GameplayTag,GameplayCueParameter: GameplayCueParameters,bRemoveOnAbilityEnd: boolean): void;
	K2_AddGameplayCue(GameplayCueTag: GameplayTag,Context: GameplayEffectContextHandle,bRemoveOnAbilityEnd: boolean): void;
	K2_ActivateAbilityFromEvent(EventData: GameplayEventData): void;
	K2_ActivateAbility(): void;
	IsLocallyControlled(): boolean;
	InvalidateClientPredictionKey(): void;
	GetSourceObject_BP(Handle: GameplayAbilitySpecHandle,ActorInfo: GameplayAbilityActorInfo): UObject;
	GetOwningComponentFromActorInfo(): SkeletalMeshComponent;
	GetOwningActorFromActorInfo(): Actor;
	GetGrantedByEffectContext(): GameplayEffectContextHandle;
	GetCurrentSourceObject(): UObject;
	GetCurrentMontage(): AnimMontage;
	GetCooldownTimeRemaining(): number;
	GetContextFromOwner(OptionalTargetData: GameplayAbilityTargetDataHandle): GameplayEffectContextHandle;
	GetAvatarActorFromActorInfo(): Actor;
	GetActorInfo(): GameplayAbilityActorInfo;
	GetAbilitySystemComponentFromActorInfo(): AbilitySystemComponent;
	GetAbilityLevel_BP(Handle: GameplayAbilitySpecHandle,ActorInfo: GameplayAbilityActorInfo): number;
	GetAbilityLevel(): number;
	EndTaskByInstanceName(InstanceName: string): void;
	EndAbilityState(OptionalStateNameToEnd: string): void;
	ConfirmTaskByInstanceName(InstanceName: string,bEndTask: boolean): void;
	CancelTaskByInstanceName(InstanceName: string): void;
	BP_RemoveGameplayEffectFromOwnerWithHandle(Handle: ActiveGameplayEffectHandle,StacksToRemove: number): void;
	BP_RemoveGameplayEffectFromOwnerWithGrantedTags(WithGrantedTags: GameplayTagContainer,StacksToRemove: number): void;
	BP_RemoveGameplayEffectFromOwnerWithAssetTags(WithAssetTags: GameplayTagContainer,StacksToRemove: number): void;
	BP_ApplyGameplayEffectToTarget(TargetData: GameplayAbilityTargetDataHandle,GameplayEffectClass: UnrealEngineClass,GameplayEffectLevel: number,Stacks: number): ActiveGameplayEffectHandle[];
	BP_ApplyGameplayEffectToOwner(GameplayEffectClass: UnrealEngineClass,GameplayEffectLevel: number,Stacks: number): ActiveGameplayEffectHandle;
	static C(Other: UObject | any): GameplayAbility;
}

declare type EGameplayEffectGrantedAbilityRemovePolicy = 'CancelAbilityImmediately' | 'RemoveAbilityOnEnd' | 'DoNothing' | 'EGameplayEffectGrantedAbilityRemovePolicy_MAX';
declare var EGameplayEffectGrantedAbilityRemovePolicy : { CancelAbilityImmediately:'CancelAbilityImmediately',RemoveAbilityOnEnd:'RemoveAbilityOnEnd',DoNothing:'DoNothing',EGameplayEffectGrantedAbilityRemovePolicy_MAX:'EGameplayEffectGrantedAbilityRemovePolicy_MAX', };
declare class GameplayAbilitySpecDef { 
	Ability: UnrealEngineClass;
	LevelScalableFloat: ScalableFloat;
	InputID: number;
	RemovalPolicy: EGameplayEffectGrantedAbilityRemovePolicy;
	SourceObject: UObject;
	AssignedHandle: GameplayAbilitySpecHandle;
	clone() : GameplayAbilitySpecDef;
	static C(Other: UObject | any): GameplayAbilitySpecDef;
}

declare class GameplayEffectSpec { 
	Def: GameplayEffect;
	ModifiedAttributes: GameplayEffectModifiedAttribute[];
	CapturedRelevantAttributes: GameplayEffectAttributeCaptureSpecContainer;
	Duration: number;
	Period: number;
	ChanceToApplyToTarget: number;
	CapturedSourceTags: TagContainerAggregator;
	CapturedTargetTags: TagContainerAggregator;
	DynamicGrantedTags: GameplayTagContainer;
	DynamicAssetTags: GameplayTagContainer;
	Modifiers: ModifierSpec[];
	StackCount: number;
	bCompletedSourceAttributeCapture: boolean;
	bCompletedTargetAttributeCapture: boolean;
	bDurationLocked: boolean;
	GrantedAbilitySpecs: GameplayAbilitySpecDef[];
	EffectContext: GameplayEffectContextHandle;
	Level: number;
	clone() : GameplayEffectSpec;
	static C(Other: UObject | any): GameplayEffectSpec;
}

declare class GameplayModMagnitudeCalculation extends GameplayEffectCalculation { 
	bAllowNonNetAuthorityDependencyRegistration: boolean;
	static Load(ResourceName: string): GameplayModMagnitudeCalculation;
	static Find(Outer: UObject, ResourceName: string): GameplayModMagnitudeCalculation;
	static GetDefaultObject(): GameplayModMagnitudeCalculation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayModMagnitudeCalculation;
	K2_GetCapturedAttributeMagnitude(EffectSpec: GameplayEffectSpec,Attribute: GameplayAttribute,SourceTags: GameplayTagContainer,TargetTags: GameplayTagContainer): number;
	GetTargetSpecTags(EffectSpec: GameplayEffectSpec): GameplayTagContainer;
	GetTargetAggregatedTags(EffectSpec: GameplayEffectSpec): GameplayTagContainer;
	GetTargetActorTags(EffectSpec: GameplayEffectSpec): GameplayTagContainer;
	GetSourceSpecTags(EffectSpec: GameplayEffectSpec): GameplayTagContainer;
	GetSourceAggregatedTags(EffectSpec: GameplayEffectSpec): GameplayTagContainer;
	GetSourceActorTags(EffectSpec: GameplayEffectSpec): GameplayTagContainer;
	GetSetByCallerMagnitudeByTag(EffectSpec: GameplayEffectSpec,Tag: GameplayTag): number;
	GetSetByCallerMagnitudeByName(EffectSpec: GameplayEffectSpec,MagnitudeName: string): number;
	CalculateBaseMagnitude(Spec: GameplayEffectSpec): number;
	static C(Other: UObject | any): GameplayModMagnitudeCalculation;
}

declare class CustomCalculationBasedFloat { 
	CalculationClassMagnitude: UnrealEngineClass;
	Coefficient: ScalableFloat;
	PreMultiplyAdditiveValue: ScalableFloat;
	PostMultiplyAdditiveValue: ScalableFloat;
	FinalLookupCurve: CurveTableRowHandle;
	clone() : CustomCalculationBasedFloat;
	static C(Other: UObject | any): CustomCalculationBasedFloat;
}

declare class SetByCallerFloat { 
	DataName: string;
	DataTag: GameplayTag;
	clone() : SetByCallerFloat;
	static C(Other: UObject | any): SetByCallerFloat;
}

declare class GameplayEffectModifierMagnitude { 
	MagnitudeCalculationType: EGameplayEffectMagnitudeCalculation;
	ScalableFloatMagnitude: ScalableFloat;
	AttributeBasedMagnitude: AttributeBasedFloat;
	CustomMagnitude: CustomCalculationBasedFloat;
	SetByCallerMagnitude: SetByCallerFloat;
	clone() : GameplayEffectModifierMagnitude;
	static C(Other: UObject | any): GameplayEffectModifierMagnitude;
}

declare type EGameplayEffectPeriodInhibitionRemovedPolicy = 'NeverReset' | 'ResetPeriod' | 'ExecuteAndResetPeriod' | 'EGameplayEffectPeriodInhibitionRemovedPolicy_MAX';
declare var EGameplayEffectPeriodInhibitionRemovedPolicy : { NeverReset:'NeverReset',ResetPeriod:'ResetPeriod',ExecuteAndResetPeriod:'ExecuteAndResetPeriod',EGameplayEffectPeriodInhibitionRemovedPolicy_MAX:'EGameplayEffectPeriodInhibitionRemovedPolicy_MAX', };
declare type EGameplayModOp = 'Additive' | 'Multiplicitive' | 'Division' | 'Override' | 'Max' | 'EGameplayModOp_MAX';
declare var EGameplayModOp : { Additive:'Additive',Multiplicitive:'Multiplicitive',Division:'Division',Override:'Override',Max:'Max',EGameplayModOp_MAX:'EGameplayModOp_MAX', };
declare class GameplayModEvaluationChannelSettings { 
	Channel: EGameplayModEvaluationChannel;
	clone() : GameplayModEvaluationChannelSettings;
	static C(Other: UObject | any): GameplayModEvaluationChannelSettings;
}

declare class GameplayModifierInfo { 
	Attribute: GameplayAttribute;
	ModifierOp: EGameplayModOp;
	Magnitude: ScalableFloat;
	ModifierMagnitude: GameplayEffectModifierMagnitude;
	EvaluationChannelSettings: GameplayModEvaluationChannelSettings;
	SourceTags: GameplayTagRequirements;
	TargetTags: GameplayTagRequirements;
	clone() : GameplayModifierInfo;
	static C(Other: UObject | any): GameplayModifierInfo;
}

declare class GameplayEffectCustomExecutionParameters { 
	clone() : GameplayEffectCustomExecutionParameters;
	static C(Other: UObject | any): GameplayEffectCustomExecutionParameters;
}

declare class GameplayModifierEvaluatedData { 
	Attribute: GameplayAttribute;
	ModifierOp: EGameplayModOp;
	Magnitude: number;
	Handle: ActiveGameplayEffectHandle;
	IsValid: boolean;
	clone() : GameplayModifierEvaluatedData;
	static C(Other: UObject | any): GameplayModifierEvaluatedData;
}

declare class GameplayEffectCustomExecutionOutput { 
	OutputModifiers: GameplayModifierEvaluatedData[];
	bTriggerConditionalGameplayEffects: boolean;
	bHandledStackCountManually: boolean;
	bHandledGameplayCuesManually: boolean;
	clone() : GameplayEffectCustomExecutionOutput;
	static C(Other: UObject | any): GameplayEffectCustomExecutionOutput;
}

declare class GameplayEffectExecutionCalculation extends GameplayEffectCalculation { 
	bRequiresPassedInTags: boolean;
	InvalidScopedModifierAttributes: GameplayEffectAttributeCaptureDefinition[];
	ValidTransientAggregatorIdentifiers: GameplayTagContainer;
	static Load(ResourceName: string): GameplayEffectExecutionCalculation;
	static Find(Outer: UObject, ResourceName: string): GameplayEffectExecutionCalculation;
	static GetDefaultObject(): GameplayEffectExecutionCalculation;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayEffectExecutionCalculation;
	Execute(ExecutionParams: GameplayEffectCustomExecutionParameters,OutExecutionOutput?: GameplayEffectCustomExecutionOutput): {OutExecutionOutput: GameplayEffectCustomExecutionOutput};
	static C(Other: UObject | any): GameplayEffectExecutionCalculation;
}

declare type EGameplayEffectScopedModifierAggregatorType = 'CapturedAttributeBacked' | 'Transient' | 'EGameplayEffectScopedModifierAggregatorType_MAX';
declare var EGameplayEffectScopedModifierAggregatorType : { CapturedAttributeBacked:'CapturedAttributeBacked',Transient:'Transient',EGameplayEffectScopedModifierAggregatorType_MAX:'EGameplayEffectScopedModifierAggregatorType_MAX', };
declare class GameplayEffectExecutionScopedModifierInfo { 
	CapturedAttribute: GameplayEffectAttributeCaptureDefinition;
	TransientAggregatorIdentifier: GameplayTag;
	AggregatorType: EGameplayEffectScopedModifierAggregatorType;
	ModifierOp: EGameplayModOp;
	ModifierMagnitude: GameplayEffectModifierMagnitude;
	EvaluationChannelSettings: GameplayModEvaluationChannelSettings;
	SourceTags: GameplayTagRequirements;
	TargetTags: GameplayTagRequirements;
	clone() : GameplayEffectExecutionScopedModifierInfo;
	static C(Other: UObject | any): GameplayEffectExecutionScopedModifierInfo;
}

declare class ConditionalGameplayEffect { 
	EffectClass: UnrealEngineClass;
	RequiredSourceTags: GameplayTagContainer;
	clone() : ConditionalGameplayEffect;
	static C(Other: UObject | any): ConditionalGameplayEffect;
}

declare class GameplayEffectExecutionDefinition { 
	CalculationClass: UnrealEngineClass;
	PassedInTags: GameplayTagContainer;
	CalculationModifiers: GameplayEffectExecutionScopedModifierInfo[];
	ConditionalGameplayEffectClasses: UnrealEngineClass[];
	ConditionalGameplayEffects: ConditionalGameplayEffect[];
	clone() : GameplayEffectExecutionDefinition;
	static C(Other: UObject | any): GameplayEffectExecutionDefinition;
}

declare class GameplayEffectCustomApplicationRequirement extends UObject { 
	static Load(ResourceName: string): GameplayEffectCustomApplicationRequirement;
	static Find(Outer: UObject, ResourceName: string): GameplayEffectCustomApplicationRequirement;
	static GetDefaultObject(): GameplayEffectCustomApplicationRequirement;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayEffectCustomApplicationRequirement;
	CanApplyGameplayEffect(GameplayEffect: GameplayEffect,Spec: GameplayEffectSpec,ASC: AbilitySystemComponent): boolean;
	static C(Other: UObject | any): GameplayEffectCustomApplicationRequirement;
}

declare class GameplayEffectCue { 
	MagnitudeAttribute: GameplayAttribute;
	MinLevel: number;
	maxlevel: number;
	GameplayCueTags: GameplayTagContainer;
	clone() : GameplayEffectCue;
	static C(Other: UObject | any): GameplayEffectCue;
}

declare class GameplayEffectUIData extends UObject { 
	static Load(ResourceName: string): GameplayEffectUIData;
	static Find(Outer: UObject, ResourceName: string): GameplayEffectUIData;
	static GetDefaultObject(): GameplayEffectUIData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayEffectUIData;
	static C(Other: UObject | any): GameplayEffectUIData;
}

declare class InheritedTagContainer { 
	CombinedTags: GameplayTagContainer;
	Added: GameplayTagContainer;
	Removed: GameplayTagContainer;
	clone() : InheritedTagContainer;
	static C(Other: UObject | any): InheritedTagContainer;
}

declare type EGameplayEffectStackingType = 'None' | 'AggregateBySource' | 'AggregateByTarget' | 'EGameplayEffectStackingType_MAX';
declare var EGameplayEffectStackingType : { None:'None',AggregateBySource:'AggregateBySource',AggregateByTarget:'AggregateByTarget',EGameplayEffectStackingType_MAX:'EGameplayEffectStackingType_MAX', };
declare type EGameplayEffectStackingDurationPolicy = 'RefreshOnSuccessfulApplication' | 'NeverRefresh' | 'EGameplayEffectStackingDurationPolicy_MAX';
declare var EGameplayEffectStackingDurationPolicy : { RefreshOnSuccessfulApplication:'RefreshOnSuccessfulApplication',NeverRefresh:'NeverRefresh',EGameplayEffectStackingDurationPolicy_MAX:'EGameplayEffectStackingDurationPolicy_MAX', };
declare type EGameplayEffectStackingPeriodPolicy = 'ResetOnSuccessfulApplication' | 'NeverReset' | 'EGameplayEffectStackingPeriodPolicy_MAX';
declare var EGameplayEffectStackingPeriodPolicy : { ResetOnSuccessfulApplication:'ResetOnSuccessfulApplication',NeverReset:'NeverReset',EGameplayEffectStackingPeriodPolicy_MAX:'EGameplayEffectStackingPeriodPolicy_MAX', };
declare type EGameplayEffectStackingExpirationPolicy = 'ClearEntireStack' | 'RemoveSingleStackAndRefreshDuration' | 'RefreshDuration' | 'EGameplayEffectStackingExpirationPolicy_MAX';
declare var EGameplayEffectStackingExpirationPolicy : { ClearEntireStack:'ClearEntireStack',RemoveSingleStackAndRefreshDuration:'RemoveSingleStackAndRefreshDuration',RefreshDuration:'RefreshDuration',EGameplayEffectStackingExpirationPolicy_MAX:'EGameplayEffectStackingExpirationPolicy_MAX', };
declare class GameplayEffect extends UObject { 
	DurationPolicy: EGameplayEffectDurationType;
	DurationMagnitude: GameplayEffectModifierMagnitude;
	Period: ScalableFloat;
	bExecutePeriodicEffectOnApplication: boolean;
	PeriodicInhibitionPolicy: EGameplayEffectPeriodInhibitionRemovedPolicy;
	Modifiers: GameplayModifierInfo[];
	Executions: GameplayEffectExecutionDefinition[];
	ChanceToApplyToTarget: ScalableFloat;
	ApplicationRequirements: UnrealEngineClass[];
	TargetEffectClasses: UnrealEngineClass[];
	ConditionalGameplayEffects: ConditionalGameplayEffect[];
	OverflowEffects: UnrealEngineClass[];
	bDenyOverflowApplication: boolean;
	bClearStackOnOverflow: boolean;
	PrematureExpirationEffectClasses: UnrealEngineClass[];
	RoutineExpirationEffectClasses: UnrealEngineClass[];
	bRequireModifierSuccessToTriggerCues: boolean;
	bSuppressStackingCues: boolean;
	GameplayCues: GameplayEffectCue[];
	UIData: GameplayEffectUIData;
	InheritableGameplayEffectTags: InheritedTagContainer;
	InheritableOwnedTagsContainer: InheritedTagContainer;
	OngoingTagRequirements: GameplayTagRequirements;
	ApplicationTagRequirements: GameplayTagRequirements;
	RemovalTagRequirements: GameplayTagRequirements;
	RemoveGameplayEffectsWithTags: InheritedTagContainer;
	GrantedApplicationImmunityTags: GameplayTagRequirements;
	GrantedApplicationImmunityQuery: GameplayEffectQuery;
	RemoveGameplayEffectQuery: GameplayEffectQuery;
	StackingType: EGameplayEffectStackingType;
	StackLimitCount: number;
	StackDurationRefreshPolicy: EGameplayEffectStackingDurationPolicy;
	StackPeriodResetPolicy: EGameplayEffectStackingPeriodPolicy;
	StackExpirationPolicy: EGameplayEffectStackingExpirationPolicy;
	GrantedAbilities: GameplayAbilitySpecDef[];
	static Load(ResourceName: string): GameplayEffect;
	static Find(Outer: UObject, ResourceName: string): GameplayEffect;
	static GetDefaultObject(): GameplayEffect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayEffect;
	static C(Other: UObject | any): GameplayEffect;
	MakeSpecHandle(InInstigator: Actor,InEffectCauser: Actor,InLevel: number): GameplayEffectSpecHandle;
	static MakeSpecHandle(InGameplayEffect: GameplayEffect,InInstigator: Actor,InEffectCauser: Actor,InLevel: number): GameplayEffectSpecHandle;
}

declare class DynamicSubsystem extends Subsystem { 
	static Load(ResourceName: string): DynamicSubsystem;
	static Find(Outer: UObject, ResourceName: string): DynamicSubsystem;
	static GetDefaultObject(): DynamicSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DynamicSubsystem;
	static C(Other: UObject | any): DynamicSubsystem;
}

declare class EngineSubsystem extends DynamicSubsystem { 
	static Load(ResourceName: string): EngineSubsystem;
	static Find(Outer: UObject, ResourceName: string): EngineSubsystem;
	static GetDefaultObject(): EngineSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EngineSubsystem;
	static C(Other: UObject | any): EngineSubsystem;
}

declare type EDataLayerRuntimeState = 'Unloaded' | 'Loaded' | 'Activated' | 'EDataLayerRuntimeState_MAX';
declare var EDataLayerRuntimeState : { Unloaded:'Unloaded',Loaded:'Loaded',Activated:'Activated',EDataLayerRuntimeState_MAX:'EDataLayerRuntimeState_MAX', };
declare type EDataLayerState = 'Unloaded' | 'Loaded' | 'Activated' | 'EDataLayerState_MAX';
declare var EDataLayerState : { Unloaded:'Unloaded',Loaded:'Loaded',Activated:'Activated',EDataLayerState_MAX:'EDataLayerState_MAX', };
declare class ActorDataLayer { 
	Name: string;
	clone() : ActorDataLayer;
	static C(Other: UObject | any): ActorDataLayer;
}

declare class DataLayer extends UObject { 
	bIsInitiallyActive: boolean;
	bIsVisible: boolean;
	bIsInitiallyVisible: boolean;
	bIsInitiallyLoadedInEditor: boolean;
	bIsLoadedInEditor: boolean;
	bIsLoadedInEditorChangedByUserOperation: boolean;
	bIsLocked: boolean;
	DataLayerLabel: string;
	bIsRuntime: boolean;
	InitialRuntimeState: EDataLayerRuntimeState;
	DebugColor: Color;
	Parent: DataLayer;
	Children: DataLayer[];
	static Load(ResourceName: string): DataLayer;
	static Find(Outer: UObject, ResourceName: string): DataLayer;
	static GetDefaultObject(): DataLayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataLayer;
	IsVisible(): boolean;
	IsRuntime(): boolean;
	IsInitiallyVisible(): boolean;
	IsInitiallyActive(): boolean;
	IsEffectiveVisible(): boolean;
	IsDynamicallyLoaded(): boolean;
	GetInitialState(): EDataLayerState;
	GetInitialRuntimeState(): EDataLayerRuntimeState;
	GetDebugColor(): Color;
	GetDataLayerLabel(): string;
	Equals(ActorDataLayer: ActorDataLayer): boolean;
	static C(Other: UObject | any): DataLayer;
}

declare class PrimaryAssetType { 
	Name: string;
	clone() : PrimaryAssetType;
	static C(Other: UObject | any): PrimaryAssetType;
	Conv_PrimaryAssetTypeToString(): string;
	EqualEqual_PrimaryAssetType(B: PrimaryAssetType): boolean;
	GetPrimaryAssetIdList(OutPrimaryAssetIdList?: PrimaryAssetId[]): {OutPrimaryAssetIdList: PrimaryAssetId[]};
	IsValidPrimaryAssetType(): boolean;
	NotEqual_PrimaryAssetType(B: PrimaryAssetType): boolean;
	static Conv_PrimaryAssetTypeToString(PrimaryAssetType: PrimaryAssetType): string;
	static EqualEqual_PrimaryAssetType(A: PrimaryAssetType,B: PrimaryAssetType): boolean;
	static GetPrimaryAssetIdList(PrimaryAssetType: PrimaryAssetType,OutPrimaryAssetIdList?: PrimaryAssetId[]): {OutPrimaryAssetIdList: PrimaryAssetId[]};
	static IsValidPrimaryAssetType(PrimaryAssetType: PrimaryAssetType): boolean;
	static NotEqual_PrimaryAssetType(A: PrimaryAssetType,B: PrimaryAssetType): boolean;
}

declare class PrimaryAssetId { 
	PrimaryAssetType: PrimaryAssetType;
	PrimaryAssetName: string;
	clone() : PrimaryAssetId;
	static C(Other: UObject | any): PrimaryAssetId;
	Conv_PrimaryAssetIdToString(): string;
	EqualEqual_PrimaryAssetId(B: PrimaryAssetId): boolean;
	GetClassFromPrimaryAssetId(): UnrealEngineClass;
	GetCurrentBundleState(bForceCurrentState: boolean,OutBundles?: string[]): {OutBundles: string[], $: boolean};
	GetObjectFromPrimaryAssetId(): UObject;
	GetSoftClassReferenceFromPrimaryAssetId(): Class;
	GetSoftObjectReferenceFromPrimaryAssetId(): UObject;
	IsValidPrimaryAssetId(): boolean;
	NotEqual_PrimaryAssetId(B: PrimaryAssetId): boolean;
	UnloadPrimaryAsset(): void;
	static Conv_PrimaryAssetIdToString(PrimaryAssetId: PrimaryAssetId): string;
	static EqualEqual_PrimaryAssetId(A: PrimaryAssetId,B: PrimaryAssetId): boolean;
	static GetClassFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): UnrealEngineClass;
	static GetCurrentBundleState(PrimaryAssetId: PrimaryAssetId,bForceCurrentState: boolean,OutBundles?: string[]): {OutBundles: string[], $: boolean};
	static GetObjectFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): UObject;
	static GetSoftClassReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): Class;
	static GetSoftObjectReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): UObject;
	static IsValidPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): boolean;
	static NotEqual_PrimaryAssetId(A: PrimaryAssetId,B: PrimaryAssetId): boolean;
	static UnloadPrimaryAsset(PrimaryAssetId: PrimaryAssetId): void;
}

declare class SaveGame extends UObject { 
	static Load(ResourceName: string): SaveGame;
	static Find(Outer: UObject, ResourceName: string): SaveGame;
	static GetDefaultObject(): SaveGame;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SaveGame;
	static C(Other: UObject | any): SaveGame;
	SaveGameToSlot(SlotName: string,UserIndex: number): boolean;
	static SaveGameToSlot(SaveGameObject: SaveGame,SlotName: string,UserIndex: number): boolean;
}

declare type EInterfaceValidResult = 'Valid' | 'Invalid' | 'EInterfaceValidResult_MAX';
declare var EInterfaceValidResult : { Valid:'Valid',Invalid:'Invalid',EInterfaceValidResult_MAX:'EInterfaceValidResult_MAX', };
declare class CameraLensInterfaceClassSupport { 
	Class: UnrealEngineClass;
	clone() : CameraLensInterfaceClassSupport;
	static C(Other: UObject | any): CameraLensInterfaceClassSupport;
	GetInterfaceClass(): UnrealEngineClass;
	IsInterfaceClassValid(Result?: EInterfaceValidResult): {Result: EInterfaceValidResult};
	static GetInterfaceClass(CameraLens: CameraLensInterfaceClassSupport): UnrealEngineClass;
	static IsInterfaceClassValid(CameraLens: CameraLensInterfaceClassSupport,Result?: EInterfaceValidResult): {Result: EInterfaceValidResult};
}

declare class EditorSubsystem extends DynamicSubsystem { 
	static Load(ResourceName: string): EditorSubsystem;
	static Find(Outer: UObject, ResourceName: string): EditorSubsystem;
	static GetDefaultObject(): EditorSubsystem;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorSubsystem;
	static C(Other: UObject | any): EditorSubsystem;
}

declare class Class extends Struct { 
	static Load(ResourceName: string): Class;
	static Find(Outer: UObject, ResourceName: string): Class;
	static GetDefaultObject(): Class;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Class;
	static C(Other: UObject | any): Class;
	SpawnActorFromClass(Location: Vector,Rotation: Rotator,bTransient: boolean): Actor;
	AddDynamicBinding(BindingObject: DynamicBlueprintBinding): void;
	GetClassPathName(): string;
	GetDerivedClasses(Results?: UnrealEngineClass[],bRecursive?: boolean): {Results: UnrealEngineClass[]};
	GetDynamicBinding(BindingObjectClass: UnrealEngineClass): DynamicBlueprintBinding;
	GetObjectsOfClass(Results?: UObject[],bIncludeDerivedClasses?: boolean,ExcludeFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	GetSuperClasses(): UnrealEngineClass[];
	IsGeneratedByBlueprint(): boolean;
	GetGameplayEffectUIData(DataType: UnrealEngineClass): GameplayEffectUIData;
	GetEngineSubsystem(): EngineSubsystem;
	CreateNewLightWeightInstance(Transform: Transform,Layer: DataLayer,World: World): ActorInstanceHandle;
	Conv_ClassToSoftClassReference(): Class;
	Conv_SoftClassReferenceToClass(): UnrealEngineClass;
	Conv_SoftClassReferenceToString(): string;
	EqualEqual_SoftClassReference(B: Class): boolean;
	GetClassDisplayName(): string;
	GetPrimaryAssetIdFromClass(): PrimaryAssetId;
	GetPrimaryAssetIdFromSoftClassReference(): PrimaryAssetId;
	IsValidClass(): boolean;
	IsValidSoftClassReference(): boolean;
	LoadClassAsset_Blocking(): UnrealEngineClass;
	NotEqual_SoftClassReference(B: Class): boolean;
	ClassIsChildOf(ParentClass: UnrealEngineClass): boolean;
	EqualEqual_ClassClass(B: UnrealEngineClass): boolean;
	NotEqual_ClassClass(B: UnrealEngineClass): boolean;
	SelectClass(B: UnrealEngineClass,bSelectA: boolean): UnrealEngineClass;
	CreateSaveGameObject(): SaveGame;
	SpawnObject(Outer: UObject): UObject;
	SetInterfaceClass(Var?: CameraLensInterfaceClassSupport,Result?: EInterfaceValidResult): {Var: CameraLensInterfaceClassSupport, Result: EInterfaceValidResult};
	GetEditorSubsystem(): EditorSubsystem;
	CreateDragDropOperation(): DragDropOperation;
	GetAllGeometriesByClass(): ARTrackedGeometry[];
	static SpawnActorFromClass(ActorClass: UnrealEngineClass,Location: Vector,Rotation: Rotator,bTransient: boolean): Actor;
	static AddDynamicBinding(Outer: UnrealEngineClass,BindingObject: DynamicBlueprintBinding): void;
	static GetClassPathName(Class: UnrealEngineClass): string;
	static GetDerivedClasses(ClassToLookFor: UnrealEngineClass,Results?: UnrealEngineClass[],bRecursive?: boolean): {Results: UnrealEngineClass[]};
	static GetDynamicBinding(Outer: UnrealEngineClass,BindingObjectClass: UnrealEngineClass): DynamicBlueprintBinding;
	static GetObjectsOfClass(ClassToLookFor: UnrealEngineClass,Results?: UObject[],bIncludeDerivedClasses?: boolean,ExcludeFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	static GetSuperClasses(InClass: UnrealEngineClass): UnrealEngineClass[];
	static IsGeneratedByBlueprint(InClass: UnrealEngineClass): boolean;
	static GetGameplayEffectUIData(EffectClass: UnrealEngineClass,DataType: UnrealEngineClass): GameplayEffectUIData;
	static GetEngineSubsystem(Class: UnrealEngineClass): EngineSubsystem;
	static CreateNewLightWeightInstance(ActorClass: UnrealEngineClass,Transform: Transform,Layer: DataLayer,World: World): ActorInstanceHandle;
	static Conv_ClassToSoftClassReference(Class: UnrealEngineClass): Class;
	static Conv_SoftClassReferenceToClass(softclass: Class): UnrealEngineClass;
	static Conv_SoftClassReferenceToString(SoftClassReference: Class): string;
	static EqualEqual_SoftClassReference(A: Class,B: Class): boolean;
	static GetClassDisplayName(Class: UnrealEngineClass): string;
	static GetPrimaryAssetIdFromClass(Class: UnrealEngineClass): PrimaryAssetId;
	static GetPrimaryAssetIdFromSoftClassReference(SoftClassReference: Class): PrimaryAssetId;
	static IsValidClass(Class: UnrealEngineClass): boolean;
	static IsValidSoftClassReference(SoftClassReference: Class): boolean;
	static LoadClassAsset_Blocking(AssetClass: Class): UnrealEngineClass;
	static NotEqual_SoftClassReference(A: Class,B: Class): boolean;
	static ClassIsChildOf(TestClass: UnrealEngineClass,ParentClass: UnrealEngineClass): boolean;
	static EqualEqual_ClassClass(A: UnrealEngineClass,B: UnrealEngineClass): boolean;
	static NotEqual_ClassClass(A: UnrealEngineClass,B: UnrealEngineClass): boolean;
	static SelectClass(A: UnrealEngineClass,B: UnrealEngineClass,bSelectA: boolean): UnrealEngineClass;
	static CreateSaveGameObject(SaveGameClass: UnrealEngineClass): SaveGame;
	static SpawnObject(ObjectClass: UnrealEngineClass,Outer: UObject): UObject;
	static SetInterfaceClass(Class: UnrealEngineClass,Var?: CameraLensInterfaceClassSupport,Result?: EInterfaceValidResult): {Var: CameraLensInterfaceClassSupport, Result: EInterfaceValidResult};
	static GetEditorSubsystem(Class: UnrealEngineClass): EditorSubsystem;
	static CreateDragDropOperation(OperationClass: UnrealEngineClass): DragDropOperation;
	static GetAllGeometriesByClass(GeometryClass: UnrealEngineClass): ARTrackedGeometry[];
}

declare class NavAgentSelector { 
	bSupportsAgent0: boolean;
	bSupportsAgent1: boolean;
	bSupportsAgent2: boolean;
	bSupportsAgent3: boolean;
	bSupportsAgent4: boolean;
	bSupportsAgent5: boolean;
	bSupportsAgent6: boolean;
	bSupportsAgent7: boolean;
	bSupportsAgent8: boolean;
	bSupportsAgent9: boolean;
	bSupportsAgent10: boolean;
	bSupportsAgent11: boolean;
	bSupportsAgent12: boolean;
	bSupportsAgent13: boolean;
	bSupportsAgent14: boolean;
	bSupportsAgent15: boolean;
	clone() : NavAgentSelector;
	static C(Other: UObject | any): NavAgentSelector;
}

declare class NavigationSystemConfig extends UObject { 
	NavigationSystemClass: SoftClassPath;
	SupportedAgentsMask: NavAgentSelector;
	DefaultAgentName: string;
	bIsOverriden: boolean;
	static Load(ResourceName: string): NavigationSystemConfig;
	static Find(Outer: UObject, ResourceName: string): NavigationSystemConfig;
	static GetDefaultObject(): NavigationSystemConfig;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationSystemConfig;
	static C(Other: UObject | any): NavigationSystemConfig;
}

declare class ActorDescContainer extends UObject { 
	World: World;
	static Load(ResourceName: string): ActorDescContainer;
	static Find(Outer: UObject, ResourceName: string): ActorDescContainer;
	static GetDefaultObject(): ActorDescContainer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorDescContainer;
	static C(Other: UObject | any): ActorDescContainer;
}

declare class WorldPartitionEditorHash extends UObject { 
	static Load(ResourceName: string): WorldPartitionEditorHash;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionEditorHash;
	static GetDefaultObject(): WorldPartitionEditorHash;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionEditorHash;
	static C(Other: UObject | any): WorldPartitionEditorHash;
}

declare class WorldPartitionStreamingPolicy extends UObject { 
	static Load(ResourceName: string): WorldPartitionStreamingPolicy;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionStreamingPolicy;
	static GetDefaultObject(): WorldPartitionStreamingPolicy;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionStreamingPolicy;
	static C(Other: UObject | any): WorldPartitionStreamingPolicy;
}

declare class WorldPartitionRuntimeHash extends UObject { 
	static Load(ResourceName: string): WorldPartitionRuntimeHash;
	static Find(Outer: UObject, ResourceName: string): WorldPartitionRuntimeHash;
	static GetDefaultObject(): WorldPartitionRuntimeHash;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartitionRuntimeHash;
	static C(Other: UObject | any): WorldPartitionRuntimeHash;
}

declare type EHLODLayerType = 'Instancing' | 'MeshMerge' | 'MeshSimplify' | 'MeshApproximate' | 'Custom' | 'EHLODLayerType_MAX';
declare var EHLODLayerType : { Instancing:'Instancing',MeshMerge:'MeshMerge',MeshSimplify:'MeshSimplify',MeshApproximate:'MeshApproximate',Custom:'Custom',EHLODLayerType_MAX:'EHLODLayerType_MAX', };
declare class HLODBuilderSettings extends UObject { 
	static Load(ResourceName: string): HLODBuilderSettings;
	static Find(Outer: UObject, ResourceName: string): HLODBuilderSettings;
	static GetDefaultObject(): HLODBuilderSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HLODBuilderSettings;
	static C(Other: UObject | any): HLODBuilderSettings;
}

declare class HLODBuilder extends UObject { 
	HLODBuilderSettings: HLODBuilderSettings;
	static Load(ResourceName: string): HLODBuilder;
	static Find(Outer: UObject, ResourceName: string): HLODBuilder;
	static GetDefaultObject(): HLODBuilder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HLODBuilder;
	static C(Other: UObject | any): HLODBuilder;
}

declare type EUVOutput = 'DoNotOutputChannel' | 'OutputChannel' | 'EUVOutput_MAX';
declare var EUVOutput : { DoNotOutputChannel:'DoNotOutputChannel',OutputChannel:'OutputChannel',EUVOutput_MAX:'EUVOutput_MAX', };
declare type EMeshLODSelectionType = 'AllLODs' | 'SpecificLOD' | 'CalculateLOD' | 'LowestDetailLOD' | 'EMeshLODSelectionType_MAX';
declare var EMeshLODSelectionType : { AllLODs:'AllLODs',SpecificLOD:'SpecificLOD',CalculateLOD:'CalculateLOD',LowestDetailLOD:'LowestDetailLOD',EMeshLODSelectionType_MAX:'EMeshLODSelectionType_MAX', };
declare class MeshMergingSettings { 
	TargetLightMapResolution: number;
	OutputUVs: EUVOutput;
	MaterialSettings: MaterialProxySettings;
	GutterSize: number;
	SpecificLOD: number;
	LODSelectionType: EMeshLODSelectionType;
	bGenerateLightMapUV: boolean;
	bComputedLightMapResolution: boolean;
	bPivotPointAtZero: boolean;
	bMergePhysicsData: boolean;
	bMergeMaterials: boolean;
	bCreateMergedMaterial: boolean;
	bBakeVertexDataToMesh: boolean;
	bUseVertexDataForBakingMaterial: boolean;
	bUseTextureBinning: boolean;
	bReuseMeshLightmapUVs: boolean;
	bMergeEquivalentMaterials: boolean;
	bUseLandscapeCulling: boolean;
	bIncludeImposters: boolean;
	bAllowDistanceField: boolean;
	bGenerateNaniteEnabledMesh: boolean;
	NaniteFallbackTrianglePercent: number;
	bImportVertexColors: boolean;
	bCalculateCorrectLODModel: boolean;
	bExportNormalMap: boolean;
	bExportMetallicMap: boolean;
	bExportRoughnessMap: boolean;
	bExportSpecularMap: boolean;
	MergedMaterialAtlasResolution: number;
	ExportSpecificLOD: number;
	clone() : MeshMergingSettings;
	static C(Other: UObject | any): MeshMergingSettings;
}

declare type EProxyNormalComputationMethod = 'AngleWeighted' | 'AreaWeighted' | 'EqualWeighted' | 'EProxyNormalComputationMethod_MAX';
declare var EProxyNormalComputationMethod : { AngleWeighted:'AngleWeighted',AreaWeighted:'AreaWeighted',EqualWeighted:'EqualWeighted',EProxyNormalComputationMethod_MAX:'EProxyNormalComputationMethod_MAX', };
declare type ELandscapeCullingPrecision = 'High' | 'Medium' | 'Low' | 'ELandscapeCullingPrecision_MAX';
declare var ELandscapeCullingPrecision : { High:'High',Medium:'Medium',Low:'Low',ELandscapeCullingPrecision_MAX:'ELandscapeCullingPrecision_MAX', };
declare class MeshProxySettings { 
	ScreenSize: number;
	VoxelSize: number;
	MaterialSettings: MaterialProxySettings;
	TextureWidth: number;
	TextureHeight: number;
	bExportNormalMap: boolean;
	bExportMetallicMap: boolean;
	bExportRoughnessMap: boolean;
	bExportSpecularMap: boolean;
	bBakeVertexData: boolean;
	MergeDistance: number;
	UnresolvedGeometryColor: Color;
	MaxRayCastDist: number;
	HardAngleThreshold: number;
	LightMapResolution: number;
	NormalCalculationMethod: EProxyNormalComputationMethod;
	LandscapeCullingPrecision: ELandscapeCullingPrecision;
	bCalculateCorrectLODModel: boolean;
	bOverrideVoxelSize: boolean;
	bOverrideTransferDistance: boolean;
	bUseHardAngleThreshold: boolean;
	bComputeLightMapResolution: boolean;
	bRecalculateNormals: boolean;
	bUseLandscapeCulling: boolean;
	bAllowDistanceField: boolean;
	bReuseMeshLightmapUVs: boolean;
	bGroupIdenticalMeshesForBaking: boolean;
	bCreateCollision: boolean;
	bAllowVertexColors: boolean;
	bGenerateLightmapUVs: boolean;
	bGenerateNaniteEnabledMesh: boolean;
	NaniteProxyTrianglePercent: number;
	clone() : MeshProxySettings;
	static C(Other: UObject | any): MeshProxySettings;
}

declare type EMeshApproximationType = 'MeshAndMaterials' | 'MeshShapeOnly' | 'EMeshApproximationType_MAX';
declare var EMeshApproximationType : { MeshAndMaterials:'MeshAndMaterials',MeshShapeOnly:'MeshShapeOnly',EMeshApproximationType_MAX:'EMeshApproximationType_MAX', };
declare type EMeshApproximationBaseCappingType = 'NoBaseCapping' | 'ConvexPolygon' | 'ConvexSolid' | 'EMeshApproximationBaseCappingType_MAX';
declare var EMeshApproximationBaseCappingType : { NoBaseCapping:'NoBaseCapping',ConvexPolygon:'ConvexPolygon',ConvexSolid:'ConvexSolid',EMeshApproximationBaseCappingType_MAX:'EMeshApproximationBaseCappingType_MAX', };
declare type EOccludedGeometryFilteringPolicy = 'NoOcclusionFiltering' | 'VisibilityBasedFiltering' | 'EOccludedGeometryFilteringPolicy_MAX';
declare var EOccludedGeometryFilteringPolicy : { NoOcclusionFiltering:'NoOcclusionFiltering',VisibilityBasedFiltering:'VisibilityBasedFiltering',EOccludedGeometryFilteringPolicy_MAX:'EOccludedGeometryFilteringPolicy_MAX', };
declare type EMeshApproximationSimplificationPolicy = 'FixedTriangleCount' | 'TrianglesPerArea' | 'GeometricTolerance' | 'EMeshApproximationSimplificationPolicy_MAX';
declare var EMeshApproximationSimplificationPolicy : { FixedTriangleCount:'FixedTriangleCount',TrianglesPerArea:'TrianglesPerArea',GeometricTolerance:'GeometricTolerance',EMeshApproximationSimplificationPolicy_MAX:'EMeshApproximationSimplificationPolicy_MAX', };
declare type EMeshApproximationGroundPlaneClippingPolicy = 'NoGroundClipping' | 'DiscardWithZPlane' | 'CutWithZPlane' | 'CutAndFillWithZPlane' | 'EMeshApproximationGroundPlaneClippingPolicy_MAX';
declare var EMeshApproximationGroundPlaneClippingPolicy : { NoGroundClipping:'NoGroundClipping',DiscardWithZPlane:'DiscardWithZPlane',CutWithZPlane:'CutWithZPlane',CutAndFillWithZPlane:'CutAndFillWithZPlane',EMeshApproximationGroundPlaneClippingPolicy_MAX:'EMeshApproximationGroundPlaneClippingPolicy_MAX', };
declare type EMeshApproximationUVGenerationPolicy = 'PreferUVAtlas' | 'PreferXAtlas' | 'PreferPatchBuilder' | 'EMeshApproximationUVGenerationPolicy_MAX';
declare var EMeshApproximationUVGenerationPolicy : { PreferUVAtlas:'PreferUVAtlas',PreferXAtlas:'PreferXAtlas',PreferPatchBuilder:'PreferPatchBuilder',EMeshApproximationUVGenerationPolicy_MAX:'EMeshApproximationUVGenerationPolicy_MAX', };
declare class MeshApproximationSettings { 
	OutputType: EMeshApproximationType;
	ApproximationAccuracy: number;
	ClampVoxelDimension: number;
	bAttemptAutoThickening: boolean;
	TargetMinThicknessMultiplier: number;
	bIgnoreTinyParts: boolean;
	TinyPartSizeMultiplier: number;
	BaseCapping: EMeshApproximationBaseCappingType;
	WindingThreshold: number;
	bFillGaps: boolean;
	GapDistance: number;
	OcclusionMethod: EOccludedGeometryFilteringPolicy;
	bOccludeFromBottom: boolean;
	SimplifyMethod: EMeshApproximationSimplificationPolicy;
	TargetTriCount: number;
	TrianglesPerM: number;
	GeometricDeviation: number;
	GroundClipping: EMeshApproximationGroundPlaneClippingPolicy;
	GroundClippingZHeight: number;
	bEstimateHardNormals: boolean;
	HardNormalAngle: number;
	UVGenerationMethod: EMeshApproximationUVGenerationPolicy;
	InitialPatchCount: number;
	CurvatureAlignment: number;
	MergingThreshold: number;
	MaxAngleDeviation: number;
	bGenerateNaniteEnabledMesh: boolean;
	NaniteProxyTrianglePercent: number;
	bSupportRayTracing: boolean;
	bAllowDistanceField: boolean;
	MultiSamplingAA: number;
	RenderCaptureResolution: number;
	MaterialSettings: MaterialProxySettings;
	CaptureFieldOfView: number;
	NearPlaneDist: number;
	bUseRenderLODMeshes: boolean;
	bEnableSimplifyPrePass: boolean;
	bEnableParallelBaking: boolean;
	bPrintDebugMessages: boolean;
	bEmitFullDebugMesh: boolean;
	clone() : MeshApproximationSettings;
	static C(Other: UObject | any): MeshApproximationSettings;
}

declare class HLODLayer extends UObject { 
	LayerType: EHLODLayerType;
	HLODBuilderClass: UnrealEngineClass;
	HLODBuilderSettings: HLODBuilderSettings;
	bIsSpatiallyLoaded: boolean;
	bAlwaysLoaded: boolean;
	CellSize: number;
	LoadingRange: any;
	ParentLayer: HLODLayer;
	MeshMergeSettings: MeshMergingSettings;
	MeshSimplifySettings: MeshProxySettings;
	MeshApproximationSettings: MeshApproximationSettings;
	HLODMaterial: Material;
	static Load(ResourceName: string): HLODLayer;
	static Find(Outer: UObject, ResourceName: string): HLODLayer;
	static GetDefaultObject(): HLODLayer;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HLODLayer;
	static C(Other: UObject | any): HLODLayer;
}

declare class WorldPartition extends ActorDescContainer { 
	EditorHash: WorldPartitionEditorHash;
	WorldPartitionStreamingPolicyClass: UnrealEngineClass;
	bEnableStreaming: boolean;
	bStreamingWasEnabled: boolean;
	RuntimeHash: WorldPartitionRuntimeHash;
	DefaultHLODLayer: HLODLayer;
	StreamingPolicy: WorldPartitionStreamingPolicy;
	static Load(ResourceName: string): WorldPartition;
	static Find(Outer: UObject, ResourceName: string): WorldPartition;
	static GetDefaultObject(): WorldPartition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldPartition;
	static C(Other: UObject | any): WorldPartition;
}

declare class DamageType extends UObject { 
	bCausedByWorld: boolean;
	bScaleMomentumByMass: boolean;
	bRadialDamageVelChange: boolean;
	DamageImpulse: number;
	DestructibleImpulse: number;
	DestructibleDamageSpreadScale: number;
	DamageFalloff: number;
	static Load(ResourceName: string): DamageType;
	static Find(Outer: UObject, ResourceName: string): DamageType;
	static GetDefaultObject(): DamageType;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DamageType;
	static C(Other: UObject | any): DamageType;
}

declare class DefaultPhysicsVolume extends PhysicsVolume { 
	static GetDefaultObject(): DefaultPhysicsVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultPhysicsVolume;
	static C(Other: UObject | any): DefaultPhysicsVolume;
}

declare class PhysicsCollisionHandler extends UObject { 
	ImpactThreshold: number;
	ImpactReFireDelay: number;
	DefaultImpactSound: SoundBase;
	LastImpactSoundTime: number;
	static Load(ResourceName: string): PhysicsCollisionHandler;
	static Find(Outer: UObject, ResourceName: string): PhysicsCollisionHandler;
	static GetDefaultObject(): PhysicsCollisionHandler;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsCollisionHandler;
	static C(Other: UObject | any): PhysicsCollisionHandler;
}

declare class GameSession extends Info { 
	MaxSpectators: number;
	MaxPlayers: number;
	MaxPartySize: number;
	MaxSplitscreensPerConnection: number;
	bRequiresPushToTalk: boolean;
	SessionName: string;
	static GetDefaultObject(): GameSession;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameSession;
	static C(Other: UObject | any): GameSession;
}

declare class GameStateBase extends Info { 
	GameModeClass: UnrealEngineClass;
	AuthorityGameMode: GameModeBase;
	SpectatorClass: UnrealEngineClass;
	PlayerArray: PlayerState[];
	bReplicatedHasBegunPlay: boolean;
	ReplicatedWorldTimeSeconds: number;
	ServerWorldTimeSecondsDelta: number;
	ServerWorldTimeSecondsUpdateFrequency: number;
	static GetDefaultObject(): GameStateBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameStateBase;
	OnRep_SpectatorClass(): void;
	OnRep_ReplicatedWorldTimeSeconds(): void;
	OnRep_ReplicatedHasBegunPlay(): void;
	OnRep_GameModeClass(): void;
	HasMatchStarted(): boolean;
	HasMatchEnded(): boolean;
	HasBegunPlay(): boolean;
	GetServerWorldTimeSeconds(): number;
	GetPlayerStartTime(Controller: Controller): number;
	GetPlayerRespawnDelay(Controller: Controller): number;
	static C(Other: UObject | any): GameStateBase;
}

declare class ServerStatReplicator extends Info { 
	bUpdateStatNet: boolean;
	bOverwriteClientStats: boolean;
	Channels: any;
	InRate: any;
	OutRate: any;
	MaxPacketOverhead: any;
	InRateClientMax: any;
	InRateClientMin: any;
	InRateClientAvg: any;
	InPacketsClientMax: any;
	InPacketsClientMin: any;
	InPacketsClientAvg: any;
	OutRateClientMax: any;
	OutRateClientMin: any;
	OutRateClientAvg: any;
	OutPacketsClientMax: any;
	OutPacketsClientMin: any;
	OutPacketsClientAvg: any;
	NetNumClients: any;
	InPackets: any;
	OutPackets: any;
	InBunches: any;
	OutBunches: any;
	OutLoss: any;
	InLoss: any;
	VoiceBytesSent: any;
	VoiceBytesRecv: any;
	VoicePacketsSent: any;
	VoicePacketsRecv: any;
	PercentInVoice: any;
	PercentOutVoice: any;
	NumActorChannels: any;
	NumConsideredActors: any;
	PrioritizedActors: any;
	NumRelevantActors: any;
	NumRelevantDeletedActors: any;
	NumReplicatedActorAttempts: any;
	NumReplicatedActors: any;
	NumActors: any;
	NumNetActors: any;
	NumDormantActors: any;
	NumInitiallyDormantActors: any;
	NumNetGUIDsAckd: any;
	NumNetGUIDsPending: any;
	NumNetGUIDsUnAckd: any;
	ObjPathBytes: any;
	NetGUIDOutRate: any;
	NetGUIDInRate: any;
	NetSaturated: any;
	static GetDefaultObject(): ServerStatReplicator;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ServerStatReplicator;
	static C(Other: UObject | any): ServerStatReplicator;
}

declare class GameModeBase extends Info { 
	OptionsString: string;
	GameSessionClass: UnrealEngineClass;
	GameStateClass: UnrealEngineClass;
	PlayerControllerClass: UnrealEngineClass;
	PlayerStateClass: UnrealEngineClass;
	HUDClass: UnrealEngineClass;
	DefaultPawnClass: UnrealEngineClass;
	SpectatorClass: UnrealEngineClass;
	ReplaySpectatorPlayerControllerClass: UnrealEngineClass;
	ServerStatReplicatorClass: UnrealEngineClass;
	GameSession: GameSession;
	GameState: GameStateBase;
	ServerStatReplicator: ServerStatReplicator;
	DefaultPlayerName: string;
	bUseSeamlessTravel: boolean;
	bStartPlayersAsSpectators: boolean;
	bPauseable: boolean;
	static GetDefaultObject(): GameModeBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameModeBase;
	StartPlay(): void;
	SpawnDefaultPawnFor(NewPlayer: Controller,StartSpot: Actor): Pawn;
	SpawnDefaultPawnAtTransform(NewPlayer: Controller,SpawnTransform: Transform): Pawn;
	ShouldReset(ActorToReset: Actor): boolean;
	ReturnToMainMenuHost(): void;
	RestartPlayerAtTransform(NewPlayer: Controller,SpawnTransform: Transform): void;
	RestartPlayerAtPlayerStart(NewPlayer: Controller,StartSpot: Actor): void;
	RestartPlayer(NewPlayer: Controller): void;
	ResetLevel(): void;
	PlayerCanRestart(Player: PlayerController): boolean;
	MustSpectate(NewPlayerController: PlayerController): boolean;
	K2_PostLogin(NewPlayer: PlayerController): void;
	K2_OnSwapPlayerControllers(OldPC: PlayerController,NewPC: PlayerController): void;
	K2_OnRestartPlayer(NewPlayer: Controller): void;
	K2_OnLogout(ExitingController: Controller): void;
	K2_OnChangeName(Other: Controller,NewName: string,bNameChange: boolean): void;
	K2_FindPlayerStart(Player: Controller,IncomingName: string): Actor;
	InitStartSpot(StartSpot: Actor,NewPlayer: Controller): void;
	InitializeHUDForPlayer(NewPlayer: PlayerController): void;
	HasMatchStarted(): boolean;
	HasMatchEnded(): boolean;
	HandleStartingNewPlayer(NewPlayer: PlayerController): void;
	GetNumSpectators(): number;
	GetNumPlayers(): number;
	GetDefaultPawnClassForController(InController: Controller): UnrealEngineClass;
	FindPlayerStart(Player: Controller,IncomingName: string): Actor;
	ChoosePlayerStart(Player: Controller): Actor;
	ChangeName(Controller: Controller,NewName: string,bNameChange: boolean): void;
	CanSpectate(Viewer: PlayerController,ViewTarget: PlayerState): boolean;
	static C(Other: UObject | any): GameModeBase;
	HandleSeamlessTravelPlayer(C?: Controller): {C: Controller};
	static HandleSeamlessTravelPlayer(GameMode: GameModeBase,C?: Controller): {C: Controller};
}

declare class GameNetworkManager extends Info { 
	BadPacketLossThreshold: number;
	SeverePacketLossThreshold: number;
	BadPingThreshold: number;
	SeverePingThreshold: number;
	AdjustedNetSpeed: number;
	LastNetSpeedUpdateTime: number;
	TotalNetBandwidth: number;
	MinDynamicBandwidth: number;
	MaxDynamicBandwidth: number;
	bIsStandbyCheckingEnabled: boolean;
	bHasStandbyCheatTriggered: boolean;
	StandbyRxCheatTime: number;
	StandbyTxCheatTime: number;
	PercentMissingForRxStandby: number;
	PercentMissingForTxStandby: number;
	PercentForBadPing: number;
	JoinInProgressStandbyWaitTime: number;
	MoveRepSize: number;
	MAXPOSITIONERRORSQUARED: number;
	MAXNEARZEROVELOCITYSQUARED: number;
	CLIENTADJUSTUPDATECOST: number;
	MAXCLIENTUPDATEINTERVAL: number;
	MaxClientForcedUpdateDuration: number;
	ServerForcedUpdateHitchThreshold: number;
	ServerForcedUpdateHitchCooldown: number;
	MaxMoveDeltaTime: number;
	MaxClientSmoothingDeltaTime: number;
	ClientNetSendMoveDeltaTime: number;
	ClientNetSendMoveDeltaTimeThrottled: number;
	ClientNetSendMoveDeltaTimeStationary: number;
	ClientNetSendMoveThrottleAtNetSpeed: number;
	ClientNetSendMoveThrottleOverPlayerCount: number;
	ClientAuthorativePosition: boolean;
	ClientErrorUpdateRateLimit: number;
	ClientNetCamUpdateDeltaTime: number;
	ClientNetCamUpdatePositionLimit: number;
	bMovementTimeDiscrepancyDetection: boolean;
	bMovementTimeDiscrepancyResolution: boolean;
	MovementTimeDiscrepancyMaxTimeMargin: number;
	MovementTimeDiscrepancyMinTimeMargin: number;
	MovementTimeDiscrepancyResolutionRate: number;
	MovementTimeDiscrepancyDriftAllowance: number;
	bMovementTimeDiscrepancyForceCorrectionsDuringResolution: boolean;
	bUseDistanceBasedRelevancy: boolean;
	static GetDefaultObject(): GameNetworkManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameNetworkManager;
	static C(Other: UObject | any): GameNetworkManager;
}

declare type EVolumeLightingMethod = 'VLM_VolumetricLightmap' | 'VLM_SparseVolumeLightingSamples' | 'VLM_MAX';
declare var EVolumeLightingMethod : { VLM_VolumetricLightmap:'VLM_VolumetricLightmap',VLM_SparseVolumeLightingSamples:'VLM_SparseVolumeLightingSamples',VLM_MAX:'VLM_MAX', };
declare class LightmassWorldInfoSettings { 
	StaticLightingLevelScale: number;
	NumIndirectLightingBounces: number;
	NumSkyLightingBounces: number;
	IndirectLightingQuality: number;
	IndirectLightingSmoothness: number;
	EnvironmentColor: Color;
	EnvironmentIntensity: number;
	EmissiveBoost: number;
	DiffuseBoost: number;
	VolumeLightingMethod: EVolumeLightingMethod;
	bUseAmbientOcclusion: boolean;
	bGenerateAmbientOcclusionMaterialMask: boolean;
	bVisualizeMaterialDiffuse: boolean;
	bVisualizeAmbientOcclusion: boolean;
	bCompressLightmaps: boolean;
	VolumetricLightmapDetailCellSize: number;
	VolumetricLightmapMaximumBrickMemoryMb: number;
	VolumetricLightmapSphericalHarmonicSmoothing: number;
	VolumeLightSamplePlacementScale: number;
	DirectIlluminationOcclusionFraction: number;
	IndirectIlluminationOcclusionFraction: number;
	OcclusionExponent: number;
	FullyOccludedSamplesFraction: number;
	MaxOcclusionDistance: number;
	clone() : LightmassWorldInfoSettings;
	static C(Other: UObject | any): LightmassWorldInfoSettings;
}

declare type ReverbPreset = 'REVERB_Default' | 'REVERB_Bathroom' | 'REVERB_StoneRoom' | 'REVERB_Auditorium' | 'REVERB_ConcertHall' | 'REVERB_Cave' | 'REVERB_Hallway' | 'REVERB_StoneCorridor' | 'REVERB_Alley' | 'REVERB_Forest' | 'REVERB_City' | 'REVERB_Mountains' | 'REVERB_Quarry' | 'REVERB_Plain' | 'REVERB_ParkingLot' | 'REVERB_SewerPipe' | 'REVERB_Underwater' | 'REVERB_SmallRoom' | 'REVERB_MediumRoom' | 'REVERB_LargeRoom' | 'REVERB_MediumHall' | 'REVERB_LargeHall' | 'REVERB_Plate' | 'REVERB_MAX';
declare var ReverbPreset : { REVERB_Default:'REVERB_Default',REVERB_Bathroom:'REVERB_Bathroom',REVERB_StoneRoom:'REVERB_StoneRoom',REVERB_Auditorium:'REVERB_Auditorium',REVERB_ConcertHall:'REVERB_ConcertHall',REVERB_Cave:'REVERB_Cave',REVERB_Hallway:'REVERB_Hallway',REVERB_StoneCorridor:'REVERB_StoneCorridor',REVERB_Alley:'REVERB_Alley',REVERB_Forest:'REVERB_Forest',REVERB_City:'REVERB_City',REVERB_Mountains:'REVERB_Mountains',REVERB_Quarry:'REVERB_Quarry',REVERB_Plain:'REVERB_Plain',REVERB_ParkingLot:'REVERB_ParkingLot',REVERB_SewerPipe:'REVERB_SewerPipe',REVERB_Underwater:'REVERB_Underwater',REVERB_SmallRoom:'REVERB_SmallRoom',REVERB_MediumRoom:'REVERB_MediumRoom',REVERB_LargeRoom:'REVERB_LargeRoom',REVERB_MediumHall:'REVERB_MediumHall',REVERB_LargeHall:'REVERB_LargeHall',REVERB_Plate:'REVERB_Plate',REVERB_MAX:'REVERB_MAX', };
declare class ReverbEffect extends UObject { 
	bBypassEarlyReflections: boolean;
	ReflectionsDelay: number;
	GainHF: number;
	ReflectionsGain: number;
	bBypassLateReflections: boolean;
	LateDelay: number;
	DecayTime: number;
	Density: number;
	Diffusion: number;
	AirAbsorptionGainHF: number;
	DecayHFRatio: number;
	LateGain: number;
	Gain: number;
	RoomRolloffFactor: number;
	bChanged: boolean;
	static Load(ResourceName: string): ReverbEffect;
	static Find(Outer: UObject, ResourceName: string): ReverbEffect;
	static GetDefaultObject(): ReverbEffect;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReverbEffect;
	static C(Other: UObject | any): ReverbEffect;
}

declare class ReverbSettings { 
	bApplyReverb: boolean;
	ReverbType: ReverbPreset;
	ReverbEffect: ReverbEffect;
	ReverbPluginEffect: SoundEffectSubmixPreset;
	Volume: number;
	FadeTime: number;
	clone() : ReverbSettings;
	static C(Other: UObject | any): ReverbSettings;
}

declare class InteriorSettings { 
	bIsWorldSettings: boolean;
	ExteriorVolume: number;
	ExteriorTime: number;
	ExteriorLPF: number;
	ExteriorLPFTime: number;
	InteriorVolume: number;
	InteriorTime: number;
	InteriorLPF: number;
	InteriorLPFTime: number;
	clone() : InteriorSettings;
	static C(Other: UObject | any): InteriorSettings;
}

declare class HierarchicalSimplification { 
	TransitionScreenSize: number;
	OverrideDrawDistance: number;
	bUseOverrideDrawDistance: boolean;
	bAllowSpecificExclusion: boolean;
	bSimplifyMesh: boolean;
	bOnlyGenerateClustersForVolumes: boolean;
	bReusePreviousLevelClusters: boolean;
	ProxySetting: MeshProxySettings;
	MergeSetting: MeshMergingSettings;
	DesiredBoundRadius: number;
	DesiredFillingPercentage: number;
	MinNumberOfActorsToBuild: number;
	clone() : HierarchicalSimplification;
	static C(Other: UObject | any): HierarchicalSimplification;
}

declare class BookmarkBase extends UObject { 
	static Load(ResourceName: string): BookmarkBase;
	static Find(Outer: UObject, ResourceName: string): BookmarkBase;
	static GetDefaultObject(): BookmarkBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BookmarkBase;
	static C(Other: UObject | any): BookmarkBase;
}

declare class BookMark extends BookmarkBase { 
	Location: Vector;
	Rotation: Rotator;
	HiddenLevels: string[];
	static Load(ResourceName: string): BookMark;
	static Find(Outer: UObject, ResourceName: string): BookMark;
	static GetDefaultObject(): BookMark;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BookMark;
	static C(Other: UObject | any): BookMark;
}

declare class BroadphaseSettings { 
	bUseMBPOnClient: boolean;
	bUseMBPOnServer: boolean;
	bUseMBPOuterBounds: boolean;
	MBPBounds: Box;
	MBPOuterBounds: Box;
	MBPNumSubdivs: any;
	clone() : BroadphaseSettings;
	static C(Other: UObject | any): BroadphaseSettings;
}

declare class NetViewer { 
	Connection: NetConnection;
	InViewer: Actor;
	ViewTarget: Actor;
	ViewLocation: Vector;
	ViewDir: Vector;
	clone() : NetViewer;
	static C(Other: UObject | any): NetViewer;
}

declare class WorldPartitionPerWorldSettings { 
	LoadedEditorGridCells: string[];
	NotLoadedDataLayers: string[];
	LoadedDataLayers: string[];
	EditorGridConfigHash: any;
	clone() : WorldPartitionPerWorldSettings;
	static C(Other: UObject | any): WorldPartitionPerWorldSettings;
}

declare class WorldSettings extends Info { 
	VisibilityCellSize: number;
	VisibilityAggressiveness: EVisibilityAggressiveness;
	bPrecomputeVisibility: boolean;
	bPlaceCellsOnlyAlongCameraTracks: boolean;
	bEnableLargeWorlds: boolean;
	bEnableWorldBoundsChecks: boolean;
	bEnableNavigationSystem: boolean;
	bEnableAISystem: boolean;
	bEnableWorldComposition: boolean;
	bUseClientSideLevelStreamingVolumes: boolean;
	bEnableWorldOriginRebasing: boolean;
	bWorldGravitySet: boolean;
	bGlobalGravitySet: boolean;
	bMinimizeBSPSections: boolean;
	bForceNoPrecomputedLighting: boolean;
	bHighPriorityLoading: boolean;
	bHighPriorityLoadingLocal: boolean;
	bOverrideDefaultBroadphaseSettings: boolean;
	bGenerateSingleClusterForLevel: boolean;
	bIncludeGridSizeInNameForFoliageActors: boolean;
	bIncludeGridSizeInNameForPartitionedActors: boolean;
	AISystemClass: Class;
	LevelInstancePivotOffset: Vector;
	NavigationSystemConfig: NavigationSystemConfig;
	NavigationSystemConfigOverride: NavigationSystemConfig;
	WorldPartition: WorldPartition;
	InstancedFoliageGridSize: any;
	NavigationDataChunkGridSize: any;
	NavigationDataBuilderLoadingCellSize: any;
	DefaultPlacementGridSize: any;
	WorldToMeters: number;
	KillZ: number;
	KillZDamageType: UnrealEngineClass;
	WorldGravityZ: number;
	GlobalGravityZ: number;
	DefaultPhysicsVolumeClass: UnrealEngineClass;
	PhysicsCollisionHandlerClass: UnrealEngineClass;
	DefaultGameMode: UnrealEngineClass;
	GameNetworkManagerClass: UnrealEngineClass;
	PackedLightAndShadowMapTextureSize: number;
	DefaultColorScale: Vector;
	DefaultMaxDistanceFieldOcclusionDistance: number;
	GlobalDistanceFieldViewDistance: number;
	DynamicIndirectShadowsSelfShadowingIntensity: number;
	LightmassSettings: LightmassWorldInfoSettings;
	DefaultReverbSettings: ReverbSettings;
	DefaultAmbientZoneSettings: InteriorSettings;
	DefaultBaseSoundMix: SoundMix;
	HLODSetupAsset: Class;
	OverrideBaseMaterial: MaterialInterface;
	HierarchicalLODSetup: HierarchicalSimplification[];
	NumHLODLevels: number;
	HLODBakingTransform: Transform;
	Bookmarks: BookMark;
	TimeDilation: number;
	MatineeTimeDilation: number;
	DemoPlayTimeDilation: number;
	MinGlobalTimeDilation: number;
	MaxGlobalTimeDilation: number;
	MinUndilatedFrameTime: number;
	MaxUndilatedFrameTime: number;
	BroadphaseSettings: BroadphaseSettings;
	ReplicationViewers: NetViewer[];
	AssetUserData: AssetUserData[];
	PauserPlayerState: PlayerState;
	DefaultWorldPartitionSettings: WorldPartitionPerWorldSettings;
	MaxNumberOfBookmarks: number;
	DefaultBookmarkClass: UnrealEngineClass;
	BookmarkArray: BookmarkBase[];
	LastBookmarkClass: UnrealEngineClass;
	bEnableHierarchicalLODSystem: boolean;
	static GetDefaultObject(): WorldSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldSettings;
	OnRep_WorldGravityZ(): void;
	static C(Other: UObject | any): WorldSettings;
}

declare class WorldDataLayers extends Info { 
	bAllowRuntimeDataLayerEditing: boolean;
	WorldDataLayers: any;
	RepActiveDataLayerNames: string[];
	RepLoadedDataLayerNames: string[];
	RepEffectiveActiveDataLayerNames: string[];
	RepEffectiveLoadedDataLayerNames: string[];
	static GetDefaultObject(): WorldDataLayers;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldDataLayers;
	OnRep_LoadedDataLayerNames(): void;
	OnRep_EffectiveLoadedDataLayerNames(): void;
	OnRep_EffectiveActiveDataLayerNames(): void;
	OnRep_ActiveDataLayerNames(): void;
	OnDataLayerRuntimeStateChanged(InDataLayer: DataLayer,InState: EDataLayerRuntimeState): void;
	static C(Other: UObject | any): WorldDataLayers;
}

declare class ReplicatedStaticActorDestructionInfo { 
	ObjClass: UnrealEngineClass;
	clone() : ReplicatedStaticActorDestructionInfo;
	static C(Other: UObject | any): ReplicatedStaticActorDestructionInfo;
}

declare class ActorFolder extends UObject { 
	ParentFolderGuid: Guid;
	FolderGuid: Guid;
	FolderLabel: string;
	bFolderInitiallyExpanded: boolean;
	bIsDeleted: boolean;
	static Load(ResourceName: string): ActorFolder;
	static Find(Outer: UObject, ResourceName: string): ActorFolder;
	static GetDefaultObject(): ActorFolder;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFolder;
	static C(Other: UObject | any): ActorFolder;
}

declare class Level extends UObject { 
	ActorsModifiedForPIE: any;
	bUseExternalActors: boolean;
	OwningWorld: World;
	Model: Model;
	ModelComponents: ModelComponent[];
	ActorCluster: LevelActorContainer;
	LevelScriptBlueprint: LevelScriptBlueprint;
	TextureStreamingResourceGuids: Guid[];
	NumTextureStreamingUnbuiltComponents: number;
	NumTextureStreamingDirtyResources: number;
	LevelScriptActor: LevelScriptActor;
	NavListStart: NavigationObjectBase;
	NavListEnd: NavigationObjectBase;
	NavDataChunks: NavigationDataChunk[];
	LightmapTotalSize: number;
	ShadowmapTotalSize: number;
	StaticNavigableGeometry: Vector[];
	StreamingTextureGuids: Guid[];
	StreamingTextures: string[];
	PackedTextureStreamingQualityLevelFeatureLevel: any;
	LevelBuildDataId: Guid;
	MapBuildData: MapBuildDataRegistry;
	LightBuildLevelOffset: IntVector;
	bIsLightingScenario: boolean;
	bTextureStreamingRotationChanged: boolean;
	bStaticComponentsRegisteredInStreamingManager: boolean;
	bIsVisible: boolean;
	bLocked: boolean;
	bIsPartitioned: boolean;
	bIsWorldPartitionRuntimeCell: boolean;
	LevelSimplification: LevelSimplificationDetails;
	LevelColor: LinearColor;
	bPromptWhenAddingToLevelBeforeCheckout: boolean;
	bPromptWhenAddingToLevelOutsideBounds: boolean;
	ActorPackagingScheme: EActorPackagingScheme;
	WorldSettings: WorldSettings;
	WorldDataLayers: WorldDataLayers;
	AssetUserData: AssetUserData[];
	DestroyedReplicatedStaticActors: ReplicatedStaticActorDestructionInfo[];
	LevelPartition: any;
	OwnerLevelPartition: UObject;
	bUseActorFolders: boolean;
	ActorFolders: any;
	LoadedExternalActorFolders: ActorFolder[];
	static Load(ResourceName: string): Level;
	static Find(Outer: UObject, ResourceName: string): Level;
	static GetDefaultObject(): Level;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Level;
	static C(Other: UObject | any): Level;
	UpdateModelComponents(): void;
	static UpdateModelComponents(Level: Level): void;
}

declare class LineBatchComponent extends PrimitiveComponent { 
	static Load(ResourceName: string): LineBatchComponent;
	static Find(Outer: UObject, ResourceName: string): LineBatchComponent;
	static GetDefaultObject(): LineBatchComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LineBatchComponent;
	static C(Other: UObject | any): LineBatchComponent;
}

declare type EStreamingVolumeUsage = 'SVB_Loading' | 'SVB_LoadingAndVisibility' | 'SVB_VisibilityBlockingOnLoad' | 'SVB_BlockingOnLoad' | 'SVB_LoadingNotVisible' | 'SVB_MAX';
declare var EStreamingVolumeUsage : { SVB_Loading:'SVB_Loading',SVB_LoadingAndVisibility:'SVB_LoadingAndVisibility',SVB_VisibilityBlockingOnLoad:'SVB_VisibilityBlockingOnLoad',SVB_BlockingOnLoad:'SVB_BlockingOnLoad',SVB_LoadingNotVisible:'SVB_LoadingNotVisible',SVB_MAX:'SVB_MAX', };
declare class LevelStreamingVolume extends Volume { 
	StreamingLevelNames: string[];
	bEditorPreVisOnly: boolean;
	bDisabled: boolean;
	StreamingUsage: EStreamingVolumeUsage;
	static GetDefaultObject(): LevelStreamingVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingVolume;
	static C(Other: UObject | any): LevelStreamingVolume;
}

declare class LevelStreaming extends UObject { 
	PackageName: string;
	WorldAsset: World;
	StreamingPriority: number;
	PackageNameToLoad: string;
	LODPackageNames: string[];
	LevelTransform: Transform;
	bClientOnlyVisible: boolean;
	LevelLODIndex: number;
	bShouldBeVisibleInEditor: boolean;
	bShouldBeVisible: boolean;
	bShouldBeLoaded: boolean;
	bLocked: boolean;
	bIsStatic: boolean;
	bShouldBlockOnLoad: boolean;
	bShouldBlockOnUnload: boolean;
	bDisableDistanceStreaming: boolean;
	bDrawOnLevelStatusMap: boolean;
	DrawColor: Color;
	LevelColor: LinearColor;
	EditorStreamingVolumes: LevelStreamingVolume[];
	MinTimeBetweenVolumeUnloadRequests: number;
	Keywords: string[];
	OnLevelLoaded: UnrealEngineMulticastDelegate<() => void>;
	OnLevelUnloaded: UnrealEngineMulticastDelegate<() => void>;
	OnLevelShown: UnrealEngineMulticastDelegate<() => void>;
	OnLevelHidden: UnrealEngineMulticastDelegate<() => void>;
	LoadedLevel: Level;
	PendingUnloadLevel: Level;
	FolderPath: string;
	static Load(ResourceName: string): LevelStreaming;
	static Find(Outer: UObject, ResourceName: string): LevelStreaming;
	static GetDefaultObject(): LevelStreaming;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreaming;
	ShouldBeLoaded(): boolean;
	SetShouldBeVisible(bInShouldBeVisible: boolean): void;
	SetShouldBeLoaded(bInShouldBeLoaded: boolean): void;
	SetPriority(NewPriority: number): void;
	SetLevelLODIndex(LODIndex: number): void;
	SetIsRequestingUnloadAndRemoval(bInIsRequestingUnloadAndRemoval: boolean): void;
	IsStreamingStatePending(): boolean;
	IsLevelVisible(): boolean;
	IsLevelLoaded(): boolean;
	GetWorldAssetPackageFName(): string;
	GetLoadedLevel(): Level;
	GetLevelScriptActor(): LevelScriptActor;
	GetIsRequestingUnloadAndRemoval(): boolean;
	CreateInstance(UniqueInstanceName: string): LevelStreaming;
	static C(Other: UObject | any): LevelStreaming;
}

declare class StreamingLevelsToConsider { 
	StreamingLevels: LevelStreaming[];
	clone() : StreamingLevelsToConsider;
	static C(Other: UObject | any): StreamingLevelsToConsider;
}

declare class MulticastRecordOptions { 
	FuncPathName: string;
	bServerSkip: boolean;
	bClientSkip: boolean;
	clone() : MulticastRecordOptions;
	static C(Other: UObject | any): MulticastRecordOptions;
}

declare class DemoNetDriver extends NetDriver { 
	RollbackNetStartupActors: any;
	CheckpointSaveMaxMSPerFrame: number;
	MulticastRecordOptions: MulticastRecordOptions[];
	SpectatorControllers: PlayerController[];
	static Load(ResourceName: string): DemoNetDriver;
	static Find(Outer: UObject, ResourceName: string): DemoNetDriver;
	static GetDefaultObject(): DemoNetDriver;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DemoNetDriver;
	static C(Other: UObject | any): DemoNetDriver;
}

declare class ParticleEventManager extends Actor { 
	static GetDefaultObject(): ParticleEventManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleEventManager;
	static C(Other: UObject | any): ParticleEventManager;
}

declare class NavigationSystemBase extends UObject { 
	static Load(ResourceName: string): NavigationSystemBase;
	static Find(Outer: UObject, ResourceName: string): NavigationSystemBase;
	static GetDefaultObject(): NavigationSystemBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationSystemBase;
	static C(Other: UObject | any): NavigationSystemBase;
}

declare class AISystemBase extends UObject { 
	AISystemClassName: SoftClassPath;
	AISystemModuleName: string;
	bInstantiateAISystemOnClient: boolean;
	static Load(ResourceName: string): AISystemBase;
	static Find(Outer: UObject, ResourceName: string): AISystemBase;
	static GetDefaultObject(): AISystemBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISystemBase;
	static C(Other: UObject | any): AISystemBase;
}

declare class AvoidanceManager extends UObject { 
	DefaultTimeToLive: number;
	LockTimeAfterAvoid: number;
	LockTimeAfterClean: number;
	DeltaTimeToPredict: number;
	ArtificialRadiusExpansion: number;
	TestHeightDifference: number;
	HeightCheckMargin: number;
	static Load(ResourceName: string): AvoidanceManager;
	static Find(Outer: UObject, ResourceName: string): AvoidanceManager;
	static GetDefaultObject(): AvoidanceManager;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AvoidanceManager;
	RegisterMovementComponent(MovementComp: MovementComponent,AvoidanceWeight: number): boolean;
	GetObjectCount(): number;
	GetNewAvoidanceUID(): number;
	GetAvoidanceVelocityForComponent(MovementComp: MovementComponent): Vector;
	static C(Other: UObject | any): AvoidanceManager;
}

declare class LevelCollection { 
	GameState: GameStateBase;
	NetDriver: NetDriver;
	DemoNetDriver: DemoNetDriver;
	PersistentLevel: Level;
	Levels: any;
	clone() : LevelCollection;
	static C(Other: UObject | any): LevelCollection;
}

declare class CollectionParameterBase { 
	ParameterName: string;
	ID: Guid;
	clone() : CollectionParameterBase;
	static C(Other: UObject | any): CollectionParameterBase;
}

declare class CollectionScalarParameter extends CollectionParameterBase { 
	DefaultValue: number;
	clone() : CollectionScalarParameter;
	static C(Other: UObject | any): CollectionScalarParameter;
}

declare class CollectionVectorParameter extends CollectionParameterBase { 
	DefaultValue: LinearColor;
	clone() : CollectionVectorParameter;
	static C(Other: UObject | any): CollectionVectorParameter;
}

declare class MaterialParameterCollection extends UObject { 
	StateId: Guid;
	ScalarParameters: CollectionScalarParameter[];
	VectorParameters: CollectionVectorParameter[];
	static Load(ResourceName: string): MaterialParameterCollection;
	static Find(Outer: UObject, ResourceName: string): MaterialParameterCollection;
	static GetDefaultObject(): MaterialParameterCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialParameterCollection;
	GetVectorParameterNames(): string[];
	GetVectorParameterDefaultValue(ParameterName: string,bParameterFound?: boolean): {bParameterFound: boolean, $: LinearColor};
	GetScalarParameterNames(): string[];
	GetScalarParameterDefaultValue(ParameterName: string,bParameterFound?: boolean): {bParameterFound: boolean, $: number};
	static C(Other: UObject | any): MaterialParameterCollection;
}

declare class MaterialParameterCollectionInstance extends UObject { 
	Collection: MaterialParameterCollection;
	static Load(ResourceName: string): MaterialParameterCollectionInstance;
	static Find(Outer: UObject, ResourceName: string): MaterialParameterCollectionInstance;
	static GetDefaultObject(): MaterialParameterCollectionInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialParameterCollectionInstance;
	static C(Other: UObject | any): MaterialParameterCollectionInstance;
}

declare class LevelViewportInfo { 
	CamPosition: Vector;
	CamRotation: Rotator;
	CamOrthoZoom: number;
	CamUpdated: boolean;
	clone() : LevelViewportInfo;
	static C(Other: UObject | any): LevelViewportInfo;
}

declare class PhysicsFieldComponent extends SceneComponent { 
	static Load(ResourceName: string): PhysicsFieldComponent;
	static Find(Outer: UObject, ResourceName: string): PhysicsFieldComponent;
	static GetDefaultObject(): PhysicsFieldComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsFieldComponent;
	static C(Other: UObject | any): PhysicsFieldComponent;
}

declare class WorldComposition extends UObject { 
	TilesStreaming: LevelStreaming[];
	TilesStreamingTimeThreshold: any;
	bLoadAllTilesDuringCinematic: boolean;
	bRebaseOriginIn3DSpace: boolean;
	bLockTilesLocation: boolean;
	RebaseOriginDistance: number;
	static Load(ResourceName: string): WorldComposition;
	static Find(Outer: UObject, ResourceName: string): WorldComposition;
	static GetDefaultObject(): WorldComposition;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldComposition;
	static C(Other: UObject | any): WorldComposition;
}

declare class WorldPSCPool { 
	WorldParticleSystemPools: any;
	clone() : WorldPSCPool;
	static C(Other: UObject | any): WorldPSCPool;
}

declare class AudioInputDeviceInfo { 
	DeviceName: string;
	DeviceID: string;
	InputChannels: number;
	PreferredSampleRate: number;
	bSupportsHardwareAEC: boolean;
	clone() : AudioInputDeviceInfo;
	static C(Other: UObject | any): AudioInputDeviceInfo;
	Conv_AudioInputDeviceInfoToString(): string;
	static Conv_AudioInputDeviceInfoToString(Info: AudioInputDeviceInfo): string;
}

declare class ActorLayer { 
	Name: string;
	clone() : ActorLayer;
	static C(Other: UObject | any): ActorLayer;
}

declare class LevelSequenceObjectReferenceMap { 
	clone() : LevelSequenceObjectReferenceMap;
	static C(Other: UObject | any): LevelSequenceObjectReferenceMap;
}

declare class LevelSequenceBindingReferences { 
	BindingIdToReferences: any;
	AnimSequenceInstances: any;
	clone() : LevelSequenceBindingReferences;
	static C(Other: UObject | any): LevelSequenceBindingReferences;
}

declare class LevelSequence extends MovieSceneSequence { 
	MovieScene: MovieScene;
	ObjectReferences: LevelSequenceObjectReferenceMap;
	BindingReferences: LevelSequenceBindingReferences;
	PossessedObjects: any;
	DirectorBlueprint: Blueprint;
	DirectorClass: UnrealEngineClass;
	MetaDataObjects: UObject[];
	AssetUserData: AssetUserData[];
	static Load(ResourceName: string): LevelSequence;
	static Find(Outer: UObject, ResourceName: string): LevelSequence;
	static GetDefaultObject(): LevelSequence;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelSequence;
	RemoveMetaDataByClass(InClass: UnrealEngineClass): void;
	FindOrAddMetaDataByClass(InClass: UnrealEngineClass): UObject;
	FindMetaDataByClass(InClass: UnrealEngineClass): UObject;
	CopyMetaData(InMetaData: UObject): UObject;
	static C(Other: UObject | any): LevelSequence;
}

declare class AnimSeqExportOption extends UObject { 
	bExportTransforms: boolean;
	bExportMorphTargets: boolean;
	bExportAttributeCurves: boolean;
	bExportMaterialCurves: boolean;
	bRecordInWorldSpace: boolean;
	bEvaluateAllSkeletalMeshComponents: boolean;
	WarmUpFrames: FrameNumber;
	DelayBeforeStart: FrameNumber;
	static Load(ResourceName: string): AnimSeqExportOption;
	static Find(Outer: UObject, ResourceName: string): AnimSeqExportOption;
	static GetDefaultObject(): AnimSeqExportOption;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSeqExportOption;
	static C(Other: UObject | any): AnimSeqExportOption;
}

declare type EFbxExportCompatibility = 'FBX_2011' | 'FBX_2012' | 'FBX_2013' | 'FBX_2014' | 'FBX_2016' | 'FBX_2018' | 'FBX_2019' | 'FBX_2020' | 'FBX_MAX';
declare var EFbxExportCompatibility : { FBX_2011:'FBX_2011',FBX_2012:'FBX_2012',FBX_2013:'FBX_2013',FBX_2014:'FBX_2014',FBX_2016:'FBX_2016',FBX_2018:'FBX_2018',FBX_2019:'FBX_2019',FBX_2020:'FBX_2020',FBX_MAX:'FBX_MAX', };
declare class FbxExportOption extends UObject { 
	FbxExportCompatibility: EFbxExportCompatibility;
	bASCII: boolean;
	bForceFrontXAxis: boolean;
	VertexColor: boolean;
	LevelOfDetail: boolean;
	Collision: boolean;
	bExportMorphTargets: boolean;
	bExportPreviewMesh: boolean;
	MapSkeletalMotionToRoot: boolean;
	bExportLocalTime: boolean;
	static Load(ResourceName: string): FbxExportOption;
	static Find(Outer: UObject, ResourceName: string): FbxExportOption;
	static GetDefaultObject(): FbxExportOption;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FbxExportOption;
	static C(Other: UObject | any): FbxExportOption;
}

declare class SequencerBoundObjects { 
	BindingProxy: SequencerBindingProxy;
	BoundObjects: UObject[];
	clone() : SequencerBoundObjects;
	static C(Other: UObject | any): SequencerBoundObjects;
}

declare class ControlFindReplaceString { 
	Find: string;
	Replace: string;
	clone() : ControlFindReplaceString;
	static C(Other: UObject | any): ControlFindReplaceString;
}

declare type FControlRigChannelEnum = 'Bool' | 'Enum' | 'Integer' | 'Float' | 'Vector2DX' | 'Vector2DY' | 'PositionX' | 'PositionY' | 'PositionZ' | 'RotatorX' | 'RotatorY' | 'RotatorZ' | 'ScaleX' | 'ScaleY' | 'ScaleZ' | 'FControlRigChannelEnum_MAX';
declare var FControlRigChannelEnum : { Bool:'Bool',Enum:'Enum',Integer:'Integer',Float:'Float',Vector2DX:'Vector2DX',Vector2DY:'Vector2DY',PositionX:'PositionX',PositionY:'PositionY',PositionZ:'PositionZ',RotatorX:'RotatorX',RotatorY:'RotatorY',RotatorZ:'RotatorZ',ScaleX:'ScaleX',ScaleY:'ScaleY',ScaleZ:'ScaleZ',FControlRigChannelEnum_MAX:'FControlRigChannelEnum_MAX', };
declare type FTransformChannelEnum = 'TranslateX' | 'TranslateY' | 'TranslateZ' | 'RotateX' | 'RotateY' | 'RotateZ' | 'ScaleX' | 'ScaleY' | 'ScaleZ' | 'FTransformChannelEnum_MAX';
declare var FTransformChannelEnum : { TranslateX:'TranslateX',TranslateY:'TranslateY',TranslateZ:'TranslateZ',RotateX:'RotateX',RotateY:'RotateY',RotateZ:'RotateZ',ScaleX:'ScaleX',ScaleY:'ScaleY',ScaleZ:'ScaleZ',FTransformChannelEnum_MAX:'FTransformChannelEnum_MAX', };
declare class ControlToTransformMappings { 
	ControlChannel: FControlRigChannelEnum;
	FBXChannel: FTransformChannelEnum;
	bNegate: boolean;
	clone() : ControlToTransformMappings;
	static C(Other: UObject | any): ControlToTransformMappings;
}

declare class MovieSceneUserImportFBXControlRigSettings extends UObject { 
	ImportedFileName: string;
	ImportedStartTime: FrameNumber;
	ImportedEndTime: FrameNumber;
	ImportedNodeNames: string[];
	ImportedFrameRate: string;
	FindAndReplaceStrings: ControlFindReplaceString[];
	bForceFrontXAxis: boolean;
	bConvertSceneUnit: boolean;
	ImportUniformScale: number;
	bImportOntoSelectedControls: boolean;
	TimeToInsertOrReplaceAnimation: FrameNumber;
	bInsertAnimation: boolean;
	bSpecifyTimeRange: boolean;
	StartTimeRange: FrameNumber;
	EndTimeRange: FrameNumber;
	ControlChannelMappings: ControlToTransformMappings[];
	static Load(ResourceName: string): MovieSceneUserImportFBXControlRigSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneUserImportFBXControlRigSettings;
	static GetDefaultObject(): MovieSceneUserImportFBXControlRigSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneUserImportFBXControlRigSettings;
	static C(Other: UObject | any): MovieSceneUserImportFBXControlRigSettings;
}

declare class MovieSceneUserImportFBXSettings extends UObject { 
	bMatchByNameOnly: boolean;
	bForceFrontXAxis: boolean;
	bConvertSceneUnit: boolean;
	ImportUniformScale: number;
	bCreateCameras: boolean;
	bReplaceTransformTrack: boolean;
	bReduceKeys: boolean;
	ReduceKeysTolerance: number;
	static Load(ResourceName: string): MovieSceneUserImportFBXSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneUserImportFBXSettings;
	static GetDefaultObject(): MovieSceneUserImportFBXSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneUserImportFBXSettings;
	static C(Other: UObject | any): MovieSceneUserImportFBXSettings;
}

declare class EMSCustomSaveGame extends SaveGame { 
	SaveGameName: string;
	bUseSaveSlot: boolean;
	static Load(ResourceName: string): EMSCustomSaveGame;
	static Find(Outer: UObject, ResourceName: string): EMSCustomSaveGame;
	static GetDefaultObject(): EMSCustomSaveGame;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EMSCustomSaveGame;
	static C(Other: UObject | any): EMSCustomSaveGame;
}

declare class TextureRenderTarget extends Texture { 
	TargetGamma: number;
	static Load(ResourceName: string): TextureRenderTarget;
	static Find(Outer: UObject, ResourceName: string): TextureRenderTarget;
	static GetDefaultObject(): TextureRenderTarget;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureRenderTarget;
	static C(Other: UObject | any): TextureRenderTarget;
}

declare type ETextureRenderTargetFormat = 'RTF_R8' | 'RTF_RG8' | 'RTF_RGBA8' | 'RTF_RGBA8_SRGB' | 'RTF_R16f' | 'RTF_RG16f' | 'RTF_RGBA16f' | 'RTF_R32f' | 'RTF_RG32f' | 'RTF_RGBA32f' | 'RTF_RGB10A2' | 'RTF_MAX';
declare var ETextureRenderTargetFormat : { RTF_R8:'RTF_R8',RTF_RG8:'RTF_RG8',RTF_RGBA8:'RTF_RGBA8',RTF_RGBA8_SRGB:'RTF_RGBA8_SRGB',RTF_R16f:'RTF_R16f',RTF_RG16f:'RTF_RG16f',RTF_RGBA16f:'RTF_RGBA16f',RTF_R32f:'RTF_R32f',RTF_RG32f:'RTF_RG32f',RTF_RGBA32f:'RTF_RGBA32f',RTF_RGB10A2:'RTF_RGB10A2',RTF_MAX:'RTF_MAX', };
declare type EPixelFormat = 'PF_Unknown' | 'PF_A32B32G32R32F' | 'PF_B8G8R8A8' | 'PF_G8' | 'PF_G16' | 'PF_DXT1' | 'PF_DXT3' | 'PF_DXT5' | 'PF_UYVY' | 'PF_FloatRGB' | 'PF_FloatRGBA' | 'PF_DepthStencil' | 'PF_ShadowDepth' | 'PF_R32_FLOAT' | 'PF_G16R16' | 'PF_G16R16F' | 'PF_G16R16F_FILTER' | 'PF_G32R32F' | 'PF_A2B10G10R10' | 'PF_A16B16G16R16' | 'PF_D24' | 'PF_R16F' | 'PF_R16F_FILTER' | 'PF_BC5' | 'PF_V8U8' | 'PF_A1' | 'PF_FloatR11G11B10' | 'PF_A8' | 'PF_R32_UINT' | 'PF_R32_SINT' | 'PF_PVRTC2' | 'PF_PVRTC4' | 'PF_R16_UINT' | 'PF_R16_SINT' | 'PF_R16G16B16A16_UINT' | 'PF_R16G16B16A16_SINT' | 'PF_R5G6B5_UNORM' | 'PF_R8G8B8A8' | 'PF_A8R8G8B8' | 'PF_BC4' | 'PF_R8G8' | 'PF_ATC_RGB' | 'PF_ATC_RGBA_E' | 'PF_ATC_RGBA_I' | 'PF_X24_G8' | 'PF_ETC1' | 'PF_ETC2_RGB' | 'PF_ETC2_RGBA' | 'PF_R32G32B32A32_UINT' | 'PF_R16G16_UINT' | 'PF_ASTC_4x4' | 'PF_ASTC_6x6' | 'PF_ASTC_8x8' | 'PF_ASTC_10x10' | 'PF_ASTC_12x12' | 'PF_BC6H' | 'PF_BC7' | 'PF_R8_UINT' | 'PF_L8' | 'PF_XGXR8' | 'PF_R8G8B8A8_UINT' | 'PF_R8G8B8A8_SNORM' | 'PF_R16G16B16A16_UNORM' | 'PF_R16G16B16A16_SNORM' | 'PF_PLATFORM_HDR_0' | 'PF_PLATFORM_HDR_1' | 'PF_PLATFORM_HDR_2' | 'PF_NV12' | 'PF_R32G32_UINT' | 'PF_ETC2_R11_EAC' | 'PF_ETC2_RG11_EAC' | 'PF_R8' | 'PF_B5G5R5A1_UNORM' | 'PF_G16R16_SNORM' | 'PF_R8G8_UINT' | 'PF_R32G32B32_UINT' | 'PF_R32G32B32_SINT' | 'PF_R32G32B32F' | 'PF_R8_SINT' | 'PF_R64_UINT' | 'PF_MAX';
declare var EPixelFormat : { PF_Unknown:'PF_Unknown',PF_A32B32G32R32F:'PF_A32B32G32R32F',PF_B8G8R8A8:'PF_B8G8R8A8',PF_G8:'PF_G8',PF_G16:'PF_G16',PF_DXT1:'PF_DXT1',PF_DXT3:'PF_DXT3',PF_DXT5:'PF_DXT5',PF_UYVY:'PF_UYVY',PF_FloatRGB:'PF_FloatRGB',PF_FloatRGBA:'PF_FloatRGBA',PF_DepthStencil:'PF_DepthStencil',PF_ShadowDepth:'PF_ShadowDepth',PF_R32_FLOAT:'PF_R32_FLOAT',PF_G16R16:'PF_G16R16',PF_G16R16F:'PF_G16R16F',PF_G16R16F_FILTER:'PF_G16R16F_FILTER',PF_G32R32F:'PF_G32R32F',PF_A2B10G10R10:'PF_A2B10G10R10',PF_A16B16G16R16:'PF_A16B16G16R16',PF_D24:'PF_D24',PF_R16F:'PF_R16F',PF_R16F_FILTER:'PF_R16F_FILTER',PF_BC5:'PF_BC5',PF_V8U8:'PF_V8U8',PF_A1:'PF_A1',PF_FloatR11G11B10:'PF_FloatR11G11B10',PF_A8:'PF_A8',PF_R32_UINT:'PF_R32_UINT',PF_R32_SINT:'PF_R32_SINT',PF_PVRTC2:'PF_PVRTC2',PF_PVRTC4:'PF_PVRTC4',PF_R16_UINT:'PF_R16_UINT',PF_R16_SINT:'PF_R16_SINT',PF_R16G16B16A16_UINT:'PF_R16G16B16A16_UINT',PF_R16G16B16A16_SINT:'PF_R16G16B16A16_SINT',PF_R5G6B5_UNORM:'PF_R5G6B5_UNORM',PF_R8G8B8A8:'PF_R8G8B8A8',PF_A8R8G8B8:'PF_A8R8G8B8',PF_BC4:'PF_BC4',PF_R8G8:'PF_R8G8',PF_ATC_RGB:'PF_ATC_RGB',PF_ATC_RGBA_E:'PF_ATC_RGBA_E',PF_ATC_RGBA_I:'PF_ATC_RGBA_I',PF_X24_G8:'PF_X24_G8',PF_ETC1:'PF_ETC1',PF_ETC2_RGB:'PF_ETC2_RGB',PF_ETC2_RGBA:'PF_ETC2_RGBA',PF_R32G32B32A32_UINT:'PF_R32G32B32A32_UINT',PF_R16G16_UINT:'PF_R16G16_UINT',PF_ASTC_4x4:'PF_ASTC_4x4',PF_ASTC_6x6:'PF_ASTC_6x6',PF_ASTC_8x8:'PF_ASTC_8x8',PF_ASTC_10x10:'PF_ASTC_10x10',PF_ASTC_12x12:'PF_ASTC_12x12',PF_BC6H:'PF_BC6H',PF_BC7:'PF_BC7',PF_R8_UINT:'PF_R8_UINT',PF_L8:'PF_L8',PF_XGXR8:'PF_XGXR8',PF_R8G8B8A8_UINT:'PF_R8G8B8A8_UINT',PF_R8G8B8A8_SNORM:'PF_R8G8B8A8_SNORM',PF_R16G16B16A16_UNORM:'PF_R16G16B16A16_UNORM',PF_R16G16B16A16_SNORM:'PF_R16G16B16A16_SNORM',PF_PLATFORM_HDR_0:'PF_PLATFORM_HDR_0',PF_PLATFORM_HDR_1:'PF_PLATFORM_HDR_1',PF_PLATFORM_HDR_2:'PF_PLATFORM_HDR_2',PF_NV12:'PF_NV12',PF_R32G32_UINT:'PF_R32G32_UINT',PF_ETC2_R11_EAC:'PF_ETC2_R11_EAC',PF_ETC2_RG11_EAC:'PF_ETC2_RG11_EAC',PF_R8:'PF_R8',PF_B5G5R5A1_UNORM:'PF_B5G5R5A1_UNORM',PF_G16R16_SNORM:'PF_G16R16_SNORM',PF_R8G8_UINT:'PF_R8G8_UINT',PF_R32G32B32_UINT:'PF_R32G32B32_UINT',PF_R32G32B32_SINT:'PF_R32G32B32_SINT',PF_R32G32B32F:'PF_R32G32B32F',PF_R8_SINT:'PF_R8_SINT',PF_R64_UINT:'PF_R64_UINT',PF_MAX:'PF_MAX', };
declare class TextureRenderTarget2D extends TextureRenderTarget { 
	SizeX: number;
	SizeY: number;
	ClearColor: LinearColor;
	AddressX: TextureAddress;
	AddressY: TextureAddress;
	bForceLinearGamma: boolean;
	bHDR: boolean;
	bGPUSharedFlag: boolean;
	RenderTargetFormat: ETextureRenderTargetFormat;
	bAutoGenerateMips: boolean;
	MipsSamplerFilter: TextureFilter;
	MipsAddressU: TextureAddress;
	MipsAddressV: TextureAddress;
	OverrideFormat: EPixelFormat;
	static Load(ResourceName: string): TextureRenderTarget2D;
	static Find(Outer: UObject, ResourceName: string): TextureRenderTarget2D;
	static GetDefaultObject(): TextureRenderTarget2D;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureRenderTarget2D;
	static C(Other: UObject | any): TextureRenderTarget2D;
	RenderTarget_SampleRectangle_EditorOnly(InRect: LinearColor): LinearColor[];
	RenderTarget_SampleUV_EditorOnly(UV: Vector2D): LinearColor;
	ReleaseRenderTarget2D(): void;
	RenderTargetCreateStaticTexture2DEditorOnly(Name: string,CompressionSettings: TextureCompressionSettings,MipSettings: TextureMipGenSettings): Texture2D;
	static RenderTarget_SampleRectangle_EditorOnly(InRenderTarget: TextureRenderTarget2D,InRect: LinearColor): LinearColor[];
	static RenderTarget_SampleUV_EditorOnly(InRenderTarget: TextureRenderTarget2D,UV: Vector2D): LinearColor;
	static ReleaseRenderTarget2D(TextureRenderTarget: TextureRenderTarget2D): void;
	static RenderTargetCreateStaticTexture2DEditorOnly(RenderTarget: TextureRenderTarget2D,Name: string,CompressionSettings: TextureCompressionSettings,MipSettings: TextureMipGenSettings): Texture2D;
}

declare class SaveSlotInfo { 
	Name: string;
	Timestamp: DateTime;
	Level: string;
	Players: string[];
	clone() : SaveSlotInfo;
	static C(Other: UObject | any): SaveSlotInfo;
}

declare class EMSInfoSaveGame extends SaveGame { 
	SlotInfo: SaveSlotInfo;
	static Load(ResourceName: string): EMSInfoSaveGame;
	static Find(Outer: UObject, ResourceName: string): EMSInfoSaveGame;
	static GetDefaultObject(): EMSInfoSaveGame;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EMSInfoSaveGame;
	static C(Other: UObject | any): EMSInfoSaveGame;
}

declare class URL { 
	Protocol: string;
	Host: string;
	Port: number;
	Valid: number;
	Map: string;
	RedirectURL: string;
	Op: string[];
	Portal: string;
	clone() : URL;
	static C(Other: UObject | any): URL;
}

declare class NavDataConfig extends NavAgentProperties { 
	Name: string;
	Color: Color;
	DefaultQueryExtent: Vector;
	NavigationDataClass: UnrealEngineClass;
	NavDataClass: Class;
	clone() : NavDataConfig;
	static C(Other: UObject | any): NavDataConfig;
}

declare type ERuntimeGenerationType = 'Static' | 'DynamicModifiersOnly' | 'Dynamic' | 'LegacyGeneration' | 'ERuntimeGenerationType_MAX';
declare var ERuntimeGenerationType : { Static:'Static',DynamicModifiersOnly:'DynamicModifiersOnly',Dynamic:'Dynamic',LegacyGeneration:'LegacyGeneration',ERuntimeGenerationType_MAX:'ERuntimeGenerationType_MAX', };
declare class SupportedAreaData { 
	AreaClassName: string;
	AreaID: number;
	AreaClass: UnrealEngineClass;
	clone() : SupportedAreaData;
	static C(Other: UObject | any): SupportedAreaData;
}

declare class NavigationData extends Actor { 
	RenderingComp: PrimitiveComponent;
	NavDataConfig: NavDataConfig;
	bEnableDrawing: boolean;
	bForceRebuildOnLoad: boolean;
	bAutoDestroyWhenNoNavigation: boolean;
	bCanBeMainNavData: boolean;
	bCanSpawnOnRebuild: boolean;
	bRebuildAtRuntime: boolean;
	RuntimeGeneration: ERuntimeGenerationType;
	ObservedPathsTickInterval: number;
	DataVersion: any;
	SupportedAreas: SupportedAreaData[];
	static GetDefaultObject(): NavigationData;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationData;
	static C(Other: UObject | any): NavigationData;
}

declare class RecastNavMeshTileGenerationDebug { 
	bEnabled: boolean;
	TileCoordinate: IntVector;
	bHeightfieldSolidFromRasterization: boolean;
	bHeightfieldSolidPostRadiusFiltering: boolean;
	bHeightfieldSolidPostHeightFiltering: boolean;
	bCompactHeightfield: boolean;
	bCompactHeightfieldEroded: boolean;
	bCompactHeightfieldRegions: boolean;
	bCompactHeightfieldDistances: boolean;
	bTileCacheLayerAreas: boolean;
	bTileCacheLayerRegions: boolean;
	bTileCacheContours: boolean;
	bTileCachePolyMesh: boolean;
	bTileCacheDetailMesh: boolean;
	clone() : RecastNavMeshTileGenerationDebug;
	static C(Other: UObject | any): RecastNavMeshTileGenerationDebug;
}

declare type ERecastPartitioning = 'Monotone' | 'Watershed' | 'ChunkyMonotone' | 'ERecastPartitioning_MAX';
declare var ERecastPartitioning : { Monotone:'Monotone',Watershed:'Watershed',ChunkyMonotone:'ChunkyMonotone',ERecastPartitioning_MAX:'ERecastPartitioning_MAX', };
declare class NavArea extends NavAreaBase { 
	DefaultCost: number;
	FixedAreaEnteringCost: number;
	DrawColor: Color;
	SupportedAgents: NavAgentSelector;
	bSupportsAgent0: boolean;
	bSupportsAgent1: boolean;
	bSupportsAgent2: boolean;
	bSupportsAgent3: boolean;
	bSupportsAgent4: boolean;
	bSupportsAgent5: boolean;
	bSupportsAgent6: boolean;
	bSupportsAgent7: boolean;
	bSupportsAgent8: boolean;
	bSupportsAgent9: boolean;
	bSupportsAgent10: boolean;
	bSupportsAgent11: boolean;
	bSupportsAgent12: boolean;
	bSupportsAgent13: boolean;
	bSupportsAgent14: boolean;
	bSupportsAgent15: boolean;
	static Load(ResourceName: string): NavArea;
	static Find(Outer: UObject, ResourceName: string): NavArea;
	static GetDefaultObject(): NavArea;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea;
	static C(Other: UObject | any): NavArea;
}

declare class RecastNavMesh extends NavigationData { 
	bDrawTriangleEdges: boolean;
	bDrawPolyEdges: boolean;
	bDrawFilledPolys: boolean;
	bDrawNavMeshEdges: boolean;
	bDrawTileBounds: boolean;
	bDrawPathCollidingGeometry: boolean;
	bDrawTileLabels: boolean;
	bDrawPolygonLabels: boolean;
	bDrawDefaultPolygonCost: boolean;
	bDrawPolygonFlags: boolean;
	bDrawLabelsOnPathNodes: boolean;
	bDrawNavLinks: boolean;
	bDrawFailedNavLinks: boolean;
	bDrawClusters: boolean;
	bDrawOctree: boolean;
	bDrawOctreeDetails: boolean;
	bDrawMarkedForbiddenPolys: boolean;
	bDistinctlyDrawTilesBeingBuilt: boolean;
	DrawOffset: number;
	TileGenerationDebug: RecastNavMeshTileGenerationDebug;
	bFixedTilePoolSize: boolean;
	TilePoolSize: number;
	TileSizeUU: number;
	CellSize: number;
	CellHeight: number;
	AgentRadius: number;
	AgentHeight: number;
	AgentMaxSlope: number;
	AgentMaxStepHeight: number;
	MinRegionArea: number;
	MergeRegionSize: number;
	MaxSimplificationError: number;
	MaxSimultaneousTileGenerationJobsCount: number;
	TileNumberHardLimit: number;
	PolyRefTileBits: number;
	PolyRefNavPolyBits: number;
	PolyRefSaltBits: number;
	NavMeshOriginOffset: Vector;
	DefaultDrawDistance: number;
	DefaultMaxSearchNodes: number;
	DefaultMaxHierarchicalSearchNodes: number;
	RegionPartitioning: ERecastPartitioning;
	LayerPartitioning: ERecastPartitioning;
	RegionChunkSplits: number;
	LayerChunkSplits: number;
	bSortNavigationAreasByCost: boolean;
	bIsWorldPartitioned: boolean;
	bPerformVoxelFiltering: boolean;
	bMarkLowHeightAreas: boolean;
	bUseExtraTopCellWhenMarkingAreas: boolean;
	bFilterLowSpanSequences: boolean;
	bFilterLowSpanFromTileCache: boolean;
	bDoFullyAsyncNavDataGathering: boolean;
	bUseBetterOffsetsFromCorners: boolean;
	bStoreEmptyTileLayers: boolean;
	bUseVirtualFilters: boolean;
	bUseVirtualGeometryFilteringAndDirtying: boolean;
	bAllowNavLinkAsPathEnd: boolean;
	bUseVoxelCache: boolean;
	TileSetUpdateInterval: number;
	HeuristicScale: number;
	VerticalDeviationFromGroundCompensation: number;
	static GetDefaultObject(): RecastNavMesh;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RecastNavMesh;
	K2_ReplaceAreaInTileBounds(Bounds: Box,OldArea: UnrealEngineClass,NewArea: UnrealEngineClass,ReplaceLinks: boolean): boolean;
	static C(Other: UObject | any): RecastNavMesh;
}

declare class TraceChannelTestBatchOptions { 
	bLineTrace: boolean;
	bSphereTrace: boolean;
	bCapsuleTrace: boolean;
	bBoxTrace: boolean;
	bChannelTrace: boolean;
	bObjectsTrace: boolean;
	bProfileTrace: boolean;
	clone() : TraceChannelTestBatchOptions;
	static C(Other: UObject | any): TraceChannelTestBatchOptions;
}

declare type EDrawDebugTrace = 'None' | 'ForOneFrame' | 'ForDuration' | 'Persistent' | 'EDrawDebugTrace_MAX';
declare var EDrawDebugTrace : { None:'None',ForOneFrame:'ForOneFrame',ForDuration:'ForDuration',Persistent:'Persistent',EDrawDebugTrace_MAX:'EDrawDebugTrace_MAX', };
declare class TraceQueryTestNames { 
	ComponentName: string;
	PhysicalMaterialName: string;
	ActorName: string;
	clone() : TraceQueryTestNames;
	static C(Other: UObject | any): TraceQueryTestNames;
}

declare class TraceQueryTestResultsInnerMost { 
	SingleHit: HitResult;
	SingleNames: TraceQueryTestNames;
	bSingleResult: boolean;
	MultiHits: HitResult[];
	MultiNames: TraceQueryTestNames[];
	bMultiResult: boolean;
	clone() : TraceQueryTestResultsInnerMost;
	static C(Other: UObject | any): TraceQueryTestResultsInnerMost;
}

declare class TraceQueryTestResultsInner { 
	LineResults: TraceQueryTestResultsInnerMost;
	SphereResults: TraceQueryTestResultsInnerMost;
	CapsuleResults: TraceQueryTestResultsInnerMost;
	BoxResults: TraceQueryTestResultsInnerMost;
	clone() : TraceQueryTestResultsInner;
	static C(Other: UObject | any): TraceQueryTestResultsInner;
}

declare class TraceQueryTestResults extends UObject { 
	ChannelResults: TraceQueryTestResultsInner;
	ObjectResults: TraceQueryTestResultsInner;
	ProfileResults: TraceQueryTestResultsInner;
	BatchOptions: TraceChannelTestBatchOptions;
	static Load(ResourceName: string): TraceQueryTestResults;
	static Find(Outer: UObject, ResourceName: string): TraceQueryTestResults;
	static GetDefaultObject(): TraceQueryTestResults;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TraceQueryTestResults;
	ToString(): string;
	static C(Other: UObject | any): TraceQueryTestResults;
}

declare class AutomationWaitForLoadingOptions { 
	WaitForReplicationToSettle: boolean;
	clone() : AutomationWaitForLoadingOptions;
	static C(Other: UObject | any): AutomationWaitForLoadingOptions;
}

declare class AutomationViewSettings extends DataAsset { 
	antialiasing: boolean;
	MotionBlur: boolean;
	TemporalAA: boolean;
	ScreenSpaceReflections: boolean;
	ScreenSpaceAO: boolean;
	DistanceFieldAO: boolean;
	ContactShadows: boolean;
	EyeAdaptation: boolean;
	Bloom: boolean;
	static Load(ResourceName: string): AutomationViewSettings;
	static Find(Outer: UObject, ResourceName: string): AutomationViewSettings;
	static GetDefaultObject(): AutomationViewSettings;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationViewSettings;
	static C(Other: UObject | any): AutomationViewSettings;
}

declare type EComparisonTolerance = 'Zero' | 'Low' | 'Medium' | 'High' | 'Custom' | 'EComparisonTolerance_MAX';
declare var EComparisonTolerance : { Zero:'Zero',Low:'Low',Medium:'Medium',High:'High',Custom:'Custom',EComparisonTolerance_MAX:'EComparisonTolerance_MAX', };
declare class ComparisonToleranceAmount { 
	red: number;
	green: number;
	blue: number;
	Alpha: number;
	MinBrightness: number;
	MaxBrightness: number;
	clone() : ComparisonToleranceAmount;
	static C(Other: UObject | any): ComparisonToleranceAmount;
}

declare class AutomationScreenshotOptions { 
	Resolution: Vector2D;
	Delay: number;
	bOverride_OverrideTimeTo: boolean;
	OverrideTimeTo: number;
	bDisableNoisyRenderingFeatures: boolean;
	bDisableTonemapping: boolean;
	ViewSettings: AutomationViewSettings;
	VisualizeBuffer: string;
	Tolerance: EComparisonTolerance;
	ToleranceAmount: ComparisonToleranceAmount;
	MaximumLocalError: number;
	MaximumGlobalError: number;
	bIgnoreAntiAliasing: boolean;
	bIgnoreColors: boolean;
	clone() : AutomationScreenshotOptions;
	static C(Other: UObject | any): AutomationScreenshotOptions;
	static GetDefaultScreenshotOptionsForGameplay(Tolerance: EComparisonTolerance,Delay: number): AutomationScreenshotOptions;
	static GetDefaultScreenshotOptionsForRendering(Tolerance: EComparisonTolerance,Delay: number): AutomationScreenshotOptions;
}

declare class NiagaraTypeDefinitionHandle { 
	RegisteredTypeIndex: number;
	clone() : NiagaraTypeDefinitionHandle;
	static C(Other: UObject | any): NiagaraTypeDefinitionHandle;
}

declare class Enum extends Field { 
	static Load(ResourceName: string): Enum;
	static Find(Outer: UObject, ResourceName: string): Enum;
	static GetDefaultObject(): Enum;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Enum;
	static C(Other: UObject | any): Enum;
	GetEnumeratorName(EnumeratorValue: number): string;
	GetEnumeratorUserFriendlyName(EnumeratorValue: number): string;
	GetEnumeratorValueFromIndex(EnumeratorIndex: number): number;
	GetValidValue(EnumeratorValue: number): number;
	static GetEnumeratorName(Enum: Enum,EnumeratorValue: number): string;
	static GetEnumeratorUserFriendlyName(Enum: Enum,EnumeratorValue: number): string;
	static GetEnumeratorValueFromIndex(Enum: Enum,EnumeratorIndex: number): number;
	static GetValidValue(Enum: Enum,EnumeratorValue: number): number;
}

declare class NiagaraTypeDefinition { 
	ClassStructOrEnum: UObject;
	UnderlyingType: any;
	Flags: number;
	struct: Struct;
	Enum: Enum;
	clone() : NiagaraTypeDefinition;
	static C(Other: UObject | any): NiagaraTypeDefinition;
}

declare class NiagaraVariableBase { 
	Name: string;
	TypeDefHandle: NiagaraTypeDefinitionHandle;
	TypeDef: NiagaraTypeDefinition;
	clone() : NiagaraVariableBase;
	static C(Other: UObject | any): NiagaraVariableBase;
}

declare class NiagaraVariable extends NiagaraVariableBase { 
	VarData: number[];
	clone() : NiagaraVariable;
	static C(Other: UObject | any): NiagaraVariable;
}

declare type ENiagaraStructConversionType = 'CopyOnly' | 'DoubleToFloat' | 'Vector2' | 'Vector3' | 'Vector4' | 'Quat' | 'ENiagaraStructConversionType_MAX';
declare var ENiagaraStructConversionType : { CopyOnly:'CopyOnly',DoubleToFloat:'DoubleToFloat',Vector2:'Vector2',Vector3:'Vector3',Vector4:'Vector4',Quat:'Quat',ENiagaraStructConversionType_MAX:'ENiagaraStructConversionType_MAX', };
declare class NiagaraStructConversionStep { 
	SourceBytes: number;
	SourceOffset: number;
	SimulationBytes: number;
	SimulationOffset: number;
	ConversionType: ENiagaraStructConversionType;
	clone() : NiagaraStructConversionStep;
	static C(Other: UObject | any): NiagaraStructConversionStep;
}

declare class NiagaraLwcStructConverter { 
	ConversionSteps: NiagaraStructConversionStep[];
	clone() : NiagaraLwcStructConverter;
	static C(Other: UObject | any): NiagaraLwcStructConverter;
}

declare class NiagaraVariableWithOffset extends NiagaraVariableBase { 
	Offset: number;
	StructConverter: NiagaraLwcStructConverter;
	clone() : NiagaraVariableWithOffset;
	static C(Other: UObject | any): NiagaraVariableWithOffset;
}

declare class NiagaraMergeable extends UObject { 
	MergeId: Guid;
	static Load(ResourceName: string): NiagaraMergeable;
	static Find(Outer: UObject, ResourceName: string): NiagaraMergeable;
	static GetDefaultObject(): NiagaraMergeable;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraMergeable;
	static C(Other: UObject | any): NiagaraMergeable;
}

declare class NiagaraDataInterfaceBase extends NiagaraMergeable { 
	static Load(ResourceName: string): NiagaraDataInterfaceBase;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterfaceBase;
	static GetDefaultObject(): NiagaraDataInterfaceBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterfaceBase;
	static C(Other: UObject | any): NiagaraDataInterfaceBase;
}

declare class NiagaraDataInterface extends NiagaraDataInterfaceBase { 
	static Load(ResourceName: string): NiagaraDataInterface;
	static Find(Outer: UObject, ResourceName: string): NiagaraDataInterface;
	static GetDefaultObject(): NiagaraDataInterface;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraDataInterface;
	static C(Other: UObject | any): NiagaraDataInterface;
}

declare class NiagaraPositionSource { 
	Name: string;
	Value: Vector;
	clone() : NiagaraPositionSource;
	static C(Other: UObject | any): NiagaraPositionSource;
}

declare class NiagaraParameterStore { 
	Owner: UObject;
	ParameterOffsets: any;
	SortedParameterOffsets: NiagaraVariableWithOffset[];
	ParameterData: number[];
	DataInterfaces: NiagaraDataInterface[];
	UObjects: UObject[];
	OriginalPositionData: NiagaraPositionSource[];
	DebugName: string;
	ParameterGuidMapping: any;
	clone() : NiagaraParameterStore;
	static C(Other: UObject | any): NiagaraParameterStore;
}

declare class NiagaraParameterCollectionInstance extends UObject { 
	Collection: NiagaraParameterCollection;
	OverridenParameters: NiagaraVariable[];
	ParameterStorage: NiagaraParameterStore;
	static Load(ResourceName: string): NiagaraParameterCollectionInstance;
	static Find(Outer: UObject, ResourceName: string): NiagaraParameterCollectionInstance;
	static GetDefaultObject(): NiagaraParameterCollectionInstance;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraParameterCollectionInstance;
	SetVectorParameter(InVariableName: string,InValue: Vector): void;
	SetVector4Parameter(InVariableName: string,InValue: Vector4): void;
	SetVector2DParameter(InVariableName: string,InValue: Vector2D): void;
	SetQuatParameter(InVariableName: string,InValue: Quat): void;
	SetIntParameter(InVariableName: string,InValue: number): void;
	SetFloatParameter(InVariableName: string,InValue: number): void;
	SetColorParameter(InVariableName: string,InValue: LinearColor): void;
	SetBoolParameter(InVariableName: string,InValue: boolean): void;
	GetVectorParameter(InVariableName: string): Vector;
	GetVector4Parameter(InVariableName: string): Vector4;
	GetVector2DParameter(InVariableName: string): Vector2D;
	GetQuatParameter(InVariableName: string): Quat;
	GetIntParameter(InVariableName: string): number;
	GetFloatParameter(InVariableName: string): number;
	GetColorParameter(InVariableName: string): LinearColor;
	GetBoolParameter(InVariableName: string): boolean;
	static C(Other: UObject | any): NiagaraParameterCollectionInstance;
}

declare class NiagaraParameterCollection extends UObject { 
	Namespace: string;
	Parameters: NiagaraVariable[];
	SourceMaterialCollection: MaterialParameterCollection;
	DefaultInstance: NiagaraParameterCollectionInstance;
	CompileId: Guid;
	static Load(ResourceName: string): NiagaraParameterCollection;
	static Find(Outer: UObject, ResourceName: string): NiagaraParameterCollection;
	static GetDefaultObject(): NiagaraParameterCollection;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraParameterCollection;
	static C(Other: UObject | any): NiagaraParameterCollection;
}

declare type ENiagaraScriptLibraryVisibility = 'Invalid' | 'Unexposed' | 'Library' | 'Hidden' | 'ENiagaraScriptLibraryVisibility_MAX';
declare var ENiagaraScriptLibraryVisibility : { Invalid:'Invalid',Unexposed:'Unexposed',Library:'Library',Hidden:'Hidden',ENiagaraScriptLibraryVisibility_MAX:'ENiagaraScriptLibraryVisibility_MAX', };
declare type ENiagaraScriptTemplateSpecification = 'None' | 'Template' | 'Behavior' | 'ENiagaraScriptTemplateSpecification_MAX';
declare var ENiagaraScriptTemplateSpecification : { None:'None',Template:'Template',Behavior:'Behavior',ENiagaraScriptTemplateSpecification_MAX:'ENiagaraScriptTemplateSpecification_MAX', };
declare class NiagaraScriptBase extends UObject { 
	static Load(ResourceName: string): NiagaraScriptBase;
	static Find(Outer: UObject, ResourceName: string): NiagaraScriptBase;
	static GetDefaultObject(): NiagaraScriptBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraScriptBase;
	static C(Other: UObject | any): NiagaraScriptBase;
}

declare type ENiagaraScriptUsage = 'Function' | 'Module' | 'DynamicInput' | 'ParticleSpawnScript' | 'ParticleSpawnScriptInterpolated' | 'ParticleUpdateScript' | 'ParticleEventScript' | 'ParticleSimulationStageScript' | 'ParticleGPUComputeScript' | 'EmitterSpawnScript' | 'EmitterUpdateScript' | 'SystemSpawnScript' | 'SystemUpdateScript' | 'ENiagaraScriptUsage_MAX';
declare var ENiagaraScriptUsage : { Function:'Function',Module:'Module',DynamicInput:'DynamicInput',ParticleSpawnScript:'ParticleSpawnScript',ParticleSpawnScriptInterpolated:'ParticleSpawnScriptInterpolated',ParticleUpdateScript:'ParticleUpdateScript',ParticleEventScript:'ParticleEventScript',ParticleSimulationStageScript:'ParticleSimulationStageScript',ParticleGPUComputeScript:'ParticleGPUComputeScript',EmitterSpawnScript:'EmitterSpawnScript',EmitterUpdateScript:'EmitterUpdateScript',SystemSpawnScript:'SystemSpawnScript',SystemUpdateScript:'SystemUpdateScript',ENiagaraScriptUsage_MAX:'ENiagaraScriptUsage_MAX', };
declare class NiagaraAssetVersion { 
	MajorVersion: number;
	MinorVersion: number;
	VersionGuid: Guid;
	bIsVisibleInVersionSelector: boolean;
	clone() : NiagaraAssetVersion;
	static C(Other: UObject | any): NiagaraAssetVersion;
}

declare type ENiagaraModuleDependencyType = 'PreDependency' | 'PostDependency' | 'ENiagaraModuleDependencyType_MAX';
declare var ENiagaraModuleDependencyType : { PreDependency:'PreDependency',PostDependency:'PostDependency',ENiagaraModuleDependencyType_MAX:'ENiagaraModuleDependencyType_MAX', };
declare type ENiagaraModuleDependencyScriptConstraint = 'SameScript' | 'AllScripts' | 'ENiagaraModuleDependencyScriptConstraint_MAX';
declare var ENiagaraModuleDependencyScriptConstraint : { SameScript:'SameScript',AllScripts:'AllScripts',ENiagaraModuleDependencyScriptConstraint_MAX:'ENiagaraModuleDependencyScriptConstraint_MAX', };
declare class NiagaraModuleDependency { 
	ID: string;
	Type: ENiagaraModuleDependencyType;
	ScriptConstraint: ENiagaraModuleDependencyScriptConstraint;
	Description: string;
	clone() : NiagaraModuleDependency;
	static C(Other: UObject | any): NiagaraModuleDependency;
}

declare class NiagaraConvertInPlaceUtilityBase extends UObject { 
	static Load(ResourceName: string): NiagaraConvertInPlaceUtilityBase;
	static Find(Outer: UObject, ResourceName: string): NiagaraConvertInPlaceUtilityBase;
	static GetDefaultObject(): NiagaraConvertInPlaceUtilityBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraConvertInPlaceUtilityBase;
	static C(Other: UObject | any): NiagaraConvertInPlaceUtilityBase;
}

declare type ENiagaraNumericOutputTypeSelectionMode = 'None' | 'Largest' | 'Smallest' | 'Scalar' | 'Custom' | 'ENiagaraNumericOutputTypeSelectionMode_MAX';
declare var ENiagaraNumericOutputTypeSelectionMode : { None:'None',Largest:'Largest',Smallest:'Smallest',Scalar:'Scalar',Custom:'Custom',ENiagaraNumericOutputTypeSelectionMode_MAX:'ENiagaraNumericOutputTypeSelectionMode_MAX', };
declare class NiagaraStackSection { 
	SectionIdentifier: string;
	SectionDisplayName: string;
	Categories: string[];
	bEnabled: boolean;
	clone() : NiagaraStackSection;
	static C(Other: UObject | any): NiagaraStackSection;
}

declare class NiagaraCompileHash { 
	DataHash: number[];
	clone() : NiagaraCompileHash;
	static C(Other: UObject | any): NiagaraCompileHash;
}

declare class NiagaraVMExecutableDataId { 
	CompilerVersionID: Guid;
	ScriptUsageType: ENiagaraScriptUsage;
	ScriptUsageTypeID: Guid;
	AdditionalDefines: string[];
	AdditionalVariables: NiagaraVariableBase[];
	bUsesRapidIterationParams: boolean;
	bDisableDebugSwitches: boolean;
	bInterpolatedSpawn: boolean;
	bRequiresPersistentIDs: boolean;
	BaseScriptID: Guid;
	BaseScriptCompileHash: NiagaraCompileHash;
	ReferencedCompileHashes: NiagaraCompileHash[];
	ScriptVersionID: Guid;
	clone() : NiagaraVMExecutableDataId;
	static C(Other: UObject | any): NiagaraVMExecutableDataId;
}

declare type ENiagaraPythonUpdateScriptReference = 'None' | 'ScriptAsset' | 'DirectTextEntry' | 'ENiagaraPythonUpdateScriptReference_MAX';
declare var ENiagaraPythonUpdateScriptReference : { None:'None',ScriptAsset:'ScriptAsset',DirectTextEntry:'DirectTextEntry',ENiagaraPythonUpdateScriptReference_MAX:'ENiagaraPythonUpdateScriptReference_MAX', };
declare class FilePath { 
	FilePath: string;
	clone() : FilePath;
	static C(Other: UObject | any): FilePath;
}

declare class NiagaraParameterDefinitionsBase extends UObject { 
	UniqueId: Guid;
	static Load(ResourceName: string): NiagaraParameterDefinitionsBase;
	static Find(Outer: UObject, ResourceName: string): NiagaraParameterDefinitionsBase;
	static GetDefaultObject(): NiagaraParameterDefinitionsBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraParameterDefinitionsBase;
	static C(Other: UObject | any): NiagaraParameterDefinitionsBase;
}

declare class ParameterDefinitionsSubscription { 
	Definitions: NiagaraParameterDefinitionsBase;
	DefinitionsId: Guid;
	CachedChangeIdHash: number;
	clone() : ParameterDefinitionsSubscription;
	static C(Other: UObject | any): ParameterDefinitionsSubscription;
}

declare class NiagaraScriptSourceBase extends UObject { 
	static Load(ResourceName: string): NiagaraScriptSourceBase;
	static Find(Outer: UObject, ResourceName: string): NiagaraScriptSourceBase;
	static GetDefaultObject(): NiagaraScriptSourceBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraScriptSourceBase;
	static C(Other: UObject | any): NiagaraScriptSourceBase;
}

declare class VersionedNiagaraScriptData { 
	Version: NiagaraAssetVersion;
	VersionChangeDescription: string;
	ModuleUsageBitmask: number;
	Category: string;
	bSuggested: boolean;
	ProvidedDependencies: string[];
	RequiredDependencies: NiagaraModuleDependency[];
	bDeprecated: boolean;
	DeprecationMessage: string;
	DeprecationRecommendation: NiagaraScript;
	ConversionUtility: UnrealEngineClass;
	bExperimental: boolean;
	ExperimentalMessage: string;
	NoteMessage: string;
	LibraryVisibility: ENiagaraScriptLibraryVisibility;
	NumericOutputTypeSelectionMode: ENiagaraNumericOutputTypeSelectionMode;
	Description: string;
	Keywords: string;
	CollapsedViewFormat: string;
	bCanBeUsedForTypeConversions: boolean;
	ScriptMetaData: any;
	InputSections: NiagaraStackSection[];
	LastGeneratedVMId: NiagaraVMExecutableDataId;
	UpdateScriptExecution: ENiagaraPythonUpdateScriptReference;
	PythonUpdateScript: string;
	ScriptAsset: FilePath;
	ParameterDefinitionsSubscriptions: ParameterDefinitionsSubscription[];
	Source: NiagaraScriptSourceBase;
	clone() : VersionedNiagaraScriptData;
	static C(Other: UObject | any): VersionedNiagaraScriptData;
}

declare class NiagaraScriptExecutionPaddingInfo { 
	SrcOffset: any;
	DestOffset: any;
	SrcSize: any;
	DestSize: any;
	clone() : NiagaraScriptExecutionPaddingInfo;
	static C(Other: UObject | any): NiagaraScriptExecutionPaddingInfo;
}

declare class NiagaraScriptExecutionParameterStore extends NiagaraParameterStore { 
	ParameterSize: number;
	PaddedParameterSize: any;
	PaddingInfo: NiagaraScriptExecutionPaddingInfo[];
	bInitialized: boolean;
	clone() : NiagaraScriptExecutionParameterStore;
	static C(Other: UObject | any): NiagaraScriptExecutionParameterStore;
}

declare class NiagaraBoundParameter { 
	Parameter: NiagaraVariable;
	SrcOffset: number;
	DestOffset: number;
	clone() : NiagaraBoundParameter;
	static C(Other: UObject | any): NiagaraBoundParameter;
}

declare class NiagaraVMExecutableByteCode { 
	Data: number[];
	UncompressedSize: number;
	clone() : NiagaraVMExecutableByteCode;
	static C(Other: UObject | any): NiagaraVMExecutableByteCode;
}

declare class NiagaraParameters { 
	Parameters: NiagaraVariable[];
	clone() : NiagaraParameters;
	static C(Other: UObject | any): NiagaraParameters;
}

declare class NiagaraCompileDependency { 
	LinkerErrorMessage: string;
	NodeGuid: Guid;
	PinGuid: Guid;
	StackGuids: Guid[];
	DependentVariable: NiagaraVariableBase;
	bDependentVariableFromCustomIterationNamespace: boolean;
	clone() : NiagaraCompileDependency;
	static C(Other: UObject | any): NiagaraCompileDependency;
}

declare class NiagaraCompilerTag { 
	Variable: NiagaraVariable;
	StringValue: string;
	clone() : NiagaraCompilerTag;
	static C(Other: UObject | any): NiagaraCompilerTag;
}

declare class NiagaraScriptDataUsageInfo { 
	bReadsAttributeData: boolean;
	clone() : NiagaraScriptDataUsageInfo;
	static C(Other: UObject | any): NiagaraScriptDataUsageInfo;
}

declare class NiagaraFunctionSignature { 
	Name: string;
	Inputs: NiagaraVariable[];
	Outputs: NiagaraVariable[];
	OwnerName: string;
	bRequiresContext: boolean;
	bRequiresExecPin: boolean;
	bMemberFunction: boolean;
	bExperimental: boolean;
	ExperimentalMessage: string;
	FunctionVersion: any;
	bSupportsCPU: boolean;
	bSupportsGPU: boolean;
	bWriteFunction: boolean;
	bSoftDeprecatedFunction: boolean;
	bIsCompileTagGenerator: boolean;
	bHidden: boolean;
	ModuleUsageBitmask: number;
	ContextStageIndex: number;
	FunctionSpecifiers: any;
	Description: string;
	InputDescriptions: any;
	OutputDescriptions: any;
	clone() : NiagaraFunctionSignature;
	static C(Other: UObject | any): NiagaraFunctionSignature;
}

declare class NiagaraScriptDataInterfaceCompileInfo { 
	Name: string;
	UserPtrIdx: number;
	Type: NiagaraTypeDefinition;
	RegisteredFunctions: NiagaraFunctionSignature[];
	RegisteredParameterMapRead: string;
	RegisteredParameterMapWrite: string;
	bIsPlaceholder: boolean;
	clone() : NiagaraScriptDataInterfaceCompileInfo;
	static C(Other: UObject | any): NiagaraScriptDataInterfaceCompileInfo;
}

declare class VMFunctionSpecifier { 
	Key: string;
	Value: string;
	clone() : VMFunctionSpecifier;
	static C(Other: UObject | any): VMFunctionSpecifier;
}

declare class VMExternalFunctionBindingInfo { 
	Name: string;
	OwnerName: string;
	InputParamLocations: boolean[];
	NumOutputs: number;
	FunctionSpecifiers: VMFunctionSpecifier[];
	Specifiers: any;
	clone() : VMExternalFunctionBindingInfo;
	static C(Other: UObject | any): VMExternalFunctionBindingInfo;
}

declare type ENiagaraDataSetType = 'ParticleData' | 'Shared' | 'Event' | 'ENiagaraDataSetType_MAX';
declare var ENiagaraDataSetType : { ParticleData:'ParticleData',Shared:'Shared',Event:'Event',ENiagaraDataSetType_MAX:'ENiagaraDataSetType_MAX', };
declare class NiagaraDataSetID { 
	Name: string;
	Type: ENiagaraDataSetType;
	clone() : NiagaraDataSetID;
	static C(Other: UObject | any): NiagaraDataSetID;
}

declare class NiagaraDataSetProperties { 
	ID: NiagaraDataSetID;
	Variables: NiagaraVariable[];
	clone() : NiagaraDataSetProperties;
	static C(Other: UObject | any): NiagaraDataSetProperties;
}

declare class NiagaraStatScope { 
	FullName: string;
	FriendlyName: string;
	clone() : NiagaraStatScope;
	static C(Other: UObject | any): NiagaraStatScope;
}

declare class NiagaraDataInterfaceGeneratedFunction { 
	clone() : NiagaraDataInterfaceGeneratedFunction;
	static C(Other: UObject | any): NiagaraDataInterfaceGeneratedFunction;
}

declare class NiagaraDataInterfaceGPUParamInfo { 
	DataInterfaceHLSLSymbol: string;
	DIClassName: string;
	GeneratedFunctions: NiagaraDataInterfaceGeneratedFunction[];
	clone() : NiagaraDataInterfaceGPUParamInfo;
	static C(Other: UObject | any): NiagaraDataInterfaceGPUParamInfo;
}

declare type ENiagaraScriptCompileStatus = 'NCS_Unknown' | 'NCS_Dirty' | 'NCS_Error' | 'NCS_UpToDate' | 'NCS_BeingCreated' | 'NCS_UpToDateWithWarnings' | 'NCS_ComputeUpToDateWithWarnings' | 'NCS_MAX';
declare var ENiagaraScriptCompileStatus : { NCS_Unknown:'NCS_Unknown',NCS_Dirty:'NCS_Dirty',NCS_Error:'NCS_Error',NCS_UpToDate:'NCS_UpToDate',NCS_BeingCreated:'NCS_BeingCreated',NCS_UpToDateWithWarnings:'NCS_UpToDateWithWarnings',NCS_ComputeUpToDateWithWarnings:'NCS_ComputeUpToDateWithWarnings',NCS_MAX:'NCS_MAX', };
declare type ENiagaraSimStageExecuteBehavior = 'Always' | 'OnSimulationReset' | 'NotOnSimulationReset' | 'ENiagaraSimStageExecuteBehavior_MAX';
declare var ENiagaraSimStageExecuteBehavior : { Always:'Always',OnSimulationReset:'OnSimulationReset',NotOnSimulationReset:'NotOnSimulationReset',ENiagaraSimStageExecuteBehavior_MAX:'ENiagaraSimStageExecuteBehavior_MAX', };
declare type ENiagaraGpuDispatchType = 'OneD' | 'TwoD' | 'ThreeD' | 'Custom' | 'ENiagaraGpuDispatchType_MAX';
declare var ENiagaraGpuDispatchType : { OneD:'OneD',TwoD:'TwoD',ThreeD:'ThreeD',Custom:'Custom',ENiagaraGpuDispatchType_MAX:'ENiagaraGpuDispatchType_MAX', };
declare class SimulationStageMetaData { 
	SimulationStageName: string;
	EnabledBinding: string;
	IterationSource: string;
	ExecuteBehavior: ENiagaraSimStageExecuteBehavior;
	bWritesParticles: boolean;
	bPartialParticleUpdate: boolean;
	bParticleIterationStateEnabled: boolean;
	ParticleIterationStateBinding: string;
	ParticleIterationStateRange: IntPoint;
	OutputDestinations: string[];
	NumIterations: number;
	NumIterationsBinding: string;
	GpuDispatchType: ENiagaraGpuDispatchType;
	GpuDispatchNumThreads: IntVector;
	clone() : SimulationStageMetaData;
	static C(Other: UObject | any): SimulationStageMetaData;
}

declare type FNiagaraCompileEventSeverity = 'Log' | 'Display' | 'Warning' | 'Error' | 'FNiagaraCompileEventSeverity_MAX';
declare var FNiagaraCompileEventSeverity : { Log:'Log',Display:'Display',Warning:'Warning',Error:'Error',FNiagaraCompileEventSeverity_MAX:'FNiagaraCompileEventSeverity_MAX', };
declare type FNiagaraCompileEventSource = 'Unset' | 'ScriptDependency' | 'FNiagaraCompileEventSource_MAX';
declare var FNiagaraCompileEventSource : { Unset:'Unset',ScriptDependency:'ScriptDependency',FNiagaraCompileEventSource_MAX:'FNiagaraCompileEventSource_MAX', };
declare class NiagaraCompileEvent { 
	Severity: FNiagaraCompileEventSeverity;
	Message: string;
	ShortDescription: string;
	bDismissable: boolean;
	NodeGuid: Guid;
	PinGuid: Guid;
	StackGuids: Guid[];
	Source: FNiagaraCompileEventSource;
	clone() : NiagaraCompileEvent;
	static C(Other: UObject | any): NiagaraCompileEvent;
}

declare class NiagaraVMExecutableData { 
	ByteCode: NiagaraVMExecutableByteCode;
	OptimizedByteCode: NiagaraVMExecutableByteCode;
	NumTempRegisters: number;
	NumUserPtrs: number;
	Parameters: NiagaraParameters;
	InternalParameters: NiagaraParameters;
	ExternalDependencies: NiagaraCompileDependency[];
	CompileTags: NiagaraCompilerTag[];
	ScriptLiterals: number[];
	Attributes: NiagaraVariable[];
	DataUsage: NiagaraScriptDataUsageInfo;
	DataSetToParameters: any;
	AdditionalExternalFunctions: NiagaraFunctionSignature[];
	DataInterfaceInfo: NiagaraScriptDataInterfaceCompileInfo[];
	CalledVMExternalFunctions: VMExternalFunctionBindingInfo[];
	ReadDataSets: NiagaraDataSetID[];
	WriteDataSets: NiagaraDataSetProperties[];
	StatScopes: NiagaraStatScope[];
	LastHlslTranslation: string;
	LastHlslTranslationGPU: string;
	LastAssemblyTranslation: string;
	LastOpCount: any;
	DIParamInfo: NiagaraDataInterfaceGPUParamInfo[];
	ParameterCollectionPaths: string[];
	LastCompileStatus: ENiagaraScriptCompileStatus;
	SimulationStageMetaData: SimulationStageMetaData[];
	bReadsAttributeData: boolean;
	AttributesWritten: NiagaraVariableBase[];
	StaticVariablesWritten: NiagaraVariable[];
	ErrorMsg: string;
	CompileTime: number;
	LastCompileEvents: NiagaraCompileEvent[];
	bReadsSignificanceIndex: boolean;
	bNeedsGPUContextInit: boolean;
	clone() : NiagaraVMExecutableData;
	static C(Other: UObject | any): NiagaraVMExecutableData;
}

declare class NiagaraScriptDataInterfaceInfo { 
	DataInterface: NiagaraDataInterface;
	Name: string;
	UserPtrIdx: number;
	Type: NiagaraTypeDefinition;
	RegisteredParameterMapRead: string;
	RegisteredParameterMapWrite: string;
	clone() : NiagaraScriptDataInterfaceInfo;
	static C(Other: UObject | any): NiagaraScriptDataInterfaceInfo;
}

declare class NiagaraScript extends NiagaraScriptBase { 
	Usage: ENiagaraScriptUsage;
	UsageId: Guid;
	ExposedVersion: Guid;
	bVersioningEnabled: boolean;
	VersionData: VersionedNiagaraScriptData[];
	RapidIterationParameters: NiagaraParameterStore;
	VersionToOpenInEditor: Guid;
	UsageIndex: number;
	ModuleUsageBitmask: number;
	Category: string;
	ProvidedDependencies: string[];
	RequiredDependencies: NiagaraModuleDependency[];
	bDeprecated: boolean;
	DeprecationMessage: string;
	DeprecationRecommendation: NiagaraScript;
	ConversionUtility: UnrealEngineClass;
	bExperimental: boolean;
	ExperimentalMessage: string;
	NoteMessage: string;
	bExposeToLibrary: boolean;
	LibraryVisibility: ENiagaraScriptLibraryVisibility;
	NumericOutputTypeSelectionMode: ENiagaraNumericOutputTypeSelectionMode;
	Description: string;
	Keywords: string;
	CollapsedViewFormat: string;
	ScriptMetaData: any;
	Source: NiagaraScriptSourceBase;
	ScriptExecutionParamStoreCPU: NiagaraScriptExecutionParameterStore;
	ScriptExecutionParamStoreGPU: NiagaraScriptExecutionParameterStore;
	ScriptExecutionParamStore: NiagaraScriptExecutionParameterStore;
	ScriptExecutionBoundParameters: NiagaraBoundParameter[];
	CachedScriptVMId: NiagaraVMExecutableDataId;
	ActiveCompileRoots: UObject[];
	CachedScriptVM: NiagaraVMExecutableData;
	CachedParameterCollectionReferences: NiagaraParameterCollection[];
	CachedDefaultDataInterfaces: NiagaraScriptDataInterfaceInfo[];
	static Load(ResourceName: string): NiagaraScript;
	static Find(Outer: UObject, ResourceName: string): NiagaraScript;
	static GetDefaultObject(): NiagaraScript;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraScript;
	RaiseOnGPUCompilationComplete(): void;
	static C(Other: UObject | any): NiagaraScript;
}

declare type ENiagaraTickBehavior = 'UsePrereqs' | 'UseComponentTickGroup' | 'ForceTickFirst' | 'ForceTickLast' | 'ENiagaraTickBehavior_MAX';
declare var ENiagaraTickBehavior : { UsePrereqs:'UsePrereqs',UseComponentTickGroup:'UseComponentTickGroup',ForceTickFirst:'ForceTickFirst',ForceTickLast:'ForceTickLast',ENiagaraTickBehavior_MAX:'ENiagaraTickBehavior_MAX', };
declare class NiagaraUserRedirectionParameterStore extends NiagaraParameterStore { 
	UserParameterRedirects: any;
	clone() : NiagaraUserRedirectionParameterStore;
	static C(Other: UObject | any): NiagaraUserRedirectionParameterStore;
}

declare class NiagaraCulledComponentInfo { 
	clone() : NiagaraCulledComponentInfo;
	static C(Other: UObject | any): NiagaraCulledComponentInfo;
}

declare class NiagaraCullProxyComponent extends NiagaraComponent { 
	Instances: NiagaraCulledComponentInfo[];
	static Load(ResourceName: string): NiagaraCullProxyComponent;
	static Find(Outer: UObject, ResourceName: string): NiagaraCullProxyComponent;
	static GetDefaultObject(): NiagaraCullProxyComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraCullProxyComponent;
	static C(Other: UObject | any): NiagaraCullProxyComponent;
}

declare type ENiagaraAgeUpdateMode = 'TickDeltaTime' | 'DesiredAge' | 'DesiredAgeNoSeek' | 'ENiagaraAgeUpdateMode_MAX';
declare var ENiagaraAgeUpdateMode : { TickDeltaTime:'TickDeltaTime',DesiredAge:'DesiredAge',DesiredAgeNoSeek:'DesiredAgeNoSeek',ENiagaraAgeUpdateMode_MAX:'ENiagaraAgeUpdateMode_MAX', };
declare class InterpCurvePointQuat { 
	InVal: number;
	OutVal: Quat;
	ArriveTangent: Quat;
	LeaveTangent: Quat;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointQuat;
	static C(Other: UObject | any): InterpCurvePointQuat;
}

declare class InterpCurveQuat { 
	Points: InterpCurvePointQuat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveQuat;
	static C(Other: UObject | any): InterpCurveQuat;
}

declare class InterpCurvePointFloat { 
	InVal: number;
	OutVal: number;
	ArriveTangent: number;
	LeaveTangent: number;
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointFloat;
	static C(Other: UObject | any): InterpCurvePointFloat;
}

declare class InterpCurveFloat { 
	Points: InterpCurvePointFloat[];
	bIsLooped: boolean;
	LoopKeyOffset: number;
	clone() : InterpCurveFloat;
	static C(Other: UObject | any): InterpCurveFloat;
}

declare class SplineMetadata extends UObject { 
	static Load(ResourceName: string): SplineMetadata;
	static Find(Outer: UObject, ResourceName: string): SplineMetadata;
	static GetDefaultObject(): SplineMetadata;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineMetadata;
	static C(Other: UObject | any): SplineMetadata;
}

declare class SplineCurves { 
	position: InterpCurveVector;
	Rotation: InterpCurveQuat;
	Scale: InterpCurveVector;
	ReparamTable: InterpCurveFloat;
	MetaData: SplineMetadata;
	Version: any;
	clone() : SplineCurves;
	static C(Other: UObject | any): SplineCurves;
}

declare type ESplineCoordinateSpace = 'Local' | 'World' | 'ESplineCoordinateSpace_MAX';
declare var ESplineCoordinateSpace : { Local:'Local',World:'World',ESplineCoordinateSpace_MAX:'ESplineCoordinateSpace_MAX', };
declare type ESplinePointType = 'Linear' | 'Curve' | 'Constant' | 'CurveClamped' | 'CurveCustomTangent' | 'ESplinePointType_MAX';
declare var ESplinePointType : { Linear:'Linear',Curve:'Curve',Constant:'Constant',CurveClamped:'CurveClamped',CurveCustomTangent:'CurveCustomTangent',ESplinePointType_MAX:'ESplinePointType_MAX', };
declare class SplinePoint { 
	InputKey: number;
	position: Vector;
	ArriveTangent: Vector;
	LeaveTangent: Vector;
	Rotation: Rotator;
	Scale: Vector;
	Type: ESplinePointType;
	clone() : SplinePoint;
	static C(Other: UObject | any): SplinePoint;
}

declare class SplineComponent extends PrimitiveComponent { 
	SplineCurves: SplineCurves;
	SplineInfo: InterpCurveVector;
	SplineRotInfo: InterpCurveQuat;
	SplineScaleInfo: InterpCurveVector;
	SplineReparamTable: InterpCurveFloat;
	bAllowSplineEditingPerInstance: boolean;
	ReparamStepsPerSegment: number;
	Duration: number;
	bStationaryEndpoints: boolean;
	bSplineHasBeenEdited: boolean;
	bModifiedByConstructionScript: boolean;
	bInputSplinePointsToConstructionScript: boolean;
	bDrawDebug: boolean;
	bClosedLoop: boolean;
	bLoopPositionOverride: boolean;
	LoopPosition: number;
	DefaultUpVector: Vector;
	EditorUnselectedSplineSegmentColor: LinearColor;
	EditorSelectedSplineSegmentColor: LinearColor;
	EditorTangentColor: LinearColor;
	bAllowDiscontinuousSpline: boolean;
	bShouldVisualizeScale: boolean;
	ScaleVisualizationWidth: number;
	static Load(ResourceName: string): SplineComponent;
	static Find(Outer: UObject, ResourceName: string): SplineComponent;
	static GetDefaultObject(): SplineComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SplineComponent;
	UpdateSpline(): void;
	SetWorldLocationAtSplinePoint(PointIndex: number,InLocation: Vector): void;
	SetUpVectorAtSplinePoint(PointIndex: number,InUpVector: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetUnselectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetTangentsAtSplinePoint(PointIndex: number,InArriveTangent: Vector,InLeaveTangent: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetTangentColor(TangentColor: LinearColor): void;
	SetTangentAtSplinePoint(PointIndex: number,InTangent: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetSplineWorldPoints(Points: Vector[]): void;
	SetSplinePointType(PointIndex: number,Type: ESplinePointType,bUpdateSpline: boolean): void;
	SetSplinePoints(Points: Vector[],CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetSplineLocalPoints(Points: Vector[]): void;
	SetSelectedSplineSegmentColor(SegmentColor: LinearColor): void;
	SetScaleAtSplinePoint(PointIndex: number,InScaleVector: Vector,bUpdateSpline: boolean): void;
	SetRotationAtSplinePoint(PointIndex: number,InRotation: Rotator,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetLocationAtSplinePoint(PointIndex: number,InLocation: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	SetDrawDebug(bShow: boolean): void;
	SetDefaultUpVector(UpVector: Vector,CoordinateSpace: ESplineCoordinateSpace): void;
	SetClosedLoopAtPosition(bInClosedLoop: boolean,Key: number,bUpdateSpline: boolean): void;
	SetClosedLoop(bInClosedLoop: boolean,bUpdateSpline: boolean): void;
	RemoveSplinePoint(index: number,bUpdateSpline: boolean): void;
	IsClosedLoop(): boolean;
	GetWorldTangentAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldRotationAtTime(Time: number,bUseConstantVelocity: boolean): Rotator;
	GetWorldRotationAtDistanceAlongSpline(Distance: number): Rotator;
	GetWorldLocationAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldLocationAtSplinePoint(PointIndex: number): Vector;
	GetWorldLocationAtDistanceAlongSpline(Distance: number): Vector;
	GetWorldDirectionAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetWorldDirectionAtDistanceAlongSpline(Distance: number): Vector;
	GetVectorPropertyAtSplinePoint(index: number,PropertyName: string): Vector;
	GetVectorPropertyAtSplineInputKey(InKey: number,PropertyName: string): Vector;
	GetUpVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetUpVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetUpVectorAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetUpVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTransformAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean,bUseScale: boolean): Transform;
	GetTransformAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTransformAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTransformAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	GetTangentAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTangentAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetTangentAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetSplinePointType(PointIndex: number): ESplinePointType;
	GetSplineLength(): number;
	GetScaleAtTime(Time: number,bUseConstantVelocity: boolean): Vector;
	GetScaleAtSplinePoint(PointIndex: number): Vector;
	GetScaleAtSplineInputKey(InKey: number): Vector;
	GetScaleAtDistanceAlongSpline(Distance: number): Vector;
	GetRotationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Rotator;
	GetRotationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRotationAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRotationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	GetRollAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): number;
	GetRollAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRollAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRollAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): number;
	GetRightVectorAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetRightVectorAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetRightVectorAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetRightVectorAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetNumberOfSplineSegments(): number;
	GetNumberOfSplinePoints(): number;
	GetLocationAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetLocationAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetLocationAndTangentAtSplinePoint(PointIndex: number,Location?: Vector,Tangent?: Vector,CoordinateSpace?: ESplineCoordinateSpace): {Location: Vector, Tangent: Vector};
	GetLocalLocationAndTangentAtSplinePoint(PointIndex: number,LocalLocation?: Vector,LocalTangent?: Vector): {LocalLocation: Vector, LocalTangent: Vector};
	GetLeaveTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetInputKeyAtDistanceAlongSpline(Distance: number): number;
	GetFloatPropertyAtSplinePoint(index: number,PropertyName: string): number;
	GetFloatPropertyAtSplineInputKey(InKey: number,PropertyName: string): number;
	GetDistanceAlongSplineAtSplinePoint(PointIndex: number): number;
	GetDistanceAlongSplineAtSplineInputKey(InKey: number): number;
	GetDirectionAtTime(Time: number,CoordinateSpace: ESplineCoordinateSpace,bUseConstantVelocity: boolean): Vector;
	GetDirectionAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDirectionAtSplineInputKey(InKey: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDirectionAtDistanceAlongSpline(Distance: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetDefaultUpVector(CoordinateSpace: ESplineCoordinateSpace): Vector;
	GetArriveTangentAtSplinePoint(PointIndex: number,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindUpVectorClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindTransformClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace,bUseScale: boolean): Transform;
	FindTangentClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindScaleClosestToWorldLocation(WorldLocation: Vector): Vector;
	FindRotationClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Rotator;
	FindRollClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): number;
	FindRightVectorClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindLocationClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	FindInputKeyClosestToWorldLocation(WorldLocation: Vector): number;
	FindDirectionClosestToWorldLocation(WorldLocation: Vector,CoordinateSpace: ESplineCoordinateSpace): Vector;
	DivideSplineIntoPolylineRecursive(StartDistanceAlongSpline: number,EndDistanceAlongSpline: number,CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ConvertSplineToPolyLine(CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ConvertSplineSegmentToPolyLine(SplinePointStartIndex: number,CoordinateSpace: ESplineCoordinateSpace,MaxSquareDistanceFromSpline: number,OutPoints?: Vector[]): {OutPoints: Vector[], $: boolean};
	ClearSplinePoints(bUpdateSpline: boolean): void;
	AddSplineWorldPoint(position: Vector): void;
	AddSplinePointAtIndex(position: Vector,index: number,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	AddSplinePoint(position: Vector,CoordinateSpace: ESplineCoordinateSpace,bUpdateSpline: boolean): void;
	AddSplineLocalPoint(position: Vector): void;
	AddPoints(Points: SplinePoint[],bUpdateSpline: boolean): void;
	AddPoint(Point: SplinePoint,bUpdateSpline: boolean): void;
	static C(Other: UObject | any): SplineComponent;
}

declare class WaterSplineCurveDefaults { 
	DefaultDepth: number;
	DefaultWidth: number;
	DefaultVelocity: number;
	DefaultAudioIntensity: number;
	clone() : WaterSplineCurveDefaults;
	static C(Other: UObject | any): WaterSplineCurveDefaults;
}

declare class WaterSplineComponent extends SplineComponent { 
	WaterSplineDefaults: WaterSplineCurveDefaults;
	PreviousWaterSplineDefaults: WaterSplineCurveDefaults;
	static Load(ResourceName: string): WaterSplineComponent;
	static Find(Outer: UObject, ResourceName: string): WaterSplineComponent;
	static GetDefaultObject(): WaterSplineComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterSplineComponent;
	static C(Other: UObject | any): WaterSplineComponent;
}

declare class WaterSplineMetadata extends SplineMetadata { 
	Depth: InterpCurveFloat;
	WaterVelocityScalar: InterpCurveFloat;
	RiverWidth: InterpCurveFloat;
	AudioIntensity: InterpCurveFloat;
	bShouldVisualizeWaterVelocity: boolean;
	bShouldVisualizeRiverWidth: boolean;
	bShouldVisualizeDepth: boolean;
	WaterVelocity: InterpCurveVector;
	static Load(ResourceName: string): WaterSplineMetadata;
	static Find(Outer: UObject, ResourceName: string): WaterSplineMetadata;
	static GetDefaultObject(): WaterSplineMetadata;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterSplineMetadata;
	static C(Other: UObject | any): WaterSplineMetadata;
}

declare class UnderwaterPostProcessSettings { 
	bEnabled: boolean;
	Priority: number;
	BlendRadius: number;
	BlendWeight: number;
	PostProcessSettings: PostProcessSettings;
	UnderwaterPostProcessMaterial: MaterialInterface;
	clone() : UnderwaterPostProcessSettings;
	static C(Other: UObject | any): UnderwaterPostProcessSettings;
}

declare class WaterCurveSettings { 
	bUseCurveChannel: boolean;
	ElevationCurveAsset: CurveFloat;
	ChannelEdgeOffset: number;
	ChannelDepth: number;
	CurveRampWidth: number;
	clone() : WaterCurveSettings;
	static C(Other: UObject | any): WaterCurveSettings;
}

declare type EWaterBrushBlendType = 'AlphaBlend' | 'Min' | 'Max' | 'Additive' | 'EWaterBrushBlendType_MAX';
declare var EWaterBrushBlendType : { AlphaBlend:'AlphaBlend',Min:'Min',Max:'Max',Additive:'Additive',EWaterBrushBlendType_MAX:'EWaterBrushBlendType_MAX', };
declare type EWaterBrushFalloffMode = 'Angle' | 'Width' | 'EWaterBrushFalloffMode_MAX';
declare var EWaterBrushFalloffMode : { Angle:'Angle',Width:'Width',EWaterBrushFalloffMode_MAX:'EWaterBrushFalloffMode_MAX', };
declare class WaterFalloffSettings { 
	FalloffMode: EWaterBrushFalloffMode;
	FalloffAngle: number;
	FalloffWidth: number;
	EdgeOffset: number;
	ZOffset: number;
	clone() : WaterFalloffSettings;
	static C(Other: UObject | any): WaterFalloffSettings;
}

declare class WaterBrushEffectBlurring { 
	bBlurShape: boolean;
	Radius: number;
	clone() : WaterBrushEffectBlurring;
	static C(Other: UObject | any): WaterBrushEffectBlurring;
}

declare class WaterBrushEffectCurlNoise { 
	Curl1Amount: number;
	Curl2Amount: number;
	Curl1Tiling: number;
	Curl2Tiling: number;
	clone() : WaterBrushEffectCurlNoise;
	static C(Other: UObject | any): WaterBrushEffectCurlNoise;
}

declare class WaterBrushEffectDisplacement { 
	DisplacementHeight: number;
	DisplacementTiling: number;
	Texture: Texture2D;
	Midpoint: number;
	Channel: LinearColor;
	WeightmapInfluence: number;
	clone() : WaterBrushEffectDisplacement;
	static C(Other: UObject | any): WaterBrushEffectDisplacement;
}

declare class WaterBrushEffectSmoothBlending { 
	InnerSmoothDistance: number;
	OuterSmoothDistance: number;
	clone() : WaterBrushEffectSmoothBlending;
	static C(Other: UObject | any): WaterBrushEffectSmoothBlending;
}

declare class WaterBrushEffectTerracing { 
	TerraceAlpha: number;
	TerraceSpacing: number;
	TerraceSmoothness: number;
	MaskLength: number;
	MaskStartOffset: number;
	clone() : WaterBrushEffectTerracing;
	static C(Other: UObject | any): WaterBrushEffectTerracing;
}

declare class WaterBrushEffects { 
	Blurring: WaterBrushEffectBlurring;
	CurlNoise: WaterBrushEffectCurlNoise;
	Displacement: WaterBrushEffectDisplacement;
	SmoothBlending: WaterBrushEffectSmoothBlending;
	Terracing: WaterBrushEffectTerracing;
	clone() : WaterBrushEffects;
	static C(Other: UObject | any): WaterBrushEffects;
}

declare class WaterBodyHeightmapSettings { 
	BlendMode: EWaterBrushBlendType;
	bInvertShape: boolean;
	FalloffSettings: WaterFalloffSettings;
	effects: WaterBrushEffects;
	Priority: number;
	clone() : WaterBodyHeightmapSettings;
	static C(Other: UObject | any): WaterBodyHeightmapSettings;
}

declare class WaterWavesBase extends UObject { 
	static Load(ResourceName: string): WaterWavesBase;
	static Find(Outer: UObject, ResourceName: string): WaterWavesBase;
	static GetDefaultObject(): WaterWavesBase;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterWavesBase;
	static C(Other: UObject | any): WaterWavesBase;
}

declare class WaterBodyIsland extends Actor { 
	WaterCurveSettings: WaterCurveSettings;
	WaterHeightmapSettings: WaterBodyHeightmapSettings;
	WaterWeightmapSettings: any;
	ActorIcon: BillboardComponent;
	SplineComp: WaterSplineComponent;
	static GetDefaultObject(): WaterBodyIsland;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBodyIsland;
	GetWaterSpline(): WaterSplineComponent;
	static C(Other: UObject | any): WaterBodyIsland;
}

declare class WaterBodyExclusionVolume extends PhysicsVolume { 
	bIgnoreAllOverlappingWaterBodies: boolean;
	WaterBodiesToIgnore: WaterBody[];
	WaterBodyToIgnore: WaterBody;
	ActorIcon: BillboardComponent;
	static GetDefaultObject(): WaterBodyExclusionVolume;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBodyExclusionVolume;
	static C(Other: UObject | any): WaterBodyExclusionVolume;
}

declare class WaterBodyComponent extends PrimitiveComponent { 
	PhysicalMaterial: PhysicalMaterial;
	TargetWaveMaskDepth: number;
	MaxWaveHeightOffset: number;
	bFillCollisionUnderWaterBodiesForNavmesh: boolean;
	UnderwaterPostProcessSettings: UnderwaterPostProcessSettings;
	CurveSettings: WaterCurveSettings;
	WaterMaterial: MaterialInterface;
	UnderwaterPostProcessMaterial: MaterialInterface;
	WaterHeightmapSettings: WaterBodyHeightmapSettings;
	LayerWeightmapSettings: any;
	ShapeDilation: number;
	CollisionHeightOffset: number;
	bAffectsLandscape: boolean;
	bGenerateCollisions: boolean;
	WaterBodyIndex: number;
	WaterMeshOverride: StaticMesh;
	OverlapMaterialPriority: number;
	CollisionProfileName: string;
	WaterSplineMetadata: WaterSplineMetadata;
	WaterMID: MaterialInstanceDynamic;
	UnderwaterPostProcessMID: MaterialInstanceDynamic;
	Islands: any[];
	ExclusionVolumes: any[];
	Landscape: any;
	CurrentPostProcessSettings: PostProcessSettings;
	bCanAffectNavigation: boolean;
	WaterNavAreaClass: UnrealEngineClass;
	bOverrideWaterMesh: boolean;
	static Load(ResourceName: string): WaterBodyComponent;
	static Find(Outer: UObject, ResourceName: string): WaterBodyComponent;
	static GetDefaultObject(): WaterBodyComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBodyComponent;
	OnWaterBodyChanged(bShapeOrPositionChanged: boolean,bWeightmapSettingsChanged: boolean): void;
	GetWaterWaves(): WaterWavesBase;
	GetWaterVelocityAtSplineInputKey(InKey: number): number;
	GetWaterSurfaceInfoAtLocation(InLocation: Vector,OutWaterSurfaceLocation?: Vector,OutWaterSurfaceNormal?: Vector,OutWaterVelocity?: Vector,OutWaterDepth?: number,bIncludeDepth?: boolean): {OutWaterSurfaceLocation: Vector, OutWaterSurfaceNormal: Vector, OutWaterVelocity: Vector, OutWaterDepth: number};
	GetWaterSpline(): WaterSplineComponent;
	GetWaterMaterialInstance(): MaterialInstanceDynamic;
	GetWaterMaterial(): MaterialInterface;
	GetWaterBodyActor(): WaterBody;
	GetUnderwaterPostProcessMaterialInstance(): MaterialInstanceDynamic;
	GetStandardRenderableComponents(): PrimitiveComponent[];
	GetRiverToOceanTransitionMaterialInstance(): MaterialInstanceDynamic;
	GetRiverToLakeTransitionMaterialInstance(): MaterialInstanceDynamic;
	GetMaxWaveHeight(): number;
	GetIslands(): WaterBodyIsland[];
	GetExclusionVolumes(): WaterBodyExclusionVolume[];
	GetCollisionComponents(): PrimitiveComponent[];
	static C(Other: UObject | any): WaterBodyComponent;
}

declare type EWaterBodyType = 'River' | 'Lake' | 'Ocean' | 'Transition' | 'Num' | 'EWaterBodyType_MAX';
declare var EWaterBodyType : { River:'River',Lake:'Lake',Ocean:'Ocean',Transition:'Transition',Num:'Num',EWaterBodyType_MAX:'EWaterBodyType_MAX', };
declare type EBrushBlendType = 'AlphaBlend' | 'Min' | 'Max' | 'Additive' | 'EBrushBlendType_MAX';
declare var EBrushBlendType : { AlphaBlend:'AlphaBlend',Min:'Min',Max:'Max',Additive:'Additive',EBrushBlendType_MAX:'EBrushBlendType_MAX', };
declare type EBrushFalloffMode = 'Angle' | 'Width' | 'EBrushFalloffMode_MAX';
declare var EBrushFalloffMode : { Angle:'Angle',Width:'Width',EBrushFalloffMode_MAX:'EBrushFalloffMode_MAX', };
declare class LandmassFalloffSettings { 
	FalloffMode: EBrushFalloffMode;
	FalloffAngle: number;
	FalloffWidth: number;
	EdgeOffset: number;
	ZOffset: number;
	clone() : LandmassFalloffSettings;
	static C(Other: UObject | any): LandmassFalloffSettings;
}

declare class BrushEffectBlurring { 
	bBlurShape: boolean;
	Radius: number;
	clone() : BrushEffectBlurring;
	static C(Other: UObject | any): BrushEffectBlurring;
}

declare class BrushEffectCurlNoise { 
	Curl1Amount: number;
	Curl2Amount: number;
	Curl1Tiling: number;
	Curl2Tiling: number;
	clone() : BrushEffectCurlNoise;
	static C(Other: UObject | any): BrushEffectCurlNoise;
}

declare class BrushEffectDisplacement { 
	DisplacementHeight: number;
	DisplacementTiling: number;
	Texture: Texture2D;
	Midpoint: number;
	Channel: LinearColor;
	WeightmapInfluence: number;
	clone() : BrushEffectDisplacement;
	static C(Other: UObject | any): BrushEffectDisplacement;
}

declare class BrushEffectSmoothBlending { 
	InnerSmoothDistance: number;
	OuterSmoothDistance: number;
	clone() : BrushEffectSmoothBlending;
	static C(Other: UObject | any): BrushEffectSmoothBlending;
}

declare class BrushEffectTerracing { 
	TerraceAlpha: number;
	TerraceSpacing: number;
	TerraceSmoothness: number;
	MaskLength: number;
	MaskStartOffset: number;
	clone() : BrushEffectTerracing;
	static C(Other: UObject | any): BrushEffectTerracing;
}

declare class LandmassBrushEffectsList { 
	Blurring: BrushEffectBlurring;
	CurlNoise: BrushEffectCurlNoise;
	Displacement: BrushEffectDisplacement;
	SmoothBlending: BrushEffectSmoothBlending;
	Terracing: BrushEffectTerracing;
	clone() : LandmassBrushEffectsList;
	static C(Other: UObject | any): LandmassBrushEffectsList;
}

declare class LandmassTerrainCarvingSettings { 
	BlendMode: EBrushBlendType;
	bInvertShape: boolean;
	FalloffSettings: LandmassFalloffSettings;
	effects: LandmassBrushEffectsList;
	Priority: number;
	clone() : LandmassTerrainCarvingSettings;
	static C(Other: UObject | any): LandmassTerrainCarvingSettings;
}

declare class WaterBody extends Actor { 
	SplineComp: WaterSplineComponent;
	WaterSplineMetadata: WaterSplineMetadata;
	WaterBodyComponent: WaterBodyComponent;
	WaterBodyIndex: number;
	WaterBodyType: EWaterBodyType;
	WaterWaves: WaterWavesBase;
	ActorIcon: BillboardComponent;
	PhysicalMaterial: PhysicalMaterial;
	TargetWaveMaskDepth: number;
	MaxWaveHeightOffset: number;
	bFillCollisionUnderWaterBodiesForNavmesh: boolean;
	UnderwaterPostProcessSettings: UnderwaterPostProcessSettings;
	CurveSettings: WaterCurveSettings;
	WaterMaterial: MaterialInterface;
	UnderwaterPostProcessMaterial: MaterialInterface;
	TerrainCarvingSettings: LandmassTerrainCarvingSettings;
	WaterHeightmapSettings: WaterBodyHeightmapSettings;
	LayerWeightmapSettings: any;
	bAffectsLandscape: boolean;
	bGenerateCollisions: boolean;
	bOverrideWaterMesh: boolean;
	WaterMeshOverride: StaticMesh;
	OverlapMaterialPriority: number;
	CollisionProfileName: string;
	WaterMID: MaterialInstanceDynamic;
	UnderwaterPostProcessMID: MaterialInstanceDynamic;
	Islands: any[];
	ExclusionVolumes: any[];
	bCanAffectNavigation: boolean;
	WaterNavAreaClass: UnrealEngineClass;
	ShapeDilation: number;
	static GetDefaultObject(): WaterBody;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WaterBody;
	SetWaterWaves(InWaterWaves: WaterWavesBase): void;
	SetWaterMaterial(InMaterial: MaterialInterface): void;
	OnWaterBodyChanged(bShapeOrPositionChanged: boolean,bWeightmapSettingsChanged: boolean): void;
	GetWaterVelocityVectorAtSplineInputKey(InKey: number): Vector;
	GetWaterVelocityAtSplineInputKey(InKey: number): number;
	GetWaterSpline(): WaterSplineComponent;
	GetWaterMaterialInstance(): MaterialInstanceDynamic;
	GetWaterBodyType(): EWaterBodyType;
	GetWaterBodyComponent(): WaterBodyComponent;
	GetRiverToOceanTransitionMaterialInstance(): MaterialInstanceDynamic;
	GetRiverToLakeTransitionMaterialInstance(): MaterialInstanceDynamic;
	GetIslands(): WaterBodyIsland[];
	GetExclusionVolumes(): WaterBodyExclusionVolume[];
	GetAudioIntensityAtSplineInputKey(InKey: number): number;
	static C(Other: UObject | any): WaterBody;
}

declare class Texture2DArray extends Texture { 
	AddressX: TextureAddress;
	AddressY: TextureAddress;
	AddressZ: TextureAddress;
	SourceTextures: Texture2D[];
	static Load(ResourceName: string): Texture2DArray;
	static Find(Outer: UObject, ResourceName: string): Texture2DArray;
	static GetDefaultObject(): Texture2DArray;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture2DArray;
	static C(Other: UObject | any): Texture2DArray;
}

declare class VolumeTexture extends Texture { 
	Source2DTexture: Texture2D;
	SourceLightingGuid: Guid;
	Source2DTileSizeX: number;
	Source2DTileSizeY: number;
	static Load(ResourceName: string): VolumeTexture;
	static Find(Outer: UObject, ResourceName: string): VolumeTexture;
	static GetDefaultObject(): VolumeTexture;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VolumeTexture;
	static C(Other: UObject | any): VolumeTexture;
}

declare class NiagaraComponent extends FXSystemComponent { 
	Asset: NiagaraSystem;
	TickBehavior: ENiagaraTickBehavior;
	RandomSeedOffset: number;
	OverrideParameters: NiagaraUserRedirectionParameterStore;
	EditorOverridesValue: any;
	TemplateParameterOverrides: any;
	InstanceParameterOverrides: any;
	bForceSolo: boolean;
	bEnableGpuComputeDebug: boolean;
	bAutoDestroy: boolean;
	bRenderingEnabled: boolean;
	bAutoManageAttachment: boolean;
	bAutoAttachWeldSimulatedBodies: boolean;
	MaxTimeBeforeForceUpdateTransform: number;
	OnSystemFinished: UnrealEngineMulticastDelegate<(PSystem: NiagaraComponent) => void>;
	AutoAttachParent: any;
	AutoAttachSocketName: string;
	AutoAttachLocationRule: EAttachmentRule;
	AutoAttachRotationRule: EAttachmentRule;
	AutoAttachScaleRule: EAttachmentRule;
	bWaitForCompilationOnActivate: boolean;
	bAllowScalability: boolean;
	CullProxy: NiagaraCullProxyComponent;
	static Load(ResourceName: string): NiagaraComponent;
	static Find(Outer: UObject, ResourceName: string): NiagaraComponent;
	static GetDefaultObject(): NiagaraComponent;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraComponent;
	SetVariableVec4(InVariableName: string,InValue: Vector4): void;
	SetVariableVec3(InVariableName: string,InValue: Vector): void;
	SetVariableVec2(InVariableName: string,InValue: Vector2D): void;
	SetVariableTextureRenderTarget(InVariableName: string,TextureRenderTarget: TextureRenderTarget): void;
	SetVariableTexture(InVariableName: string,Texture: Texture): void;
	SetVariableStaticMesh(InVariableName: string,InValue: StaticMesh): void;
	SetVariableQuat(InVariableName: string,InValue: Quat): void;
	SetVariablePosition(InVariableName: string,InValue: Vector): void;
	SetVariableObject(InVariableName: string,UObject: UObject): void;
	SetVariableMaterial(InVariableName: string,UObject: MaterialInterface): void;
	SetVariableLinearColor(InVariableName: string,InValue: LinearColor): void;
	SetVariableInt(InVariableName: string,InValue: number): void;
	SetVariableFloat(InVariableName: string,InValue: number): void;
	SetVariableBool(InVariableName: string,InValue: boolean): void;
	SetVariableActor(InVariableName: string,Actor: Actor): void;
	SetTickBehavior(NewTickBehavior: ENiagaraTickBehavior): void;
	SetSystemFixedBounds(LocalBounds: Box): void;
	SetSeekDelta(InSeekDelta: number): void;
	SetRenderingEnabled(bInRenderingEnabled: boolean): void;
	SetRandomSeedOffset(NewRandomSeedOffset: number): void;
	SetPreviewLODDistance(bEnablePreviewLODDistance: boolean,PreviewLODDistance: number,PreviewMaxDistance: number): void;
	SetPaused(bInPaused: boolean): void;
	SetNiagaraVariableVec4(InVariableName: string,InValue: Vector4): void;
	SetNiagaraVariableVec3(InVariableName: string,InValue: Vector): void;
	SetNiagaraVariableVec2(InVariableName: string,InValue: Vector2D): void;
	SetNiagaraVariableQuat(InVariableName: string,InValue: Quat): void;
	SetNiagaraVariablePosition(InVariableName: string,InValue: Vector): void;
	SetNiagaraVariableObject(InVariableName: string,UObject: UObject): void;
	SetNiagaraVariableLinearColor(InVariableName: string,InValue: LinearColor): void;
	SetNiagaraVariableInt(InVariableName: string,InValue: number): void;
	SetNiagaraVariableFloat(InVariableName: string,InValue: number): void;
	SetNiagaraVariableBool(InVariableName: string,InValue: boolean): void;
	SetNiagaraVariableActor(InVariableName: string,Actor: Actor): void;
	SetMaxSimTime(InMaxTime: number): void;
	SetLockDesiredAgeDeltaTimeToSeekDelta(bLock: boolean): void;
	SetGpuComputeDebug(bEnableDebug: boolean): void;
	SetForceSolo(bInForceSolo: boolean): void;
	SetForceLocalPlayerEffect(bIsPlayerEffect: boolean): void;
	SetEmitterFixedBounds(EmitterName: string,LocalBounds: Box): void;
	SetDesiredAge(InDesiredAge: number): void;
	SetCustomTimeDilation(Dilation: number): void;
	SetCanRenderWhileSeeking(bInCanRenderWhileSeeking: boolean): void;
	SetAutoDestroy(bInAutoDestroy: boolean): void;
	SetAsset(InAsset: NiagaraSystem,bResetExistingOverrideParameters: boolean): void;
	SetAllowScalability(bAllow: boolean): void;
	SetAgeUpdateMode(InAgeUpdateMode: ENiagaraAgeUpdateMode): void;
	SeekToDesiredAge(InDesiredAge: number): void;
	ResetSystem(): void;
	ReinitializeSystem(): void;
	IsPaused(): boolean;
	InitForPerformanceBaseline(): void;
	GetTickBehavior(): ENiagaraTickBehavior;
	GetSystemFixedBounds(): Box;
	GetSeekDelta(): number;
	GetRandomSeedOffset(): number;
	GetPreviewLODDistanceEnabled(): boolean;
	GetPreviewLODDistance(): number;
	GetNiagaraParticleValueVec3_DebugOnly(InEmitterName: string,InValueName: string): Vector[];
	GetNiagaraParticleValues_DebugOnly(InEmitterName: string,InValueName: string): number[];
	GetNiagaraParticlePositions_DebugOnly(InEmitterName: string): Vector[];
	GetMaxSimTime(): number;
	GetLockDesiredAgeDeltaTimeToSeekDelta(): boolean;
	GetForceSolo(): boolean;
	GetForceLocalPlayerEffect(): boolean;
	GetEmitterFixedBounds(EmitterName: string): Box;
	GetDesiredAge(): number;
	GetDataInterface(Name: string): NiagaraDataInterface;
	GetCustomTimeDilation(): number;
	GetAsset(): NiagaraSystem;
	GetAllowScalability(): boolean;
	GetAgeUpdateMode(): ENiagaraAgeUpdateMode;
	ClearSystemFixedBounds(): void;
	ClearEmitterFixedBounds(EmitterName: string): void;
	AdvanceSimulationByTime(SimulateTime: number,TickDeltaSeconds: number): void;
	AdvanceSimulation(TickCount: number,TickDeltaSeconds: number): void;
	static C(Other: UObject | any): NiagaraComponent;
	SetWaterBody(OverrideName: string,WaterBody: WaterBody): void;
	SetWaterBodyComponent(OverrideName: string,WaterBodyComponent: WaterBodyComponent): void;
	OverrideSystemUserVariableSkeletalMeshComponent(OverrideName: string,SkeletalMeshComponent: SkeletalMeshComponent): void;
	OverrideSystemUserVariableStaticMesh(OverrideName: string,StaticMesh: StaticMesh): void;
	OverrideSystemUserVariableStaticMeshComponent(OverrideName: string,StaticMeshComponent: StaticMeshComponent): void;
	SetSkeletalMeshDataInterfaceSamplingRegions(OverrideName: string,SamplingRegions: string[]): void;
	SetTexture2DArrayObject(OverrideName: string,Texture: Texture2DArray): void;
	SetTextureObject(OverrideName: string,Texture: Texture): void;
	SetVolumeTextureObject(OverrideName: string,Texture: VolumeTexture): void;
	GetNiagaraArrayBool(OverrideName: string): boolean[];
	GetNiagaraArrayBoolValue(OverrideName: string,index: number): boolean;
	GetNiagaraArrayColor(OverrideName: string): LinearColor[];
	GetNiagaraArrayColorValue(OverrideName: string,index: number): LinearColor;
	GetNiagaraArrayFloat(OverrideName: string): number[];
	GetNiagaraArrayFloatValue(OverrideName: string,index: number): number;
	GetNiagaraArrayInt32(OverrideName: string): number[];
	GetNiagaraArrayInt32Value(OverrideName: string,index: number): number;
	GetNiagaraArrayPosition(OverrideName: string): Vector[];
	GetNiagaraArrayPositionValue(OverrideName: string,index: number): Vector;
	GetNiagaraArrayQuat(OverrideName: string): Quat[];
	GetNiagaraArrayQuatValue(OverrideName: string,index: number): Quat;
	GetNiagaraArrayVector(OverrideName: string): Vector[];
	GetNiagaraArrayVector2D(OverrideName: string): Vector2D[];
	GetNiagaraArrayVector2DValue(OverrideName: string,index: number): Vector2D;
	GetNiagaraArrayVector4(OverrideName: string): Vector4[];
	GetNiagaraArrayVector4Value(OverrideName: string,index: number): Vector4;
	GetNiagaraArrayVectorValue(OverrideName: string,index: number): Vector;
	SetNiagaraArrayBool(OverrideName: string,ArrayData: boolean[]): void;
	SetNiagaraArrayBoolValue(OverrideName: string,index: number,Value: boolean,bSizeToFit: boolean): void;
	SetNiagaraArrayColor(OverrideName: string,ArrayData: LinearColor[]): void;
	SetNiagaraArrayColorValue(OverrideName: string,index: number,Value: LinearColor,bSizeToFit: boolean): void;
	SetNiagaraArrayFloat(OverrideName: string,ArrayData: number[]): void;
	SetNiagaraArrayFloatValue(OverrideName: string,index: number,Value: number,bSizeToFit: boolean): void;
	SetNiagaraArrayInt32(OverrideName: string,ArrayData: number[]): void;
	SetNiagaraArrayInt32Value(OverrideName: string,index: number,Value: number,bSizeToFit: boolean): void;
	SetNiagaraArrayPosition(OverrideName: string,ArrayData: Vector[]): void;
	SetNiagaraArrayPositionValue(OverrideName: string,index: number,Value: Vector,bSizeToFit: boolean): void;
	SetNiagaraArrayQuat(OverrideName: string,ArrayData: Quat[]): void;
	SetNiagaraArrayQuatValue(OverrideName: string,index: number,Value: Quat,bSizeToFit: boolean): void;
	SetNiagaraArrayVector(OverrideName: string,ArrayData: Vector[]): void;
	SetNiagaraArrayVector2D(OverrideName: string,ArrayData: Vector2D[]): void;
	SetNiagaraArrayVector2DValue(OverrideName: string,index: number,Value: Vector2D,bSizeToFit: boolean): void;
	SetNiagaraArrayVector4(OverrideName: string,ArrayData: Vector4[]): void;
	SetNiagaraArrayVector4Value(OverrideName: string,index: number,Value: Vector4,bSizeToFit: boolean): void;
	SetNiagaraArrayVectorValue(OverrideName: string,index: number,Value: Vector,bSizeToFit: boolean): void;
	static SetWaterBody(NiagaraSystem: NiagaraComponent,OverrideName: string,WaterBody: WaterBody): void;
	static SetWaterBodyComponent(NiagaraSystem: NiagaraComponent,OverrideName: string,WaterBodyComponent: WaterBodyComponent): void;
	static OverrideSystemUserVariableSkeletalMeshComponent(NiagaraSystem: NiagaraComponent,OverrideName: string,SkeletalMeshComponent: SkeletalMeshComponent): void;
	static OverrideSystemUserVariableStaticMesh(NiagaraSystem: NiagaraComponent,OverrideName: string,StaticMesh: StaticMesh): void;
	static OverrideSystemUserVariableStaticMeshComponent(NiagaraSystem: NiagaraComponent,OverrideName: string,StaticMeshComponent: StaticMeshComponent): void;
	static SetSkeletalMeshDataInterfaceSamplingRegions(NiagaraSystem: NiagaraComponent,OverrideName: string,SamplingRegions: string[]): void;
	static SetTexture2DArrayObject(NiagaraSystem: NiagaraComponent,OverrideName: string,Texture: Texture2DArray): void;
	static SetTextureObject(NiagaraSystem: NiagaraComponent,OverrideName: string,Texture: Texture): void;
	static SetVolumeTextureObject(NiagaraSystem: NiagaraComponent,OverrideName: string,Texture: VolumeTexture): void;
	static GetNiagaraArrayBool(NiagaraSystem: NiagaraComponent,OverrideName: string): boolean[];
	static GetNiagaraArrayBoolValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): boolean;
	static GetNiagaraArrayColor(NiagaraSystem: NiagaraComponent,OverrideName: string): LinearColor[];
	static GetNiagaraArrayColorValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): LinearColor;
	static GetNiagaraArrayFloat(NiagaraSystem: NiagaraComponent,OverrideName: string): number[];
	static GetNiagaraArrayFloatValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): number;
	static GetNiagaraArrayInt32(NiagaraSystem: NiagaraComponent,OverrideName: string): number[];
	static GetNiagaraArrayInt32Value(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): number;
	static GetNiagaraArrayPosition(NiagaraSystem: NiagaraComponent,OverrideName: string): Vector[];
	static GetNiagaraArrayPositionValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): Vector;
	static GetNiagaraArrayQuat(NiagaraSystem: NiagaraComponent,OverrideName: string): Quat[];
	static GetNiagaraArrayQuatValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): Quat;
	static GetNiagaraArrayVector(NiagaraSystem: NiagaraComponent,OverrideName: string): Vector[];
	static GetNiagaraArrayVector2D(NiagaraSystem: NiagaraComponent,OverrideName: string): Vector2D[];
	static GetNiagaraArrayVector2DValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): Vector2D;
	static GetNiagaraArrayVector4(NiagaraSystem: NiagaraComponent,OverrideName: string): Vector4[];
	static GetNiagaraArrayVector4Value(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): Vector4;
	static GetNiagaraArrayVectorValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number): Vector;
	static SetNiagaraArrayBool(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: boolean[]): void;
	static SetNiagaraArrayBoolValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: boolean,bSizeToFit: boolean): void;
	static SetNiagaraArrayColor(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: LinearColor[]): void;
	static SetNiagaraArrayColorValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: LinearColor,bSizeToFit: boolean): void;
	static SetNiagaraArrayFloat(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: number[]): void;
	static SetNiagaraArrayFloatValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: number,bSizeToFit: boolean): void;
	static SetNiagaraArrayInt32(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: number[]): void;
	static SetNiagaraArrayInt32Value(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: number,bSizeToFit: boolean): void;
	static SetNiagaraArrayPosition(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: Vector[]): void;
	static SetNiagaraArrayPositionValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: Vector,bSizeToFit: boolean): void;
	static SetNiagaraArrayQuat(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: Quat[]): void;
	static SetNiagaraArrayQuatValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: Quat,bSizeToFit: boolean): void;
	static SetNiagaraArrayVector(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: Vector[]): void;
	static SetNiagaraArrayVector2D(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: Vector2D[]): void;
	static SetNiagaraArrayVector2DValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: Vector2D,bSizeToFit: boolean): void;
	static SetNiagaraArrayVector4(NiagaraSystem: NiagaraComponent,OverrideName: string,ArrayData: Vector4[]): void;
	static SetNiagaraArrayVector4Value(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: Vector4,bSizeToFit: boolean): void;
	static SetNiagaraArrayVectorValue(NiagaraSystem: NiagaraComponent,OverrideName: string,index: number,Value: Vector,bSizeToFit: boolean): void;
}

